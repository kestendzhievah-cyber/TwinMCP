/**
 * Vulnerability Scanner Service.
 *
 * Scans library dependencies against a known vulnerability database.
 * Supports severity scoring (CVSS-like), affected version range matching,
 * and remediation suggestions.
 *
 * In production, this would query OSV (https://osv.dev), GitHub Advisory DB,
 * or Snyk. Here we provide a local advisory store for testability.
 */

import crypto from 'crypto'

export type VulnSeverity = 'critical' | 'high' | 'medium' | 'low' | 'info'

export interface Advisory {
  id: string
  title: string
  description: string
  severity: VulnSeverity
  cvssScore: number
  affectedPackage: string
  affectedVersions: string // semver range, e.g. ">=1.0.0 <1.5.3"
  patchedVersions?: string
  cwe?: string
  references?: string[]
  publishedAt: string
}

export interface ScanTarget {
  name: string
  version: string
}

export interface VulnerabilityResult {
  target: ScanTarget
  advisories: Advisory[]
  riskLevel: VulnSeverity
  totalVulnerabilities: number
}

export interface ScanReport {
  id: string
  scannedAt: string
  targets: ScanTarget[]
  results: VulnerabilityResult[]
  summary: {
    totalPackages: number
    vulnerablePackages: number
    totalVulnerabilities: number
    bySeverity: Record<VulnSeverity, number>
    overallRisk: VulnSeverity
  }
}

export class VulnerabilityScannerService {
  private advisoryDB: Map<string, Advisory[]> = new Map()

  /** Add an advisory to the local database. */
  addAdvisory(advisory: Advisory): void {
    const key = advisory.affectedPackage.toLowerCase()
    if (!this.advisoryDB.has(key)) {
      this.advisoryDB.set(key, [])
    }
    this.advisoryDB.get(key)!.push(advisory)
  }

  /** Bulk load advisories. */
  loadAdvisories(advisories: Advisory[]): void {
    for (const adv of advisories) {
      this.addAdvisory(adv)
    }
  }

  /** Get advisories for a package. */
  getAdvisories(packageName: string): Advisory[] {
    return this.advisoryDB.get(packageName.toLowerCase()) || []
  }

  /** Get total advisory count. */
  get advisoryCount(): number {
    let count = 0
    for (const list of this.advisoryDB.values()) count += list.length
    return count
  }

  /**
   * Scan a single package against the advisory database.
   */
  scanPackage(target: ScanTarget): VulnerabilityResult {
    const advisories = this.getAdvisories(target.name)
    const matching = advisories.filter(adv =>
      this.isVersionAffected(target.version, adv.affectedVersions)
    )

    const riskLevel = this.computeRiskLevel(matching)

    return {
      target,
      advisories: matching,
      riskLevel,
      totalVulnerabilities: matching.length,
    }
  }

  /**
   * Scan multiple packages and generate a full report.
   */
  scan(targets: ScanTarget[]): ScanReport {
    const results = targets.map(t => this.scanPackage(t))

    const bySeverity: Record<VulnSeverity, number> = {
      critical: 0, high: 0, medium: 0, low: 0, info: 0,
    }

    let totalVulns = 0
    let vulnerableCount = 0

    for (const result of results) {
      totalVulns += result.totalVulnerabilities
      if (result.totalVulnerabilities > 0) vulnerableCount++
      for (const adv of result.advisories) {
        bySeverity[adv.severity]++
      }
    }

    return {
      id: crypto.randomUUID(),
      scannedAt: new Date().toISOString(),
      targets,
      results,
      summary: {
        totalPackages: targets.length,
        vulnerablePackages: vulnerableCount,
        totalVulnerabilities: totalVulns,
        bySeverity,
        overallRisk: this.computeOverallRisk(bySeverity),
      },
    }
  }

  // ── Version Matching ───────────────────────────────────────

  /**
   * Simple semver range check.
   * Supports: ">=X.Y.Z <A.B.C", ">=X.Y.Z", "<X.Y.Z", "X.Y.Z"
   */
  isVersionAffected(version: string, range: string): boolean {
    const parts = range.trim().split(/\s+/)
    const ver = this.parseVersion(version)
    if (!ver) return false

    for (const part of parts) {
      if (part.startsWith('>=')) {
        const bound = this.parseVersion(part.slice(2))
        if (bound && this.compareVersions(ver, bound) < 0) return false
      } else if (part.startsWith('>')) {
        const bound = this.parseVersion(part.slice(1))
        if (bound && this.compareVersions(ver, bound) <= 0) return false
      } else if (part.startsWith('<=')) {
        const bound = this.parseVersion(part.slice(2))
        if (bound && this.compareVersions(ver, bound) > 0) return false
      } else if (part.startsWith('<')) {
        const bound = this.parseVersion(part.slice(1))
        if (bound && this.compareVersions(ver, bound) >= 0) return false
      } else {
        // Exact match
        const bound = this.parseVersion(part)
        if (bound && this.compareVersions(ver, bound) !== 0) return false
      }
    }

    return true
  }

  private parseVersion(v: string): number[] | null {
    const match = v.match(/^(\d+)\.(\d+)\.(\d+)/)
    if (!match) return null
    return [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])]
  }

  private compareVersions(a: number[], b: number[]): number {
    for (let i = 0; i < 3; i++) {
      if (a[i] !== b[i]) return a[i] - b[i]
    }
    return 0
  }

  // ── Risk Computation ───────────────────────────────────────

  private computeRiskLevel(advisories: Advisory[]): VulnSeverity {
    if (advisories.length === 0) return 'info'
    const severities = advisories.map(a => a.severity)
    if (severities.includes('critical')) return 'critical'
    if (severities.includes('high')) return 'high'
    if (severities.includes('medium')) return 'medium'
    if (severities.includes('low')) return 'low'
    return 'info'
  }

  private computeOverallRisk(bySeverity: Record<VulnSeverity, number>): VulnSeverity {
    if (bySeverity.critical > 0) return 'critical'
    if (bySeverity.high > 0) return 'high'
    if (bySeverity.medium > 0) return 'medium'
    if (bySeverity.low > 0) return 'low'
    return 'info'
  }
}

export const vulnerabilityScannerService = new VulnerabilityScannerService()
