
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type ClientPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Client"
  objects: {
    modules: ModuleOnClientPayload<ExtArgs>[]
    environmentVariables: EnvironmentVariablePayload<ExtArgs>[]
    users: UserPayload<ExtArgs>[]
    libraries: LibraryPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    domain: string | null
    apiKeys: Prisma.JsonValue
    settings: Prisma.JsonValue | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["client"]>
  composites: {}
}

/**
 * Model Client
 * 
 */
export type Client = runtime.Types.DefaultSelection<ClientPayload>
export type ModulePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Module"
  objects: {
    clients: ModuleOnClientPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    description: string | null
    version: string | null
  }, ExtArgs["result"]["module"]>
  composites: {}
}

/**
 * Model Module
 * 
 */
export type Module = runtime.Types.DefaultSelection<ModulePayload>
export type ModuleOnClientPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ModuleOnClient"
  objects: {
    client: ClientPayload<ExtArgs>
    module: ModulePayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    clientId: string
    moduleId: string
    enabled: boolean
  }, ExtArgs["result"]["moduleOnClient"]>
  composites: {}
}

/**
 * Model ModuleOnClient
 * 
 */
export type ModuleOnClient = runtime.Types.DefaultSelection<ModuleOnClientPayload>
export type EnvironmentVariablePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "EnvironmentVariable"
  objects: {
    client: ClientPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    key: string
    value: string
    environment: Environment
    clientId: string
  }, ExtArgs["result"]["environmentVariable"]>
  composites: {}
}

/**
 * Model EnvironmentVariable
 * 
 */
export type EnvironmentVariable = runtime.Types.DefaultSelection<EnvironmentVariablePayload>
export type UserPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "User"
  objects: {
    client: ClientPayload<ExtArgs>
    apiKeys: ApiKeyPayload<ExtArgs>[]
    mcpConfigurations: MCPConfigurationPayload<ExtArgs>[]
    usageLogs: UsageLogPayload<ExtArgs>[]
    oauthTokens: OAuthTokenPayload<ExtArgs>[]
    conversations: ConversationPayload<ExtArgs>[]
    messageReactions: MessageReactionPayload<ExtArgs>[]
    userPreferences: UserPreferencesPayload<ExtArgs> | null
    themes: ThemePayload<ExtArgs>[]
    personalizationAnalytics: PersonalizationAnalyticsPayload<ExtArgs>[]
    conversationShares: ConversationSharePayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    email: string
    name: string | null
    avatar: string | null
    hashedPassword: string | null
    oauthProvider: string | null
    oauthId: string | null
    role: Role
    clientId: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["user"]>
  composites: {}
}

/**
 * Model User
 * 
 */
export type User = runtime.Types.DefaultSelection<UserPayload>
export type LibraryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Library"
  objects: {
    client: ClientPayload<ExtArgs>
    versions: LibraryVersionPayload<ExtArgs>[]
    aliases: LibraryAliasPayload<ExtArgs>[]
    documentationChunks: DocumentationChunkPayload<ExtArgs>[]
    usageLogs: UsageLogPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    displayName: string
    description: string | null
    vendor: string | null
    repoUrl: string | null
    docsUrl: string | null
    defaultVersion: string | null
    popularityScore: number
    totalSnippets: number
    totalTokens: number
    language: string
    ecosystem: string
    tags: string[]
    metadata: Prisma.JsonValue | null
    clientId: string
    lastCrawledAt: Date | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["library"]>
  composites: {}
}

/**
 * Model Library
 * 
 */
export type Library = runtime.Types.DefaultSelection<LibraryPayload>
export type LibraryVersionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "LibraryVersion"
  objects: {
    library: LibraryPayload<ExtArgs>
    documentationChunks: DocumentationChunkPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    libraryId: string
    version: string
    releaseDate: Date | null
    isLatest: boolean
    docsSnapshotUrl: string | null
  }, ExtArgs["result"]["libraryVersion"]>
  composites: {}
}

/**
 * Model LibraryVersion
 * 
 */
export type LibraryVersion = runtime.Types.DefaultSelection<LibraryVersionPayload>
export type LibraryAliasPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "LibraryAlias"
  objects: {
    library: LibraryPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    libraryId: string
    alias: string
  }, ExtArgs["result"]["libraryAlias"]>
  composites: {}
}

/**
 * Model LibraryAlias
 * 
 */
export type LibraryAlias = runtime.Types.DefaultSelection<LibraryAliasPayload>
export type DocumentationChunkPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "DocumentationChunk"
  objects: {
    libraryVersion: LibraryVersionPayload<ExtArgs>
    Library: LibraryPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    libraryVersionId: string
    chunkIndex: number
    content: string
    contentType: string
    sourceUrl: string | null
    tokenCount: number
    embeddingId: string | null
    metadata: Prisma.JsonValue | null
    createdAt: Date
    libraryId: string | null
  }, ExtArgs["result"]["documentationChunk"]>
  composites: {}
}

/**
 * Model DocumentationChunk
 * 
 */
export type DocumentationChunk = runtime.Types.DefaultSelection<DocumentationChunkPayload>
export type ApiKeyPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ApiKey"
  objects: {
    user: UserPayload<ExtArgs>
    usageLogs: UsageLogPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    keyHash: string
    keyPrefix: string
    name: string | null
    tier: string
    quotaDaily: number
    quotaMonthly: number
    usedDaily: number
    usedMonthly: number
    lastUsedAt: Date | null
    expiresAt: Date | null
    isActive: boolean
    permissions: Prisma.JsonValue
    createdAt: Date
    updatedAt: Date
    revokedAt: Date | null
  }, ExtArgs["result"]["apiKey"]>
  composites: {}
}

/**
 * Model ApiKey
 * 
 */
export type ApiKey = runtime.Types.DefaultSelection<ApiKeyPayload>
export type UsageLogPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "UsageLog"
  objects: {
    user: UserPayload<ExtArgs> | null
    apiKey: ApiKeyPayload<ExtArgs> | null
    library: LibraryPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string | null
    apiKeyId: string | null
    libraryId: string | null
    toolName: string
    query: string | null
    tokensReturned: number | null
    responseTimeMs: number | null
    createdAt: Date
  }, ExtArgs["result"]["usageLog"]>
  composites: {}
}

/**
 * Model UsageLog
 * 
 */
export type UsageLog = runtime.Types.DefaultSelection<UsageLogPayload>
export type MCPConfigurationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "MCPConfiguration"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    description: string | null
    configData: Prisma.JsonValue
    status: ConfigStatus
    userId: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["mCPConfiguration"]>
  composites: {}
}

/**
 * Model MCPConfiguration
 * 
 */
export type MCPConfiguration = runtime.Types.DefaultSelection<MCPConfigurationPayload>
export type OAuthTokenPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "OAuthToken"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    provider: string
    accessToken: string
    refreshToken: string | null
    expiresAt: Date
    createdAt: Date
  }, ExtArgs["result"]["oAuthToken"]>
  composites: {}
}

/**
 * Model OAuthToken
 * 
 */
export type OAuthToken = runtime.Types.DefaultSelection<OAuthTokenPayload>
export type OAuthClientPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "OAuthClient"
  objects: {
    authorizationCodes: OAuthAuthorizationCodePayload<ExtArgs>[]
    accessTokens: OAuthAccessTokenPayload<ExtArgs>[]
    refreshTokens: OAuthRefreshTokenPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    clientId: string
    clientSecretHash: string
    name: string
    redirectUris: string[]
    allowedScopes: string[]
    grantTypes: string[]
    requirePkce: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["oAuthClient"]>
  composites: {}
}

/**
 * Model OAuthClient
 * 
 */
export type OAuthClient = runtime.Types.DefaultSelection<OAuthClientPayload>
export type OAuthAuthorizationCodePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "OAuthAuthorizationCode"
  objects: {
    client: OAuthClientPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    code: string
    clientId: string
    userId: string
    redirectUri: string
    scopes: string[]
    codeChallenge: string | null
    codeChallengeMethod: string | null
    expiresAt: Date
    createdAt: Date
  }, ExtArgs["result"]["oAuthAuthorizationCode"]>
  composites: {}
}

/**
 * Model OAuthAuthorizationCode
 * 
 */
export type OAuthAuthorizationCode = runtime.Types.DefaultSelection<OAuthAuthorizationCodePayload>
export type OAuthAccessTokenPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "OAuthAccessToken"
  objects: {
    client: OAuthClientPayload<ExtArgs>
    refreshToken: OAuthRefreshTokenPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    tokenHash: string
    clientId: string
    userId: string
    scopes: string[]
    expiresAt: Date
    createdAt: Date
  }, ExtArgs["result"]["oAuthAccessToken"]>
  composites: {}
}

/**
 * Model OAuthAccessToken
 * 
 */
export type OAuthAccessToken = runtime.Types.DefaultSelection<OAuthAccessTokenPayload>
export type OAuthRefreshTokenPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "OAuthRefreshToken"
  objects: {
    accessToken: OAuthAccessTokenPayload<ExtArgs>
    client: OAuthClientPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    tokenHash: string
    accessTokenId: string
    clientId: string
    userId: string
    scopes: string[]
    expiresAt: Date
    isRevoked: boolean
    createdAt: Date
  }, ExtArgs["result"]["oAuthRefreshToken"]>
  composites: {}
}

/**
 * Model OAuthRefreshToken
 * 
 */
export type OAuthRefreshToken = runtime.Types.DefaultSelection<OAuthRefreshTokenPayload>
export type DownloadTaskPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "DownloadTask"
  objects: {
    downloadResults: DownloadResultPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    type: string
    source: Prisma.JsonValue
    options: Prisma.JsonValue
    priority: string
    status: string
    progress: Prisma.JsonValue
    metadata: Prisma.JsonValue | null
    created_at: Date
    started_at: Date | null
    completed_at: Date | null
    error: string | null
    retry_count: number
  }, ExtArgs["result"]["downloadTask"]>
  composites: {}
}

/**
 * Model DownloadTask
 * 
 */
export type DownloadTask = runtime.Types.DefaultSelection<DownloadTaskPayload>
export type DownloadResultPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "DownloadResult"
  objects: {
    downloadTask: DownloadTaskPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    task_id: string
    success: boolean
    local_path: string
    metadata: Prisma.JsonValue
    files: Prisma.JsonValue
    errors: string[]
    created_at: Date
  }, ExtArgs["result"]["downloadResult"]>
  composites: {}
}

/**
 * Model DownloadResult
 * 
 */
export type DownloadResult = runtime.Types.DefaultSelection<DownloadResultPayload>
export type PromptCategoryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "PromptCategory"
  objects: {
    templates: PromptTemplatePayload<ExtArgs>[]
    parent: PromptCategoryPayload<ExtArgs> | null
    children: PromptCategoryPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    description: string | null
    parentCategory: string | null
    icon: string | null
    color: string | null
    order: number
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["promptCategory"]>
  composites: {}
}

/**
 * Model PromptCategory
 * 
 */
export type PromptCategory = runtime.Types.DefaultSelection<PromptCategoryPayload>
export type PromptTemplatePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "PromptTemplate"
  objects: {
    categoryRel: PromptCategoryPayload<ExtArgs>
    executions: PromptExecutionPayload<ExtArgs>[]
    changes: TemplateChangePayload<ExtArgs>[]
    optimizations: OptimizationRecordPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    version: string
    name: string
    description: string | null
    category: string
    status: string
    template: string
    variables: Prisma.JsonValue
    examples: Prisma.JsonValue
    metadata: Prisma.JsonValue
    constraints: Prisma.JsonValue
    optimization: Prisma.JsonValue
    testing: Prisma.JsonValue
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["promptTemplate"]>
  composites: {}
}

/**
 * Model PromptTemplate
 * 
 */
export type PromptTemplate = runtime.Types.DefaultSelection<PromptTemplatePayload>
export type TemplateChangePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "TemplateChange"
  objects: {
    template: PromptTemplatePayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    templateId: string
    fromVersion: string
    toVersion: string
    changes: Prisma.JsonValue
    createdAt: Date
  }, ExtArgs["result"]["templateChange"]>
  composites: {}
}

/**
 * Model TemplateChange
 * 
 */
export type TemplateChange = runtime.Types.DefaultSelection<TemplateChangePayload>
export type PromptExecutionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "PromptExecution"
  objects: {
    template: PromptTemplatePayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    templateId: string
    templateVersion: string
    variables: Prisma.JsonValue
    renderedPrompt: string
    context: Prisma.JsonValue | null
    model: string
    provider: string
    response: string | null
    metrics: Prisma.JsonValue
    quality: Prisma.JsonValue
    feedback: Prisma.JsonValue | null
    abTestVariant: string | null
    userId: string | null
    createdAt: Date
  }, ExtArgs["result"]["promptExecution"]>
  composites: {}
}

/**
 * Model PromptExecution
 * 
 */
export type PromptExecution = runtime.Types.DefaultSelection<PromptExecutionPayload>
export type PromptExecutionErrorPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "PromptExecutionError"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    templateId: string
    variables: Prisma.JsonValue
    errorMessage: string
    context: Prisma.JsonValue | null
    createdAt: Date
  }, ExtArgs["result"]["promptExecutionError"]>
  composites: {}
}

/**
 * Model PromptExecutionError
 * 
 */
export type PromptExecutionError = runtime.Types.DefaultSelection<PromptExecutionErrorPayload>
export type ABTestPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ABTest"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    description: string | null
    status: string
    variants: Prisma.JsonValue
    trafficSplit: Prisma.JsonValue
    startDate: Date | null
    endDate: Date | null
    sampleSize: number
    confidence: Prisma.Decimal
    results: Prisma.JsonValue | null
    createdAt: Date
  }, ExtArgs["result"]["aBTest"]>
  composites: {}
}

/**
 * Model ABTest
 * 
 */
export type ABTest = runtime.Types.DefaultSelection<ABTestPayload>
export type OptimizationRecordPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "OptimizationRecord"
  objects: {
    template: PromptTemplatePayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    templateId: string
    timestamp: Date
    type: string
    reason: string | null
    changes: Prisma.JsonValue
    metricsBefore: Prisma.JsonValue
    metricsAfter: Prisma.JsonValue
    improvement: Prisma.Decimal | null
    createdAt: Date
  }, ExtArgs["result"]["optimizationRecord"]>
  composites: {}
}

/**
 * Model OptimizationRecord
 * 
 */
export type OptimizationRecord = runtime.Types.DefaultSelection<OptimizationRecordPayload>
export type ConversationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Conversation"
  objects: {
    user: UserPayload<ExtArgs>
    messages: MessagePayload<ExtArgs>[]
    shares: ConversationSharePayload<ExtArgs>[]
    exports: ConversationExportPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    title: string
    metadata: Prisma.JsonValue
    settings: Prisma.JsonValue
    analytics: Prisma.JsonValue
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["conversation"]>
  composites: {}
}

/**
 * Model Conversation
 * 
 */
export type Conversation = runtime.Types.DefaultSelection<ConversationPayload>
export type MessagePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Message"
  objects: {
    conversation: ConversationPayload<ExtArgs>
    reactions: MessageReactionPayload<ExtArgs>[]
    attachments: MessageAttachmentPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    conversationId: string
    role: string
    content: string
    timestamp: Date
    metadata: Prisma.JsonValue
  }, ExtArgs["result"]["message"]>
  composites: {}
}

/**
 * Model Message
 * 
 */
export type Message = runtime.Types.DefaultSelection<MessagePayload>
export type MessageReactionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "MessageReaction"
  objects: {
    message: MessagePayload<ExtArgs>
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    messageId: string
    userId: string
    emoji: string
    timestamp: Date
  }, ExtArgs["result"]["messageReaction"]>
  composites: {}
}

/**
 * Model MessageReaction
 * 
 */
export type MessageReaction = runtime.Types.DefaultSelection<MessageReactionPayload>
export type MessageAttachmentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "MessageAttachment"
  objects: {
    message: MessagePayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    messageId: string
    type: string
    name: string
    url: string
    size: bigint | null
    mimeType: string | null
    metadata: Prisma.JsonValue
    thumbnail: string | null
  }, ExtArgs["result"]["messageAttachment"]>
  composites: {}
}

/**
 * Model MessageAttachment
 * 
 */
export type MessageAttachment = runtime.Types.DefaultSelection<MessageAttachmentPayload>
export type ConversationSharePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ConversationShare"
  objects: {
    conversation: ConversationPayload<ExtArgs>
    creator: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    conversationId: string
    shareId: string
    createdBy: string
    createdAt: Date
    expiresAt: Date | null
    permissions: Prisma.JsonValue
    settings: Prisma.JsonValue
    analytics: Prisma.JsonValue
  }, ExtArgs["result"]["conversationShare"]>
  composites: {}
}

/**
 * Model ConversationShare
 * 
 */
export type ConversationShare = runtime.Types.DefaultSelection<ConversationSharePayload>
export type ConversationExportPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ConversationExport"
  objects: {
    conversation: ConversationPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    conversationId: string
    format: string
    options: Prisma.JsonValue
    status: string
    downloadUrl: string | null
    expiresAt: Date | null
    createdAt: Date
    completedAt: Date | null
    error: string | null
  }, ExtArgs["result"]["conversationExport"]>
  composites: {}
}

/**
 * Model ConversationExport
 * 
 */
export type ConversationExport = runtime.Types.DefaultSelection<ConversationExportPayload>
export type ContextSourcePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ContextSource"
  objects: {
    chunks: ContextChunkPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    type: string
    title: string
    content: string
    url: string | null
    libraryId: string | null
    version: string | null
    language: string
    tags: string[]
    relevanceScore: number
    freshness: number
    popularity: number
    lastUpdated: Date
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["contextSource"]>
  composites: {}
}

/**
 * Model ContextSource
 * 
 */
export type ContextSource = runtime.Types.DefaultSelection<ContextSourcePayload>
export type ContextChunkPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ContextChunk"
  objects: {
    source: ContextSourcePayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    sourceId: string
    content: string
    positionStart: number
    positionEnd: number
    positionIndex: number
    positionTotal: number
    sectionTitle: string | null
    codeBlocks: number
    links: number
    images: number
    complexity: string
    embedding: number[]
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["contextChunk"]>
  composites: {}
}

/**
 * Model ContextChunk
 * 
 */
export type ContextChunk = runtime.Types.DefaultSelection<ContextChunkPayload>
export type ContextQueryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ContextQuery"
  objects: {
    results: ContextResultPayload<ExtArgs>[]
    analytics: ContextQueryAnalyticsPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    conversationId: string
    messageId: string
    queryText: string
    intentType: string | null
    intentConfidence: number | null
    intentKeywords: string[]
    intentCategory: string | null
    intentSubcategory: string | null
    entities: Prisma.JsonValue
    filters: Prisma.JsonValue
    options: Prisma.JsonValue
    createdAt: Date
  }, ExtArgs["result"]["contextQuery"]>
  composites: {}
}

/**
 * Model ContextQuery
 * 
 */
export type ContextQuery = runtime.Types.DefaultSelection<ContextQueryPayload>
export type ContextResultPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ContextResult"
  objects: {
    query: ContextQueryPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    queryId: string
    sources: Prisma.JsonValue
    chunks: Prisma.JsonValue
    summary: string | null
    totalSources: number
    totalChunks: number
    queryTime: number
    relevanceScore: number
    coverage: number
    freshness: number
    suggestions: Prisma.JsonValue
    createdAt: Date
  }, ExtArgs["result"]["contextResult"]>
  composites: {}
}

/**
 * Model ContextResult
 * 
 */
export type ContextResult = runtime.Types.DefaultSelection<ContextResultPayload>
export type ContextInjectionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ContextInjection"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    conversationId: string
    messageId: string
    context: Prisma.JsonValue
    templateId: string | null
    injectedPrompt: string
    originalLength: number
    injectedLength: number
    compressionRatio: number
    relevanceScore: number
    createdAt: Date
  }, ExtArgs["result"]["contextInjection"]>
  composites: {}
}

/**
 * Model ContextInjection
 * 
 */
export type ContextInjection = runtime.Types.DefaultSelection<ContextInjectionPayload>
export type ContextTemplatePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ContextTemplate"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    type: string
    template: string
    variables: string[]
    description: string | null
    version: string
    usageCount: number
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["contextTemplate"]>
  composites: {}
}

/**
 * Model ContextTemplate
 * 
 */
export type ContextTemplate = runtime.Types.DefaultSelection<ContextTemplatePayload>
export type ContextQueryAnalyticsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ContextQueryAnalytics"
  objects: {
    query: ContextQueryPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    queryId: string | null
    conversationId: string
    queryText: string
    intent: Prisma.JsonValue
    entities: Prisma.JsonValue
    filters: Prisma.JsonValue
    options: Prisma.JsonValue
    resultMetadata: Prisma.JsonValue
    createdAt: Date
  }, ExtArgs["result"]["contextQueryAnalytics"]>
  composites: {}
}

/**
 * Model ContextQueryAnalytics
 * 
 */
export type ContextQueryAnalytics = runtime.Types.DefaultSelection<ContextQueryAnalyticsPayload>
export type ContextCachePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "ContextCache"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    cacheKey: string
    queryText: string
    result: Prisma.JsonValue
    expiresAt: Date
    hitCount: number
    lastAccessed: Date
    createdAt: Date
  }, ExtArgs["result"]["contextCache"]>
  composites: {}
}

/**
 * Model ContextCache
 * 
 */
export type ContextCache = runtime.Types.DefaultSelection<ContextCachePayload>
export type UserPreferencesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "UserPreferences"
  objects: {
    user: UserPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    preferences: Prisma.JsonValue
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["userPreferences"]>
  composites: {}
}

/**
 * Model UserPreferences
 * 
 */
export type UserPreferences = runtime.Types.DefaultSelection<UserPreferencesPayload>
export type ThemePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Theme"
  objects: {
    creator: UserPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    description: string | null
    category: string
    colors: Prisma.JsonValue
    typography: Prisma.JsonValue
    spacing: Prisma.JsonValue
    shadows: Prisma.JsonValue
    borderRadius: Prisma.JsonValue
    animations: Prisma.JsonValue
    custom: boolean
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["theme"]>
  composites: {}
}

/**
 * Model Theme
 * 
 */
export type Theme = runtime.Types.DefaultSelection<ThemePayload>
export type PersonalizationAnalyticsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "PersonalizationAnalytics"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    actionType: string
    metadata: Prisma.JsonValue
    createdAt: Date
  }, ExtArgs["result"]["personalizationAnalytics"]>
  composites: {}
}

/**
 * Model PersonalizationAnalytics
 * 
 */
export type PersonalizationAnalytics = runtime.Types.DefaultSelection<PersonalizationAnalyticsPayload>
export type UserProfilePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "UserProfile"
  objects: {
    invoices: InvoicePayload<ExtArgs>[]
    payments: PaymentPayload<ExtArgs>[]
    subscriptions: SubscriptionPayload<ExtArgs>[]
    credits: CreditPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    postalCode: string | null
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["userProfile"]>
  composites: {}
}

/**
 * Model UserProfile
 * 
 */
export type UserProfile = runtime.Types.DefaultSelection<UserProfilePayload>
export type InvoicePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Invoice"
  objects: {
    userProfile: UserProfilePayload<ExtArgs>
    payments: PaymentPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    number: string
    userId: string
    status: InvoiceStatus
    period: Prisma.JsonValue
    issueDate: Date
    dueDate: Date
    paidDate: Date | null
    subtotal: Prisma.Decimal
    tax: Prisma.Decimal
    total: Prisma.Decimal
    currency: string
    items: Prisma.JsonValue
    billingAddress: Prisma.JsonValue
    metadata: Prisma.JsonValue
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["invoice"]>
  composites: {}
}

/**
 * Model Invoice
 * 
 */
export type Invoice = runtime.Types.DefaultSelection<InvoicePayload>
export type PaymentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Payment"
  objects: {
    invoice: InvoicePayload<ExtArgs>
    userProfile: UserProfilePayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    invoiceId: string
    userId: string
    amount: Prisma.Decimal
    currency: string
    status: PaymentStatus
    providerTransactionId: string | null
    failureReason: string | null
    refundedAmount: Prisma.Decimal | null
    createdAt: Date
    processedAt: Date | null
    metadata: Prisma.JsonValue
  }, ExtArgs["result"]["payment"]>
  composites: {}
}

/**
 * Model Payment
 * 
 */
export type Payment = runtime.Types.DefaultSelection<PaymentPayload>
export type SubscriptionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Subscription"
  objects: {
    userProfile: UserProfilePayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    plan: string
    status: SubscriptionStatus
    currentPeriodStart: Date
    currentPeriodEnd: Date
    cancelAtPeriodEnd: boolean
    amount: Prisma.Decimal
    currency: string
    interval: SubscriptionInterval
    intervalCount: number
    trialStart: Date | null
    trialEnd: Date | null
    createdAt: Date
    updatedAt: Date
    metadata: Prisma.JsonValue
  }, ExtArgs["result"]["subscription"]>
  composites: {}
}

/**
 * Model Subscription
 * 
 */
export type Subscription = runtime.Types.DefaultSelection<SubscriptionPayload>
export type CreditPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Credit"
  objects: {
    userProfile: UserProfilePayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    amount: Prisma.Decimal
    currency: string
    reason: string
    type: CreditType
    expiresAt: Date | null
    usedAt: Date | null
    invoiceId: string | null
    createdAt: Date
    metadata: Prisma.JsonValue
  }, ExtArgs["result"]["credit"]>
  composites: {}
}

/**
 * Model Credit
 * 
 */
export type Credit = runtime.Types.DefaultSelection<CreditPayload>
export type BillingAlertPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "BillingAlert"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    type: BillingAlertType
    threshold: Prisma.Decimal | null
    currentValue: Prisma.Decimal | null
    message: string
    isRead: boolean
    createdAt: Date
    readAt: Date | null
    metadata: Prisma.JsonValue
  }, ExtArgs["result"]["billingAlert"]>
  composites: {}
}

/**
 * Model BillingAlert
 * 
 */
export type BillingAlert = runtime.Types.DefaultSelection<BillingAlertPayload>
export type PlanPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Plan"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    description: string | null
    amount: Prisma.Decimal
    currency: string
    interval: PlanInterval
    features: string[]
    limits: Prisma.JsonValue
    createdAt: Date
    updatedAt: Date
    metadata: Prisma.JsonValue
  }, ExtArgs["result"]["plan"]>
  composites: {}
}

/**
 * Model Plan
 * 
 */
export type Plan = runtime.Types.DefaultSelection<PlanPayload>

/**
 * Enums
 */

export const Environment: {
  DEVELOPMENT: 'DEVELOPMENT',
  STAGING: 'STAGING',
  PRODUCTION: 'PRODUCTION'
};

export type Environment = (typeof Environment)[keyof typeof Environment]


export const Role: {
  BUYER: 'BUYER',
  SELLER: 'SELLER',
  ADMIN: 'ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const ConfigStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  TESTING: 'TESTING',
  ERROR: 'ERROR'
};

export type ConfigStatus = (typeof ConfigStatus)[keyof typeof ConfigStatus]


export const InvoiceStatus: {
  DRAFT: 'DRAFT',
  SENT: 'SENT',
  PAID: 'PAID',
  OVERDUE: 'OVERDUE',
  CANCELLED: 'CANCELLED'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const PaymentStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const SubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  CANCELLED: 'CANCELLED',
  EXPIRED: 'EXPIRED'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const SubscriptionInterval: {
  MONTH: 'MONTH',
  YEAR: 'YEAR'
};

export type SubscriptionInterval = (typeof SubscriptionInterval)[keyof typeof SubscriptionInterval]


export const CreditType: {
  PROMOTIONAL: 'PROMOTIONAL',
  REFUND: 'REFUND',
  COMPENSATION: 'COMPENSATION',
  ADJUSTMENT: 'ADJUSTMENT'
};

export type CreditType = (typeof CreditType)[keyof typeof CreditType]


export const BillingAlertType: {
  USAGE_THRESHOLD: 'USAGE_THRESHOLD',
  PAYMENT_FAILED: 'PAYMENT_FAILED',
  INVOICE_OVERDUE: 'INVOICE_OVERDUE',
  SUBSCRIPTION_EXPIRING: 'SUBSCRIPTION_EXPIRING'
};

export type BillingAlertType = (typeof BillingAlertType)[keyof typeof BillingAlertType]


export const PlanInterval: {
  MONTH: 'MONTH',
  YEAR: 'YEAR'
};

export type PlanInterval = (typeof PlanInterval)[keyof typeof PlanInterval]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Clients
 * const clients = await prisma.client.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Clients
   * const clients = await prisma.client.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs>;

  /**
   * `prisma.module`: Exposes CRUD operations for the **Module** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Modules
    * const modules = await prisma.module.findMany()
    * ```
    */
  get module(): Prisma.ModuleDelegate<ExtArgs>;

  /**
   * `prisma.moduleOnClient`: Exposes CRUD operations for the **ModuleOnClient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModuleOnClients
    * const moduleOnClients = await prisma.moduleOnClient.findMany()
    * ```
    */
  get moduleOnClient(): Prisma.ModuleOnClientDelegate<ExtArgs>;

  /**
   * `prisma.environmentVariable`: Exposes CRUD operations for the **EnvironmentVariable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EnvironmentVariables
    * const environmentVariables = await prisma.environmentVariable.findMany()
    * ```
    */
  get environmentVariable(): Prisma.EnvironmentVariableDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.library`: Exposes CRUD operations for the **Library** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Libraries
    * const libraries = await prisma.library.findMany()
    * ```
    */
  get library(): Prisma.LibraryDelegate<ExtArgs>;

  /**
   * `prisma.libraryVersion`: Exposes CRUD operations for the **LibraryVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryVersions
    * const libraryVersions = await prisma.libraryVersion.findMany()
    * ```
    */
  get libraryVersion(): Prisma.LibraryVersionDelegate<ExtArgs>;

  /**
   * `prisma.libraryAlias`: Exposes CRUD operations for the **LibraryAlias** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LibraryAliases
    * const libraryAliases = await prisma.libraryAlias.findMany()
    * ```
    */
  get libraryAlias(): Prisma.LibraryAliasDelegate<ExtArgs>;

  /**
   * `prisma.documentationChunk`: Exposes CRUD operations for the **DocumentationChunk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentationChunks
    * const documentationChunks = await prisma.documentationChunk.findMany()
    * ```
    */
  get documentationChunk(): Prisma.DocumentationChunkDelegate<ExtArgs>;

  /**
   * `prisma.apiKey`: Exposes CRUD operations for the **ApiKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeys
    * const apiKeys = await prisma.apiKey.findMany()
    * ```
    */
  get apiKey(): Prisma.ApiKeyDelegate<ExtArgs>;

  /**
   * `prisma.usageLog`: Exposes CRUD operations for the **UsageLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsageLogs
    * const usageLogs = await prisma.usageLog.findMany()
    * ```
    */
  get usageLog(): Prisma.UsageLogDelegate<ExtArgs>;

  /**
   * `prisma.mCPConfiguration`: Exposes CRUD operations for the **MCPConfiguration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MCPConfigurations
    * const mCPConfigurations = await prisma.mCPConfiguration.findMany()
    * ```
    */
  get mCPConfiguration(): Prisma.MCPConfigurationDelegate<ExtArgs>;

  /**
   * `prisma.oAuthToken`: Exposes CRUD operations for the **OAuthToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OAuthTokens
    * const oAuthTokens = await prisma.oAuthToken.findMany()
    * ```
    */
  get oAuthToken(): Prisma.OAuthTokenDelegate<ExtArgs>;

  /**
   * `prisma.oAuthClient`: Exposes CRUD operations for the **OAuthClient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OAuthClients
    * const oAuthClients = await prisma.oAuthClient.findMany()
    * ```
    */
  get oAuthClient(): Prisma.OAuthClientDelegate<ExtArgs>;

  /**
   * `prisma.oAuthAuthorizationCode`: Exposes CRUD operations for the **OAuthAuthorizationCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OAuthAuthorizationCodes
    * const oAuthAuthorizationCodes = await prisma.oAuthAuthorizationCode.findMany()
    * ```
    */
  get oAuthAuthorizationCode(): Prisma.OAuthAuthorizationCodeDelegate<ExtArgs>;

  /**
   * `prisma.oAuthAccessToken`: Exposes CRUD operations for the **OAuthAccessToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OAuthAccessTokens
    * const oAuthAccessTokens = await prisma.oAuthAccessToken.findMany()
    * ```
    */
  get oAuthAccessToken(): Prisma.OAuthAccessTokenDelegate<ExtArgs>;

  /**
   * `prisma.oAuthRefreshToken`: Exposes CRUD operations for the **OAuthRefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OAuthRefreshTokens
    * const oAuthRefreshTokens = await prisma.oAuthRefreshToken.findMany()
    * ```
    */
  get oAuthRefreshToken(): Prisma.OAuthRefreshTokenDelegate<ExtArgs>;

  /**
   * `prisma.downloadTask`: Exposes CRUD operations for the **DownloadTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DownloadTasks
    * const downloadTasks = await prisma.downloadTask.findMany()
    * ```
    */
  get downloadTask(): Prisma.DownloadTaskDelegate<ExtArgs>;

  /**
   * `prisma.downloadResult`: Exposes CRUD operations for the **DownloadResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DownloadResults
    * const downloadResults = await prisma.downloadResult.findMany()
    * ```
    */
  get downloadResult(): Prisma.DownloadResultDelegate<ExtArgs>;

  /**
   * `prisma.promptCategory`: Exposes CRUD operations for the **PromptCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromptCategories
    * const promptCategories = await prisma.promptCategory.findMany()
    * ```
    */
  get promptCategory(): Prisma.PromptCategoryDelegate<ExtArgs>;

  /**
   * `prisma.promptTemplate`: Exposes CRUD operations for the **PromptTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromptTemplates
    * const promptTemplates = await prisma.promptTemplate.findMany()
    * ```
    */
  get promptTemplate(): Prisma.PromptTemplateDelegate<ExtArgs>;

  /**
   * `prisma.templateChange`: Exposes CRUD operations for the **TemplateChange** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemplateChanges
    * const templateChanges = await prisma.templateChange.findMany()
    * ```
    */
  get templateChange(): Prisma.TemplateChangeDelegate<ExtArgs>;

  /**
   * `prisma.promptExecution`: Exposes CRUD operations for the **PromptExecution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromptExecutions
    * const promptExecutions = await prisma.promptExecution.findMany()
    * ```
    */
  get promptExecution(): Prisma.PromptExecutionDelegate<ExtArgs>;

  /**
   * `prisma.promptExecutionError`: Exposes CRUD operations for the **PromptExecutionError** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromptExecutionErrors
    * const promptExecutionErrors = await prisma.promptExecutionError.findMany()
    * ```
    */
  get promptExecutionError(): Prisma.PromptExecutionErrorDelegate<ExtArgs>;

  /**
   * `prisma.aBTest`: Exposes CRUD operations for the **ABTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ABTests
    * const aBTests = await prisma.aBTest.findMany()
    * ```
    */
  get aBTest(): Prisma.ABTestDelegate<ExtArgs>;

  /**
   * `prisma.optimizationRecord`: Exposes CRUD operations for the **OptimizationRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OptimizationRecords
    * const optimizationRecords = await prisma.optimizationRecord.findMany()
    * ```
    */
  get optimizationRecord(): Prisma.OptimizationRecordDelegate<ExtArgs>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.messageReaction`: Exposes CRUD operations for the **MessageReaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageReactions
    * const messageReactions = await prisma.messageReaction.findMany()
    * ```
    */
  get messageReaction(): Prisma.MessageReactionDelegate<ExtArgs>;

  /**
   * `prisma.messageAttachment`: Exposes CRUD operations for the **MessageAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageAttachments
    * const messageAttachments = await prisma.messageAttachment.findMany()
    * ```
    */
  get messageAttachment(): Prisma.MessageAttachmentDelegate<ExtArgs>;

  /**
   * `prisma.conversationShare`: Exposes CRUD operations for the **ConversationShare** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConversationShares
    * const conversationShares = await prisma.conversationShare.findMany()
    * ```
    */
  get conversationShare(): Prisma.ConversationShareDelegate<ExtArgs>;

  /**
   * `prisma.conversationExport`: Exposes CRUD operations for the **ConversationExport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConversationExports
    * const conversationExports = await prisma.conversationExport.findMany()
    * ```
    */
  get conversationExport(): Prisma.ConversationExportDelegate<ExtArgs>;

  /**
   * `prisma.contextSource`: Exposes CRUD operations for the **ContextSource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContextSources
    * const contextSources = await prisma.contextSource.findMany()
    * ```
    */
  get contextSource(): Prisma.ContextSourceDelegate<ExtArgs>;

  /**
   * `prisma.contextChunk`: Exposes CRUD operations for the **ContextChunk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContextChunks
    * const contextChunks = await prisma.contextChunk.findMany()
    * ```
    */
  get contextChunk(): Prisma.ContextChunkDelegate<ExtArgs>;

  /**
   * `prisma.contextQuery`: Exposes CRUD operations for the **ContextQuery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContextQueries
    * const contextQueries = await prisma.contextQuery.findMany()
    * ```
    */
  get contextQuery(): Prisma.ContextQueryDelegate<ExtArgs>;

  /**
   * `prisma.contextResult`: Exposes CRUD operations for the **ContextResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContextResults
    * const contextResults = await prisma.contextResult.findMany()
    * ```
    */
  get contextResult(): Prisma.ContextResultDelegate<ExtArgs>;

  /**
   * `prisma.contextInjection`: Exposes CRUD operations for the **ContextInjection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContextInjections
    * const contextInjections = await prisma.contextInjection.findMany()
    * ```
    */
  get contextInjection(): Prisma.ContextInjectionDelegate<ExtArgs>;

  /**
   * `prisma.contextTemplate`: Exposes CRUD operations for the **ContextTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContextTemplates
    * const contextTemplates = await prisma.contextTemplate.findMany()
    * ```
    */
  get contextTemplate(): Prisma.ContextTemplateDelegate<ExtArgs>;

  /**
   * `prisma.contextQueryAnalytics`: Exposes CRUD operations for the **ContextQueryAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContextQueryAnalytics
    * const contextQueryAnalytics = await prisma.contextQueryAnalytics.findMany()
    * ```
    */
  get contextQueryAnalytics(): Prisma.ContextQueryAnalyticsDelegate<ExtArgs>;

  /**
   * `prisma.contextCache`: Exposes CRUD operations for the **ContextCache** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContextCaches
    * const contextCaches = await prisma.contextCache.findMany()
    * ```
    */
  get contextCache(): Prisma.ContextCacheDelegate<ExtArgs>;

  /**
   * `prisma.userPreferences`: Exposes CRUD operations for the **UserPreferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPreferences
    * const userPreferences = await prisma.userPreferences.findMany()
    * ```
    */
  get userPreferences(): Prisma.UserPreferencesDelegate<ExtArgs>;

  /**
   * `prisma.theme`: Exposes CRUD operations for the **Theme** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Themes
    * const themes = await prisma.theme.findMany()
    * ```
    */
  get theme(): Prisma.ThemeDelegate<ExtArgs>;

  /**
   * `prisma.personalizationAnalytics`: Exposes CRUD operations for the **PersonalizationAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonalizationAnalytics
    * const personalizationAnalytics = await prisma.personalizationAnalytics.findMany()
    * ```
    */
  get personalizationAnalytics(): Prisma.PersonalizationAnalyticsDelegate<ExtArgs>;

  /**
   * `prisma.userProfile`: Exposes CRUD operations for the **UserProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfiles
    * const userProfiles = await prisma.userProfile.findMany()
    * ```
    */
  get userProfile(): Prisma.UserProfileDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.credit`: Exposes CRUD operations for the **Credit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Credits
    * const credits = await prisma.credit.findMany()
    * ```
    */
  get credit(): Prisma.CreditDelegate<ExtArgs>;

  /**
   * `prisma.billingAlert`: Exposes CRUD operations for the **BillingAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BillingAlerts
    * const billingAlerts = await prisma.billingAlert.findMany()
    * ```
    */
  get billingAlert(): Prisma.BillingAlertDelegate<ExtArgs>;

  /**
   * `prisma.plan`: Exposes CRUD operations for the **Plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plan.findMany()
    * ```
    */
  get plan(): Prisma.PlanDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 5.0.0
   * Query Engine version: 6b0aef69b7cdfc787f822ecd7cdc76d5f1991584
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Client: 'Client',
    Module: 'Module',
    ModuleOnClient: 'ModuleOnClient',
    EnvironmentVariable: 'EnvironmentVariable',
    User: 'User',
    Library: 'Library',
    LibraryVersion: 'LibraryVersion',
    LibraryAlias: 'LibraryAlias',
    DocumentationChunk: 'DocumentationChunk',
    ApiKey: 'ApiKey',
    UsageLog: 'UsageLog',
    MCPConfiguration: 'MCPConfiguration',
    OAuthToken: 'OAuthToken',
    OAuthClient: 'OAuthClient',
    OAuthAuthorizationCode: 'OAuthAuthorizationCode',
    OAuthAccessToken: 'OAuthAccessToken',
    OAuthRefreshToken: 'OAuthRefreshToken',
    DownloadTask: 'DownloadTask',
    DownloadResult: 'DownloadResult',
    PromptCategory: 'PromptCategory',
    PromptTemplate: 'PromptTemplate',
    TemplateChange: 'TemplateChange',
    PromptExecution: 'PromptExecution',
    PromptExecutionError: 'PromptExecutionError',
    ABTest: 'ABTest',
    OptimizationRecord: 'OptimizationRecord',
    Conversation: 'Conversation',
    Message: 'Message',
    MessageReaction: 'MessageReaction',
    MessageAttachment: 'MessageAttachment',
    ConversationShare: 'ConversationShare',
    ConversationExport: 'ConversationExport',
    ContextSource: 'ContextSource',
    ContextChunk: 'ContextChunk',
    ContextQuery: 'ContextQuery',
    ContextResult: 'ContextResult',
    ContextInjection: 'ContextInjection',
    ContextTemplate: 'ContextTemplate',
    ContextQueryAnalytics: 'ContextQueryAnalytics',
    ContextCache: 'ContextCache',
    UserPreferences: 'UserPreferences',
    Theme: 'Theme',
    PersonalizationAnalytics: 'PersonalizationAnalytics',
    UserProfile: 'UserProfile',
    Invoice: 'Invoice',
    Payment: 'Payment',
    Subscription: 'Subscription',
    Credit: 'Credit',
    BillingAlert: 'BillingAlert',
    Plan: 'Plan'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'client' | 'module' | 'moduleOnClient' | 'environmentVariable' | 'user' | 'library' | 'libraryVersion' | 'libraryAlias' | 'documentationChunk' | 'apiKey' | 'usageLog' | 'mCPConfiguration' | 'oAuthToken' | 'oAuthClient' | 'oAuthAuthorizationCode' | 'oAuthAccessToken' | 'oAuthRefreshToken' | 'downloadTask' | 'downloadResult' | 'promptCategory' | 'promptTemplate' | 'templateChange' | 'promptExecution' | 'promptExecutionError' | 'aBTest' | 'optimizationRecord' | 'conversation' | 'message' | 'messageReaction' | 'messageAttachment' | 'conversationShare' | 'conversationExport' | 'contextSource' | 'contextChunk' | 'contextQuery' | 'contextResult' | 'contextInjection' | 'contextTemplate' | 'contextQueryAnalytics' | 'contextCache' | 'userPreferences' | 'theme' | 'personalizationAnalytics' | 'userProfile' | 'invoice' | 'payment' | 'subscription' | 'credit' | 'billingAlert' | 'plan'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Client: {
        payload: ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>,
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Module: {
        payload: ModulePayload<ExtArgs>
        fields: Prisma.ModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ModulePayload>
          }
          findFirst: {
            args: Prisma.ModuleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ModulePayload>
          }
          findMany: {
            args: Prisma.ModuleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ModulePayload>[]
          }
          create: {
            args: Prisma.ModuleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ModulePayload>
          }
          createMany: {
            args: Prisma.ModuleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ModuleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ModulePayload>
          }
          update: {
            args: Prisma.ModuleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ModulePayload>
          }
          deleteMany: {
            args: Prisma.ModuleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ModuleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ModulePayload>
          }
          aggregate: {
            args: Prisma.ModuleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateModule>
          }
          groupBy: {
            args: Prisma.ModuleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleCountArgs<ExtArgs>,
            result: $Utils.Optional<ModuleCountAggregateOutputType> | number
          }
        }
      }
      ModuleOnClient: {
        payload: ModuleOnClientPayload<ExtArgs>
        fields: Prisma.ModuleOnClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleOnClientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ModuleOnClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleOnClientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ModuleOnClientPayload>
          }
          findFirst: {
            args: Prisma.ModuleOnClientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ModuleOnClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleOnClientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ModuleOnClientPayload>
          }
          findMany: {
            args: Prisma.ModuleOnClientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ModuleOnClientPayload>[]
          }
          create: {
            args: Prisma.ModuleOnClientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ModuleOnClientPayload>
          }
          createMany: {
            args: Prisma.ModuleOnClientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ModuleOnClientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ModuleOnClientPayload>
          }
          update: {
            args: Prisma.ModuleOnClientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ModuleOnClientPayload>
          }
          deleteMany: {
            args: Prisma.ModuleOnClientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleOnClientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ModuleOnClientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ModuleOnClientPayload>
          }
          aggregate: {
            args: Prisma.ModuleOnClientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateModuleOnClient>
          }
          groupBy: {
            args: Prisma.ModuleOnClientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ModuleOnClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleOnClientCountArgs<ExtArgs>,
            result: $Utils.Optional<ModuleOnClientCountAggregateOutputType> | number
          }
        }
      }
      EnvironmentVariable: {
        payload: EnvironmentVariablePayload<ExtArgs>
        fields: Prisma.EnvironmentVariableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnvironmentVariableFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EnvironmentVariablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnvironmentVariableFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EnvironmentVariablePayload>
          }
          findFirst: {
            args: Prisma.EnvironmentVariableFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EnvironmentVariablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnvironmentVariableFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EnvironmentVariablePayload>
          }
          findMany: {
            args: Prisma.EnvironmentVariableFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EnvironmentVariablePayload>[]
          }
          create: {
            args: Prisma.EnvironmentVariableCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EnvironmentVariablePayload>
          }
          createMany: {
            args: Prisma.EnvironmentVariableCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EnvironmentVariableDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EnvironmentVariablePayload>
          }
          update: {
            args: Prisma.EnvironmentVariableUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EnvironmentVariablePayload>
          }
          deleteMany: {
            args: Prisma.EnvironmentVariableDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EnvironmentVariableUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EnvironmentVariableUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EnvironmentVariablePayload>
          }
          aggregate: {
            args: Prisma.EnvironmentVariableAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEnvironmentVariable>
          }
          groupBy: {
            args: Prisma.EnvironmentVariableGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EnvironmentVariableGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnvironmentVariableCountArgs<ExtArgs>,
            result: $Utils.Optional<EnvironmentVariableCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Library: {
        payload: LibraryPayload<ExtArgs>
        fields: Prisma.LibraryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LibraryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LibraryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryPayload>
          }
          findFirst: {
            args: Prisma.LibraryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LibraryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryPayload>
          }
          findMany: {
            args: Prisma.LibraryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryPayload>[]
          }
          create: {
            args: Prisma.LibraryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryPayload>
          }
          createMany: {
            args: Prisma.LibraryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LibraryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryPayload>
          }
          update: {
            args: Prisma.LibraryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryPayload>
          }
          deleteMany: {
            args: Prisma.LibraryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LibraryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LibraryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryPayload>
          }
          aggregate: {
            args: Prisma.LibraryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLibrary>
          }
          groupBy: {
            args: Prisma.LibraryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LibraryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LibraryCountArgs<ExtArgs>,
            result: $Utils.Optional<LibraryCountAggregateOutputType> | number
          }
        }
      }
      LibraryVersion: {
        payload: LibraryVersionPayload<ExtArgs>
        fields: Prisma.LibraryVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LibraryVersionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LibraryVersionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryVersionPayload>
          }
          findFirst: {
            args: Prisma.LibraryVersionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LibraryVersionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryVersionPayload>
          }
          findMany: {
            args: Prisma.LibraryVersionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryVersionPayload>[]
          }
          create: {
            args: Prisma.LibraryVersionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryVersionPayload>
          }
          createMany: {
            args: Prisma.LibraryVersionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LibraryVersionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryVersionPayload>
          }
          update: {
            args: Prisma.LibraryVersionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryVersionPayload>
          }
          deleteMany: {
            args: Prisma.LibraryVersionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LibraryVersionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LibraryVersionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryVersionPayload>
          }
          aggregate: {
            args: Prisma.LibraryVersionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLibraryVersion>
          }
          groupBy: {
            args: Prisma.LibraryVersionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LibraryVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.LibraryVersionCountArgs<ExtArgs>,
            result: $Utils.Optional<LibraryVersionCountAggregateOutputType> | number
          }
        }
      }
      LibraryAlias: {
        payload: LibraryAliasPayload<ExtArgs>
        fields: Prisma.LibraryAliasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LibraryAliasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryAliasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LibraryAliasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryAliasPayload>
          }
          findFirst: {
            args: Prisma.LibraryAliasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryAliasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LibraryAliasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryAliasPayload>
          }
          findMany: {
            args: Prisma.LibraryAliasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryAliasPayload>[]
          }
          create: {
            args: Prisma.LibraryAliasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryAliasPayload>
          }
          createMany: {
            args: Prisma.LibraryAliasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LibraryAliasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryAliasPayload>
          }
          update: {
            args: Prisma.LibraryAliasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryAliasPayload>
          }
          deleteMany: {
            args: Prisma.LibraryAliasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LibraryAliasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LibraryAliasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LibraryAliasPayload>
          }
          aggregate: {
            args: Prisma.LibraryAliasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLibraryAlias>
          }
          groupBy: {
            args: Prisma.LibraryAliasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LibraryAliasGroupByOutputType>[]
          }
          count: {
            args: Prisma.LibraryAliasCountArgs<ExtArgs>,
            result: $Utils.Optional<LibraryAliasCountAggregateOutputType> | number
          }
        }
      }
      DocumentationChunk: {
        payload: DocumentationChunkPayload<ExtArgs>
        fields: Prisma.DocumentationChunkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentationChunkFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentationChunkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentationChunkFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentationChunkPayload>
          }
          findFirst: {
            args: Prisma.DocumentationChunkFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentationChunkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentationChunkFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentationChunkPayload>
          }
          findMany: {
            args: Prisma.DocumentationChunkFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentationChunkPayload>[]
          }
          create: {
            args: Prisma.DocumentationChunkCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentationChunkPayload>
          }
          createMany: {
            args: Prisma.DocumentationChunkCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DocumentationChunkDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentationChunkPayload>
          }
          update: {
            args: Prisma.DocumentationChunkUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentationChunkPayload>
          }
          deleteMany: {
            args: Prisma.DocumentationChunkDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentationChunkUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DocumentationChunkUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DocumentationChunkPayload>
          }
          aggregate: {
            args: Prisma.DocumentationChunkAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDocumentationChunk>
          }
          groupBy: {
            args: Prisma.DocumentationChunkGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DocumentationChunkGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentationChunkCountArgs<ExtArgs>,
            result: $Utils.Optional<DocumentationChunkCountAggregateOutputType> | number
          }
        }
      }
      ApiKey: {
        payload: ApiKeyPayload<ExtArgs>
        fields: Prisma.ApiKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ApiKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ApiKeyPayload>
          }
          findFirst: {
            args: Prisma.ApiKeyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ApiKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ApiKeyPayload>
          }
          findMany: {
            args: Prisma.ApiKeyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ApiKeyPayload>[]
          }
          create: {
            args: Prisma.ApiKeyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ApiKeyPayload>
          }
          createMany: {
            args: Prisma.ApiKeyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ApiKeyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ApiKeyPayload>
          }
          update: {
            args: Prisma.ApiKeyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ApiKeyPayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ApiKeyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ApiKeyPayload>
          }
          aggregate: {
            args: Prisma.ApiKeyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateApiKey>
          }
          groupBy: {
            args: Prisma.ApiKeyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ApiKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyCountArgs<ExtArgs>,
            result: $Utils.Optional<ApiKeyCountAggregateOutputType> | number
          }
        }
      }
      UsageLog: {
        payload: UsageLogPayload<ExtArgs>
        fields: Prisma.UsageLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsageLogFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsageLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsageLogFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsageLogPayload>
          }
          findFirst: {
            args: Prisma.UsageLogFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsageLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsageLogFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsageLogPayload>
          }
          findMany: {
            args: Prisma.UsageLogFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsageLogPayload>[]
          }
          create: {
            args: Prisma.UsageLogCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsageLogPayload>
          }
          createMany: {
            args: Prisma.UsageLogCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UsageLogDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsageLogPayload>
          }
          update: {
            args: Prisma.UsageLogUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsageLogPayload>
          }
          deleteMany: {
            args: Prisma.UsageLogDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UsageLogUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UsageLogUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UsageLogPayload>
          }
          aggregate: {
            args: Prisma.UsageLogAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsageLog>
          }
          groupBy: {
            args: Prisma.UsageLogGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsageLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsageLogCountArgs<ExtArgs>,
            result: $Utils.Optional<UsageLogCountAggregateOutputType> | number
          }
        }
      }
      MCPConfiguration: {
        payload: MCPConfigurationPayload<ExtArgs>
        fields: Prisma.MCPConfigurationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MCPConfigurationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MCPConfigurationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MCPConfigurationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MCPConfigurationPayload>
          }
          findFirst: {
            args: Prisma.MCPConfigurationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MCPConfigurationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MCPConfigurationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MCPConfigurationPayload>
          }
          findMany: {
            args: Prisma.MCPConfigurationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MCPConfigurationPayload>[]
          }
          create: {
            args: Prisma.MCPConfigurationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MCPConfigurationPayload>
          }
          createMany: {
            args: Prisma.MCPConfigurationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MCPConfigurationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MCPConfigurationPayload>
          }
          update: {
            args: Prisma.MCPConfigurationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MCPConfigurationPayload>
          }
          deleteMany: {
            args: Prisma.MCPConfigurationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MCPConfigurationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MCPConfigurationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MCPConfigurationPayload>
          }
          aggregate: {
            args: Prisma.MCPConfigurationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMCPConfiguration>
          }
          groupBy: {
            args: Prisma.MCPConfigurationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MCPConfigurationGroupByOutputType>[]
          }
          count: {
            args: Prisma.MCPConfigurationCountArgs<ExtArgs>,
            result: $Utils.Optional<MCPConfigurationCountAggregateOutputType> | number
          }
        }
      }
      OAuthToken: {
        payload: OAuthTokenPayload<ExtArgs>
        fields: Prisma.OAuthTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OAuthTokenFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OAuthTokenFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthTokenPayload>
          }
          findFirst: {
            args: Prisma.OAuthTokenFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OAuthTokenFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthTokenPayload>
          }
          findMany: {
            args: Prisma.OAuthTokenFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthTokenPayload>[]
          }
          create: {
            args: Prisma.OAuthTokenCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthTokenPayload>
          }
          createMany: {
            args: Prisma.OAuthTokenCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OAuthTokenDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthTokenPayload>
          }
          update: {
            args: Prisma.OAuthTokenUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthTokenPayload>
          }
          deleteMany: {
            args: Prisma.OAuthTokenDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OAuthTokenUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OAuthTokenUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthTokenPayload>
          }
          aggregate: {
            args: Prisma.OAuthTokenAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOAuthToken>
          }
          groupBy: {
            args: Prisma.OAuthTokenGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OAuthTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.OAuthTokenCountArgs<ExtArgs>,
            result: $Utils.Optional<OAuthTokenCountAggregateOutputType> | number
          }
        }
      }
      OAuthClient: {
        payload: OAuthClientPayload<ExtArgs>
        fields: Prisma.OAuthClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OAuthClientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OAuthClientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthClientPayload>
          }
          findFirst: {
            args: Prisma.OAuthClientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OAuthClientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthClientPayload>
          }
          findMany: {
            args: Prisma.OAuthClientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthClientPayload>[]
          }
          create: {
            args: Prisma.OAuthClientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthClientPayload>
          }
          createMany: {
            args: Prisma.OAuthClientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OAuthClientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthClientPayload>
          }
          update: {
            args: Prisma.OAuthClientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthClientPayload>
          }
          deleteMany: {
            args: Prisma.OAuthClientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OAuthClientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OAuthClientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthClientPayload>
          }
          aggregate: {
            args: Prisma.OAuthClientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOAuthClient>
          }
          groupBy: {
            args: Prisma.OAuthClientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OAuthClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.OAuthClientCountArgs<ExtArgs>,
            result: $Utils.Optional<OAuthClientCountAggregateOutputType> | number
          }
        }
      }
      OAuthAuthorizationCode: {
        payload: OAuthAuthorizationCodePayload<ExtArgs>
        fields: Prisma.OAuthAuthorizationCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OAuthAuthorizationCodeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthAuthorizationCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OAuthAuthorizationCodeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthAuthorizationCodePayload>
          }
          findFirst: {
            args: Prisma.OAuthAuthorizationCodeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthAuthorizationCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OAuthAuthorizationCodeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthAuthorizationCodePayload>
          }
          findMany: {
            args: Prisma.OAuthAuthorizationCodeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthAuthorizationCodePayload>[]
          }
          create: {
            args: Prisma.OAuthAuthorizationCodeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthAuthorizationCodePayload>
          }
          createMany: {
            args: Prisma.OAuthAuthorizationCodeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OAuthAuthorizationCodeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthAuthorizationCodePayload>
          }
          update: {
            args: Prisma.OAuthAuthorizationCodeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthAuthorizationCodePayload>
          }
          deleteMany: {
            args: Prisma.OAuthAuthorizationCodeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OAuthAuthorizationCodeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OAuthAuthorizationCodeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthAuthorizationCodePayload>
          }
          aggregate: {
            args: Prisma.OAuthAuthorizationCodeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOAuthAuthorizationCode>
          }
          groupBy: {
            args: Prisma.OAuthAuthorizationCodeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OAuthAuthorizationCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.OAuthAuthorizationCodeCountArgs<ExtArgs>,
            result: $Utils.Optional<OAuthAuthorizationCodeCountAggregateOutputType> | number
          }
        }
      }
      OAuthAccessToken: {
        payload: OAuthAccessTokenPayload<ExtArgs>
        fields: Prisma.OAuthAccessTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OAuthAccessTokenFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthAccessTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OAuthAccessTokenFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthAccessTokenPayload>
          }
          findFirst: {
            args: Prisma.OAuthAccessTokenFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthAccessTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OAuthAccessTokenFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthAccessTokenPayload>
          }
          findMany: {
            args: Prisma.OAuthAccessTokenFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthAccessTokenPayload>[]
          }
          create: {
            args: Prisma.OAuthAccessTokenCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthAccessTokenPayload>
          }
          createMany: {
            args: Prisma.OAuthAccessTokenCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OAuthAccessTokenDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthAccessTokenPayload>
          }
          update: {
            args: Prisma.OAuthAccessTokenUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthAccessTokenPayload>
          }
          deleteMany: {
            args: Prisma.OAuthAccessTokenDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OAuthAccessTokenUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OAuthAccessTokenUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthAccessTokenPayload>
          }
          aggregate: {
            args: Prisma.OAuthAccessTokenAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOAuthAccessToken>
          }
          groupBy: {
            args: Prisma.OAuthAccessTokenGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OAuthAccessTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.OAuthAccessTokenCountArgs<ExtArgs>,
            result: $Utils.Optional<OAuthAccessTokenCountAggregateOutputType> | number
          }
        }
      }
      OAuthRefreshToken: {
        payload: OAuthRefreshTokenPayload<ExtArgs>
        fields: Prisma.OAuthRefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OAuthRefreshTokenFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthRefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OAuthRefreshTokenFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthRefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.OAuthRefreshTokenFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthRefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OAuthRefreshTokenFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthRefreshTokenPayload>
          }
          findMany: {
            args: Prisma.OAuthRefreshTokenFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthRefreshTokenPayload>[]
          }
          create: {
            args: Prisma.OAuthRefreshTokenCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthRefreshTokenPayload>
          }
          createMany: {
            args: Prisma.OAuthRefreshTokenCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OAuthRefreshTokenDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthRefreshTokenPayload>
          }
          update: {
            args: Prisma.OAuthRefreshTokenUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthRefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.OAuthRefreshTokenDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OAuthRefreshTokenUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OAuthRefreshTokenUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OAuthRefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.OAuthRefreshTokenAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOAuthRefreshToken>
          }
          groupBy: {
            args: Prisma.OAuthRefreshTokenGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OAuthRefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.OAuthRefreshTokenCountArgs<ExtArgs>,
            result: $Utils.Optional<OAuthRefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      DownloadTask: {
        payload: DownloadTaskPayload<ExtArgs>
        fields: Prisma.DownloadTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DownloadTaskFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DownloadTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DownloadTaskFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DownloadTaskPayload>
          }
          findFirst: {
            args: Prisma.DownloadTaskFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DownloadTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DownloadTaskFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DownloadTaskPayload>
          }
          findMany: {
            args: Prisma.DownloadTaskFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DownloadTaskPayload>[]
          }
          create: {
            args: Prisma.DownloadTaskCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DownloadTaskPayload>
          }
          createMany: {
            args: Prisma.DownloadTaskCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DownloadTaskDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DownloadTaskPayload>
          }
          update: {
            args: Prisma.DownloadTaskUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DownloadTaskPayload>
          }
          deleteMany: {
            args: Prisma.DownloadTaskDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DownloadTaskUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DownloadTaskUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DownloadTaskPayload>
          }
          aggregate: {
            args: Prisma.DownloadTaskAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDownloadTask>
          }
          groupBy: {
            args: Prisma.DownloadTaskGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DownloadTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.DownloadTaskCountArgs<ExtArgs>,
            result: $Utils.Optional<DownloadTaskCountAggregateOutputType> | number
          }
        }
      }
      DownloadResult: {
        payload: DownloadResultPayload<ExtArgs>
        fields: Prisma.DownloadResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DownloadResultFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DownloadResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DownloadResultFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DownloadResultPayload>
          }
          findFirst: {
            args: Prisma.DownloadResultFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DownloadResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DownloadResultFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DownloadResultPayload>
          }
          findMany: {
            args: Prisma.DownloadResultFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DownloadResultPayload>[]
          }
          create: {
            args: Prisma.DownloadResultCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DownloadResultPayload>
          }
          createMany: {
            args: Prisma.DownloadResultCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DownloadResultDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DownloadResultPayload>
          }
          update: {
            args: Prisma.DownloadResultUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DownloadResultPayload>
          }
          deleteMany: {
            args: Prisma.DownloadResultDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DownloadResultUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DownloadResultUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DownloadResultPayload>
          }
          aggregate: {
            args: Prisma.DownloadResultAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDownloadResult>
          }
          groupBy: {
            args: Prisma.DownloadResultGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DownloadResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.DownloadResultCountArgs<ExtArgs>,
            result: $Utils.Optional<DownloadResultCountAggregateOutputType> | number
          }
        }
      }
      PromptCategory: {
        payload: PromptCategoryPayload<ExtArgs>
        fields: Prisma.PromptCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromptCategoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromptCategoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptCategoryPayload>
          }
          findFirst: {
            args: Prisma.PromptCategoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromptCategoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptCategoryPayload>
          }
          findMany: {
            args: Prisma.PromptCategoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptCategoryPayload>[]
          }
          create: {
            args: Prisma.PromptCategoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptCategoryPayload>
          }
          createMany: {
            args: Prisma.PromptCategoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PromptCategoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptCategoryPayload>
          }
          update: {
            args: Prisma.PromptCategoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptCategoryPayload>
          }
          deleteMany: {
            args: Prisma.PromptCategoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PromptCategoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PromptCategoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptCategoryPayload>
          }
          aggregate: {
            args: Prisma.PromptCategoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePromptCategory>
          }
          groupBy: {
            args: Prisma.PromptCategoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PromptCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromptCategoryCountArgs<ExtArgs>,
            result: $Utils.Optional<PromptCategoryCountAggregateOutputType> | number
          }
        }
      }
      PromptTemplate: {
        payload: PromptTemplatePayload<ExtArgs>
        fields: Prisma.PromptTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromptTemplateFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromptTemplateFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptTemplatePayload>
          }
          findFirst: {
            args: Prisma.PromptTemplateFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromptTemplateFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptTemplatePayload>
          }
          findMany: {
            args: Prisma.PromptTemplateFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptTemplatePayload>[]
          }
          create: {
            args: Prisma.PromptTemplateCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptTemplatePayload>
          }
          createMany: {
            args: Prisma.PromptTemplateCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PromptTemplateDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptTemplatePayload>
          }
          update: {
            args: Prisma.PromptTemplateUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptTemplatePayload>
          }
          deleteMany: {
            args: Prisma.PromptTemplateDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PromptTemplateUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PromptTemplateUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptTemplatePayload>
          }
          aggregate: {
            args: Prisma.PromptTemplateAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePromptTemplate>
          }
          groupBy: {
            args: Prisma.PromptTemplateGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PromptTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromptTemplateCountArgs<ExtArgs>,
            result: $Utils.Optional<PromptTemplateCountAggregateOutputType> | number
          }
        }
      }
      TemplateChange: {
        payload: TemplateChangePayload<ExtArgs>
        fields: Prisma.TemplateChangeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateChangeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TemplateChangePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateChangeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TemplateChangePayload>
          }
          findFirst: {
            args: Prisma.TemplateChangeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TemplateChangePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateChangeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TemplateChangePayload>
          }
          findMany: {
            args: Prisma.TemplateChangeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TemplateChangePayload>[]
          }
          create: {
            args: Prisma.TemplateChangeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TemplateChangePayload>
          }
          createMany: {
            args: Prisma.TemplateChangeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TemplateChangeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TemplateChangePayload>
          }
          update: {
            args: Prisma.TemplateChangeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TemplateChangePayload>
          }
          deleteMany: {
            args: Prisma.TemplateChangeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateChangeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TemplateChangeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TemplateChangePayload>
          }
          aggregate: {
            args: Prisma.TemplateChangeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTemplateChange>
          }
          groupBy: {
            args: Prisma.TemplateChangeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TemplateChangeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateChangeCountArgs<ExtArgs>,
            result: $Utils.Optional<TemplateChangeCountAggregateOutputType> | number
          }
        }
      }
      PromptExecution: {
        payload: PromptExecutionPayload<ExtArgs>
        fields: Prisma.PromptExecutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromptExecutionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptExecutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromptExecutionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptExecutionPayload>
          }
          findFirst: {
            args: Prisma.PromptExecutionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptExecutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromptExecutionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptExecutionPayload>
          }
          findMany: {
            args: Prisma.PromptExecutionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptExecutionPayload>[]
          }
          create: {
            args: Prisma.PromptExecutionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptExecutionPayload>
          }
          createMany: {
            args: Prisma.PromptExecutionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PromptExecutionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptExecutionPayload>
          }
          update: {
            args: Prisma.PromptExecutionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptExecutionPayload>
          }
          deleteMany: {
            args: Prisma.PromptExecutionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PromptExecutionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PromptExecutionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptExecutionPayload>
          }
          aggregate: {
            args: Prisma.PromptExecutionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePromptExecution>
          }
          groupBy: {
            args: Prisma.PromptExecutionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PromptExecutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromptExecutionCountArgs<ExtArgs>,
            result: $Utils.Optional<PromptExecutionCountAggregateOutputType> | number
          }
        }
      }
      PromptExecutionError: {
        payload: PromptExecutionErrorPayload<ExtArgs>
        fields: Prisma.PromptExecutionErrorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromptExecutionErrorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptExecutionErrorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromptExecutionErrorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptExecutionErrorPayload>
          }
          findFirst: {
            args: Prisma.PromptExecutionErrorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptExecutionErrorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromptExecutionErrorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptExecutionErrorPayload>
          }
          findMany: {
            args: Prisma.PromptExecutionErrorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptExecutionErrorPayload>[]
          }
          create: {
            args: Prisma.PromptExecutionErrorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptExecutionErrorPayload>
          }
          createMany: {
            args: Prisma.PromptExecutionErrorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PromptExecutionErrorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptExecutionErrorPayload>
          }
          update: {
            args: Prisma.PromptExecutionErrorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptExecutionErrorPayload>
          }
          deleteMany: {
            args: Prisma.PromptExecutionErrorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PromptExecutionErrorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PromptExecutionErrorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PromptExecutionErrorPayload>
          }
          aggregate: {
            args: Prisma.PromptExecutionErrorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePromptExecutionError>
          }
          groupBy: {
            args: Prisma.PromptExecutionErrorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PromptExecutionErrorGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromptExecutionErrorCountArgs<ExtArgs>,
            result: $Utils.Optional<PromptExecutionErrorCountAggregateOutputType> | number
          }
        }
      }
      ABTest: {
        payload: ABTestPayload<ExtArgs>
        fields: Prisma.ABTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ABTestFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ABTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ABTestFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ABTestPayload>
          }
          findFirst: {
            args: Prisma.ABTestFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ABTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ABTestFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ABTestPayload>
          }
          findMany: {
            args: Prisma.ABTestFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ABTestPayload>[]
          }
          create: {
            args: Prisma.ABTestCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ABTestPayload>
          }
          createMany: {
            args: Prisma.ABTestCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ABTestDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ABTestPayload>
          }
          update: {
            args: Prisma.ABTestUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ABTestPayload>
          }
          deleteMany: {
            args: Prisma.ABTestDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ABTestUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ABTestUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ABTestPayload>
          }
          aggregate: {
            args: Prisma.ABTestAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateABTest>
          }
          groupBy: {
            args: Prisma.ABTestGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ABTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ABTestCountArgs<ExtArgs>,
            result: $Utils.Optional<ABTestCountAggregateOutputType> | number
          }
        }
      }
      OptimizationRecord: {
        payload: OptimizationRecordPayload<ExtArgs>
        fields: Prisma.OptimizationRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OptimizationRecordFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OptimizationRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OptimizationRecordFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OptimizationRecordPayload>
          }
          findFirst: {
            args: Prisma.OptimizationRecordFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OptimizationRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OptimizationRecordFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OptimizationRecordPayload>
          }
          findMany: {
            args: Prisma.OptimizationRecordFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OptimizationRecordPayload>[]
          }
          create: {
            args: Prisma.OptimizationRecordCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OptimizationRecordPayload>
          }
          createMany: {
            args: Prisma.OptimizationRecordCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OptimizationRecordDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OptimizationRecordPayload>
          }
          update: {
            args: Prisma.OptimizationRecordUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OptimizationRecordPayload>
          }
          deleteMany: {
            args: Prisma.OptimizationRecordDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OptimizationRecordUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OptimizationRecordUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<OptimizationRecordPayload>
          }
          aggregate: {
            args: Prisma.OptimizationRecordAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOptimizationRecord>
          }
          groupBy: {
            args: Prisma.OptimizationRecordGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OptimizationRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.OptimizationRecordCountArgs<ExtArgs>,
            result: $Utils.Optional<OptimizationRecordCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>,
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>,
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      MessageReaction: {
        payload: MessageReactionPayload<ExtArgs>
        fields: Prisma.MessageReactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageReactionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessageReactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageReactionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessageReactionPayload>
          }
          findFirst: {
            args: Prisma.MessageReactionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessageReactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageReactionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessageReactionPayload>
          }
          findMany: {
            args: Prisma.MessageReactionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessageReactionPayload>[]
          }
          create: {
            args: Prisma.MessageReactionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessageReactionPayload>
          }
          createMany: {
            args: Prisma.MessageReactionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MessageReactionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessageReactionPayload>
          }
          update: {
            args: Prisma.MessageReactionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessageReactionPayload>
          }
          deleteMany: {
            args: Prisma.MessageReactionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MessageReactionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MessageReactionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessageReactionPayload>
          }
          aggregate: {
            args: Prisma.MessageReactionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMessageReaction>
          }
          groupBy: {
            args: Prisma.MessageReactionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MessageReactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageReactionCountArgs<ExtArgs>,
            result: $Utils.Optional<MessageReactionCountAggregateOutputType> | number
          }
        }
      }
      MessageAttachment: {
        payload: MessageAttachmentPayload<ExtArgs>
        fields: Prisma.MessageAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageAttachmentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessageAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageAttachmentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessageAttachmentPayload>
          }
          findFirst: {
            args: Prisma.MessageAttachmentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessageAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageAttachmentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessageAttachmentPayload>
          }
          findMany: {
            args: Prisma.MessageAttachmentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessageAttachmentPayload>[]
          }
          create: {
            args: Prisma.MessageAttachmentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessageAttachmentPayload>
          }
          createMany: {
            args: Prisma.MessageAttachmentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MessageAttachmentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessageAttachmentPayload>
          }
          update: {
            args: Prisma.MessageAttachmentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessageAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.MessageAttachmentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MessageAttachmentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MessageAttachmentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MessageAttachmentPayload>
          }
          aggregate: {
            args: Prisma.MessageAttachmentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMessageAttachment>
          }
          groupBy: {
            args: Prisma.MessageAttachmentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MessageAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageAttachmentCountArgs<ExtArgs>,
            result: $Utils.Optional<MessageAttachmentCountAggregateOutputType> | number
          }
        }
      }
      ConversationShare: {
        payload: ConversationSharePayload<ExtArgs>
        fields: Prisma.ConversationShareFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationShareFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConversationSharePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationShareFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConversationSharePayload>
          }
          findFirst: {
            args: Prisma.ConversationShareFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConversationSharePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationShareFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConversationSharePayload>
          }
          findMany: {
            args: Prisma.ConversationShareFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConversationSharePayload>[]
          }
          create: {
            args: Prisma.ConversationShareCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConversationSharePayload>
          }
          createMany: {
            args: Prisma.ConversationShareCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConversationShareDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConversationSharePayload>
          }
          update: {
            args: Prisma.ConversationShareUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConversationSharePayload>
          }
          deleteMany: {
            args: Prisma.ConversationShareDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationShareUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConversationShareUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConversationSharePayload>
          }
          aggregate: {
            args: Prisma.ConversationShareAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConversationShare>
          }
          groupBy: {
            args: Prisma.ConversationShareGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConversationShareGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationShareCountArgs<ExtArgs>,
            result: $Utils.Optional<ConversationShareCountAggregateOutputType> | number
          }
        }
      }
      ConversationExport: {
        payload: ConversationExportPayload<ExtArgs>
        fields: Prisma.ConversationExportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationExportFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConversationExportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationExportFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConversationExportPayload>
          }
          findFirst: {
            args: Prisma.ConversationExportFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConversationExportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationExportFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConversationExportPayload>
          }
          findMany: {
            args: Prisma.ConversationExportFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConversationExportPayload>[]
          }
          create: {
            args: Prisma.ConversationExportCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConversationExportPayload>
          }
          createMany: {
            args: Prisma.ConversationExportCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConversationExportDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConversationExportPayload>
          }
          update: {
            args: Prisma.ConversationExportUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConversationExportPayload>
          }
          deleteMany: {
            args: Prisma.ConversationExportDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationExportUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConversationExportUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ConversationExportPayload>
          }
          aggregate: {
            args: Prisma.ConversationExportAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConversationExport>
          }
          groupBy: {
            args: Prisma.ConversationExportGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConversationExportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationExportCountArgs<ExtArgs>,
            result: $Utils.Optional<ConversationExportCountAggregateOutputType> | number
          }
        }
      }
      ContextSource: {
        payload: ContextSourcePayload<ExtArgs>
        fields: Prisma.ContextSourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContextSourceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextSourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContextSourceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextSourcePayload>
          }
          findFirst: {
            args: Prisma.ContextSourceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextSourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContextSourceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextSourcePayload>
          }
          findMany: {
            args: Prisma.ContextSourceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextSourcePayload>[]
          }
          create: {
            args: Prisma.ContextSourceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextSourcePayload>
          }
          createMany: {
            args: Prisma.ContextSourceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ContextSourceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextSourcePayload>
          }
          update: {
            args: Prisma.ContextSourceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextSourcePayload>
          }
          deleteMany: {
            args: Prisma.ContextSourceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ContextSourceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ContextSourceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextSourcePayload>
          }
          aggregate: {
            args: Prisma.ContextSourceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContextSource>
          }
          groupBy: {
            args: Prisma.ContextSourceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContextSourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContextSourceCountArgs<ExtArgs>,
            result: $Utils.Optional<ContextSourceCountAggregateOutputType> | number
          }
        }
      }
      ContextChunk: {
        payload: ContextChunkPayload<ExtArgs>
        fields: Prisma.ContextChunkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContextChunkFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextChunkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContextChunkFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextChunkPayload>
          }
          findFirst: {
            args: Prisma.ContextChunkFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextChunkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContextChunkFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextChunkPayload>
          }
          findMany: {
            args: Prisma.ContextChunkFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextChunkPayload>[]
          }
          create: {
            args: Prisma.ContextChunkCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextChunkPayload>
          }
          createMany: {
            args: Prisma.ContextChunkCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ContextChunkDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextChunkPayload>
          }
          update: {
            args: Prisma.ContextChunkUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextChunkPayload>
          }
          deleteMany: {
            args: Prisma.ContextChunkDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ContextChunkUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ContextChunkUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextChunkPayload>
          }
          aggregate: {
            args: Prisma.ContextChunkAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContextChunk>
          }
          groupBy: {
            args: Prisma.ContextChunkGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContextChunkGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContextChunkCountArgs<ExtArgs>,
            result: $Utils.Optional<ContextChunkCountAggregateOutputType> | number
          }
        }
      }
      ContextQuery: {
        payload: ContextQueryPayload<ExtArgs>
        fields: Prisma.ContextQueryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContextQueryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextQueryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContextQueryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextQueryPayload>
          }
          findFirst: {
            args: Prisma.ContextQueryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextQueryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContextQueryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextQueryPayload>
          }
          findMany: {
            args: Prisma.ContextQueryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextQueryPayload>[]
          }
          create: {
            args: Prisma.ContextQueryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextQueryPayload>
          }
          createMany: {
            args: Prisma.ContextQueryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ContextQueryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextQueryPayload>
          }
          update: {
            args: Prisma.ContextQueryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextQueryPayload>
          }
          deleteMany: {
            args: Prisma.ContextQueryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ContextQueryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ContextQueryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextQueryPayload>
          }
          aggregate: {
            args: Prisma.ContextQueryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContextQuery>
          }
          groupBy: {
            args: Prisma.ContextQueryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContextQueryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContextQueryCountArgs<ExtArgs>,
            result: $Utils.Optional<ContextQueryCountAggregateOutputType> | number
          }
        }
      }
      ContextResult: {
        payload: ContextResultPayload<ExtArgs>
        fields: Prisma.ContextResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContextResultFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContextResultFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextResultPayload>
          }
          findFirst: {
            args: Prisma.ContextResultFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContextResultFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextResultPayload>
          }
          findMany: {
            args: Prisma.ContextResultFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextResultPayload>[]
          }
          create: {
            args: Prisma.ContextResultCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextResultPayload>
          }
          createMany: {
            args: Prisma.ContextResultCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ContextResultDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextResultPayload>
          }
          update: {
            args: Prisma.ContextResultUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextResultPayload>
          }
          deleteMany: {
            args: Prisma.ContextResultDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ContextResultUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ContextResultUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextResultPayload>
          }
          aggregate: {
            args: Prisma.ContextResultAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContextResult>
          }
          groupBy: {
            args: Prisma.ContextResultGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContextResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContextResultCountArgs<ExtArgs>,
            result: $Utils.Optional<ContextResultCountAggregateOutputType> | number
          }
        }
      }
      ContextInjection: {
        payload: ContextInjectionPayload<ExtArgs>
        fields: Prisma.ContextInjectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContextInjectionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextInjectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContextInjectionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextInjectionPayload>
          }
          findFirst: {
            args: Prisma.ContextInjectionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextInjectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContextInjectionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextInjectionPayload>
          }
          findMany: {
            args: Prisma.ContextInjectionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextInjectionPayload>[]
          }
          create: {
            args: Prisma.ContextInjectionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextInjectionPayload>
          }
          createMany: {
            args: Prisma.ContextInjectionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ContextInjectionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextInjectionPayload>
          }
          update: {
            args: Prisma.ContextInjectionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextInjectionPayload>
          }
          deleteMany: {
            args: Prisma.ContextInjectionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ContextInjectionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ContextInjectionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextInjectionPayload>
          }
          aggregate: {
            args: Prisma.ContextInjectionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContextInjection>
          }
          groupBy: {
            args: Prisma.ContextInjectionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContextInjectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContextInjectionCountArgs<ExtArgs>,
            result: $Utils.Optional<ContextInjectionCountAggregateOutputType> | number
          }
        }
      }
      ContextTemplate: {
        payload: ContextTemplatePayload<ExtArgs>
        fields: Prisma.ContextTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContextTemplateFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContextTemplateFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextTemplatePayload>
          }
          findFirst: {
            args: Prisma.ContextTemplateFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContextTemplateFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextTemplatePayload>
          }
          findMany: {
            args: Prisma.ContextTemplateFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextTemplatePayload>[]
          }
          create: {
            args: Prisma.ContextTemplateCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextTemplatePayload>
          }
          createMany: {
            args: Prisma.ContextTemplateCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ContextTemplateDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextTemplatePayload>
          }
          update: {
            args: Prisma.ContextTemplateUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextTemplatePayload>
          }
          deleteMany: {
            args: Prisma.ContextTemplateDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ContextTemplateUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ContextTemplateUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextTemplatePayload>
          }
          aggregate: {
            args: Prisma.ContextTemplateAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContextTemplate>
          }
          groupBy: {
            args: Prisma.ContextTemplateGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContextTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContextTemplateCountArgs<ExtArgs>,
            result: $Utils.Optional<ContextTemplateCountAggregateOutputType> | number
          }
        }
      }
      ContextQueryAnalytics: {
        payload: ContextQueryAnalyticsPayload<ExtArgs>
        fields: Prisma.ContextQueryAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContextQueryAnalyticsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextQueryAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContextQueryAnalyticsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextQueryAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.ContextQueryAnalyticsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextQueryAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContextQueryAnalyticsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextQueryAnalyticsPayload>
          }
          findMany: {
            args: Prisma.ContextQueryAnalyticsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextQueryAnalyticsPayload>[]
          }
          create: {
            args: Prisma.ContextQueryAnalyticsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextQueryAnalyticsPayload>
          }
          createMany: {
            args: Prisma.ContextQueryAnalyticsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ContextQueryAnalyticsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextQueryAnalyticsPayload>
          }
          update: {
            args: Prisma.ContextQueryAnalyticsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextQueryAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.ContextQueryAnalyticsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ContextQueryAnalyticsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ContextQueryAnalyticsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextQueryAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.ContextQueryAnalyticsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContextQueryAnalytics>
          }
          groupBy: {
            args: Prisma.ContextQueryAnalyticsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContextQueryAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContextQueryAnalyticsCountArgs<ExtArgs>,
            result: $Utils.Optional<ContextQueryAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      ContextCache: {
        payload: ContextCachePayload<ExtArgs>
        fields: Prisma.ContextCacheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContextCacheFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextCachePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContextCacheFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextCachePayload>
          }
          findFirst: {
            args: Prisma.ContextCacheFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextCachePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContextCacheFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextCachePayload>
          }
          findMany: {
            args: Prisma.ContextCacheFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextCachePayload>[]
          }
          create: {
            args: Prisma.ContextCacheCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextCachePayload>
          }
          createMany: {
            args: Prisma.ContextCacheCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ContextCacheDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextCachePayload>
          }
          update: {
            args: Prisma.ContextCacheUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextCachePayload>
          }
          deleteMany: {
            args: Prisma.ContextCacheDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ContextCacheUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ContextCacheUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ContextCachePayload>
          }
          aggregate: {
            args: Prisma.ContextCacheAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContextCache>
          }
          groupBy: {
            args: Prisma.ContextCacheGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContextCacheGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContextCacheCountArgs<ExtArgs>,
            result: $Utils.Optional<ContextCacheCountAggregateOutputType> | number
          }
        }
      }
      UserPreferences: {
        payload: UserPreferencesPayload<ExtArgs>
        fields: Prisma.UserPreferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPreferencesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPreferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPreferencesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPreferencesPayload>
          }
          findFirst: {
            args: Prisma.UserPreferencesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPreferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPreferencesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPreferencesPayload>
          }
          findMany: {
            args: Prisma.UserPreferencesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPreferencesPayload>[]
          }
          create: {
            args: Prisma.UserPreferencesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPreferencesPayload>
          }
          createMany: {
            args: Prisma.UserPreferencesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserPreferencesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPreferencesPayload>
          }
          update: {
            args: Prisma.UserPreferencesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPreferencesPayload>
          }
          deleteMany: {
            args: Prisma.UserPreferencesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserPreferencesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserPreferencesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPreferencesPayload>
          }
          aggregate: {
            args: Prisma.UserPreferencesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserPreferences>
          }
          groupBy: {
            args: Prisma.UserPreferencesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserPreferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPreferencesCountArgs<ExtArgs>,
            result: $Utils.Optional<UserPreferencesCountAggregateOutputType> | number
          }
        }
      }
      Theme: {
        payload: ThemePayload<ExtArgs>
        fields: Prisma.ThemeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ThemeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ThemePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ThemeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ThemePayload>
          }
          findFirst: {
            args: Prisma.ThemeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ThemePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ThemeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ThemePayload>
          }
          findMany: {
            args: Prisma.ThemeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ThemePayload>[]
          }
          create: {
            args: Prisma.ThemeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ThemePayload>
          }
          createMany: {
            args: Prisma.ThemeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ThemeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ThemePayload>
          }
          update: {
            args: Prisma.ThemeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ThemePayload>
          }
          deleteMany: {
            args: Prisma.ThemeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ThemeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ThemeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ThemePayload>
          }
          aggregate: {
            args: Prisma.ThemeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTheme>
          }
          groupBy: {
            args: Prisma.ThemeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ThemeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ThemeCountArgs<ExtArgs>,
            result: $Utils.Optional<ThemeCountAggregateOutputType> | number
          }
        }
      }
      PersonalizationAnalytics: {
        payload: PersonalizationAnalyticsPayload<ExtArgs>
        fields: Prisma.PersonalizationAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonalizationAnalyticsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonalizationAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonalizationAnalyticsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonalizationAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.PersonalizationAnalyticsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonalizationAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonalizationAnalyticsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonalizationAnalyticsPayload>
          }
          findMany: {
            args: Prisma.PersonalizationAnalyticsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonalizationAnalyticsPayload>[]
          }
          create: {
            args: Prisma.PersonalizationAnalyticsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonalizationAnalyticsPayload>
          }
          createMany: {
            args: Prisma.PersonalizationAnalyticsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PersonalizationAnalyticsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonalizationAnalyticsPayload>
          }
          update: {
            args: Prisma.PersonalizationAnalyticsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonalizationAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.PersonalizationAnalyticsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PersonalizationAnalyticsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PersonalizationAnalyticsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PersonalizationAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.PersonalizationAnalyticsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePersonalizationAnalytics>
          }
          groupBy: {
            args: Prisma.PersonalizationAnalyticsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PersonalizationAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonalizationAnalyticsCountArgs<ExtArgs>,
            result: $Utils.Optional<PersonalizationAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      UserProfile: {
        payload: UserProfilePayload<ExtArgs>
        fields: Prisma.UserProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProfileFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProfileFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserProfilePayload>
          }
          findFirst: {
            args: Prisma.UserProfileFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProfileFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserProfilePayload>
          }
          findMany: {
            args: Prisma.UserProfileFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserProfilePayload>[]
          }
          create: {
            args: Prisma.UserProfileCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserProfilePayload>
          }
          createMany: {
            args: Prisma.UserProfileCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserProfileDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserProfilePayload>
          }
          update: {
            args: Prisma.UserProfileUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserProfilePayload>
          }
          deleteMany: {
            args: Prisma.UserProfileDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserProfileUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserProfileUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserProfilePayload>
          }
          aggregate: {
            args: Prisma.UserProfileAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserProfile>
          }
          groupBy: {
            args: Prisma.UserProfileGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProfileCountArgs<ExtArgs>,
            result: $Utils.Optional<UserProfileCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>,
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>,
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>,
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Credit: {
        payload: CreditPayload<ExtArgs>
        fields: Prisma.CreditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CreditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CreditPayload>
          }
          findFirst: {
            args: Prisma.CreditFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CreditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CreditPayload>
          }
          findMany: {
            args: Prisma.CreditFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CreditPayload>[]
          }
          create: {
            args: Prisma.CreditCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CreditPayload>
          }
          createMany: {
            args: Prisma.CreditCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CreditDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CreditPayload>
          }
          update: {
            args: Prisma.CreditUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CreditPayload>
          }
          deleteMany: {
            args: Prisma.CreditDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CreditUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CreditUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CreditPayload>
          }
          aggregate: {
            args: Prisma.CreditAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCredit>
          }
          groupBy: {
            args: Prisma.CreditGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CreditGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditCountArgs<ExtArgs>,
            result: $Utils.Optional<CreditCountAggregateOutputType> | number
          }
        }
      }
      BillingAlert: {
        payload: BillingAlertPayload<ExtArgs>
        fields: Prisma.BillingAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillingAlertFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BillingAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillingAlertFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BillingAlertPayload>
          }
          findFirst: {
            args: Prisma.BillingAlertFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BillingAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillingAlertFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BillingAlertPayload>
          }
          findMany: {
            args: Prisma.BillingAlertFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BillingAlertPayload>[]
          }
          create: {
            args: Prisma.BillingAlertCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BillingAlertPayload>
          }
          createMany: {
            args: Prisma.BillingAlertCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BillingAlertDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BillingAlertPayload>
          }
          update: {
            args: Prisma.BillingAlertUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BillingAlertPayload>
          }
          deleteMany: {
            args: Prisma.BillingAlertDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BillingAlertUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BillingAlertUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BillingAlertPayload>
          }
          aggregate: {
            args: Prisma.BillingAlertAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBillingAlert>
          }
          groupBy: {
            args: Prisma.BillingAlertGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BillingAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillingAlertCountArgs<ExtArgs>,
            result: $Utils.Optional<BillingAlertCountAggregateOutputType> | number
          }
        }
      }
      Plan: {
        payload: PlanPayload<ExtArgs>
        fields: Prisma.PlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PlanPayload>
          }
          findFirst: {
            args: Prisma.PlanFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PlanPayload>
          }
          findMany: {
            args: Prisma.PlanFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PlanPayload>[]
          }
          create: {
            args: Prisma.PlanCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PlanPayload>
          }
          createMany: {
            args: Prisma.PlanCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PlanDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PlanPayload>
          }
          update: {
            args: Prisma.PlanUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PlanPayload>
          }
          deleteMany: {
            args: Prisma.PlanDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PlanUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PlanUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PlanPayload>
          }
          aggregate: {
            args: Prisma.PlanAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePlan>
          }
          groupBy: {
            args: Prisma.PlanGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanCountArgs<ExtArgs>,
            result: $Utils.Optional<PlanCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ClientCountOutputType
   */


  export type ClientCountOutputType = {
    modules: number
    environmentVariables: number
    users: number
    libraries: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    modules?: boolean | ClientCountOutputTypeCountModulesArgs
    environmentVariables?: boolean | ClientCountOutputTypeCountEnvironmentVariablesArgs
    users?: boolean | ClientCountOutputTypeCountUsersArgs
    libraries?: boolean | ClientCountOutputTypeCountLibrariesArgs
  }

  // Custom InputTypes

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ModuleOnClientWhereInput
  }


  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountEnvironmentVariablesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EnvironmentVariableWhereInput
  }


  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountLibrariesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LibraryWhereInput
  }



  /**
   * Count Type ModuleCountOutputType
   */


  export type ModuleCountOutputType = {
    clients: number
  }

  export type ModuleCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    clients?: boolean | ModuleCountOutputTypeCountClientsArgs
  }

  // Custom InputTypes

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCountOutputType
     */
    select?: ModuleCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountClientsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ModuleOnClientWhereInput
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    apiKeys: number
    mcpConfigurations: number
    usageLogs: number
    oauthTokens: number
    conversations: number
    messageReactions: number
    themes: number
    personalizationAnalytics: number
    conversationShares: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    apiKeys?: boolean | UserCountOutputTypeCountApiKeysArgs
    mcpConfigurations?: boolean | UserCountOutputTypeCountMcpConfigurationsArgs
    usageLogs?: boolean | UserCountOutputTypeCountUsageLogsArgs
    oauthTokens?: boolean | UserCountOutputTypeCountOauthTokensArgs
    conversations?: boolean | UserCountOutputTypeCountConversationsArgs
    messageReactions?: boolean | UserCountOutputTypeCountMessageReactionsArgs
    themes?: boolean | UserCountOutputTypeCountThemesArgs
    personalizationAnalytics?: boolean | UserCountOutputTypeCountPersonalizationAnalyticsArgs
    conversationShares?: boolean | UserCountOutputTypeCountConversationSharesArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApiKeysArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMcpConfigurationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MCPConfigurationWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUsageLogsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UsageLogWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOauthTokensArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OAuthTokenWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessageReactionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MessageReactionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountThemesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ThemeWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPersonalizationAnalyticsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PersonalizationAnalyticsWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationSharesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ConversationShareWhereInput
  }



  /**
   * Count Type LibraryCountOutputType
   */


  export type LibraryCountOutputType = {
    versions: number
    aliases: number
    documentationChunks: number
    usageLogs: number
  }

  export type LibraryCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    versions?: boolean | LibraryCountOutputTypeCountVersionsArgs
    aliases?: boolean | LibraryCountOutputTypeCountAliasesArgs
    documentationChunks?: boolean | LibraryCountOutputTypeCountDocumentationChunksArgs
    usageLogs?: boolean | LibraryCountOutputTypeCountUsageLogsArgs
  }

  // Custom InputTypes

  /**
   * LibraryCountOutputType without action
   */
  export type LibraryCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryCountOutputType
     */
    select?: LibraryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * LibraryCountOutputType without action
   */
  export type LibraryCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LibraryVersionWhereInput
  }


  /**
   * LibraryCountOutputType without action
   */
  export type LibraryCountOutputTypeCountAliasesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LibraryAliasWhereInput
  }


  /**
   * LibraryCountOutputType without action
   */
  export type LibraryCountOutputTypeCountDocumentationChunksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentationChunkWhereInput
  }


  /**
   * LibraryCountOutputType without action
   */
  export type LibraryCountOutputTypeCountUsageLogsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UsageLogWhereInput
  }



  /**
   * Count Type LibraryVersionCountOutputType
   */


  export type LibraryVersionCountOutputType = {
    documentationChunks: number
  }

  export type LibraryVersionCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    documentationChunks?: boolean | LibraryVersionCountOutputTypeCountDocumentationChunksArgs
  }

  // Custom InputTypes

  /**
   * LibraryVersionCountOutputType without action
   */
  export type LibraryVersionCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryVersionCountOutputType
     */
    select?: LibraryVersionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * LibraryVersionCountOutputType without action
   */
  export type LibraryVersionCountOutputTypeCountDocumentationChunksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentationChunkWhereInput
  }



  /**
   * Count Type ApiKeyCountOutputType
   */


  export type ApiKeyCountOutputType = {
    usageLogs: number
  }

  export type ApiKeyCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    usageLogs?: boolean | ApiKeyCountOutputTypeCountUsageLogsArgs
  }

  // Custom InputTypes

  /**
   * ApiKeyCountOutputType without action
   */
  export type ApiKeyCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKeyCountOutputType
     */
    select?: ApiKeyCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ApiKeyCountOutputType without action
   */
  export type ApiKeyCountOutputTypeCountUsageLogsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UsageLogWhereInput
  }



  /**
   * Count Type OAuthClientCountOutputType
   */


  export type OAuthClientCountOutputType = {
    authorizationCodes: number
    accessTokens: number
    refreshTokens: number
  }

  export type OAuthClientCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    authorizationCodes?: boolean | OAuthClientCountOutputTypeCountAuthorizationCodesArgs
    accessTokens?: boolean | OAuthClientCountOutputTypeCountAccessTokensArgs
    refreshTokens?: boolean | OAuthClientCountOutputTypeCountRefreshTokensArgs
  }

  // Custom InputTypes

  /**
   * OAuthClientCountOutputType without action
   */
  export type OAuthClientCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthClientCountOutputType
     */
    select?: OAuthClientCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * OAuthClientCountOutputType without action
   */
  export type OAuthClientCountOutputTypeCountAuthorizationCodesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OAuthAuthorizationCodeWhereInput
  }


  /**
   * OAuthClientCountOutputType without action
   */
  export type OAuthClientCountOutputTypeCountAccessTokensArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OAuthAccessTokenWhereInput
  }


  /**
   * OAuthClientCountOutputType without action
   */
  export type OAuthClientCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OAuthRefreshTokenWhereInput
  }



  /**
   * Count Type OAuthAccessTokenCountOutputType
   */


  export type OAuthAccessTokenCountOutputType = {
    refreshToken: number
  }

  export type OAuthAccessTokenCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    refreshToken?: boolean | OAuthAccessTokenCountOutputTypeCountRefreshTokenArgs
  }

  // Custom InputTypes

  /**
   * OAuthAccessTokenCountOutputType without action
   */
  export type OAuthAccessTokenCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccessTokenCountOutputType
     */
    select?: OAuthAccessTokenCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * OAuthAccessTokenCountOutputType without action
   */
  export type OAuthAccessTokenCountOutputTypeCountRefreshTokenArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OAuthRefreshTokenWhereInput
  }



  /**
   * Count Type DownloadTaskCountOutputType
   */


  export type DownloadTaskCountOutputType = {
    downloadResults: number
  }

  export type DownloadTaskCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    downloadResults?: boolean | DownloadTaskCountOutputTypeCountDownloadResultsArgs
  }

  // Custom InputTypes

  /**
   * DownloadTaskCountOutputType without action
   */
  export type DownloadTaskCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadTaskCountOutputType
     */
    select?: DownloadTaskCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DownloadTaskCountOutputType without action
   */
  export type DownloadTaskCountOutputTypeCountDownloadResultsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DownloadResultWhereInput
  }



  /**
   * Count Type PromptCategoryCountOutputType
   */


  export type PromptCategoryCountOutputType = {
    templates: number
    children: number
  }

  export type PromptCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    templates?: boolean | PromptCategoryCountOutputTypeCountTemplatesArgs
    children?: boolean | PromptCategoryCountOutputTypeCountChildrenArgs
  }

  // Custom InputTypes

  /**
   * PromptCategoryCountOutputType without action
   */
  export type PromptCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptCategoryCountOutputType
     */
    select?: PromptCategoryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PromptCategoryCountOutputType without action
   */
  export type PromptCategoryCountOutputTypeCountTemplatesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PromptTemplateWhereInput
  }


  /**
   * PromptCategoryCountOutputType without action
   */
  export type PromptCategoryCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PromptCategoryWhereInput
  }



  /**
   * Count Type PromptTemplateCountOutputType
   */


  export type PromptTemplateCountOutputType = {
    executions: number
    changes: number
    optimizations: number
  }

  export type PromptTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    executions?: boolean | PromptTemplateCountOutputTypeCountExecutionsArgs
    changes?: boolean | PromptTemplateCountOutputTypeCountChangesArgs
    optimizations?: boolean | PromptTemplateCountOutputTypeCountOptimizationsArgs
  }

  // Custom InputTypes

  /**
   * PromptTemplateCountOutputType without action
   */
  export type PromptTemplateCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptTemplateCountOutputType
     */
    select?: PromptTemplateCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PromptTemplateCountOutputType without action
   */
  export type PromptTemplateCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PromptExecutionWhereInput
  }


  /**
   * PromptTemplateCountOutputType without action
   */
  export type PromptTemplateCountOutputTypeCountChangesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TemplateChangeWhereInput
  }


  /**
   * PromptTemplateCountOutputType without action
   */
  export type PromptTemplateCountOutputTypeCountOptimizationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OptimizationRecordWhereInput
  }



  /**
   * Count Type ConversationCountOutputType
   */


  export type ConversationCountOutputType = {
    messages: number
    shares: number
    exports: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
    shares?: boolean | ConversationCountOutputTypeCountSharesArgs
    exports?: boolean | ConversationCountOutputTypeCountExportsArgs
  }

  // Custom InputTypes

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountSharesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ConversationShareWhereInput
  }


  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountExportsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ConversationExportWhereInput
  }



  /**
   * Count Type MessageCountOutputType
   */


  export type MessageCountOutputType = {
    reactions: number
    attachments: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    reactions?: boolean | MessageCountOutputTypeCountReactionsArgs
    attachments?: boolean | MessageCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountReactionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MessageReactionWhereInput
  }


  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MessageAttachmentWhereInput
  }



  /**
   * Count Type ContextSourceCountOutputType
   */


  export type ContextSourceCountOutputType = {
    chunks: number
  }

  export type ContextSourceCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    chunks?: boolean | ContextSourceCountOutputTypeCountChunksArgs
  }

  // Custom InputTypes

  /**
   * ContextSourceCountOutputType without action
   */
  export type ContextSourceCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextSourceCountOutputType
     */
    select?: ContextSourceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ContextSourceCountOutputType without action
   */
  export type ContextSourceCountOutputTypeCountChunksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ContextChunkWhereInput
  }



  /**
   * Count Type ContextQueryCountOutputType
   */


  export type ContextQueryCountOutputType = {
    results: number
    analytics: number
  }

  export type ContextQueryCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    results?: boolean | ContextQueryCountOutputTypeCountResultsArgs
    analytics?: boolean | ContextQueryCountOutputTypeCountAnalyticsArgs
  }

  // Custom InputTypes

  /**
   * ContextQueryCountOutputType without action
   */
  export type ContextQueryCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextQueryCountOutputType
     */
    select?: ContextQueryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ContextQueryCountOutputType without action
   */
  export type ContextQueryCountOutputTypeCountResultsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ContextResultWhereInput
  }


  /**
   * ContextQueryCountOutputType without action
   */
  export type ContextQueryCountOutputTypeCountAnalyticsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ContextQueryAnalyticsWhereInput
  }



  /**
   * Count Type UserProfileCountOutputType
   */


  export type UserProfileCountOutputType = {
    invoices: number
    payments: number
    subscriptions: number
    credits: number
  }

  export type UserProfileCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    invoices?: boolean | UserProfileCountOutputTypeCountInvoicesArgs
    payments?: boolean | UserProfileCountOutputTypeCountPaymentsArgs
    subscriptions?: boolean | UserProfileCountOutputTypeCountSubscriptionsArgs
    credits?: boolean | UserProfileCountOutputTypeCountCreditsArgs
  }

  // Custom InputTypes

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfileCountOutputType
     */
    select?: UserProfileCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountCreditsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CreditWhereInput
  }



  /**
   * Count Type InvoiceCountOutputType
   */


  export type InvoiceCountOutputType = {
    payments: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Client
   */


  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    name: number
    domain: number
    apiKeys: number
    settings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    apiKeys?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }


  export type ClientGroupByOutputType = {
    id: string
    name: string
    domain: string | null
    apiKeys: JsonValue
    settings: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    apiKeys?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    modules?: boolean | Client$modulesArgs<ExtArgs>
    environmentVariables?: boolean | Client$environmentVariablesArgs<ExtArgs>
    users?: boolean | Client$usersArgs<ExtArgs>
    libraries?: boolean | Client$librariesArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    name?: boolean
    domain?: boolean
    apiKeys?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    modules?: boolean | Client$modulesArgs<ExtArgs>
    environmentVariables?: boolean | Client$environmentVariablesArgs<ExtArgs>
    users?: boolean | Client$usersArgs<ExtArgs>
    libraries?: boolean | Client$librariesArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeArgs<ExtArgs>
  }


  type ClientGetPayload<S extends boolean | null | undefined | ClientArgs> = $Types.GetResult<ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ClientFindManyArgs, 'select' | 'include'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>
    ): Prisma__ClientClient<$Types.GetResult<ClientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Client that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClientClient<$Types.GetResult<ClientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>
    ): Prisma__ClientClient<$Types.GetResult<ClientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClientClient<$Types.GetResult<ClientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ClientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
    **/
    create<T extends ClientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientCreateArgs<ExtArgs>>
    ): Prisma__ClientClient<$Types.GetResult<ClientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Clients.
     *     @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     *     @example
     *     // Create many Clients
     *     const client = await prisma.client.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
    **/
    delete<T extends ClientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>
    ): Prisma__ClientClient<$Types.GetResult<ClientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>
    ): Prisma__ClientClient<$Types.GetResult<ClientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
    **/
    upsert<T extends ClientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>
    ): Prisma__ClientClient<$Types.GetResult<ClientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    modules<T extends Client$modulesArgs<ExtArgs> = {}>(args?: Subset<T, Client$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ModuleOnClientPayload<ExtArgs>, T, 'findMany'>| Null>;

    environmentVariables<T extends Client$environmentVariablesArgs<ExtArgs> = {}>(args?: Subset<T, Client$environmentVariablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<EnvironmentVariablePayload<ExtArgs>, T, 'findMany'>| Null>;

    users<T extends Client$usersArgs<ExtArgs> = {}>(args?: Subset<T, Client$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserPayload<ExtArgs>, T, 'findMany'>| Null>;

    libraries<T extends Client$librariesArgs<ExtArgs> = {}>(args?: Subset<T, Client$librariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<LibraryPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the Client model
   */ 
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly name: FieldRef<"Client", 'String'>
    readonly domain: FieldRef<"Client", 'String'>
    readonly apiKeys: FieldRef<"Client", 'Json'>
    readonly settings: FieldRef<"Client", 'Json'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }


  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }


  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }


  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }


  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }


  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }


  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }


  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
  }


  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }


  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }


  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
  }


  /**
   * Client.modules
   */
  export type Client$modulesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleOnClient
     */
    select?: ModuleOnClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModuleOnClientInclude<ExtArgs> | null
    where?: ModuleOnClientWhereInput
    orderBy?: ModuleOnClientOrderByWithRelationInput | ModuleOnClientOrderByWithRelationInput[]
    cursor?: ModuleOnClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleOnClientScalarFieldEnum | ModuleOnClientScalarFieldEnum[]
  }


  /**
   * Client.environmentVariables
   */
  export type Client$environmentVariablesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentVariable
     */
    select?: EnvironmentVariableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnvironmentVariableInclude<ExtArgs> | null
    where?: EnvironmentVariableWhereInput
    orderBy?: EnvironmentVariableOrderByWithRelationInput | EnvironmentVariableOrderByWithRelationInput[]
    cursor?: EnvironmentVariableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnvironmentVariableScalarFieldEnum | EnvironmentVariableScalarFieldEnum[]
  }


  /**
   * Client.users
   */
  export type Client$usersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * Client.libraries
   */
  export type Client$librariesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryInclude<ExtArgs> | null
    where?: LibraryWhereInput
    orderBy?: LibraryOrderByWithRelationInput | LibraryOrderByWithRelationInput[]
    cursor?: LibraryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LibraryScalarFieldEnum | LibraryScalarFieldEnum[]
  }


  /**
   * Client without action
   */
  export type ClientArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientInclude<ExtArgs> | null
  }



  /**
   * Model Module
   */


  export type AggregateModule = {
    _count: ModuleCountAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  export type ModuleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    version: string | null
  }

  export type ModuleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    version: string | null
  }

  export type ModuleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    version: number
    _all: number
  }


  export type ModuleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    version?: true
  }

  export type ModuleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    version?: true
  }

  export type ModuleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    version?: true
    _all?: true
  }

  export type ModuleAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Module to aggregate.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Modules
    **/
    _count?: true | ModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleMaxAggregateInputType
  }

  export type GetModuleAggregateType<T extends ModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModule[P]>
      : GetScalarType<T[P], AggregateModule[P]>
  }




  export type ModuleGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithAggregationInput | ModuleOrderByWithAggregationInput[]
    by: ModuleScalarFieldEnum[] | ModuleScalarFieldEnum
    having?: ModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleCountAggregateInputType | true
    _min?: ModuleMinAggregateInputType
    _max?: ModuleMaxAggregateInputType
  }


  export type ModuleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    version: string | null
    _count: ModuleCountAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  type GetModuleGroupByPayload<T extends ModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleGroupByOutputType[P]>
        }
      >
    >


  export type ModuleSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    clients?: boolean | Module$clientsArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
  }

  export type ModuleInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    clients?: boolean | Module$clientsArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeArgs<ExtArgs>
  }


  type ModuleGetPayload<S extends boolean | null | undefined | ModuleArgs> = $Types.GetResult<ModulePayload, S>

  type ModuleCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ModuleFindManyArgs, 'select' | 'include'> & {
      select?: ModuleCountAggregateInputType | true
    }

  export interface ModuleDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Module'], meta: { name: 'Module' } }
    /**
     * Find zero or one Module that matches the filter.
     * @param {ModuleFindUniqueArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ModuleFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ModuleFindUniqueArgs<ExtArgs>>
    ): Prisma__ModuleClient<$Types.GetResult<ModulePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Module that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ModuleFindUniqueOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ModuleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ModuleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ModuleClient<$Types.GetResult<ModulePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Module that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ModuleFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ModuleFindFirstArgs<ExtArgs>>
    ): Prisma__ModuleClient<$Types.GetResult<ModulePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Module that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ModuleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ModuleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ModuleClient<$Types.GetResult<ModulePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Modules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modules
     * const modules = await prisma.module.findMany()
     * 
     * // Get first 10 Modules
     * const modules = await prisma.module.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduleWithIdOnly = await prisma.module.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ModuleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ModuleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ModulePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Module.
     * @param {ModuleCreateArgs} args - Arguments to create a Module.
     * @example
     * // Create one Module
     * const Module = await prisma.module.create({
     *   data: {
     *     // ... data to create a Module
     *   }
     * })
     * 
    **/
    create<T extends ModuleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ModuleCreateArgs<ExtArgs>>
    ): Prisma__ModuleClient<$Types.GetResult<ModulePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Modules.
     *     @param {ModuleCreateManyArgs} args - Arguments to create many Modules.
     *     @example
     *     // Create many Modules
     *     const module = await prisma.module.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ModuleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ModuleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Module.
     * @param {ModuleDeleteArgs} args - Arguments to delete one Module.
     * @example
     * // Delete one Module
     * const Module = await prisma.module.delete({
     *   where: {
     *     // ... filter to delete one Module
     *   }
     * })
     * 
    **/
    delete<T extends ModuleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ModuleDeleteArgs<ExtArgs>>
    ): Prisma__ModuleClient<$Types.GetResult<ModulePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Module.
     * @param {ModuleUpdateArgs} args - Arguments to update one Module.
     * @example
     * // Update one Module
     * const module = await prisma.module.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ModuleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ModuleUpdateArgs<ExtArgs>>
    ): Prisma__ModuleClient<$Types.GetResult<ModulePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Modules.
     * @param {ModuleDeleteManyArgs} args - Arguments to filter Modules to delete.
     * @example
     * // Delete a few Modules
     * const { count } = await prisma.module.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ModuleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ModuleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ModuleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ModuleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Module.
     * @param {ModuleUpsertArgs} args - Arguments to update or create a Module.
     * @example
     * // Update or create a Module
     * const module = await prisma.module.upsert({
     *   create: {
     *     // ... data to create a Module
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Module we want to update
     *   }
     * })
    **/
    upsert<T extends ModuleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ModuleUpsertArgs<ExtArgs>>
    ): Prisma__ModuleClient<$Types.GetResult<ModulePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleCountArgs} args - Arguments to filter Modules to count.
     * @example
     * // Count the number of Modules
     * const count = await prisma.module.count({
     *   where: {
     *     // ... the filter for the Modules we want to count
     *   }
     * })
    **/
    count<T extends ModuleCountArgs>(
      args?: Subset<T, ModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleAggregateArgs>(args: Subset<T, ModuleAggregateArgs>): Prisma.PrismaPromise<GetModuleAggregateType<T>>

    /**
     * Group by Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleGroupByArgs['orderBy'] }
        : { orderBy?: ModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Module model
   */
  readonly fields: ModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Module.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ModuleClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    clients<T extends Module$clientsArgs<ExtArgs> = {}>(args?: Subset<T, Module$clientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ModuleOnClientPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the Module model
   */ 
  interface ModuleFieldRefs {
    readonly id: FieldRef<"Module", 'String'>
    readonly name: FieldRef<"Module", 'String'>
    readonly description: FieldRef<"Module", 'String'>
    readonly version: FieldRef<"Module", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Module findUnique
   */
  export type ModuleFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }


  /**
   * Module findUniqueOrThrow
   */
  export type ModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }


  /**
   * Module findFirst
   */
  export type ModuleFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }


  /**
   * Module findFirstOrThrow
   */
  export type ModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }


  /**
   * Module findMany
   */
  export type ModuleFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Modules to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }


  /**
   * Module create
   */
  export type ModuleCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a Module.
     */
    data: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
  }


  /**
   * Module createMany
   */
  export type ModuleCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Module update
   */
  export type ModuleUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a Module.
     */
    data: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
    /**
     * Choose, which Module to update.
     */
    where: ModuleWhereUniqueInput
  }


  /**
   * Module updateMany
   */
  export type ModuleUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Modules.
     */
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyInput>
    /**
     * Filter which Modules to update
     */
    where?: ModuleWhereInput
  }


  /**
   * Module upsert
   */
  export type ModuleUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the Module to update in case it exists.
     */
    where: ModuleWhereUniqueInput
    /**
     * In case the Module found by the `where` argument doesn't exist, create a new Module with this data.
     */
    create: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
    /**
     * In case the Module was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
  }


  /**
   * Module delete
   */
  export type ModuleDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter which Module to delete.
     */
    where: ModuleWhereUniqueInput
  }


  /**
   * Module deleteMany
   */
  export type ModuleDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Modules to delete
     */
    where?: ModuleWhereInput
  }


  /**
   * Module.clients
   */
  export type Module$clientsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleOnClient
     */
    select?: ModuleOnClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModuleOnClientInclude<ExtArgs> | null
    where?: ModuleOnClientWhereInput
    orderBy?: ModuleOnClientOrderByWithRelationInput | ModuleOnClientOrderByWithRelationInput[]
    cursor?: ModuleOnClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleOnClientScalarFieldEnum | ModuleOnClientScalarFieldEnum[]
  }


  /**
   * Module without action
   */
  export type ModuleArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModuleInclude<ExtArgs> | null
  }



  /**
   * Model ModuleOnClient
   */


  export type AggregateModuleOnClient = {
    _count: ModuleOnClientCountAggregateOutputType | null
    _min: ModuleOnClientMinAggregateOutputType | null
    _max: ModuleOnClientMaxAggregateOutputType | null
  }

  export type ModuleOnClientMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    moduleId: string | null
    enabled: boolean | null
  }

  export type ModuleOnClientMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    moduleId: string | null
    enabled: boolean | null
  }

  export type ModuleOnClientCountAggregateOutputType = {
    id: number
    clientId: number
    moduleId: number
    enabled: number
    _all: number
  }


  export type ModuleOnClientMinAggregateInputType = {
    id?: true
    clientId?: true
    moduleId?: true
    enabled?: true
  }

  export type ModuleOnClientMaxAggregateInputType = {
    id?: true
    clientId?: true
    moduleId?: true
    enabled?: true
  }

  export type ModuleOnClientCountAggregateInputType = {
    id?: true
    clientId?: true
    moduleId?: true
    enabled?: true
    _all?: true
  }

  export type ModuleOnClientAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleOnClient to aggregate.
     */
    where?: ModuleOnClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleOnClients to fetch.
     */
    orderBy?: ModuleOnClientOrderByWithRelationInput | ModuleOnClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleOnClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleOnClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleOnClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModuleOnClients
    **/
    _count?: true | ModuleOnClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleOnClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleOnClientMaxAggregateInputType
  }

  export type GetModuleOnClientAggregateType<T extends ModuleOnClientAggregateArgs> = {
        [P in keyof T & keyof AggregateModuleOnClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModuleOnClient[P]>
      : GetScalarType<T[P], AggregateModuleOnClient[P]>
  }




  export type ModuleOnClientGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ModuleOnClientWhereInput
    orderBy?: ModuleOnClientOrderByWithAggregationInput | ModuleOnClientOrderByWithAggregationInput[]
    by: ModuleOnClientScalarFieldEnum[] | ModuleOnClientScalarFieldEnum
    having?: ModuleOnClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleOnClientCountAggregateInputType | true
    _min?: ModuleOnClientMinAggregateInputType
    _max?: ModuleOnClientMaxAggregateInputType
  }


  export type ModuleOnClientGroupByOutputType = {
    id: string
    clientId: string
    moduleId: string
    enabled: boolean
    _count: ModuleOnClientCountAggregateOutputType | null
    _min: ModuleOnClientMinAggregateOutputType | null
    _max: ModuleOnClientMaxAggregateOutputType | null
  }

  type GetModuleOnClientGroupByPayload<T extends ModuleOnClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleOnClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleOnClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleOnClientGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleOnClientGroupByOutputType[P]>
        }
      >
    >


  export type ModuleOnClientSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    moduleId?: boolean
    enabled?: boolean
    client?: boolean | ClientArgs<ExtArgs>
    module?: boolean | ModuleArgs<ExtArgs>
  }, ExtArgs["result"]["moduleOnClient"]>

  export type ModuleOnClientSelectScalar = {
    id?: boolean
    clientId?: boolean
    moduleId?: boolean
    enabled?: boolean
  }

  export type ModuleOnClientInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    client?: boolean | ClientArgs<ExtArgs>
    module?: boolean | ModuleArgs<ExtArgs>
  }


  type ModuleOnClientGetPayload<S extends boolean | null | undefined | ModuleOnClientArgs> = $Types.GetResult<ModuleOnClientPayload, S>

  type ModuleOnClientCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ModuleOnClientFindManyArgs, 'select' | 'include'> & {
      select?: ModuleOnClientCountAggregateInputType | true
    }

  export interface ModuleOnClientDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModuleOnClient'], meta: { name: 'ModuleOnClient' } }
    /**
     * Find zero or one ModuleOnClient that matches the filter.
     * @param {ModuleOnClientFindUniqueArgs} args - Arguments to find a ModuleOnClient
     * @example
     * // Get one ModuleOnClient
     * const moduleOnClient = await prisma.moduleOnClient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ModuleOnClientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ModuleOnClientFindUniqueArgs<ExtArgs>>
    ): Prisma__ModuleOnClientClient<$Types.GetResult<ModuleOnClientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ModuleOnClient that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ModuleOnClientFindUniqueOrThrowArgs} args - Arguments to find a ModuleOnClient
     * @example
     * // Get one ModuleOnClient
     * const moduleOnClient = await prisma.moduleOnClient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ModuleOnClientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ModuleOnClientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ModuleOnClientClient<$Types.GetResult<ModuleOnClientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ModuleOnClient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleOnClientFindFirstArgs} args - Arguments to find a ModuleOnClient
     * @example
     * // Get one ModuleOnClient
     * const moduleOnClient = await prisma.moduleOnClient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ModuleOnClientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ModuleOnClientFindFirstArgs<ExtArgs>>
    ): Prisma__ModuleOnClientClient<$Types.GetResult<ModuleOnClientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ModuleOnClient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleOnClientFindFirstOrThrowArgs} args - Arguments to find a ModuleOnClient
     * @example
     * // Get one ModuleOnClient
     * const moduleOnClient = await prisma.moduleOnClient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ModuleOnClientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ModuleOnClientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ModuleOnClientClient<$Types.GetResult<ModuleOnClientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ModuleOnClients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleOnClientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModuleOnClients
     * const moduleOnClients = await prisma.moduleOnClient.findMany()
     * 
     * // Get first 10 ModuleOnClients
     * const moduleOnClients = await prisma.moduleOnClient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduleOnClientWithIdOnly = await prisma.moduleOnClient.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ModuleOnClientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ModuleOnClientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ModuleOnClientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ModuleOnClient.
     * @param {ModuleOnClientCreateArgs} args - Arguments to create a ModuleOnClient.
     * @example
     * // Create one ModuleOnClient
     * const ModuleOnClient = await prisma.moduleOnClient.create({
     *   data: {
     *     // ... data to create a ModuleOnClient
     *   }
     * })
     * 
    **/
    create<T extends ModuleOnClientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ModuleOnClientCreateArgs<ExtArgs>>
    ): Prisma__ModuleOnClientClient<$Types.GetResult<ModuleOnClientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ModuleOnClients.
     *     @param {ModuleOnClientCreateManyArgs} args - Arguments to create many ModuleOnClients.
     *     @example
     *     // Create many ModuleOnClients
     *     const moduleOnClient = await prisma.moduleOnClient.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ModuleOnClientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ModuleOnClientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ModuleOnClient.
     * @param {ModuleOnClientDeleteArgs} args - Arguments to delete one ModuleOnClient.
     * @example
     * // Delete one ModuleOnClient
     * const ModuleOnClient = await prisma.moduleOnClient.delete({
     *   where: {
     *     // ... filter to delete one ModuleOnClient
     *   }
     * })
     * 
    **/
    delete<T extends ModuleOnClientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ModuleOnClientDeleteArgs<ExtArgs>>
    ): Prisma__ModuleOnClientClient<$Types.GetResult<ModuleOnClientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ModuleOnClient.
     * @param {ModuleOnClientUpdateArgs} args - Arguments to update one ModuleOnClient.
     * @example
     * // Update one ModuleOnClient
     * const moduleOnClient = await prisma.moduleOnClient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ModuleOnClientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ModuleOnClientUpdateArgs<ExtArgs>>
    ): Prisma__ModuleOnClientClient<$Types.GetResult<ModuleOnClientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ModuleOnClients.
     * @param {ModuleOnClientDeleteManyArgs} args - Arguments to filter ModuleOnClients to delete.
     * @example
     * // Delete a few ModuleOnClients
     * const { count } = await prisma.moduleOnClient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ModuleOnClientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ModuleOnClientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleOnClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleOnClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModuleOnClients
     * const moduleOnClient = await prisma.moduleOnClient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ModuleOnClientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ModuleOnClientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ModuleOnClient.
     * @param {ModuleOnClientUpsertArgs} args - Arguments to update or create a ModuleOnClient.
     * @example
     * // Update or create a ModuleOnClient
     * const moduleOnClient = await prisma.moduleOnClient.upsert({
     *   create: {
     *     // ... data to create a ModuleOnClient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModuleOnClient we want to update
     *   }
     * })
    **/
    upsert<T extends ModuleOnClientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ModuleOnClientUpsertArgs<ExtArgs>>
    ): Prisma__ModuleOnClientClient<$Types.GetResult<ModuleOnClientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ModuleOnClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleOnClientCountArgs} args - Arguments to filter ModuleOnClients to count.
     * @example
     * // Count the number of ModuleOnClients
     * const count = await prisma.moduleOnClient.count({
     *   where: {
     *     // ... the filter for the ModuleOnClients we want to count
     *   }
     * })
    **/
    count<T extends ModuleOnClientCountArgs>(
      args?: Subset<T, ModuleOnClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleOnClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModuleOnClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleOnClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleOnClientAggregateArgs>(args: Subset<T, ModuleOnClientAggregateArgs>): Prisma.PrismaPromise<GetModuleOnClientAggregateType<T>>

    /**
     * Group by ModuleOnClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleOnClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleOnClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleOnClientGroupByArgs['orderBy'] }
        : { orderBy?: ModuleOnClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleOnClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleOnClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModuleOnClient model
   */
  readonly fields: ModuleOnClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModuleOnClient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ModuleOnClientClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    client<T extends ClientArgs<ExtArgs> = {}>(args?: Subset<T, ClientArgs<ExtArgs>>): Prisma__ClientClient<$Types.GetResult<ClientPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    module<T extends ModuleArgs<ExtArgs> = {}>(args?: Subset<T, ModuleArgs<ExtArgs>>): Prisma__ModuleClient<$Types.GetResult<ModulePayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the ModuleOnClient model
   */ 
  interface ModuleOnClientFieldRefs {
    readonly id: FieldRef<"ModuleOnClient", 'String'>
    readonly clientId: FieldRef<"ModuleOnClient", 'String'>
    readonly moduleId: FieldRef<"ModuleOnClient", 'String'>
    readonly enabled: FieldRef<"ModuleOnClient", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * ModuleOnClient findUnique
   */
  export type ModuleOnClientFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleOnClient
     */
    select?: ModuleOnClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModuleOnClientInclude<ExtArgs> | null
    /**
     * Filter, which ModuleOnClient to fetch.
     */
    where: ModuleOnClientWhereUniqueInput
  }


  /**
   * ModuleOnClient findUniqueOrThrow
   */
  export type ModuleOnClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleOnClient
     */
    select?: ModuleOnClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModuleOnClientInclude<ExtArgs> | null
    /**
     * Filter, which ModuleOnClient to fetch.
     */
    where: ModuleOnClientWhereUniqueInput
  }


  /**
   * ModuleOnClient findFirst
   */
  export type ModuleOnClientFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleOnClient
     */
    select?: ModuleOnClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModuleOnClientInclude<ExtArgs> | null
    /**
     * Filter, which ModuleOnClient to fetch.
     */
    where?: ModuleOnClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleOnClients to fetch.
     */
    orderBy?: ModuleOnClientOrderByWithRelationInput | ModuleOnClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleOnClients.
     */
    cursor?: ModuleOnClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleOnClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleOnClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleOnClients.
     */
    distinct?: ModuleOnClientScalarFieldEnum | ModuleOnClientScalarFieldEnum[]
  }


  /**
   * ModuleOnClient findFirstOrThrow
   */
  export type ModuleOnClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleOnClient
     */
    select?: ModuleOnClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModuleOnClientInclude<ExtArgs> | null
    /**
     * Filter, which ModuleOnClient to fetch.
     */
    where?: ModuleOnClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleOnClients to fetch.
     */
    orderBy?: ModuleOnClientOrderByWithRelationInput | ModuleOnClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleOnClients.
     */
    cursor?: ModuleOnClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleOnClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleOnClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleOnClients.
     */
    distinct?: ModuleOnClientScalarFieldEnum | ModuleOnClientScalarFieldEnum[]
  }


  /**
   * ModuleOnClient findMany
   */
  export type ModuleOnClientFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleOnClient
     */
    select?: ModuleOnClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModuleOnClientInclude<ExtArgs> | null
    /**
     * Filter, which ModuleOnClients to fetch.
     */
    where?: ModuleOnClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleOnClients to fetch.
     */
    orderBy?: ModuleOnClientOrderByWithRelationInput | ModuleOnClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModuleOnClients.
     */
    cursor?: ModuleOnClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleOnClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleOnClients.
     */
    skip?: number
    distinct?: ModuleOnClientScalarFieldEnum | ModuleOnClientScalarFieldEnum[]
  }


  /**
   * ModuleOnClient create
   */
  export type ModuleOnClientCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleOnClient
     */
    select?: ModuleOnClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModuleOnClientInclude<ExtArgs> | null
    /**
     * The data needed to create a ModuleOnClient.
     */
    data: XOR<ModuleOnClientCreateInput, ModuleOnClientUncheckedCreateInput>
  }


  /**
   * ModuleOnClient createMany
   */
  export type ModuleOnClientCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModuleOnClients.
     */
    data: ModuleOnClientCreateManyInput | ModuleOnClientCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ModuleOnClient update
   */
  export type ModuleOnClientUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleOnClient
     */
    select?: ModuleOnClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModuleOnClientInclude<ExtArgs> | null
    /**
     * The data needed to update a ModuleOnClient.
     */
    data: XOR<ModuleOnClientUpdateInput, ModuleOnClientUncheckedUpdateInput>
    /**
     * Choose, which ModuleOnClient to update.
     */
    where: ModuleOnClientWhereUniqueInput
  }


  /**
   * ModuleOnClient updateMany
   */
  export type ModuleOnClientUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModuleOnClients.
     */
    data: XOR<ModuleOnClientUpdateManyMutationInput, ModuleOnClientUncheckedUpdateManyInput>
    /**
     * Filter which ModuleOnClients to update
     */
    where?: ModuleOnClientWhereInput
  }


  /**
   * ModuleOnClient upsert
   */
  export type ModuleOnClientUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleOnClient
     */
    select?: ModuleOnClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModuleOnClientInclude<ExtArgs> | null
    /**
     * The filter to search for the ModuleOnClient to update in case it exists.
     */
    where: ModuleOnClientWhereUniqueInput
    /**
     * In case the ModuleOnClient found by the `where` argument doesn't exist, create a new ModuleOnClient with this data.
     */
    create: XOR<ModuleOnClientCreateInput, ModuleOnClientUncheckedCreateInput>
    /**
     * In case the ModuleOnClient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleOnClientUpdateInput, ModuleOnClientUncheckedUpdateInput>
  }


  /**
   * ModuleOnClient delete
   */
  export type ModuleOnClientDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleOnClient
     */
    select?: ModuleOnClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModuleOnClientInclude<ExtArgs> | null
    /**
     * Filter which ModuleOnClient to delete.
     */
    where: ModuleOnClientWhereUniqueInput
  }


  /**
   * ModuleOnClient deleteMany
   */
  export type ModuleOnClientDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleOnClients to delete
     */
    where?: ModuleOnClientWhereInput
  }


  /**
   * ModuleOnClient without action
   */
  export type ModuleOnClientArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleOnClient
     */
    select?: ModuleOnClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ModuleOnClientInclude<ExtArgs> | null
  }



  /**
   * Model EnvironmentVariable
   */


  export type AggregateEnvironmentVariable = {
    _count: EnvironmentVariableCountAggregateOutputType | null
    _min: EnvironmentVariableMinAggregateOutputType | null
    _max: EnvironmentVariableMaxAggregateOutputType | null
  }

  export type EnvironmentVariableMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    environment: Environment | null
    clientId: string | null
  }

  export type EnvironmentVariableMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    environment: Environment | null
    clientId: string | null
  }

  export type EnvironmentVariableCountAggregateOutputType = {
    id: number
    key: number
    value: number
    environment: number
    clientId: number
    _all: number
  }


  export type EnvironmentVariableMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    environment?: true
    clientId?: true
  }

  export type EnvironmentVariableMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    environment?: true
    clientId?: true
  }

  export type EnvironmentVariableCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    environment?: true
    clientId?: true
    _all?: true
  }

  export type EnvironmentVariableAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnvironmentVariable to aggregate.
     */
    where?: EnvironmentVariableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnvironmentVariables to fetch.
     */
    orderBy?: EnvironmentVariableOrderByWithRelationInput | EnvironmentVariableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnvironmentVariableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnvironmentVariables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnvironmentVariables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EnvironmentVariables
    **/
    _count?: true | EnvironmentVariableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnvironmentVariableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnvironmentVariableMaxAggregateInputType
  }

  export type GetEnvironmentVariableAggregateType<T extends EnvironmentVariableAggregateArgs> = {
        [P in keyof T & keyof AggregateEnvironmentVariable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnvironmentVariable[P]>
      : GetScalarType<T[P], AggregateEnvironmentVariable[P]>
  }




  export type EnvironmentVariableGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EnvironmentVariableWhereInput
    orderBy?: EnvironmentVariableOrderByWithAggregationInput | EnvironmentVariableOrderByWithAggregationInput[]
    by: EnvironmentVariableScalarFieldEnum[] | EnvironmentVariableScalarFieldEnum
    having?: EnvironmentVariableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnvironmentVariableCountAggregateInputType | true
    _min?: EnvironmentVariableMinAggregateInputType
    _max?: EnvironmentVariableMaxAggregateInputType
  }


  export type EnvironmentVariableGroupByOutputType = {
    id: string
    key: string
    value: string
    environment: Environment
    clientId: string
    _count: EnvironmentVariableCountAggregateOutputType | null
    _min: EnvironmentVariableMinAggregateOutputType | null
    _max: EnvironmentVariableMaxAggregateOutputType | null
  }

  type GetEnvironmentVariableGroupByPayload<T extends EnvironmentVariableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnvironmentVariableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnvironmentVariableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnvironmentVariableGroupByOutputType[P]>
            : GetScalarType<T[P], EnvironmentVariableGroupByOutputType[P]>
        }
      >
    >


  export type EnvironmentVariableSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    environment?: boolean
    clientId?: boolean
    client?: boolean | ClientArgs<ExtArgs>
  }, ExtArgs["result"]["environmentVariable"]>

  export type EnvironmentVariableSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    environment?: boolean
    clientId?: boolean
  }

  export type EnvironmentVariableInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    client?: boolean | ClientArgs<ExtArgs>
  }


  type EnvironmentVariableGetPayload<S extends boolean | null | undefined | EnvironmentVariableArgs> = $Types.GetResult<EnvironmentVariablePayload, S>

  type EnvironmentVariableCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<EnvironmentVariableFindManyArgs, 'select' | 'include'> & {
      select?: EnvironmentVariableCountAggregateInputType | true
    }

  export interface EnvironmentVariableDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EnvironmentVariable'], meta: { name: 'EnvironmentVariable' } }
    /**
     * Find zero or one EnvironmentVariable that matches the filter.
     * @param {EnvironmentVariableFindUniqueArgs} args - Arguments to find a EnvironmentVariable
     * @example
     * // Get one EnvironmentVariable
     * const environmentVariable = await prisma.environmentVariable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EnvironmentVariableFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EnvironmentVariableFindUniqueArgs<ExtArgs>>
    ): Prisma__EnvironmentVariableClient<$Types.GetResult<EnvironmentVariablePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EnvironmentVariable that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EnvironmentVariableFindUniqueOrThrowArgs} args - Arguments to find a EnvironmentVariable
     * @example
     * // Get one EnvironmentVariable
     * const environmentVariable = await prisma.environmentVariable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EnvironmentVariableFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EnvironmentVariableFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EnvironmentVariableClient<$Types.GetResult<EnvironmentVariablePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EnvironmentVariable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentVariableFindFirstArgs} args - Arguments to find a EnvironmentVariable
     * @example
     * // Get one EnvironmentVariable
     * const environmentVariable = await prisma.environmentVariable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EnvironmentVariableFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EnvironmentVariableFindFirstArgs<ExtArgs>>
    ): Prisma__EnvironmentVariableClient<$Types.GetResult<EnvironmentVariablePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EnvironmentVariable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentVariableFindFirstOrThrowArgs} args - Arguments to find a EnvironmentVariable
     * @example
     * // Get one EnvironmentVariable
     * const environmentVariable = await prisma.environmentVariable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EnvironmentVariableFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EnvironmentVariableFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EnvironmentVariableClient<$Types.GetResult<EnvironmentVariablePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EnvironmentVariables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentVariableFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EnvironmentVariables
     * const environmentVariables = await prisma.environmentVariable.findMany()
     * 
     * // Get first 10 EnvironmentVariables
     * const environmentVariables = await prisma.environmentVariable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const environmentVariableWithIdOnly = await prisma.environmentVariable.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EnvironmentVariableFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EnvironmentVariableFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<EnvironmentVariablePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EnvironmentVariable.
     * @param {EnvironmentVariableCreateArgs} args - Arguments to create a EnvironmentVariable.
     * @example
     * // Create one EnvironmentVariable
     * const EnvironmentVariable = await prisma.environmentVariable.create({
     *   data: {
     *     // ... data to create a EnvironmentVariable
     *   }
     * })
     * 
    **/
    create<T extends EnvironmentVariableCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EnvironmentVariableCreateArgs<ExtArgs>>
    ): Prisma__EnvironmentVariableClient<$Types.GetResult<EnvironmentVariablePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EnvironmentVariables.
     *     @param {EnvironmentVariableCreateManyArgs} args - Arguments to create many EnvironmentVariables.
     *     @example
     *     // Create many EnvironmentVariables
     *     const environmentVariable = await prisma.environmentVariable.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EnvironmentVariableCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EnvironmentVariableCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EnvironmentVariable.
     * @param {EnvironmentVariableDeleteArgs} args - Arguments to delete one EnvironmentVariable.
     * @example
     * // Delete one EnvironmentVariable
     * const EnvironmentVariable = await prisma.environmentVariable.delete({
     *   where: {
     *     // ... filter to delete one EnvironmentVariable
     *   }
     * })
     * 
    **/
    delete<T extends EnvironmentVariableDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EnvironmentVariableDeleteArgs<ExtArgs>>
    ): Prisma__EnvironmentVariableClient<$Types.GetResult<EnvironmentVariablePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EnvironmentVariable.
     * @param {EnvironmentVariableUpdateArgs} args - Arguments to update one EnvironmentVariable.
     * @example
     * // Update one EnvironmentVariable
     * const environmentVariable = await prisma.environmentVariable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EnvironmentVariableUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EnvironmentVariableUpdateArgs<ExtArgs>>
    ): Prisma__EnvironmentVariableClient<$Types.GetResult<EnvironmentVariablePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EnvironmentVariables.
     * @param {EnvironmentVariableDeleteManyArgs} args - Arguments to filter EnvironmentVariables to delete.
     * @example
     * // Delete a few EnvironmentVariables
     * const { count } = await prisma.environmentVariable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EnvironmentVariableDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EnvironmentVariableDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EnvironmentVariables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentVariableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EnvironmentVariables
     * const environmentVariable = await prisma.environmentVariable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EnvironmentVariableUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EnvironmentVariableUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EnvironmentVariable.
     * @param {EnvironmentVariableUpsertArgs} args - Arguments to update or create a EnvironmentVariable.
     * @example
     * // Update or create a EnvironmentVariable
     * const environmentVariable = await prisma.environmentVariable.upsert({
     *   create: {
     *     // ... data to create a EnvironmentVariable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EnvironmentVariable we want to update
     *   }
     * })
    **/
    upsert<T extends EnvironmentVariableUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EnvironmentVariableUpsertArgs<ExtArgs>>
    ): Prisma__EnvironmentVariableClient<$Types.GetResult<EnvironmentVariablePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of EnvironmentVariables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentVariableCountArgs} args - Arguments to filter EnvironmentVariables to count.
     * @example
     * // Count the number of EnvironmentVariables
     * const count = await prisma.environmentVariable.count({
     *   where: {
     *     // ... the filter for the EnvironmentVariables we want to count
     *   }
     * })
    **/
    count<T extends EnvironmentVariableCountArgs>(
      args?: Subset<T, EnvironmentVariableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnvironmentVariableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EnvironmentVariable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentVariableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnvironmentVariableAggregateArgs>(args: Subset<T, EnvironmentVariableAggregateArgs>): Prisma.PrismaPromise<GetEnvironmentVariableAggregateType<T>>

    /**
     * Group by EnvironmentVariable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnvironmentVariableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnvironmentVariableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnvironmentVariableGroupByArgs['orderBy'] }
        : { orderBy?: EnvironmentVariableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnvironmentVariableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnvironmentVariableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EnvironmentVariable model
   */
  readonly fields: EnvironmentVariableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EnvironmentVariable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EnvironmentVariableClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    client<T extends ClientArgs<ExtArgs> = {}>(args?: Subset<T, ClientArgs<ExtArgs>>): Prisma__ClientClient<$Types.GetResult<ClientPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the EnvironmentVariable model
   */ 
  interface EnvironmentVariableFieldRefs {
    readonly id: FieldRef<"EnvironmentVariable", 'String'>
    readonly key: FieldRef<"EnvironmentVariable", 'String'>
    readonly value: FieldRef<"EnvironmentVariable", 'String'>
    readonly environment: FieldRef<"EnvironmentVariable", 'Environment'>
    readonly clientId: FieldRef<"EnvironmentVariable", 'String'>
  }
    

  // Custom InputTypes

  /**
   * EnvironmentVariable findUnique
   */
  export type EnvironmentVariableFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentVariable
     */
    select?: EnvironmentVariableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnvironmentVariableInclude<ExtArgs> | null
    /**
     * Filter, which EnvironmentVariable to fetch.
     */
    where: EnvironmentVariableWhereUniqueInput
  }


  /**
   * EnvironmentVariable findUniqueOrThrow
   */
  export type EnvironmentVariableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentVariable
     */
    select?: EnvironmentVariableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnvironmentVariableInclude<ExtArgs> | null
    /**
     * Filter, which EnvironmentVariable to fetch.
     */
    where: EnvironmentVariableWhereUniqueInput
  }


  /**
   * EnvironmentVariable findFirst
   */
  export type EnvironmentVariableFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentVariable
     */
    select?: EnvironmentVariableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnvironmentVariableInclude<ExtArgs> | null
    /**
     * Filter, which EnvironmentVariable to fetch.
     */
    where?: EnvironmentVariableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnvironmentVariables to fetch.
     */
    orderBy?: EnvironmentVariableOrderByWithRelationInput | EnvironmentVariableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnvironmentVariables.
     */
    cursor?: EnvironmentVariableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnvironmentVariables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnvironmentVariables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnvironmentVariables.
     */
    distinct?: EnvironmentVariableScalarFieldEnum | EnvironmentVariableScalarFieldEnum[]
  }


  /**
   * EnvironmentVariable findFirstOrThrow
   */
  export type EnvironmentVariableFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentVariable
     */
    select?: EnvironmentVariableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnvironmentVariableInclude<ExtArgs> | null
    /**
     * Filter, which EnvironmentVariable to fetch.
     */
    where?: EnvironmentVariableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnvironmentVariables to fetch.
     */
    orderBy?: EnvironmentVariableOrderByWithRelationInput | EnvironmentVariableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnvironmentVariables.
     */
    cursor?: EnvironmentVariableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnvironmentVariables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnvironmentVariables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnvironmentVariables.
     */
    distinct?: EnvironmentVariableScalarFieldEnum | EnvironmentVariableScalarFieldEnum[]
  }


  /**
   * EnvironmentVariable findMany
   */
  export type EnvironmentVariableFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentVariable
     */
    select?: EnvironmentVariableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnvironmentVariableInclude<ExtArgs> | null
    /**
     * Filter, which EnvironmentVariables to fetch.
     */
    where?: EnvironmentVariableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnvironmentVariables to fetch.
     */
    orderBy?: EnvironmentVariableOrderByWithRelationInput | EnvironmentVariableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EnvironmentVariables.
     */
    cursor?: EnvironmentVariableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnvironmentVariables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnvironmentVariables.
     */
    skip?: number
    distinct?: EnvironmentVariableScalarFieldEnum | EnvironmentVariableScalarFieldEnum[]
  }


  /**
   * EnvironmentVariable create
   */
  export type EnvironmentVariableCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentVariable
     */
    select?: EnvironmentVariableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnvironmentVariableInclude<ExtArgs> | null
    /**
     * The data needed to create a EnvironmentVariable.
     */
    data: XOR<EnvironmentVariableCreateInput, EnvironmentVariableUncheckedCreateInput>
  }


  /**
   * EnvironmentVariable createMany
   */
  export type EnvironmentVariableCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EnvironmentVariables.
     */
    data: EnvironmentVariableCreateManyInput | EnvironmentVariableCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * EnvironmentVariable update
   */
  export type EnvironmentVariableUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentVariable
     */
    select?: EnvironmentVariableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnvironmentVariableInclude<ExtArgs> | null
    /**
     * The data needed to update a EnvironmentVariable.
     */
    data: XOR<EnvironmentVariableUpdateInput, EnvironmentVariableUncheckedUpdateInput>
    /**
     * Choose, which EnvironmentVariable to update.
     */
    where: EnvironmentVariableWhereUniqueInput
  }


  /**
   * EnvironmentVariable updateMany
   */
  export type EnvironmentVariableUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EnvironmentVariables.
     */
    data: XOR<EnvironmentVariableUpdateManyMutationInput, EnvironmentVariableUncheckedUpdateManyInput>
    /**
     * Filter which EnvironmentVariables to update
     */
    where?: EnvironmentVariableWhereInput
  }


  /**
   * EnvironmentVariable upsert
   */
  export type EnvironmentVariableUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentVariable
     */
    select?: EnvironmentVariableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnvironmentVariableInclude<ExtArgs> | null
    /**
     * The filter to search for the EnvironmentVariable to update in case it exists.
     */
    where: EnvironmentVariableWhereUniqueInput
    /**
     * In case the EnvironmentVariable found by the `where` argument doesn't exist, create a new EnvironmentVariable with this data.
     */
    create: XOR<EnvironmentVariableCreateInput, EnvironmentVariableUncheckedCreateInput>
    /**
     * In case the EnvironmentVariable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnvironmentVariableUpdateInput, EnvironmentVariableUncheckedUpdateInput>
  }


  /**
   * EnvironmentVariable delete
   */
  export type EnvironmentVariableDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentVariable
     */
    select?: EnvironmentVariableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnvironmentVariableInclude<ExtArgs> | null
    /**
     * Filter which EnvironmentVariable to delete.
     */
    where: EnvironmentVariableWhereUniqueInput
  }


  /**
   * EnvironmentVariable deleteMany
   */
  export type EnvironmentVariableDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnvironmentVariables to delete
     */
    where?: EnvironmentVariableWhereInput
  }


  /**
   * EnvironmentVariable without action
   */
  export type EnvironmentVariableArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnvironmentVariable
     */
    select?: EnvironmentVariableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnvironmentVariableInclude<ExtArgs> | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    avatar: string | null
    hashedPassword: string | null
    oauthProvider: string | null
    oauthId: string | null
    role: Role | null
    clientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    avatar: string | null
    hashedPassword: string | null
    oauthProvider: string | null
    oauthId: string | null
    role: Role | null
    clientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    avatar: number
    hashedPassword: number
    oauthProvider: number
    oauthId: number
    role: number
    clientId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatar?: true
    hashedPassword?: true
    oauthProvider?: true
    oauthId?: true
    role?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatar?: true
    hashedPassword?: true
    oauthProvider?: true
    oauthId?: true
    role?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    avatar?: true
    hashedPassword?: true
    oauthProvider?: true
    oauthId?: true
    role?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    avatar: string | null
    hashedPassword: string | null
    oauthProvider: string | null
    oauthId: string | null
    role: Role
    clientId: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    hashedPassword?: boolean
    oauthProvider?: boolean
    oauthId?: boolean
    role?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientArgs<ExtArgs>
    apiKeys?: boolean | User$apiKeysArgs<ExtArgs>
    mcpConfigurations?: boolean | User$mcpConfigurationsArgs<ExtArgs>
    usageLogs?: boolean | User$usageLogsArgs<ExtArgs>
    oauthTokens?: boolean | User$oauthTokensArgs<ExtArgs>
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    messageReactions?: boolean | User$messageReactionsArgs<ExtArgs>
    userPreferences?: boolean | User$userPreferencesArgs<ExtArgs>
    themes?: boolean | User$themesArgs<ExtArgs>
    personalizationAnalytics?: boolean | User$personalizationAnalyticsArgs<ExtArgs>
    conversationShares?: boolean | User$conversationSharesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    hashedPassword?: boolean
    oauthProvider?: boolean
    oauthId?: boolean
    role?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    client?: boolean | ClientArgs<ExtArgs>
    apiKeys?: boolean | User$apiKeysArgs<ExtArgs>
    mcpConfigurations?: boolean | User$mcpConfigurationsArgs<ExtArgs>
    usageLogs?: boolean | User$usageLogsArgs<ExtArgs>
    oauthTokens?: boolean | User$oauthTokensArgs<ExtArgs>
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    messageReactions?: boolean | User$messageReactionsArgs<ExtArgs>
    userPreferences?: boolean | User$userPreferencesArgs<ExtArgs>
    themes?: boolean | User$themesArgs<ExtArgs>
    personalizationAnalytics?: boolean | User$personalizationAnalyticsArgs<ExtArgs>
    conversationShares?: boolean | User$conversationSharesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }


  type UserGetPayload<S extends boolean | null | undefined | UserArgs> = $Types.GetResult<UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    client<T extends ClientArgs<ExtArgs> = {}>(args?: Subset<T, ClientArgs<ExtArgs>>): Prisma__ClientClient<$Types.GetResult<ClientPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    apiKeys<T extends User$apiKeysArgs<ExtArgs> = {}>(args?: Subset<T, User$apiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ApiKeyPayload<ExtArgs>, T, 'findMany'>| Null>;

    mcpConfigurations<T extends User$mcpConfigurationsArgs<ExtArgs> = {}>(args?: Subset<T, User$mcpConfigurationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<MCPConfigurationPayload<ExtArgs>, T, 'findMany'>| Null>;

    usageLogs<T extends User$usageLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$usageLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UsageLogPayload<ExtArgs>, T, 'findMany'>| Null>;

    oauthTokens<T extends User$oauthTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$oauthTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<OAuthTokenPayload<ExtArgs>, T, 'findMany'>| Null>;

    conversations<T extends User$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, User$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ConversationPayload<ExtArgs>, T, 'findMany'>| Null>;

    messageReactions<T extends User$messageReactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$messageReactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<MessageReactionPayload<ExtArgs>, T, 'findMany'>| Null>;

    userPreferences<T extends User$userPreferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$userPreferencesArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Types.GetResult<UserPreferencesPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    themes<T extends User$themesArgs<ExtArgs> = {}>(args?: Subset<T, User$themesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ThemePayload<ExtArgs>, T, 'findMany'>| Null>;

    personalizationAnalytics<T extends User$personalizationAnalyticsArgs<ExtArgs> = {}>(args?: Subset<T, User$personalizationAnalyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PersonalizationAnalyticsPayload<ExtArgs>, T, 'findMany'>| Null>;

    conversationShares<T extends User$conversationSharesArgs<ExtArgs> = {}>(args?: Subset<T, User$conversationSharesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ConversationSharePayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly hashedPassword: FieldRef<"User", 'String'>
    readonly oauthProvider: FieldRef<"User", 'String'>
    readonly oauthId: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly clientId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.apiKeys
   */
  export type User$apiKeysArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApiKeyInclude<ExtArgs> | null
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    cursor?: ApiKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }


  /**
   * User.mcpConfigurations
   */
  export type User$mcpConfigurationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPConfiguration
     */
    select?: MCPConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCPConfigurationInclude<ExtArgs> | null
    where?: MCPConfigurationWhereInput
    orderBy?: MCPConfigurationOrderByWithRelationInput | MCPConfigurationOrderByWithRelationInput[]
    cursor?: MCPConfigurationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MCPConfigurationScalarFieldEnum | MCPConfigurationScalarFieldEnum[]
  }


  /**
   * User.usageLogs
   */
  export type User$usageLogsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsageLogInclude<ExtArgs> | null
    where?: UsageLogWhereInput
    orderBy?: UsageLogOrderByWithRelationInput | UsageLogOrderByWithRelationInput[]
    cursor?: UsageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsageLogScalarFieldEnum | UsageLogScalarFieldEnum[]
  }


  /**
   * User.oauthTokens
   */
  export type User$oauthTokensArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthTokenInclude<ExtArgs> | null
    where?: OAuthTokenWhereInput
    orderBy?: OAuthTokenOrderByWithRelationInput | OAuthTokenOrderByWithRelationInput[]
    cursor?: OAuthTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OAuthTokenScalarFieldEnum | OAuthTokenScalarFieldEnum[]
  }


  /**
   * User.conversations
   */
  export type User$conversationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }


  /**
   * User.messageReactions
   */
  export type User$messageReactionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageReactionInclude<ExtArgs> | null
    where?: MessageReactionWhereInput
    orderBy?: MessageReactionOrderByWithRelationInput | MessageReactionOrderByWithRelationInput[]
    cursor?: MessageReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageReactionScalarFieldEnum | MessageReactionScalarFieldEnum[]
  }


  /**
   * User.userPreferences
   */
  export type User$userPreferencesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    where?: UserPreferencesWhereInput
  }


  /**
   * User.themes
   */
  export type User$themesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThemeInclude<ExtArgs> | null
    where?: ThemeWhereInput
    orderBy?: ThemeOrderByWithRelationInput | ThemeOrderByWithRelationInput[]
    cursor?: ThemeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ThemeScalarFieldEnum | ThemeScalarFieldEnum[]
  }


  /**
   * User.personalizationAnalytics
   */
  export type User$personalizationAnalyticsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalizationAnalytics
     */
    select?: PersonalizationAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalizationAnalyticsInclude<ExtArgs> | null
    where?: PersonalizationAnalyticsWhereInput
    orderBy?: PersonalizationAnalyticsOrderByWithRelationInput | PersonalizationAnalyticsOrderByWithRelationInput[]
    cursor?: PersonalizationAnalyticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonalizationAnalyticsScalarFieldEnum | PersonalizationAnalyticsScalarFieldEnum[]
  }


  /**
   * User.conversationShares
   */
  export type User$conversationSharesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationShare
     */
    select?: ConversationShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationShareInclude<ExtArgs> | null
    where?: ConversationShareWhereInput
    orderBy?: ConversationShareOrderByWithRelationInput | ConversationShareOrderByWithRelationInput[]
    cursor?: ConversationShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationShareScalarFieldEnum | ConversationShareScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Library
   */


  export type AggregateLibrary = {
    _count: LibraryCountAggregateOutputType | null
    _avg: LibraryAvgAggregateOutputType | null
    _sum: LibrarySumAggregateOutputType | null
    _min: LibraryMinAggregateOutputType | null
    _max: LibraryMaxAggregateOutputType | null
  }

  export type LibraryAvgAggregateOutputType = {
    popularityScore: number | null
    totalSnippets: number | null
    totalTokens: number | null
  }

  export type LibrarySumAggregateOutputType = {
    popularityScore: number | null
    totalSnippets: number | null
    totalTokens: number | null
  }

  export type LibraryMinAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    vendor: string | null
    repoUrl: string | null
    docsUrl: string | null
    defaultVersion: string | null
    popularityScore: number | null
    totalSnippets: number | null
    totalTokens: number | null
    language: string | null
    ecosystem: string | null
    clientId: string | null
    lastCrawledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    displayName: string | null
    description: string | null
    vendor: string | null
    repoUrl: string | null
    docsUrl: string | null
    defaultVersion: string | null
    popularityScore: number | null
    totalSnippets: number | null
    totalTokens: number | null
    language: string | null
    ecosystem: string | null
    clientId: string | null
    lastCrawledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LibraryCountAggregateOutputType = {
    id: number
    name: number
    displayName: number
    description: number
    vendor: number
    repoUrl: number
    docsUrl: number
    defaultVersion: number
    popularityScore: number
    totalSnippets: number
    totalTokens: number
    language: number
    ecosystem: number
    tags: number
    metadata: number
    clientId: number
    lastCrawledAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LibraryAvgAggregateInputType = {
    popularityScore?: true
    totalSnippets?: true
    totalTokens?: true
  }

  export type LibrarySumAggregateInputType = {
    popularityScore?: true
    totalSnippets?: true
    totalTokens?: true
  }

  export type LibraryMinAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    vendor?: true
    repoUrl?: true
    docsUrl?: true
    defaultVersion?: true
    popularityScore?: true
    totalSnippets?: true
    totalTokens?: true
    language?: true
    ecosystem?: true
    clientId?: true
    lastCrawledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryMaxAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    vendor?: true
    repoUrl?: true
    docsUrl?: true
    defaultVersion?: true
    popularityScore?: true
    totalSnippets?: true
    totalTokens?: true
    language?: true
    ecosystem?: true
    clientId?: true
    lastCrawledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LibraryCountAggregateInputType = {
    id?: true
    name?: true
    displayName?: true
    description?: true
    vendor?: true
    repoUrl?: true
    docsUrl?: true
    defaultVersion?: true
    popularityScore?: true
    totalSnippets?: true
    totalTokens?: true
    language?: true
    ecosystem?: true
    tags?: true
    metadata?: true
    clientId?: true
    lastCrawledAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LibraryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Library to aggregate.
     */
    where?: LibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Libraries to fetch.
     */
    orderBy?: LibraryOrderByWithRelationInput | LibraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Libraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Libraries
    **/
    _count?: true | LibraryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LibraryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LibrarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryMaxAggregateInputType
  }

  export type GetLibraryAggregateType<T extends LibraryAggregateArgs> = {
        [P in keyof T & keyof AggregateLibrary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibrary[P]>
      : GetScalarType<T[P], AggregateLibrary[P]>
  }




  export type LibraryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LibraryWhereInput
    orderBy?: LibraryOrderByWithAggregationInput | LibraryOrderByWithAggregationInput[]
    by: LibraryScalarFieldEnum[] | LibraryScalarFieldEnum
    having?: LibraryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryCountAggregateInputType | true
    _avg?: LibraryAvgAggregateInputType
    _sum?: LibrarySumAggregateInputType
    _min?: LibraryMinAggregateInputType
    _max?: LibraryMaxAggregateInputType
  }


  export type LibraryGroupByOutputType = {
    id: string
    name: string
    displayName: string
    description: string | null
    vendor: string | null
    repoUrl: string | null
    docsUrl: string | null
    defaultVersion: string | null
    popularityScore: number
    totalSnippets: number
    totalTokens: number
    language: string
    ecosystem: string
    tags: string[]
    metadata: JsonValue | null
    clientId: string
    lastCrawledAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: LibraryCountAggregateOutputType | null
    _avg: LibraryAvgAggregateOutputType | null
    _sum: LibrarySumAggregateOutputType | null
    _min: LibraryMinAggregateOutputType | null
    _max: LibraryMaxAggregateOutputType | null
  }

  type GetLibraryGroupByPayload<T extends LibraryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LibraryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryGroupByOutputType[P]>
        }
      >
    >


  export type LibrarySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    vendor?: boolean
    repoUrl?: boolean
    docsUrl?: boolean
    defaultVersion?: boolean
    popularityScore?: boolean
    totalSnippets?: boolean
    totalTokens?: boolean
    language?: boolean
    ecosystem?: boolean
    tags?: boolean
    metadata?: boolean
    clientId?: boolean
    lastCrawledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientArgs<ExtArgs>
    versions?: boolean | Library$versionsArgs<ExtArgs>
    aliases?: boolean | Library$aliasesArgs<ExtArgs>
    documentationChunks?: boolean | Library$documentationChunksArgs<ExtArgs>
    usageLogs?: boolean | Library$usageLogsArgs<ExtArgs>
    _count?: boolean | LibraryCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["library"]>

  export type LibrarySelectScalar = {
    id?: boolean
    name?: boolean
    displayName?: boolean
    description?: boolean
    vendor?: boolean
    repoUrl?: boolean
    docsUrl?: boolean
    defaultVersion?: boolean
    popularityScore?: boolean
    totalSnippets?: boolean
    totalTokens?: boolean
    language?: boolean
    ecosystem?: boolean
    tags?: boolean
    metadata?: boolean
    clientId?: boolean
    lastCrawledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LibraryInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    client?: boolean | ClientArgs<ExtArgs>
    versions?: boolean | Library$versionsArgs<ExtArgs>
    aliases?: boolean | Library$aliasesArgs<ExtArgs>
    documentationChunks?: boolean | Library$documentationChunksArgs<ExtArgs>
    usageLogs?: boolean | Library$usageLogsArgs<ExtArgs>
    _count?: boolean | LibraryCountOutputTypeArgs<ExtArgs>
  }


  type LibraryGetPayload<S extends boolean | null | undefined | LibraryArgs> = $Types.GetResult<LibraryPayload, S>

  type LibraryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<LibraryFindManyArgs, 'select' | 'include'> & {
      select?: LibraryCountAggregateInputType | true
    }

  export interface LibraryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Library'], meta: { name: 'Library' } }
    /**
     * Find zero or one Library that matches the filter.
     * @param {LibraryFindUniqueArgs} args - Arguments to find a Library
     * @example
     * // Get one Library
     * const library = await prisma.library.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LibraryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LibraryFindUniqueArgs<ExtArgs>>
    ): Prisma__LibraryClient<$Types.GetResult<LibraryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Library that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LibraryFindUniqueOrThrowArgs} args - Arguments to find a Library
     * @example
     * // Get one Library
     * const library = await prisma.library.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LibraryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LibraryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LibraryClient<$Types.GetResult<LibraryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Library that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryFindFirstArgs} args - Arguments to find a Library
     * @example
     * // Get one Library
     * const library = await prisma.library.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LibraryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LibraryFindFirstArgs<ExtArgs>>
    ): Prisma__LibraryClient<$Types.GetResult<LibraryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Library that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryFindFirstOrThrowArgs} args - Arguments to find a Library
     * @example
     * // Get one Library
     * const library = await prisma.library.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LibraryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LibraryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LibraryClient<$Types.GetResult<LibraryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Libraries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Libraries
     * const libraries = await prisma.library.findMany()
     * 
     * // Get first 10 Libraries
     * const libraries = await prisma.library.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryWithIdOnly = await prisma.library.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LibraryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LibraryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<LibraryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Library.
     * @param {LibraryCreateArgs} args - Arguments to create a Library.
     * @example
     * // Create one Library
     * const Library = await prisma.library.create({
     *   data: {
     *     // ... data to create a Library
     *   }
     * })
     * 
    **/
    create<T extends LibraryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LibraryCreateArgs<ExtArgs>>
    ): Prisma__LibraryClient<$Types.GetResult<LibraryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Libraries.
     *     @param {LibraryCreateManyArgs} args - Arguments to create many Libraries.
     *     @example
     *     // Create many Libraries
     *     const library = await prisma.library.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LibraryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LibraryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Library.
     * @param {LibraryDeleteArgs} args - Arguments to delete one Library.
     * @example
     * // Delete one Library
     * const Library = await prisma.library.delete({
     *   where: {
     *     // ... filter to delete one Library
     *   }
     * })
     * 
    **/
    delete<T extends LibraryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LibraryDeleteArgs<ExtArgs>>
    ): Prisma__LibraryClient<$Types.GetResult<LibraryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Library.
     * @param {LibraryUpdateArgs} args - Arguments to update one Library.
     * @example
     * // Update one Library
     * const library = await prisma.library.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LibraryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LibraryUpdateArgs<ExtArgs>>
    ): Prisma__LibraryClient<$Types.GetResult<LibraryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Libraries.
     * @param {LibraryDeleteManyArgs} args - Arguments to filter Libraries to delete.
     * @example
     * // Delete a few Libraries
     * const { count } = await prisma.library.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LibraryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LibraryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Libraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Libraries
     * const library = await prisma.library.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LibraryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LibraryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Library.
     * @param {LibraryUpsertArgs} args - Arguments to update or create a Library.
     * @example
     * // Update or create a Library
     * const library = await prisma.library.upsert({
     *   create: {
     *     // ... data to create a Library
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Library we want to update
     *   }
     * })
    **/
    upsert<T extends LibraryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LibraryUpsertArgs<ExtArgs>>
    ): Prisma__LibraryClient<$Types.GetResult<LibraryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Libraries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryCountArgs} args - Arguments to filter Libraries to count.
     * @example
     * // Count the number of Libraries
     * const count = await prisma.library.count({
     *   where: {
     *     // ... the filter for the Libraries we want to count
     *   }
     * })
    **/
    count<T extends LibraryCountArgs>(
      args?: Subset<T, LibraryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Library.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryAggregateArgs>(args: Subset<T, LibraryAggregateArgs>): Prisma.PrismaPromise<GetLibraryAggregateType<T>>

    /**
     * Group by Library.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryGroupByArgs['orderBy'] }
        : { orderBy?: LibraryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Library model
   */
  readonly fields: LibraryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Library.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LibraryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    client<T extends ClientArgs<ExtArgs> = {}>(args?: Subset<T, ClientArgs<ExtArgs>>): Prisma__ClientClient<$Types.GetResult<ClientPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    versions<T extends Library$versionsArgs<ExtArgs> = {}>(args?: Subset<T, Library$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<LibraryVersionPayload<ExtArgs>, T, 'findMany'>| Null>;

    aliases<T extends Library$aliasesArgs<ExtArgs> = {}>(args?: Subset<T, Library$aliasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<LibraryAliasPayload<ExtArgs>, T, 'findMany'>| Null>;

    documentationChunks<T extends Library$documentationChunksArgs<ExtArgs> = {}>(args?: Subset<T, Library$documentationChunksArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DocumentationChunkPayload<ExtArgs>, T, 'findMany'>| Null>;

    usageLogs<T extends Library$usageLogsArgs<ExtArgs> = {}>(args?: Subset<T, Library$usageLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UsageLogPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the Library model
   */ 
  interface LibraryFieldRefs {
    readonly id: FieldRef<"Library", 'String'>
    readonly name: FieldRef<"Library", 'String'>
    readonly displayName: FieldRef<"Library", 'String'>
    readonly description: FieldRef<"Library", 'String'>
    readonly vendor: FieldRef<"Library", 'String'>
    readonly repoUrl: FieldRef<"Library", 'String'>
    readonly docsUrl: FieldRef<"Library", 'String'>
    readonly defaultVersion: FieldRef<"Library", 'String'>
    readonly popularityScore: FieldRef<"Library", 'Float'>
    readonly totalSnippets: FieldRef<"Library", 'Int'>
    readonly totalTokens: FieldRef<"Library", 'Int'>
    readonly language: FieldRef<"Library", 'String'>
    readonly ecosystem: FieldRef<"Library", 'String'>
    readonly tags: FieldRef<"Library", 'String[]'>
    readonly metadata: FieldRef<"Library", 'Json'>
    readonly clientId: FieldRef<"Library", 'String'>
    readonly lastCrawledAt: FieldRef<"Library", 'DateTime'>
    readonly createdAt: FieldRef<"Library", 'DateTime'>
    readonly updatedAt: FieldRef<"Library", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Library findUnique
   */
  export type LibraryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryInclude<ExtArgs> | null
    /**
     * Filter, which Library to fetch.
     */
    where: LibraryWhereUniqueInput
  }


  /**
   * Library findUniqueOrThrow
   */
  export type LibraryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryInclude<ExtArgs> | null
    /**
     * Filter, which Library to fetch.
     */
    where: LibraryWhereUniqueInput
  }


  /**
   * Library findFirst
   */
  export type LibraryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryInclude<ExtArgs> | null
    /**
     * Filter, which Library to fetch.
     */
    where?: LibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Libraries to fetch.
     */
    orderBy?: LibraryOrderByWithRelationInput | LibraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Libraries.
     */
    cursor?: LibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Libraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Libraries.
     */
    distinct?: LibraryScalarFieldEnum | LibraryScalarFieldEnum[]
  }


  /**
   * Library findFirstOrThrow
   */
  export type LibraryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryInclude<ExtArgs> | null
    /**
     * Filter, which Library to fetch.
     */
    where?: LibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Libraries to fetch.
     */
    orderBy?: LibraryOrderByWithRelationInput | LibraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Libraries.
     */
    cursor?: LibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Libraries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Libraries.
     */
    distinct?: LibraryScalarFieldEnum | LibraryScalarFieldEnum[]
  }


  /**
   * Library findMany
   */
  export type LibraryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryInclude<ExtArgs> | null
    /**
     * Filter, which Libraries to fetch.
     */
    where?: LibraryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Libraries to fetch.
     */
    orderBy?: LibraryOrderByWithRelationInput | LibraryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Libraries.
     */
    cursor?: LibraryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Libraries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Libraries.
     */
    skip?: number
    distinct?: LibraryScalarFieldEnum | LibraryScalarFieldEnum[]
  }


  /**
   * Library create
   */
  export type LibraryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryInclude<ExtArgs> | null
    /**
     * The data needed to create a Library.
     */
    data: XOR<LibraryCreateInput, LibraryUncheckedCreateInput>
  }


  /**
   * Library createMany
   */
  export type LibraryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Libraries.
     */
    data: LibraryCreateManyInput | LibraryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Library update
   */
  export type LibraryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryInclude<ExtArgs> | null
    /**
     * The data needed to update a Library.
     */
    data: XOR<LibraryUpdateInput, LibraryUncheckedUpdateInput>
    /**
     * Choose, which Library to update.
     */
    where: LibraryWhereUniqueInput
  }


  /**
   * Library updateMany
   */
  export type LibraryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Libraries.
     */
    data: XOR<LibraryUpdateManyMutationInput, LibraryUncheckedUpdateManyInput>
    /**
     * Filter which Libraries to update
     */
    where?: LibraryWhereInput
  }


  /**
   * Library upsert
   */
  export type LibraryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryInclude<ExtArgs> | null
    /**
     * The filter to search for the Library to update in case it exists.
     */
    where: LibraryWhereUniqueInput
    /**
     * In case the Library found by the `where` argument doesn't exist, create a new Library with this data.
     */
    create: XOR<LibraryCreateInput, LibraryUncheckedCreateInput>
    /**
     * In case the Library was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryUpdateInput, LibraryUncheckedUpdateInput>
  }


  /**
   * Library delete
   */
  export type LibraryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryInclude<ExtArgs> | null
    /**
     * Filter which Library to delete.
     */
    where: LibraryWhereUniqueInput
  }


  /**
   * Library deleteMany
   */
  export type LibraryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Libraries to delete
     */
    where?: LibraryWhereInput
  }


  /**
   * Library.versions
   */
  export type Library$versionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryVersion
     */
    select?: LibraryVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryVersionInclude<ExtArgs> | null
    where?: LibraryVersionWhereInput
    orderBy?: LibraryVersionOrderByWithRelationInput | LibraryVersionOrderByWithRelationInput[]
    cursor?: LibraryVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LibraryVersionScalarFieldEnum | LibraryVersionScalarFieldEnum[]
  }


  /**
   * Library.aliases
   */
  export type Library$aliasesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryAlias
     */
    select?: LibraryAliasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryAliasInclude<ExtArgs> | null
    where?: LibraryAliasWhereInput
    orderBy?: LibraryAliasOrderByWithRelationInput | LibraryAliasOrderByWithRelationInput[]
    cursor?: LibraryAliasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LibraryAliasScalarFieldEnum | LibraryAliasScalarFieldEnum[]
  }


  /**
   * Library.documentationChunks
   */
  export type Library$documentationChunksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentationChunk
     */
    select?: DocumentationChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentationChunkInclude<ExtArgs> | null
    where?: DocumentationChunkWhereInput
    orderBy?: DocumentationChunkOrderByWithRelationInput | DocumentationChunkOrderByWithRelationInput[]
    cursor?: DocumentationChunkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentationChunkScalarFieldEnum | DocumentationChunkScalarFieldEnum[]
  }


  /**
   * Library.usageLogs
   */
  export type Library$usageLogsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsageLogInclude<ExtArgs> | null
    where?: UsageLogWhereInput
    orderBy?: UsageLogOrderByWithRelationInput | UsageLogOrderByWithRelationInput[]
    cursor?: UsageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsageLogScalarFieldEnum | UsageLogScalarFieldEnum[]
  }


  /**
   * Library without action
   */
  export type LibraryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryInclude<ExtArgs> | null
  }



  /**
   * Model LibraryVersion
   */


  export type AggregateLibraryVersion = {
    _count: LibraryVersionCountAggregateOutputType | null
    _min: LibraryVersionMinAggregateOutputType | null
    _max: LibraryVersionMaxAggregateOutputType | null
  }

  export type LibraryVersionMinAggregateOutputType = {
    id: string | null
    libraryId: string | null
    version: string | null
    releaseDate: Date | null
    isLatest: boolean | null
    docsSnapshotUrl: string | null
  }

  export type LibraryVersionMaxAggregateOutputType = {
    id: string | null
    libraryId: string | null
    version: string | null
    releaseDate: Date | null
    isLatest: boolean | null
    docsSnapshotUrl: string | null
  }

  export type LibraryVersionCountAggregateOutputType = {
    id: number
    libraryId: number
    version: number
    releaseDate: number
    isLatest: number
    docsSnapshotUrl: number
    _all: number
  }


  export type LibraryVersionMinAggregateInputType = {
    id?: true
    libraryId?: true
    version?: true
    releaseDate?: true
    isLatest?: true
    docsSnapshotUrl?: true
  }

  export type LibraryVersionMaxAggregateInputType = {
    id?: true
    libraryId?: true
    version?: true
    releaseDate?: true
    isLatest?: true
    docsSnapshotUrl?: true
  }

  export type LibraryVersionCountAggregateInputType = {
    id?: true
    libraryId?: true
    version?: true
    releaseDate?: true
    isLatest?: true
    docsSnapshotUrl?: true
    _all?: true
  }

  export type LibraryVersionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which LibraryVersion to aggregate.
     */
    where?: LibraryVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryVersions to fetch.
     */
    orderBy?: LibraryVersionOrderByWithRelationInput | LibraryVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryVersions
    **/
    _count?: true | LibraryVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryVersionMaxAggregateInputType
  }

  export type GetLibraryVersionAggregateType<T extends LibraryVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryVersion[P]>
      : GetScalarType<T[P], AggregateLibraryVersion[P]>
  }




  export type LibraryVersionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LibraryVersionWhereInput
    orderBy?: LibraryVersionOrderByWithAggregationInput | LibraryVersionOrderByWithAggregationInput[]
    by: LibraryVersionScalarFieldEnum[] | LibraryVersionScalarFieldEnum
    having?: LibraryVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryVersionCountAggregateInputType | true
    _min?: LibraryVersionMinAggregateInputType
    _max?: LibraryVersionMaxAggregateInputType
  }


  export type LibraryVersionGroupByOutputType = {
    id: string
    libraryId: string
    version: string
    releaseDate: Date | null
    isLatest: boolean
    docsSnapshotUrl: string | null
    _count: LibraryVersionCountAggregateOutputType | null
    _min: LibraryVersionMinAggregateOutputType | null
    _max: LibraryVersionMaxAggregateOutputType | null
  }

  type GetLibraryVersionGroupByPayload<T extends LibraryVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LibraryVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryVersionGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryVersionGroupByOutputType[P]>
        }
      >
    >


  export type LibraryVersionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    libraryId?: boolean
    version?: boolean
    releaseDate?: boolean
    isLatest?: boolean
    docsSnapshotUrl?: boolean
    library?: boolean | LibraryArgs<ExtArgs>
    documentationChunks?: boolean | LibraryVersion$documentationChunksArgs<ExtArgs>
    _count?: boolean | LibraryVersionCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["libraryVersion"]>

  export type LibraryVersionSelectScalar = {
    id?: boolean
    libraryId?: boolean
    version?: boolean
    releaseDate?: boolean
    isLatest?: boolean
    docsSnapshotUrl?: boolean
  }

  export type LibraryVersionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    library?: boolean | LibraryArgs<ExtArgs>
    documentationChunks?: boolean | LibraryVersion$documentationChunksArgs<ExtArgs>
    _count?: boolean | LibraryVersionCountOutputTypeArgs<ExtArgs>
  }


  type LibraryVersionGetPayload<S extends boolean | null | undefined | LibraryVersionArgs> = $Types.GetResult<LibraryVersionPayload, S>

  type LibraryVersionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<LibraryVersionFindManyArgs, 'select' | 'include'> & {
      select?: LibraryVersionCountAggregateInputType | true
    }

  export interface LibraryVersionDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LibraryVersion'], meta: { name: 'LibraryVersion' } }
    /**
     * Find zero or one LibraryVersion that matches the filter.
     * @param {LibraryVersionFindUniqueArgs} args - Arguments to find a LibraryVersion
     * @example
     * // Get one LibraryVersion
     * const libraryVersion = await prisma.libraryVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LibraryVersionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LibraryVersionFindUniqueArgs<ExtArgs>>
    ): Prisma__LibraryVersionClient<$Types.GetResult<LibraryVersionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LibraryVersion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LibraryVersionFindUniqueOrThrowArgs} args - Arguments to find a LibraryVersion
     * @example
     * // Get one LibraryVersion
     * const libraryVersion = await prisma.libraryVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LibraryVersionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LibraryVersionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LibraryVersionClient<$Types.GetResult<LibraryVersionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LibraryVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryVersionFindFirstArgs} args - Arguments to find a LibraryVersion
     * @example
     * // Get one LibraryVersion
     * const libraryVersion = await prisma.libraryVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LibraryVersionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LibraryVersionFindFirstArgs<ExtArgs>>
    ): Prisma__LibraryVersionClient<$Types.GetResult<LibraryVersionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LibraryVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryVersionFindFirstOrThrowArgs} args - Arguments to find a LibraryVersion
     * @example
     * // Get one LibraryVersion
     * const libraryVersion = await prisma.libraryVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LibraryVersionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LibraryVersionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LibraryVersionClient<$Types.GetResult<LibraryVersionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LibraryVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryVersionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryVersions
     * const libraryVersions = await prisma.libraryVersion.findMany()
     * 
     * // Get first 10 LibraryVersions
     * const libraryVersions = await prisma.libraryVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryVersionWithIdOnly = await prisma.libraryVersion.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LibraryVersionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LibraryVersionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<LibraryVersionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LibraryVersion.
     * @param {LibraryVersionCreateArgs} args - Arguments to create a LibraryVersion.
     * @example
     * // Create one LibraryVersion
     * const LibraryVersion = await prisma.libraryVersion.create({
     *   data: {
     *     // ... data to create a LibraryVersion
     *   }
     * })
     * 
    **/
    create<T extends LibraryVersionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LibraryVersionCreateArgs<ExtArgs>>
    ): Prisma__LibraryVersionClient<$Types.GetResult<LibraryVersionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LibraryVersions.
     *     @param {LibraryVersionCreateManyArgs} args - Arguments to create many LibraryVersions.
     *     @example
     *     // Create many LibraryVersions
     *     const libraryVersion = await prisma.libraryVersion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LibraryVersionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LibraryVersionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LibraryVersion.
     * @param {LibraryVersionDeleteArgs} args - Arguments to delete one LibraryVersion.
     * @example
     * // Delete one LibraryVersion
     * const LibraryVersion = await prisma.libraryVersion.delete({
     *   where: {
     *     // ... filter to delete one LibraryVersion
     *   }
     * })
     * 
    **/
    delete<T extends LibraryVersionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LibraryVersionDeleteArgs<ExtArgs>>
    ): Prisma__LibraryVersionClient<$Types.GetResult<LibraryVersionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LibraryVersion.
     * @param {LibraryVersionUpdateArgs} args - Arguments to update one LibraryVersion.
     * @example
     * // Update one LibraryVersion
     * const libraryVersion = await prisma.libraryVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LibraryVersionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LibraryVersionUpdateArgs<ExtArgs>>
    ): Prisma__LibraryVersionClient<$Types.GetResult<LibraryVersionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LibraryVersions.
     * @param {LibraryVersionDeleteManyArgs} args - Arguments to filter LibraryVersions to delete.
     * @example
     * // Delete a few LibraryVersions
     * const { count } = await prisma.libraryVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LibraryVersionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LibraryVersionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryVersions
     * const libraryVersion = await prisma.libraryVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LibraryVersionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LibraryVersionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LibraryVersion.
     * @param {LibraryVersionUpsertArgs} args - Arguments to update or create a LibraryVersion.
     * @example
     * // Update or create a LibraryVersion
     * const libraryVersion = await prisma.libraryVersion.upsert({
     *   create: {
     *     // ... data to create a LibraryVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryVersion we want to update
     *   }
     * })
    **/
    upsert<T extends LibraryVersionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LibraryVersionUpsertArgs<ExtArgs>>
    ): Prisma__LibraryVersionClient<$Types.GetResult<LibraryVersionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LibraryVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryVersionCountArgs} args - Arguments to filter LibraryVersions to count.
     * @example
     * // Count the number of LibraryVersions
     * const count = await prisma.libraryVersion.count({
     *   where: {
     *     // ... the filter for the LibraryVersions we want to count
     *   }
     * })
    **/
    count<T extends LibraryVersionCountArgs>(
      args?: Subset<T, LibraryVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryVersionAggregateArgs>(args: Subset<T, LibraryVersionAggregateArgs>): Prisma.PrismaPromise<GetLibraryVersionAggregateType<T>>

    /**
     * Group by LibraryVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryVersionGroupByArgs['orderBy'] }
        : { orderBy?: LibraryVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LibraryVersion model
   */
  readonly fields: LibraryVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LibraryVersionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    library<T extends LibraryArgs<ExtArgs> = {}>(args?: Subset<T, LibraryArgs<ExtArgs>>): Prisma__LibraryClient<$Types.GetResult<LibraryPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    documentationChunks<T extends LibraryVersion$documentationChunksArgs<ExtArgs> = {}>(args?: Subset<T, LibraryVersion$documentationChunksArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DocumentationChunkPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the LibraryVersion model
   */ 
  interface LibraryVersionFieldRefs {
    readonly id: FieldRef<"LibraryVersion", 'String'>
    readonly libraryId: FieldRef<"LibraryVersion", 'String'>
    readonly version: FieldRef<"LibraryVersion", 'String'>
    readonly releaseDate: FieldRef<"LibraryVersion", 'DateTime'>
    readonly isLatest: FieldRef<"LibraryVersion", 'Boolean'>
    readonly docsSnapshotUrl: FieldRef<"LibraryVersion", 'String'>
  }
    

  // Custom InputTypes

  /**
   * LibraryVersion findUnique
   */
  export type LibraryVersionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryVersion
     */
    select?: LibraryVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryVersionInclude<ExtArgs> | null
    /**
     * Filter, which LibraryVersion to fetch.
     */
    where: LibraryVersionWhereUniqueInput
  }


  /**
   * LibraryVersion findUniqueOrThrow
   */
  export type LibraryVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryVersion
     */
    select?: LibraryVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryVersionInclude<ExtArgs> | null
    /**
     * Filter, which LibraryVersion to fetch.
     */
    where: LibraryVersionWhereUniqueInput
  }


  /**
   * LibraryVersion findFirst
   */
  export type LibraryVersionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryVersion
     */
    select?: LibraryVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryVersionInclude<ExtArgs> | null
    /**
     * Filter, which LibraryVersion to fetch.
     */
    where?: LibraryVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryVersions to fetch.
     */
    orderBy?: LibraryVersionOrderByWithRelationInput | LibraryVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryVersions.
     */
    cursor?: LibraryVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryVersions.
     */
    distinct?: LibraryVersionScalarFieldEnum | LibraryVersionScalarFieldEnum[]
  }


  /**
   * LibraryVersion findFirstOrThrow
   */
  export type LibraryVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryVersion
     */
    select?: LibraryVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryVersionInclude<ExtArgs> | null
    /**
     * Filter, which LibraryVersion to fetch.
     */
    where?: LibraryVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryVersions to fetch.
     */
    orderBy?: LibraryVersionOrderByWithRelationInput | LibraryVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryVersions.
     */
    cursor?: LibraryVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryVersions.
     */
    distinct?: LibraryVersionScalarFieldEnum | LibraryVersionScalarFieldEnum[]
  }


  /**
   * LibraryVersion findMany
   */
  export type LibraryVersionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryVersion
     */
    select?: LibraryVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryVersionInclude<ExtArgs> | null
    /**
     * Filter, which LibraryVersions to fetch.
     */
    where?: LibraryVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryVersions to fetch.
     */
    orderBy?: LibraryVersionOrderByWithRelationInput | LibraryVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryVersions.
     */
    cursor?: LibraryVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryVersions.
     */
    skip?: number
    distinct?: LibraryVersionScalarFieldEnum | LibraryVersionScalarFieldEnum[]
  }


  /**
   * LibraryVersion create
   */
  export type LibraryVersionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryVersion
     */
    select?: LibraryVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a LibraryVersion.
     */
    data: XOR<LibraryVersionCreateInput, LibraryVersionUncheckedCreateInput>
  }


  /**
   * LibraryVersion createMany
   */
  export type LibraryVersionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LibraryVersions.
     */
    data: LibraryVersionCreateManyInput | LibraryVersionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * LibraryVersion update
   */
  export type LibraryVersionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryVersion
     */
    select?: LibraryVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a LibraryVersion.
     */
    data: XOR<LibraryVersionUpdateInput, LibraryVersionUncheckedUpdateInput>
    /**
     * Choose, which LibraryVersion to update.
     */
    where: LibraryVersionWhereUniqueInput
  }


  /**
   * LibraryVersion updateMany
   */
  export type LibraryVersionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LibraryVersions.
     */
    data: XOR<LibraryVersionUpdateManyMutationInput, LibraryVersionUncheckedUpdateManyInput>
    /**
     * Filter which LibraryVersions to update
     */
    where?: LibraryVersionWhereInput
  }


  /**
   * LibraryVersion upsert
   */
  export type LibraryVersionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryVersion
     */
    select?: LibraryVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the LibraryVersion to update in case it exists.
     */
    where: LibraryVersionWhereUniqueInput
    /**
     * In case the LibraryVersion found by the `where` argument doesn't exist, create a new LibraryVersion with this data.
     */
    create: XOR<LibraryVersionCreateInput, LibraryVersionUncheckedCreateInput>
    /**
     * In case the LibraryVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryVersionUpdateInput, LibraryVersionUncheckedUpdateInput>
  }


  /**
   * LibraryVersion delete
   */
  export type LibraryVersionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryVersion
     */
    select?: LibraryVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryVersionInclude<ExtArgs> | null
    /**
     * Filter which LibraryVersion to delete.
     */
    where: LibraryVersionWhereUniqueInput
  }


  /**
   * LibraryVersion deleteMany
   */
  export type LibraryVersionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which LibraryVersions to delete
     */
    where?: LibraryVersionWhereInput
  }


  /**
   * LibraryVersion.documentationChunks
   */
  export type LibraryVersion$documentationChunksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentationChunk
     */
    select?: DocumentationChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentationChunkInclude<ExtArgs> | null
    where?: DocumentationChunkWhereInput
    orderBy?: DocumentationChunkOrderByWithRelationInput | DocumentationChunkOrderByWithRelationInput[]
    cursor?: DocumentationChunkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentationChunkScalarFieldEnum | DocumentationChunkScalarFieldEnum[]
  }


  /**
   * LibraryVersion without action
   */
  export type LibraryVersionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryVersion
     */
    select?: LibraryVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryVersionInclude<ExtArgs> | null
  }



  /**
   * Model LibraryAlias
   */


  export type AggregateLibraryAlias = {
    _count: LibraryAliasCountAggregateOutputType | null
    _min: LibraryAliasMinAggregateOutputType | null
    _max: LibraryAliasMaxAggregateOutputType | null
  }

  export type LibraryAliasMinAggregateOutputType = {
    id: string | null
    libraryId: string | null
    alias: string | null
  }

  export type LibraryAliasMaxAggregateOutputType = {
    id: string | null
    libraryId: string | null
    alias: string | null
  }

  export type LibraryAliasCountAggregateOutputType = {
    id: number
    libraryId: number
    alias: number
    _all: number
  }


  export type LibraryAliasMinAggregateInputType = {
    id?: true
    libraryId?: true
    alias?: true
  }

  export type LibraryAliasMaxAggregateInputType = {
    id?: true
    libraryId?: true
    alias?: true
  }

  export type LibraryAliasCountAggregateInputType = {
    id?: true
    libraryId?: true
    alias?: true
    _all?: true
  }

  export type LibraryAliasAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which LibraryAlias to aggregate.
     */
    where?: LibraryAliasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryAliases to fetch.
     */
    orderBy?: LibraryAliasOrderByWithRelationInput | LibraryAliasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LibraryAliasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryAliases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryAliases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LibraryAliases
    **/
    _count?: true | LibraryAliasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LibraryAliasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LibraryAliasMaxAggregateInputType
  }

  export type GetLibraryAliasAggregateType<T extends LibraryAliasAggregateArgs> = {
        [P in keyof T & keyof AggregateLibraryAlias]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLibraryAlias[P]>
      : GetScalarType<T[P], AggregateLibraryAlias[P]>
  }




  export type LibraryAliasGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LibraryAliasWhereInput
    orderBy?: LibraryAliasOrderByWithAggregationInput | LibraryAliasOrderByWithAggregationInput[]
    by: LibraryAliasScalarFieldEnum[] | LibraryAliasScalarFieldEnum
    having?: LibraryAliasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LibraryAliasCountAggregateInputType | true
    _min?: LibraryAliasMinAggregateInputType
    _max?: LibraryAliasMaxAggregateInputType
  }


  export type LibraryAliasGroupByOutputType = {
    id: string
    libraryId: string
    alias: string
    _count: LibraryAliasCountAggregateOutputType | null
    _min: LibraryAliasMinAggregateOutputType | null
    _max: LibraryAliasMaxAggregateOutputType | null
  }

  type GetLibraryAliasGroupByPayload<T extends LibraryAliasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LibraryAliasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LibraryAliasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LibraryAliasGroupByOutputType[P]>
            : GetScalarType<T[P], LibraryAliasGroupByOutputType[P]>
        }
      >
    >


  export type LibraryAliasSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    libraryId?: boolean
    alias?: boolean
    library?: boolean | LibraryArgs<ExtArgs>
  }, ExtArgs["result"]["libraryAlias"]>

  export type LibraryAliasSelectScalar = {
    id?: boolean
    libraryId?: boolean
    alias?: boolean
  }

  export type LibraryAliasInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    library?: boolean | LibraryArgs<ExtArgs>
  }


  type LibraryAliasGetPayload<S extends boolean | null | undefined | LibraryAliasArgs> = $Types.GetResult<LibraryAliasPayload, S>

  type LibraryAliasCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<LibraryAliasFindManyArgs, 'select' | 'include'> & {
      select?: LibraryAliasCountAggregateInputType | true
    }

  export interface LibraryAliasDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LibraryAlias'], meta: { name: 'LibraryAlias' } }
    /**
     * Find zero or one LibraryAlias that matches the filter.
     * @param {LibraryAliasFindUniqueArgs} args - Arguments to find a LibraryAlias
     * @example
     * // Get one LibraryAlias
     * const libraryAlias = await prisma.libraryAlias.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LibraryAliasFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LibraryAliasFindUniqueArgs<ExtArgs>>
    ): Prisma__LibraryAliasClient<$Types.GetResult<LibraryAliasPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one LibraryAlias that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LibraryAliasFindUniqueOrThrowArgs} args - Arguments to find a LibraryAlias
     * @example
     * // Get one LibraryAlias
     * const libraryAlias = await prisma.libraryAlias.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LibraryAliasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LibraryAliasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LibraryAliasClient<$Types.GetResult<LibraryAliasPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first LibraryAlias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryAliasFindFirstArgs} args - Arguments to find a LibraryAlias
     * @example
     * // Get one LibraryAlias
     * const libraryAlias = await prisma.libraryAlias.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LibraryAliasFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LibraryAliasFindFirstArgs<ExtArgs>>
    ): Prisma__LibraryAliasClient<$Types.GetResult<LibraryAliasPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first LibraryAlias that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryAliasFindFirstOrThrowArgs} args - Arguments to find a LibraryAlias
     * @example
     * // Get one LibraryAlias
     * const libraryAlias = await prisma.libraryAlias.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LibraryAliasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LibraryAliasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LibraryAliasClient<$Types.GetResult<LibraryAliasPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more LibraryAliases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryAliasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LibraryAliases
     * const libraryAliases = await prisma.libraryAlias.findMany()
     * 
     * // Get first 10 LibraryAliases
     * const libraryAliases = await prisma.libraryAlias.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const libraryAliasWithIdOnly = await prisma.libraryAlias.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LibraryAliasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LibraryAliasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<LibraryAliasPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a LibraryAlias.
     * @param {LibraryAliasCreateArgs} args - Arguments to create a LibraryAlias.
     * @example
     * // Create one LibraryAlias
     * const LibraryAlias = await prisma.libraryAlias.create({
     *   data: {
     *     // ... data to create a LibraryAlias
     *   }
     * })
     * 
    **/
    create<T extends LibraryAliasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LibraryAliasCreateArgs<ExtArgs>>
    ): Prisma__LibraryAliasClient<$Types.GetResult<LibraryAliasPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many LibraryAliases.
     *     @param {LibraryAliasCreateManyArgs} args - Arguments to create many LibraryAliases.
     *     @example
     *     // Create many LibraryAliases
     *     const libraryAlias = await prisma.libraryAlias.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LibraryAliasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LibraryAliasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LibraryAlias.
     * @param {LibraryAliasDeleteArgs} args - Arguments to delete one LibraryAlias.
     * @example
     * // Delete one LibraryAlias
     * const LibraryAlias = await prisma.libraryAlias.delete({
     *   where: {
     *     // ... filter to delete one LibraryAlias
     *   }
     * })
     * 
    **/
    delete<T extends LibraryAliasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LibraryAliasDeleteArgs<ExtArgs>>
    ): Prisma__LibraryAliasClient<$Types.GetResult<LibraryAliasPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one LibraryAlias.
     * @param {LibraryAliasUpdateArgs} args - Arguments to update one LibraryAlias.
     * @example
     * // Update one LibraryAlias
     * const libraryAlias = await prisma.libraryAlias.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LibraryAliasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LibraryAliasUpdateArgs<ExtArgs>>
    ): Prisma__LibraryAliasClient<$Types.GetResult<LibraryAliasPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more LibraryAliases.
     * @param {LibraryAliasDeleteManyArgs} args - Arguments to filter LibraryAliases to delete.
     * @example
     * // Delete a few LibraryAliases
     * const { count } = await prisma.libraryAlias.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LibraryAliasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LibraryAliasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LibraryAliases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryAliasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LibraryAliases
     * const libraryAlias = await prisma.libraryAlias.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LibraryAliasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LibraryAliasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LibraryAlias.
     * @param {LibraryAliasUpsertArgs} args - Arguments to update or create a LibraryAlias.
     * @example
     * // Update or create a LibraryAlias
     * const libraryAlias = await prisma.libraryAlias.upsert({
     *   create: {
     *     // ... data to create a LibraryAlias
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LibraryAlias we want to update
     *   }
     * })
    **/
    upsert<T extends LibraryAliasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LibraryAliasUpsertArgs<ExtArgs>>
    ): Prisma__LibraryAliasClient<$Types.GetResult<LibraryAliasPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of LibraryAliases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryAliasCountArgs} args - Arguments to filter LibraryAliases to count.
     * @example
     * // Count the number of LibraryAliases
     * const count = await prisma.libraryAlias.count({
     *   where: {
     *     // ... the filter for the LibraryAliases we want to count
     *   }
     * })
    **/
    count<T extends LibraryAliasCountArgs>(
      args?: Subset<T, LibraryAliasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LibraryAliasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LibraryAlias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryAliasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LibraryAliasAggregateArgs>(args: Subset<T, LibraryAliasAggregateArgs>): Prisma.PrismaPromise<GetLibraryAliasAggregateType<T>>

    /**
     * Group by LibraryAlias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LibraryAliasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LibraryAliasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LibraryAliasGroupByArgs['orderBy'] }
        : { orderBy?: LibraryAliasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LibraryAliasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLibraryAliasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LibraryAlias model
   */
  readonly fields: LibraryAliasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LibraryAlias.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LibraryAliasClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    library<T extends LibraryArgs<ExtArgs> = {}>(args?: Subset<T, LibraryArgs<ExtArgs>>): Prisma__LibraryClient<$Types.GetResult<LibraryPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the LibraryAlias model
   */ 
  interface LibraryAliasFieldRefs {
    readonly id: FieldRef<"LibraryAlias", 'String'>
    readonly libraryId: FieldRef<"LibraryAlias", 'String'>
    readonly alias: FieldRef<"LibraryAlias", 'String'>
  }
    

  // Custom InputTypes

  /**
   * LibraryAlias findUnique
   */
  export type LibraryAliasFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryAlias
     */
    select?: LibraryAliasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryAliasInclude<ExtArgs> | null
    /**
     * Filter, which LibraryAlias to fetch.
     */
    where: LibraryAliasWhereUniqueInput
  }


  /**
   * LibraryAlias findUniqueOrThrow
   */
  export type LibraryAliasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryAlias
     */
    select?: LibraryAliasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryAliasInclude<ExtArgs> | null
    /**
     * Filter, which LibraryAlias to fetch.
     */
    where: LibraryAliasWhereUniqueInput
  }


  /**
   * LibraryAlias findFirst
   */
  export type LibraryAliasFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryAlias
     */
    select?: LibraryAliasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryAliasInclude<ExtArgs> | null
    /**
     * Filter, which LibraryAlias to fetch.
     */
    where?: LibraryAliasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryAliases to fetch.
     */
    orderBy?: LibraryAliasOrderByWithRelationInput | LibraryAliasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryAliases.
     */
    cursor?: LibraryAliasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryAliases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryAliases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryAliases.
     */
    distinct?: LibraryAliasScalarFieldEnum | LibraryAliasScalarFieldEnum[]
  }


  /**
   * LibraryAlias findFirstOrThrow
   */
  export type LibraryAliasFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryAlias
     */
    select?: LibraryAliasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryAliasInclude<ExtArgs> | null
    /**
     * Filter, which LibraryAlias to fetch.
     */
    where?: LibraryAliasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryAliases to fetch.
     */
    orderBy?: LibraryAliasOrderByWithRelationInput | LibraryAliasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LibraryAliases.
     */
    cursor?: LibraryAliasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryAliases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryAliases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LibraryAliases.
     */
    distinct?: LibraryAliasScalarFieldEnum | LibraryAliasScalarFieldEnum[]
  }


  /**
   * LibraryAlias findMany
   */
  export type LibraryAliasFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryAlias
     */
    select?: LibraryAliasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryAliasInclude<ExtArgs> | null
    /**
     * Filter, which LibraryAliases to fetch.
     */
    where?: LibraryAliasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LibraryAliases to fetch.
     */
    orderBy?: LibraryAliasOrderByWithRelationInput | LibraryAliasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LibraryAliases.
     */
    cursor?: LibraryAliasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LibraryAliases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LibraryAliases.
     */
    skip?: number
    distinct?: LibraryAliasScalarFieldEnum | LibraryAliasScalarFieldEnum[]
  }


  /**
   * LibraryAlias create
   */
  export type LibraryAliasCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryAlias
     */
    select?: LibraryAliasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryAliasInclude<ExtArgs> | null
    /**
     * The data needed to create a LibraryAlias.
     */
    data: XOR<LibraryAliasCreateInput, LibraryAliasUncheckedCreateInput>
  }


  /**
   * LibraryAlias createMany
   */
  export type LibraryAliasCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LibraryAliases.
     */
    data: LibraryAliasCreateManyInput | LibraryAliasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * LibraryAlias update
   */
  export type LibraryAliasUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryAlias
     */
    select?: LibraryAliasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryAliasInclude<ExtArgs> | null
    /**
     * The data needed to update a LibraryAlias.
     */
    data: XOR<LibraryAliasUpdateInput, LibraryAliasUncheckedUpdateInput>
    /**
     * Choose, which LibraryAlias to update.
     */
    where: LibraryAliasWhereUniqueInput
  }


  /**
   * LibraryAlias updateMany
   */
  export type LibraryAliasUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LibraryAliases.
     */
    data: XOR<LibraryAliasUpdateManyMutationInput, LibraryAliasUncheckedUpdateManyInput>
    /**
     * Filter which LibraryAliases to update
     */
    where?: LibraryAliasWhereInput
  }


  /**
   * LibraryAlias upsert
   */
  export type LibraryAliasUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryAlias
     */
    select?: LibraryAliasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryAliasInclude<ExtArgs> | null
    /**
     * The filter to search for the LibraryAlias to update in case it exists.
     */
    where: LibraryAliasWhereUniqueInput
    /**
     * In case the LibraryAlias found by the `where` argument doesn't exist, create a new LibraryAlias with this data.
     */
    create: XOR<LibraryAliasCreateInput, LibraryAliasUncheckedCreateInput>
    /**
     * In case the LibraryAlias was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LibraryAliasUpdateInput, LibraryAliasUncheckedUpdateInput>
  }


  /**
   * LibraryAlias delete
   */
  export type LibraryAliasDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryAlias
     */
    select?: LibraryAliasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryAliasInclude<ExtArgs> | null
    /**
     * Filter which LibraryAlias to delete.
     */
    where: LibraryAliasWhereUniqueInput
  }


  /**
   * LibraryAlias deleteMany
   */
  export type LibraryAliasDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which LibraryAliases to delete
     */
    where?: LibraryAliasWhereInput
  }


  /**
   * LibraryAlias without action
   */
  export type LibraryAliasArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LibraryAlias
     */
    select?: LibraryAliasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryAliasInclude<ExtArgs> | null
  }



  /**
   * Model DocumentationChunk
   */


  export type AggregateDocumentationChunk = {
    _count: DocumentationChunkCountAggregateOutputType | null
    _avg: DocumentationChunkAvgAggregateOutputType | null
    _sum: DocumentationChunkSumAggregateOutputType | null
    _min: DocumentationChunkMinAggregateOutputType | null
    _max: DocumentationChunkMaxAggregateOutputType | null
  }

  export type DocumentationChunkAvgAggregateOutputType = {
    chunkIndex: number | null
    tokenCount: number | null
  }

  export type DocumentationChunkSumAggregateOutputType = {
    chunkIndex: number | null
    tokenCount: number | null
  }

  export type DocumentationChunkMinAggregateOutputType = {
    id: string | null
    libraryVersionId: string | null
    chunkIndex: number | null
    content: string | null
    contentType: string | null
    sourceUrl: string | null
    tokenCount: number | null
    embeddingId: string | null
    createdAt: Date | null
    libraryId: string | null
  }

  export type DocumentationChunkMaxAggregateOutputType = {
    id: string | null
    libraryVersionId: string | null
    chunkIndex: number | null
    content: string | null
    contentType: string | null
    sourceUrl: string | null
    tokenCount: number | null
    embeddingId: string | null
    createdAt: Date | null
    libraryId: string | null
  }

  export type DocumentationChunkCountAggregateOutputType = {
    id: number
    libraryVersionId: number
    chunkIndex: number
    content: number
    contentType: number
    sourceUrl: number
    tokenCount: number
    embeddingId: number
    metadata: number
    createdAt: number
    libraryId: number
    _all: number
  }


  export type DocumentationChunkAvgAggregateInputType = {
    chunkIndex?: true
    tokenCount?: true
  }

  export type DocumentationChunkSumAggregateInputType = {
    chunkIndex?: true
    tokenCount?: true
  }

  export type DocumentationChunkMinAggregateInputType = {
    id?: true
    libraryVersionId?: true
    chunkIndex?: true
    content?: true
    contentType?: true
    sourceUrl?: true
    tokenCount?: true
    embeddingId?: true
    createdAt?: true
    libraryId?: true
  }

  export type DocumentationChunkMaxAggregateInputType = {
    id?: true
    libraryVersionId?: true
    chunkIndex?: true
    content?: true
    contentType?: true
    sourceUrl?: true
    tokenCount?: true
    embeddingId?: true
    createdAt?: true
    libraryId?: true
  }

  export type DocumentationChunkCountAggregateInputType = {
    id?: true
    libraryVersionId?: true
    chunkIndex?: true
    content?: true
    contentType?: true
    sourceUrl?: true
    tokenCount?: true
    embeddingId?: true
    metadata?: true
    createdAt?: true
    libraryId?: true
    _all?: true
  }

  export type DocumentationChunkAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentationChunk to aggregate.
     */
    where?: DocumentationChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentationChunks to fetch.
     */
    orderBy?: DocumentationChunkOrderByWithRelationInput | DocumentationChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentationChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentationChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentationChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentationChunks
    **/
    _count?: true | DocumentationChunkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentationChunkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentationChunkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentationChunkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentationChunkMaxAggregateInputType
  }

  export type GetDocumentationChunkAggregateType<T extends DocumentationChunkAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentationChunk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentationChunk[P]>
      : GetScalarType<T[P], AggregateDocumentationChunk[P]>
  }




  export type DocumentationChunkGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentationChunkWhereInput
    orderBy?: DocumentationChunkOrderByWithAggregationInput | DocumentationChunkOrderByWithAggregationInput[]
    by: DocumentationChunkScalarFieldEnum[] | DocumentationChunkScalarFieldEnum
    having?: DocumentationChunkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentationChunkCountAggregateInputType | true
    _avg?: DocumentationChunkAvgAggregateInputType
    _sum?: DocumentationChunkSumAggregateInputType
    _min?: DocumentationChunkMinAggregateInputType
    _max?: DocumentationChunkMaxAggregateInputType
  }


  export type DocumentationChunkGroupByOutputType = {
    id: string
    libraryVersionId: string
    chunkIndex: number
    content: string
    contentType: string
    sourceUrl: string | null
    tokenCount: number
    embeddingId: string | null
    metadata: JsonValue | null
    createdAt: Date
    libraryId: string | null
    _count: DocumentationChunkCountAggregateOutputType | null
    _avg: DocumentationChunkAvgAggregateOutputType | null
    _sum: DocumentationChunkSumAggregateOutputType | null
    _min: DocumentationChunkMinAggregateOutputType | null
    _max: DocumentationChunkMaxAggregateOutputType | null
  }

  type GetDocumentationChunkGroupByPayload<T extends DocumentationChunkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentationChunkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentationChunkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentationChunkGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentationChunkGroupByOutputType[P]>
        }
      >
    >


  export type DocumentationChunkSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    libraryVersionId?: boolean
    chunkIndex?: boolean
    content?: boolean
    contentType?: boolean
    sourceUrl?: boolean
    tokenCount?: boolean
    embeddingId?: boolean
    metadata?: boolean
    createdAt?: boolean
    libraryId?: boolean
    libraryVersion?: boolean | LibraryVersionArgs<ExtArgs>
    Library?: boolean | DocumentationChunk$LibraryArgs<ExtArgs>
  }, ExtArgs["result"]["documentationChunk"]>

  export type DocumentationChunkSelectScalar = {
    id?: boolean
    libraryVersionId?: boolean
    chunkIndex?: boolean
    content?: boolean
    contentType?: boolean
    sourceUrl?: boolean
    tokenCount?: boolean
    embeddingId?: boolean
    metadata?: boolean
    createdAt?: boolean
    libraryId?: boolean
  }

  export type DocumentationChunkInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    libraryVersion?: boolean | LibraryVersionArgs<ExtArgs>
    Library?: boolean | DocumentationChunk$LibraryArgs<ExtArgs>
  }


  type DocumentationChunkGetPayload<S extends boolean | null | undefined | DocumentationChunkArgs> = $Types.GetResult<DocumentationChunkPayload, S>

  type DocumentationChunkCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DocumentationChunkFindManyArgs, 'select' | 'include'> & {
      select?: DocumentationChunkCountAggregateInputType | true
    }

  export interface DocumentationChunkDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentationChunk'], meta: { name: 'DocumentationChunk' } }
    /**
     * Find zero or one DocumentationChunk that matches the filter.
     * @param {DocumentationChunkFindUniqueArgs} args - Arguments to find a DocumentationChunk
     * @example
     * // Get one DocumentationChunk
     * const documentationChunk = await prisma.documentationChunk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DocumentationChunkFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentationChunkFindUniqueArgs<ExtArgs>>
    ): Prisma__DocumentationChunkClient<$Types.GetResult<DocumentationChunkPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DocumentationChunk that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DocumentationChunkFindUniqueOrThrowArgs} args - Arguments to find a DocumentationChunk
     * @example
     * // Get one DocumentationChunk
     * const documentationChunk = await prisma.documentationChunk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DocumentationChunkFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentationChunkFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentationChunkClient<$Types.GetResult<DocumentationChunkPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DocumentationChunk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentationChunkFindFirstArgs} args - Arguments to find a DocumentationChunk
     * @example
     * // Get one DocumentationChunk
     * const documentationChunk = await prisma.documentationChunk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DocumentationChunkFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentationChunkFindFirstArgs<ExtArgs>>
    ): Prisma__DocumentationChunkClient<$Types.GetResult<DocumentationChunkPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DocumentationChunk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentationChunkFindFirstOrThrowArgs} args - Arguments to find a DocumentationChunk
     * @example
     * // Get one DocumentationChunk
     * const documentationChunk = await prisma.documentationChunk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DocumentationChunkFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentationChunkFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentationChunkClient<$Types.GetResult<DocumentationChunkPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DocumentationChunks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentationChunkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentationChunks
     * const documentationChunks = await prisma.documentationChunk.findMany()
     * 
     * // Get first 10 DocumentationChunks
     * const documentationChunks = await prisma.documentationChunk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentationChunkWithIdOnly = await prisma.documentationChunk.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DocumentationChunkFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentationChunkFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DocumentationChunkPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DocumentationChunk.
     * @param {DocumentationChunkCreateArgs} args - Arguments to create a DocumentationChunk.
     * @example
     * // Create one DocumentationChunk
     * const DocumentationChunk = await prisma.documentationChunk.create({
     *   data: {
     *     // ... data to create a DocumentationChunk
     *   }
     * })
     * 
    **/
    create<T extends DocumentationChunkCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentationChunkCreateArgs<ExtArgs>>
    ): Prisma__DocumentationChunkClient<$Types.GetResult<DocumentationChunkPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DocumentationChunks.
     *     @param {DocumentationChunkCreateManyArgs} args - Arguments to create many DocumentationChunks.
     *     @example
     *     // Create many DocumentationChunks
     *     const documentationChunk = await prisma.documentationChunk.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DocumentationChunkCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentationChunkCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DocumentationChunk.
     * @param {DocumentationChunkDeleteArgs} args - Arguments to delete one DocumentationChunk.
     * @example
     * // Delete one DocumentationChunk
     * const DocumentationChunk = await prisma.documentationChunk.delete({
     *   where: {
     *     // ... filter to delete one DocumentationChunk
     *   }
     * })
     * 
    **/
    delete<T extends DocumentationChunkDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentationChunkDeleteArgs<ExtArgs>>
    ): Prisma__DocumentationChunkClient<$Types.GetResult<DocumentationChunkPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DocumentationChunk.
     * @param {DocumentationChunkUpdateArgs} args - Arguments to update one DocumentationChunk.
     * @example
     * // Update one DocumentationChunk
     * const documentationChunk = await prisma.documentationChunk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DocumentationChunkUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentationChunkUpdateArgs<ExtArgs>>
    ): Prisma__DocumentationChunkClient<$Types.GetResult<DocumentationChunkPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DocumentationChunks.
     * @param {DocumentationChunkDeleteManyArgs} args - Arguments to filter DocumentationChunks to delete.
     * @example
     * // Delete a few DocumentationChunks
     * const { count } = await prisma.documentationChunk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DocumentationChunkDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentationChunkDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentationChunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentationChunkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentationChunks
     * const documentationChunk = await prisma.documentationChunk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DocumentationChunkUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentationChunkUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DocumentationChunk.
     * @param {DocumentationChunkUpsertArgs} args - Arguments to update or create a DocumentationChunk.
     * @example
     * // Update or create a DocumentationChunk
     * const documentationChunk = await prisma.documentationChunk.upsert({
     *   create: {
     *     // ... data to create a DocumentationChunk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentationChunk we want to update
     *   }
     * })
    **/
    upsert<T extends DocumentationChunkUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentationChunkUpsertArgs<ExtArgs>>
    ): Prisma__DocumentationChunkClient<$Types.GetResult<DocumentationChunkPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DocumentationChunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentationChunkCountArgs} args - Arguments to filter DocumentationChunks to count.
     * @example
     * // Count the number of DocumentationChunks
     * const count = await prisma.documentationChunk.count({
     *   where: {
     *     // ... the filter for the DocumentationChunks we want to count
     *   }
     * })
    **/
    count<T extends DocumentationChunkCountArgs>(
      args?: Subset<T, DocumentationChunkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentationChunkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentationChunk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentationChunkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentationChunkAggregateArgs>(args: Subset<T, DocumentationChunkAggregateArgs>): Prisma.PrismaPromise<GetDocumentationChunkAggregateType<T>>

    /**
     * Group by DocumentationChunk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentationChunkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentationChunkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentationChunkGroupByArgs['orderBy'] }
        : { orderBy?: DocumentationChunkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentationChunkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentationChunkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentationChunk model
   */
  readonly fields: DocumentationChunkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentationChunk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DocumentationChunkClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    libraryVersion<T extends LibraryVersionArgs<ExtArgs> = {}>(args?: Subset<T, LibraryVersionArgs<ExtArgs>>): Prisma__LibraryVersionClient<$Types.GetResult<LibraryVersionPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    Library<T extends DocumentationChunk$LibraryArgs<ExtArgs> = {}>(args?: Subset<T, DocumentationChunk$LibraryArgs<ExtArgs>>): Prisma__LibraryClient<$Types.GetResult<LibraryPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the DocumentationChunk model
   */ 
  interface DocumentationChunkFieldRefs {
    readonly id: FieldRef<"DocumentationChunk", 'String'>
    readonly libraryVersionId: FieldRef<"DocumentationChunk", 'String'>
    readonly chunkIndex: FieldRef<"DocumentationChunk", 'Int'>
    readonly content: FieldRef<"DocumentationChunk", 'String'>
    readonly contentType: FieldRef<"DocumentationChunk", 'String'>
    readonly sourceUrl: FieldRef<"DocumentationChunk", 'String'>
    readonly tokenCount: FieldRef<"DocumentationChunk", 'Int'>
    readonly embeddingId: FieldRef<"DocumentationChunk", 'String'>
    readonly metadata: FieldRef<"DocumentationChunk", 'Json'>
    readonly createdAt: FieldRef<"DocumentationChunk", 'DateTime'>
    readonly libraryId: FieldRef<"DocumentationChunk", 'String'>
  }
    

  // Custom InputTypes

  /**
   * DocumentationChunk findUnique
   */
  export type DocumentationChunkFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentationChunk
     */
    select?: DocumentationChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentationChunkInclude<ExtArgs> | null
    /**
     * Filter, which DocumentationChunk to fetch.
     */
    where: DocumentationChunkWhereUniqueInput
  }


  /**
   * DocumentationChunk findUniqueOrThrow
   */
  export type DocumentationChunkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentationChunk
     */
    select?: DocumentationChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentationChunkInclude<ExtArgs> | null
    /**
     * Filter, which DocumentationChunk to fetch.
     */
    where: DocumentationChunkWhereUniqueInput
  }


  /**
   * DocumentationChunk findFirst
   */
  export type DocumentationChunkFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentationChunk
     */
    select?: DocumentationChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentationChunkInclude<ExtArgs> | null
    /**
     * Filter, which DocumentationChunk to fetch.
     */
    where?: DocumentationChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentationChunks to fetch.
     */
    orderBy?: DocumentationChunkOrderByWithRelationInput | DocumentationChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentationChunks.
     */
    cursor?: DocumentationChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentationChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentationChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentationChunks.
     */
    distinct?: DocumentationChunkScalarFieldEnum | DocumentationChunkScalarFieldEnum[]
  }


  /**
   * DocumentationChunk findFirstOrThrow
   */
  export type DocumentationChunkFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentationChunk
     */
    select?: DocumentationChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentationChunkInclude<ExtArgs> | null
    /**
     * Filter, which DocumentationChunk to fetch.
     */
    where?: DocumentationChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentationChunks to fetch.
     */
    orderBy?: DocumentationChunkOrderByWithRelationInput | DocumentationChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentationChunks.
     */
    cursor?: DocumentationChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentationChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentationChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentationChunks.
     */
    distinct?: DocumentationChunkScalarFieldEnum | DocumentationChunkScalarFieldEnum[]
  }


  /**
   * DocumentationChunk findMany
   */
  export type DocumentationChunkFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentationChunk
     */
    select?: DocumentationChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentationChunkInclude<ExtArgs> | null
    /**
     * Filter, which DocumentationChunks to fetch.
     */
    where?: DocumentationChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentationChunks to fetch.
     */
    orderBy?: DocumentationChunkOrderByWithRelationInput | DocumentationChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentationChunks.
     */
    cursor?: DocumentationChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentationChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentationChunks.
     */
    skip?: number
    distinct?: DocumentationChunkScalarFieldEnum | DocumentationChunkScalarFieldEnum[]
  }


  /**
   * DocumentationChunk create
   */
  export type DocumentationChunkCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentationChunk
     */
    select?: DocumentationChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentationChunkInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentationChunk.
     */
    data: XOR<DocumentationChunkCreateInput, DocumentationChunkUncheckedCreateInput>
  }


  /**
   * DocumentationChunk createMany
   */
  export type DocumentationChunkCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentationChunks.
     */
    data: DocumentationChunkCreateManyInput | DocumentationChunkCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * DocumentationChunk update
   */
  export type DocumentationChunkUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentationChunk
     */
    select?: DocumentationChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentationChunkInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentationChunk.
     */
    data: XOR<DocumentationChunkUpdateInput, DocumentationChunkUncheckedUpdateInput>
    /**
     * Choose, which DocumentationChunk to update.
     */
    where: DocumentationChunkWhereUniqueInput
  }


  /**
   * DocumentationChunk updateMany
   */
  export type DocumentationChunkUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentationChunks.
     */
    data: XOR<DocumentationChunkUpdateManyMutationInput, DocumentationChunkUncheckedUpdateManyInput>
    /**
     * Filter which DocumentationChunks to update
     */
    where?: DocumentationChunkWhereInput
  }


  /**
   * DocumentationChunk upsert
   */
  export type DocumentationChunkUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentationChunk
     */
    select?: DocumentationChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentationChunkInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentationChunk to update in case it exists.
     */
    where: DocumentationChunkWhereUniqueInput
    /**
     * In case the DocumentationChunk found by the `where` argument doesn't exist, create a new DocumentationChunk with this data.
     */
    create: XOR<DocumentationChunkCreateInput, DocumentationChunkUncheckedCreateInput>
    /**
     * In case the DocumentationChunk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentationChunkUpdateInput, DocumentationChunkUncheckedUpdateInput>
  }


  /**
   * DocumentationChunk delete
   */
  export type DocumentationChunkDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentationChunk
     */
    select?: DocumentationChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentationChunkInclude<ExtArgs> | null
    /**
     * Filter which DocumentationChunk to delete.
     */
    where: DocumentationChunkWhereUniqueInput
  }


  /**
   * DocumentationChunk deleteMany
   */
  export type DocumentationChunkDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentationChunks to delete
     */
    where?: DocumentationChunkWhereInput
  }


  /**
   * DocumentationChunk.Library
   */
  export type DocumentationChunk$LibraryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryInclude<ExtArgs> | null
    where?: LibraryWhereInput
  }


  /**
   * DocumentationChunk without action
   */
  export type DocumentationChunkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentationChunk
     */
    select?: DocumentationChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentationChunkInclude<ExtArgs> | null
  }



  /**
   * Model ApiKey
   */


  export type AggregateApiKey = {
    _count: ApiKeyCountAggregateOutputType | null
    _avg: ApiKeyAvgAggregateOutputType | null
    _sum: ApiKeySumAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  export type ApiKeyAvgAggregateOutputType = {
    quotaDaily: number | null
    quotaMonthly: number | null
    usedDaily: number | null
    usedMonthly: number | null
  }

  export type ApiKeySumAggregateOutputType = {
    quotaDaily: number | null
    quotaMonthly: number | null
    usedDaily: number | null
    usedMonthly: number | null
  }

  export type ApiKeyMinAggregateOutputType = {
    id: string | null
    userId: string | null
    keyHash: string | null
    keyPrefix: string | null
    name: string | null
    tier: string | null
    quotaDaily: number | null
    quotaMonthly: number | null
    usedDaily: number | null
    usedMonthly: number | null
    lastUsedAt: Date | null
    expiresAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    revokedAt: Date | null
  }

  export type ApiKeyMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    keyHash: string | null
    keyPrefix: string | null
    name: string | null
    tier: string | null
    quotaDaily: number | null
    quotaMonthly: number | null
    usedDaily: number | null
    usedMonthly: number | null
    lastUsedAt: Date | null
    expiresAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    revokedAt: Date | null
  }

  export type ApiKeyCountAggregateOutputType = {
    id: number
    userId: number
    keyHash: number
    keyPrefix: number
    name: number
    tier: number
    quotaDaily: number
    quotaMonthly: number
    usedDaily: number
    usedMonthly: number
    lastUsedAt: number
    expiresAt: number
    isActive: number
    permissions: number
    createdAt: number
    updatedAt: number
    revokedAt: number
    _all: number
  }


  export type ApiKeyAvgAggregateInputType = {
    quotaDaily?: true
    quotaMonthly?: true
    usedDaily?: true
    usedMonthly?: true
  }

  export type ApiKeySumAggregateInputType = {
    quotaDaily?: true
    quotaMonthly?: true
    usedDaily?: true
    usedMonthly?: true
  }

  export type ApiKeyMinAggregateInputType = {
    id?: true
    userId?: true
    keyHash?: true
    keyPrefix?: true
    name?: true
    tier?: true
    quotaDaily?: true
    quotaMonthly?: true
    usedDaily?: true
    usedMonthly?: true
    lastUsedAt?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    revokedAt?: true
  }

  export type ApiKeyMaxAggregateInputType = {
    id?: true
    userId?: true
    keyHash?: true
    keyPrefix?: true
    name?: true
    tier?: true
    quotaDaily?: true
    quotaMonthly?: true
    usedDaily?: true
    usedMonthly?: true
    lastUsedAt?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    revokedAt?: true
  }

  export type ApiKeyCountAggregateInputType = {
    id?: true
    userId?: true
    keyHash?: true
    keyPrefix?: true
    name?: true
    tier?: true
    quotaDaily?: true
    quotaMonthly?: true
    usedDaily?: true
    usedMonthly?: true
    lastUsedAt?: true
    expiresAt?: true
    isActive?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
    revokedAt?: true
    _all?: true
  }

  export type ApiKeyAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKey to aggregate.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeys
    **/
    _count?: true | ApiKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiKeyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiKeySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyMaxAggregateInputType
  }

  export type GetApiKeyAggregateType<T extends ApiKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKey[P]>
      : GetScalarType<T[P], AggregateApiKey[P]>
  }




  export type ApiKeyGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithAggregationInput | ApiKeyOrderByWithAggregationInput[]
    by: ApiKeyScalarFieldEnum[] | ApiKeyScalarFieldEnum
    having?: ApiKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyCountAggregateInputType | true
    _avg?: ApiKeyAvgAggregateInputType
    _sum?: ApiKeySumAggregateInputType
    _min?: ApiKeyMinAggregateInputType
    _max?: ApiKeyMaxAggregateInputType
  }


  export type ApiKeyGroupByOutputType = {
    id: string
    userId: string
    keyHash: string
    keyPrefix: string
    name: string | null
    tier: string
    quotaDaily: number
    quotaMonthly: number
    usedDaily: number
    usedMonthly: number
    lastUsedAt: Date | null
    expiresAt: Date | null
    isActive: boolean
    permissions: JsonValue
    createdAt: Date
    updatedAt: Date
    revokedAt: Date | null
    _count: ApiKeyCountAggregateOutputType | null
    _avg: ApiKeyAvgAggregateOutputType | null
    _sum: ApiKeySumAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  type GetApiKeyGroupByPayload<T extends ApiKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    keyHash?: boolean
    keyPrefix?: boolean
    name?: boolean
    tier?: boolean
    quotaDaily?: boolean
    quotaMonthly?: boolean
    usedDaily?: boolean
    usedMonthly?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    revokedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
    usageLogs?: boolean | ApiKey$usageLogsArgs<ExtArgs>
    _count?: boolean | ApiKeyCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectScalar = {
    id?: boolean
    userId?: boolean
    keyHash?: boolean
    keyPrefix?: boolean
    name?: boolean
    tier?: boolean
    quotaDaily?: boolean
    quotaMonthly?: boolean
    usedDaily?: boolean
    usedMonthly?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    revokedAt?: boolean
  }

  export type ApiKeyInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    usageLogs?: boolean | ApiKey$usageLogsArgs<ExtArgs>
    _count?: boolean | ApiKeyCountOutputTypeArgs<ExtArgs>
  }


  type ApiKeyGetPayload<S extends boolean | null | undefined | ApiKeyArgs> = $Types.GetResult<ApiKeyPayload, S>

  type ApiKeyCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ApiKeyFindManyArgs, 'select' | 'include'> & {
      select?: ApiKeyCountAggregateInputType | true
    }

  export interface ApiKeyDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKey'], meta: { name: 'ApiKey' } }
    /**
     * Find zero or one ApiKey that matches the filter.
     * @param {ApiKeyFindUniqueArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ApiKeyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ApiKeyFindUniqueArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Types.GetResult<ApiKeyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ApiKey that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ApiKeyFindUniqueOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ApiKeyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ApiKeyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Types.GetResult<ApiKeyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ApiKeyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ApiKeyFindFirstArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Types.GetResult<ApiKeyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ApiKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ApiKeyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ApiKeyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Types.GetResult<ApiKeyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeys
     * const apiKeys = await prisma.apiKey.findMany()
     * 
     * // Get first 10 ApiKeys
     * const apiKeys = await prisma.apiKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ApiKeyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ApiKeyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ApiKeyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ApiKey.
     * @param {ApiKeyCreateArgs} args - Arguments to create a ApiKey.
     * @example
     * // Create one ApiKey
     * const ApiKey = await prisma.apiKey.create({
     *   data: {
     *     // ... data to create a ApiKey
     *   }
     * })
     * 
    **/
    create<T extends ApiKeyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ApiKeyCreateArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Types.GetResult<ApiKeyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ApiKeys.
     *     @param {ApiKeyCreateManyArgs} args - Arguments to create many ApiKeys.
     *     @example
     *     // Create many ApiKeys
     *     const apiKey = await prisma.apiKey.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ApiKeyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ApiKeyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ApiKey.
     * @param {ApiKeyDeleteArgs} args - Arguments to delete one ApiKey.
     * @example
     * // Delete one ApiKey
     * const ApiKey = await prisma.apiKey.delete({
     *   where: {
     *     // ... filter to delete one ApiKey
     *   }
     * })
     * 
    **/
    delete<T extends ApiKeyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ApiKeyDeleteArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Types.GetResult<ApiKeyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ApiKey.
     * @param {ApiKeyUpdateArgs} args - Arguments to update one ApiKey.
     * @example
     * // Update one ApiKey
     * const apiKey = await prisma.apiKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ApiKeyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ApiKeyUpdateArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Types.GetResult<ApiKeyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ApiKeys.
     * @param {ApiKeyDeleteManyArgs} args - Arguments to filter ApiKeys to delete.
     * @example
     * // Delete a few ApiKeys
     * const { count } = await prisma.apiKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ApiKeyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ApiKeyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ApiKeyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ApiKeyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApiKey.
     * @param {ApiKeyUpsertArgs} args - Arguments to update or create a ApiKey.
     * @example
     * // Update or create a ApiKey
     * const apiKey = await prisma.apiKey.upsert({
     *   create: {
     *     // ... data to create a ApiKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKey we want to update
     *   }
     * })
    **/
    upsert<T extends ApiKeyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ApiKeyUpsertArgs<ExtArgs>>
    ): Prisma__ApiKeyClient<$Types.GetResult<ApiKeyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyCountArgs} args - Arguments to filter ApiKeys to count.
     * @example
     * // Count the number of ApiKeys
     * const count = await prisma.apiKey.count({
     *   where: {
     *     // ... the filter for the ApiKeys we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyCountArgs>(
      args?: Subset<T, ApiKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyAggregateArgs>(args: Subset<T, ApiKeyAggregateArgs>): Prisma.PrismaPromise<GetApiKeyAggregateType<T>>

    /**
     * Group by ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKey model
   */
  readonly fields: ApiKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ApiKeyClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    usageLogs<T extends ApiKey$usageLogsArgs<ExtArgs> = {}>(args?: Subset<T, ApiKey$usageLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UsageLogPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the ApiKey model
   */ 
  interface ApiKeyFieldRefs {
    readonly id: FieldRef<"ApiKey", 'String'>
    readonly userId: FieldRef<"ApiKey", 'String'>
    readonly keyHash: FieldRef<"ApiKey", 'String'>
    readonly keyPrefix: FieldRef<"ApiKey", 'String'>
    readonly name: FieldRef<"ApiKey", 'String'>
    readonly tier: FieldRef<"ApiKey", 'String'>
    readonly quotaDaily: FieldRef<"ApiKey", 'Int'>
    readonly quotaMonthly: FieldRef<"ApiKey", 'Int'>
    readonly usedDaily: FieldRef<"ApiKey", 'Int'>
    readonly usedMonthly: FieldRef<"ApiKey", 'Int'>
    readonly lastUsedAt: FieldRef<"ApiKey", 'DateTime'>
    readonly expiresAt: FieldRef<"ApiKey", 'DateTime'>
    readonly isActive: FieldRef<"ApiKey", 'Boolean'>
    readonly permissions: FieldRef<"ApiKey", 'Json'>
    readonly createdAt: FieldRef<"ApiKey", 'DateTime'>
    readonly updatedAt: FieldRef<"ApiKey", 'DateTime'>
    readonly revokedAt: FieldRef<"ApiKey", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ApiKey findUnique
   */
  export type ApiKeyFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }


  /**
   * ApiKey findUniqueOrThrow
   */
  export type ApiKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }


  /**
   * ApiKey findFirst
   */
  export type ApiKeyFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }


  /**
   * ApiKey findFirstOrThrow
   */
  export type ApiKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }


  /**
   * ApiKey findMany
   */
  export type ApiKeyFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeys to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }


  /**
   * ApiKey create
   */
  export type ApiKeyCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKey.
     */
    data: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
  }


  /**
   * ApiKey createMany
   */
  export type ApiKeyCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ApiKey update
   */
  export type ApiKeyUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKey.
     */
    data: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
    /**
     * Choose, which ApiKey to update.
     */
    where: ApiKeyWhereUniqueInput
  }


  /**
   * ApiKey updateMany
   */
  export type ApiKeyUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
  }


  /**
   * ApiKey upsert
   */
  export type ApiKeyUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKey to update in case it exists.
     */
    where: ApiKeyWhereUniqueInput
    /**
     * In case the ApiKey found by the `where` argument doesn't exist, create a new ApiKey with this data.
     */
    create: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
    /**
     * In case the ApiKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
  }


  /**
   * ApiKey delete
   */
  export type ApiKeyDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter which ApiKey to delete.
     */
    where: ApiKeyWhereUniqueInput
  }


  /**
   * ApiKey deleteMany
   */
  export type ApiKeyDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeys to delete
     */
    where?: ApiKeyWhereInput
  }


  /**
   * ApiKey.usageLogs
   */
  export type ApiKey$usageLogsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsageLogInclude<ExtArgs> | null
    where?: UsageLogWhereInput
    orderBy?: UsageLogOrderByWithRelationInput | UsageLogOrderByWithRelationInput[]
    cursor?: UsageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsageLogScalarFieldEnum | UsageLogScalarFieldEnum[]
  }


  /**
   * ApiKey without action
   */
  export type ApiKeyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApiKeyInclude<ExtArgs> | null
  }



  /**
   * Model UsageLog
   */


  export type AggregateUsageLog = {
    _count: UsageLogCountAggregateOutputType | null
    _avg: UsageLogAvgAggregateOutputType | null
    _sum: UsageLogSumAggregateOutputType | null
    _min: UsageLogMinAggregateOutputType | null
    _max: UsageLogMaxAggregateOutputType | null
  }

  export type UsageLogAvgAggregateOutputType = {
    tokensReturned: number | null
    responseTimeMs: number | null
  }

  export type UsageLogSumAggregateOutputType = {
    tokensReturned: number | null
    responseTimeMs: number | null
  }

  export type UsageLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    apiKeyId: string | null
    libraryId: string | null
    toolName: string | null
    query: string | null
    tokensReturned: number | null
    responseTimeMs: number | null
    createdAt: Date | null
  }

  export type UsageLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    apiKeyId: string | null
    libraryId: string | null
    toolName: string | null
    query: string | null
    tokensReturned: number | null
    responseTimeMs: number | null
    createdAt: Date | null
  }

  export type UsageLogCountAggregateOutputType = {
    id: number
    userId: number
    apiKeyId: number
    libraryId: number
    toolName: number
    query: number
    tokensReturned: number
    responseTimeMs: number
    createdAt: number
    _all: number
  }


  export type UsageLogAvgAggregateInputType = {
    tokensReturned?: true
    responseTimeMs?: true
  }

  export type UsageLogSumAggregateInputType = {
    tokensReturned?: true
    responseTimeMs?: true
  }

  export type UsageLogMinAggregateInputType = {
    id?: true
    userId?: true
    apiKeyId?: true
    libraryId?: true
    toolName?: true
    query?: true
    tokensReturned?: true
    responseTimeMs?: true
    createdAt?: true
  }

  export type UsageLogMaxAggregateInputType = {
    id?: true
    userId?: true
    apiKeyId?: true
    libraryId?: true
    toolName?: true
    query?: true
    tokensReturned?: true
    responseTimeMs?: true
    createdAt?: true
  }

  export type UsageLogCountAggregateInputType = {
    id?: true
    userId?: true
    apiKeyId?: true
    libraryId?: true
    toolName?: true
    query?: true
    tokensReturned?: true
    responseTimeMs?: true
    createdAt?: true
    _all?: true
  }

  export type UsageLogAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageLog to aggregate.
     */
    where?: UsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageLogs to fetch.
     */
    orderBy?: UsageLogOrderByWithRelationInput | UsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsageLogs
    **/
    _count?: true | UsageLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsageLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsageLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsageLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsageLogMaxAggregateInputType
  }

  export type GetUsageLogAggregateType<T extends UsageLogAggregateArgs> = {
        [P in keyof T & keyof AggregateUsageLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsageLog[P]>
      : GetScalarType<T[P], AggregateUsageLog[P]>
  }




  export type UsageLogGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UsageLogWhereInput
    orderBy?: UsageLogOrderByWithAggregationInput | UsageLogOrderByWithAggregationInput[]
    by: UsageLogScalarFieldEnum[] | UsageLogScalarFieldEnum
    having?: UsageLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsageLogCountAggregateInputType | true
    _avg?: UsageLogAvgAggregateInputType
    _sum?: UsageLogSumAggregateInputType
    _min?: UsageLogMinAggregateInputType
    _max?: UsageLogMaxAggregateInputType
  }


  export type UsageLogGroupByOutputType = {
    id: string
    userId: string | null
    apiKeyId: string | null
    libraryId: string | null
    toolName: string
    query: string | null
    tokensReturned: number | null
    responseTimeMs: number | null
    createdAt: Date
    _count: UsageLogCountAggregateOutputType | null
    _avg: UsageLogAvgAggregateOutputType | null
    _sum: UsageLogSumAggregateOutputType | null
    _min: UsageLogMinAggregateOutputType | null
    _max: UsageLogMaxAggregateOutputType | null
  }

  type GetUsageLogGroupByPayload<T extends UsageLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsageLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsageLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsageLogGroupByOutputType[P]>
            : GetScalarType<T[P], UsageLogGroupByOutputType[P]>
        }
      >
    >


  export type UsageLogSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    apiKeyId?: boolean
    libraryId?: boolean
    toolName?: boolean
    query?: boolean
    tokensReturned?: boolean
    responseTimeMs?: boolean
    createdAt?: boolean
    user?: boolean | UsageLog$userArgs<ExtArgs>
    apiKey?: boolean | UsageLog$apiKeyArgs<ExtArgs>
    library?: boolean | UsageLog$libraryArgs<ExtArgs>
  }, ExtArgs["result"]["usageLog"]>

  export type UsageLogSelectScalar = {
    id?: boolean
    userId?: boolean
    apiKeyId?: boolean
    libraryId?: boolean
    toolName?: boolean
    query?: boolean
    tokensReturned?: boolean
    responseTimeMs?: boolean
    createdAt?: boolean
  }

  export type UsageLogInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UsageLog$userArgs<ExtArgs>
    apiKey?: boolean | UsageLog$apiKeyArgs<ExtArgs>
    library?: boolean | UsageLog$libraryArgs<ExtArgs>
  }


  type UsageLogGetPayload<S extends boolean | null | undefined | UsageLogArgs> = $Types.GetResult<UsageLogPayload, S>

  type UsageLogCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UsageLogFindManyArgs, 'select' | 'include'> & {
      select?: UsageLogCountAggregateInputType | true
    }

  export interface UsageLogDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsageLog'], meta: { name: 'UsageLog' } }
    /**
     * Find zero or one UsageLog that matches the filter.
     * @param {UsageLogFindUniqueArgs} args - Arguments to find a UsageLog
     * @example
     * // Get one UsageLog
     * const usageLog = await prisma.usageLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsageLogFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UsageLogFindUniqueArgs<ExtArgs>>
    ): Prisma__UsageLogClient<$Types.GetResult<UsageLogPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UsageLog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UsageLogFindUniqueOrThrowArgs} args - Arguments to find a UsageLog
     * @example
     * // Get one UsageLog
     * const usageLog = await prisma.usageLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UsageLogFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsageLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UsageLogClient<$Types.GetResult<UsageLogPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UsageLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogFindFirstArgs} args - Arguments to find a UsageLog
     * @example
     * // Get one UsageLog
     * const usageLog = await prisma.usageLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsageLogFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UsageLogFindFirstArgs<ExtArgs>>
    ): Prisma__UsageLogClient<$Types.GetResult<UsageLogPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UsageLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogFindFirstOrThrowArgs} args - Arguments to find a UsageLog
     * @example
     * // Get one UsageLog
     * const usageLog = await prisma.usageLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UsageLogFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsageLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UsageLogClient<$Types.GetResult<UsageLogPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UsageLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsageLogs
     * const usageLogs = await prisma.usageLog.findMany()
     * 
     * // Get first 10 UsageLogs
     * const usageLogs = await prisma.usageLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usageLogWithIdOnly = await prisma.usageLog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UsageLogFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsageLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UsageLogPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UsageLog.
     * @param {UsageLogCreateArgs} args - Arguments to create a UsageLog.
     * @example
     * // Create one UsageLog
     * const UsageLog = await prisma.usageLog.create({
     *   data: {
     *     // ... data to create a UsageLog
     *   }
     * })
     * 
    **/
    create<T extends UsageLogCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UsageLogCreateArgs<ExtArgs>>
    ): Prisma__UsageLogClient<$Types.GetResult<UsageLogPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UsageLogs.
     *     @param {UsageLogCreateManyArgs} args - Arguments to create many UsageLogs.
     *     @example
     *     // Create many UsageLogs
     *     const usageLog = await prisma.usageLog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UsageLogCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsageLogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UsageLog.
     * @param {UsageLogDeleteArgs} args - Arguments to delete one UsageLog.
     * @example
     * // Delete one UsageLog
     * const UsageLog = await prisma.usageLog.delete({
     *   where: {
     *     // ... filter to delete one UsageLog
     *   }
     * })
     * 
    **/
    delete<T extends UsageLogDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UsageLogDeleteArgs<ExtArgs>>
    ): Prisma__UsageLogClient<$Types.GetResult<UsageLogPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UsageLog.
     * @param {UsageLogUpdateArgs} args - Arguments to update one UsageLog.
     * @example
     * // Update one UsageLog
     * const usageLog = await prisma.usageLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsageLogUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UsageLogUpdateArgs<ExtArgs>>
    ): Prisma__UsageLogClient<$Types.GetResult<UsageLogPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UsageLogs.
     * @param {UsageLogDeleteManyArgs} args - Arguments to filter UsageLogs to delete.
     * @example
     * // Delete a few UsageLogs
     * const { count } = await prisma.usageLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsageLogDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsageLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsageLogs
     * const usageLog = await prisma.usageLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsageLogUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UsageLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsageLog.
     * @param {UsageLogUpsertArgs} args - Arguments to update or create a UsageLog.
     * @example
     * // Update or create a UsageLog
     * const usageLog = await prisma.usageLog.upsert({
     *   create: {
     *     // ... data to create a UsageLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsageLog we want to update
     *   }
     * })
    **/
    upsert<T extends UsageLogUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UsageLogUpsertArgs<ExtArgs>>
    ): Prisma__UsageLogClient<$Types.GetResult<UsageLogPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogCountArgs} args - Arguments to filter UsageLogs to count.
     * @example
     * // Count the number of UsageLogs
     * const count = await prisma.usageLog.count({
     *   where: {
     *     // ... the filter for the UsageLogs we want to count
     *   }
     * })
    **/
    count<T extends UsageLogCountArgs>(
      args?: Subset<T, UsageLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsageLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsageLogAggregateArgs>(args: Subset<T, UsageLogAggregateArgs>): Prisma.PrismaPromise<GetUsageLogAggregateType<T>>

    /**
     * Group by UsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsageLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsageLogGroupByArgs['orderBy'] }
        : { orderBy?: UsageLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsageLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsageLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsageLog model
   */
  readonly fields: UsageLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsageLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UsageLogClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UsageLog$userArgs<ExtArgs> = {}>(args?: Subset<T, UsageLog$userArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    apiKey<T extends UsageLog$apiKeyArgs<ExtArgs> = {}>(args?: Subset<T, UsageLog$apiKeyArgs<ExtArgs>>): Prisma__ApiKeyClient<$Types.GetResult<ApiKeyPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    library<T extends UsageLog$libraryArgs<ExtArgs> = {}>(args?: Subset<T, UsageLog$libraryArgs<ExtArgs>>): Prisma__LibraryClient<$Types.GetResult<LibraryPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the UsageLog model
   */ 
  interface UsageLogFieldRefs {
    readonly id: FieldRef<"UsageLog", 'String'>
    readonly userId: FieldRef<"UsageLog", 'String'>
    readonly apiKeyId: FieldRef<"UsageLog", 'String'>
    readonly libraryId: FieldRef<"UsageLog", 'String'>
    readonly toolName: FieldRef<"UsageLog", 'String'>
    readonly query: FieldRef<"UsageLog", 'String'>
    readonly tokensReturned: FieldRef<"UsageLog", 'Int'>
    readonly responseTimeMs: FieldRef<"UsageLog", 'Int'>
    readonly createdAt: FieldRef<"UsageLog", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * UsageLog findUnique
   */
  export type UsageLogFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsageLogInclude<ExtArgs> | null
    /**
     * Filter, which UsageLog to fetch.
     */
    where: UsageLogWhereUniqueInput
  }


  /**
   * UsageLog findUniqueOrThrow
   */
  export type UsageLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsageLogInclude<ExtArgs> | null
    /**
     * Filter, which UsageLog to fetch.
     */
    where: UsageLogWhereUniqueInput
  }


  /**
   * UsageLog findFirst
   */
  export type UsageLogFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsageLogInclude<ExtArgs> | null
    /**
     * Filter, which UsageLog to fetch.
     */
    where?: UsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageLogs to fetch.
     */
    orderBy?: UsageLogOrderByWithRelationInput | UsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageLogs.
     */
    cursor?: UsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageLogs.
     */
    distinct?: UsageLogScalarFieldEnum | UsageLogScalarFieldEnum[]
  }


  /**
   * UsageLog findFirstOrThrow
   */
  export type UsageLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsageLogInclude<ExtArgs> | null
    /**
     * Filter, which UsageLog to fetch.
     */
    where?: UsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageLogs to fetch.
     */
    orderBy?: UsageLogOrderByWithRelationInput | UsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageLogs.
     */
    cursor?: UsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageLogs.
     */
    distinct?: UsageLogScalarFieldEnum | UsageLogScalarFieldEnum[]
  }


  /**
   * UsageLog findMany
   */
  export type UsageLogFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsageLogInclude<ExtArgs> | null
    /**
     * Filter, which UsageLogs to fetch.
     */
    where?: UsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageLogs to fetch.
     */
    orderBy?: UsageLogOrderByWithRelationInput | UsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsageLogs.
     */
    cursor?: UsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageLogs.
     */
    skip?: number
    distinct?: UsageLogScalarFieldEnum | UsageLogScalarFieldEnum[]
  }


  /**
   * UsageLog create
   */
  export type UsageLogCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsageLogInclude<ExtArgs> | null
    /**
     * The data needed to create a UsageLog.
     */
    data: XOR<UsageLogCreateInput, UsageLogUncheckedCreateInput>
  }


  /**
   * UsageLog createMany
   */
  export type UsageLogCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsageLogs.
     */
    data: UsageLogCreateManyInput | UsageLogCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UsageLog update
   */
  export type UsageLogUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsageLogInclude<ExtArgs> | null
    /**
     * The data needed to update a UsageLog.
     */
    data: XOR<UsageLogUpdateInput, UsageLogUncheckedUpdateInput>
    /**
     * Choose, which UsageLog to update.
     */
    where: UsageLogWhereUniqueInput
  }


  /**
   * UsageLog updateMany
   */
  export type UsageLogUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsageLogs.
     */
    data: XOR<UsageLogUpdateManyMutationInput, UsageLogUncheckedUpdateManyInput>
    /**
     * Filter which UsageLogs to update
     */
    where?: UsageLogWhereInput
  }


  /**
   * UsageLog upsert
   */
  export type UsageLogUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsageLogInclude<ExtArgs> | null
    /**
     * The filter to search for the UsageLog to update in case it exists.
     */
    where: UsageLogWhereUniqueInput
    /**
     * In case the UsageLog found by the `where` argument doesn't exist, create a new UsageLog with this data.
     */
    create: XOR<UsageLogCreateInput, UsageLogUncheckedCreateInput>
    /**
     * In case the UsageLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsageLogUpdateInput, UsageLogUncheckedUpdateInput>
  }


  /**
   * UsageLog delete
   */
  export type UsageLogDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsageLogInclude<ExtArgs> | null
    /**
     * Filter which UsageLog to delete.
     */
    where: UsageLogWhereUniqueInput
  }


  /**
   * UsageLog deleteMany
   */
  export type UsageLogDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageLogs to delete
     */
    where?: UsageLogWhereInput
  }


  /**
   * UsageLog.user
   */
  export type UsageLog$userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * UsageLog.apiKey
   */
  export type UsageLog$apiKeyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApiKeyInclude<ExtArgs> | null
    where?: ApiKeyWhereInput
  }


  /**
   * UsageLog.library
   */
  export type UsageLog$libraryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Library
     */
    select?: LibrarySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LibraryInclude<ExtArgs> | null
    where?: LibraryWhereInput
  }


  /**
   * UsageLog without action
   */
  export type UsageLogArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageLog
     */
    select?: UsageLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsageLogInclude<ExtArgs> | null
  }



  /**
   * Model MCPConfiguration
   */


  export type AggregateMCPConfiguration = {
    _count: MCPConfigurationCountAggregateOutputType | null
    _min: MCPConfigurationMinAggregateOutputType | null
    _max: MCPConfigurationMaxAggregateOutputType | null
  }

  export type MCPConfigurationMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: ConfigStatus | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MCPConfigurationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: ConfigStatus | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MCPConfigurationCountAggregateOutputType = {
    id: number
    name: number
    description: number
    configData: number
    status: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MCPConfigurationMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MCPConfigurationMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MCPConfigurationCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    configData?: true
    status?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MCPConfigurationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which MCPConfiguration to aggregate.
     */
    where?: MCPConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCPConfigurations to fetch.
     */
    orderBy?: MCPConfigurationOrderByWithRelationInput | MCPConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MCPConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCPConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCPConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MCPConfigurations
    **/
    _count?: true | MCPConfigurationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MCPConfigurationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MCPConfigurationMaxAggregateInputType
  }

  export type GetMCPConfigurationAggregateType<T extends MCPConfigurationAggregateArgs> = {
        [P in keyof T & keyof AggregateMCPConfiguration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMCPConfiguration[P]>
      : GetScalarType<T[P], AggregateMCPConfiguration[P]>
  }




  export type MCPConfigurationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MCPConfigurationWhereInput
    orderBy?: MCPConfigurationOrderByWithAggregationInput | MCPConfigurationOrderByWithAggregationInput[]
    by: MCPConfigurationScalarFieldEnum[] | MCPConfigurationScalarFieldEnum
    having?: MCPConfigurationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MCPConfigurationCountAggregateInputType | true
    _min?: MCPConfigurationMinAggregateInputType
    _max?: MCPConfigurationMaxAggregateInputType
  }


  export type MCPConfigurationGroupByOutputType = {
    id: string
    name: string
    description: string | null
    configData: JsonValue
    status: ConfigStatus
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: MCPConfigurationCountAggregateOutputType | null
    _min: MCPConfigurationMinAggregateOutputType | null
    _max: MCPConfigurationMaxAggregateOutputType | null
  }

  type GetMCPConfigurationGroupByPayload<T extends MCPConfigurationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MCPConfigurationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MCPConfigurationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MCPConfigurationGroupByOutputType[P]>
            : GetScalarType<T[P], MCPConfigurationGroupByOutputType[P]>
        }
      >
    >


  export type MCPConfigurationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    configData?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["mCPConfiguration"]>

  export type MCPConfigurationSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    configData?: boolean
    status?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MCPConfigurationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type MCPConfigurationGetPayload<S extends boolean | null | undefined | MCPConfigurationArgs> = $Types.GetResult<MCPConfigurationPayload, S>

  type MCPConfigurationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<MCPConfigurationFindManyArgs, 'select' | 'include'> & {
      select?: MCPConfigurationCountAggregateInputType | true
    }

  export interface MCPConfigurationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MCPConfiguration'], meta: { name: 'MCPConfiguration' } }
    /**
     * Find zero or one MCPConfiguration that matches the filter.
     * @param {MCPConfigurationFindUniqueArgs} args - Arguments to find a MCPConfiguration
     * @example
     * // Get one MCPConfiguration
     * const mCPConfiguration = await prisma.mCPConfiguration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MCPConfigurationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MCPConfigurationFindUniqueArgs<ExtArgs>>
    ): Prisma__MCPConfigurationClient<$Types.GetResult<MCPConfigurationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MCPConfiguration that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MCPConfigurationFindUniqueOrThrowArgs} args - Arguments to find a MCPConfiguration
     * @example
     * // Get one MCPConfiguration
     * const mCPConfiguration = await prisma.mCPConfiguration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MCPConfigurationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MCPConfigurationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MCPConfigurationClient<$Types.GetResult<MCPConfigurationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MCPConfiguration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPConfigurationFindFirstArgs} args - Arguments to find a MCPConfiguration
     * @example
     * // Get one MCPConfiguration
     * const mCPConfiguration = await prisma.mCPConfiguration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MCPConfigurationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MCPConfigurationFindFirstArgs<ExtArgs>>
    ): Prisma__MCPConfigurationClient<$Types.GetResult<MCPConfigurationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MCPConfiguration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPConfigurationFindFirstOrThrowArgs} args - Arguments to find a MCPConfiguration
     * @example
     * // Get one MCPConfiguration
     * const mCPConfiguration = await prisma.mCPConfiguration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MCPConfigurationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MCPConfigurationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MCPConfigurationClient<$Types.GetResult<MCPConfigurationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MCPConfigurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPConfigurationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MCPConfigurations
     * const mCPConfigurations = await prisma.mCPConfiguration.findMany()
     * 
     * // Get first 10 MCPConfigurations
     * const mCPConfigurations = await prisma.mCPConfiguration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mCPConfigurationWithIdOnly = await prisma.mCPConfiguration.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MCPConfigurationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MCPConfigurationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<MCPConfigurationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MCPConfiguration.
     * @param {MCPConfigurationCreateArgs} args - Arguments to create a MCPConfiguration.
     * @example
     * // Create one MCPConfiguration
     * const MCPConfiguration = await prisma.mCPConfiguration.create({
     *   data: {
     *     // ... data to create a MCPConfiguration
     *   }
     * })
     * 
    **/
    create<T extends MCPConfigurationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MCPConfigurationCreateArgs<ExtArgs>>
    ): Prisma__MCPConfigurationClient<$Types.GetResult<MCPConfigurationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MCPConfigurations.
     *     @param {MCPConfigurationCreateManyArgs} args - Arguments to create many MCPConfigurations.
     *     @example
     *     // Create many MCPConfigurations
     *     const mCPConfiguration = await prisma.mCPConfiguration.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MCPConfigurationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MCPConfigurationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MCPConfiguration.
     * @param {MCPConfigurationDeleteArgs} args - Arguments to delete one MCPConfiguration.
     * @example
     * // Delete one MCPConfiguration
     * const MCPConfiguration = await prisma.mCPConfiguration.delete({
     *   where: {
     *     // ... filter to delete one MCPConfiguration
     *   }
     * })
     * 
    **/
    delete<T extends MCPConfigurationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MCPConfigurationDeleteArgs<ExtArgs>>
    ): Prisma__MCPConfigurationClient<$Types.GetResult<MCPConfigurationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MCPConfiguration.
     * @param {MCPConfigurationUpdateArgs} args - Arguments to update one MCPConfiguration.
     * @example
     * // Update one MCPConfiguration
     * const mCPConfiguration = await prisma.mCPConfiguration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MCPConfigurationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MCPConfigurationUpdateArgs<ExtArgs>>
    ): Prisma__MCPConfigurationClient<$Types.GetResult<MCPConfigurationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MCPConfigurations.
     * @param {MCPConfigurationDeleteManyArgs} args - Arguments to filter MCPConfigurations to delete.
     * @example
     * // Delete a few MCPConfigurations
     * const { count } = await prisma.mCPConfiguration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MCPConfigurationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MCPConfigurationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MCPConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPConfigurationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MCPConfigurations
     * const mCPConfiguration = await prisma.mCPConfiguration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MCPConfigurationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MCPConfigurationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MCPConfiguration.
     * @param {MCPConfigurationUpsertArgs} args - Arguments to update or create a MCPConfiguration.
     * @example
     * // Update or create a MCPConfiguration
     * const mCPConfiguration = await prisma.mCPConfiguration.upsert({
     *   create: {
     *     // ... data to create a MCPConfiguration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MCPConfiguration we want to update
     *   }
     * })
    **/
    upsert<T extends MCPConfigurationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MCPConfigurationUpsertArgs<ExtArgs>>
    ): Prisma__MCPConfigurationClient<$Types.GetResult<MCPConfigurationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MCPConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPConfigurationCountArgs} args - Arguments to filter MCPConfigurations to count.
     * @example
     * // Count the number of MCPConfigurations
     * const count = await prisma.mCPConfiguration.count({
     *   where: {
     *     // ... the filter for the MCPConfigurations we want to count
     *   }
     * })
    **/
    count<T extends MCPConfigurationCountArgs>(
      args?: Subset<T, MCPConfigurationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MCPConfigurationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MCPConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPConfigurationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MCPConfigurationAggregateArgs>(args: Subset<T, MCPConfigurationAggregateArgs>): Prisma.PrismaPromise<GetMCPConfigurationAggregateType<T>>

    /**
     * Group by MCPConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MCPConfigurationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MCPConfigurationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MCPConfigurationGroupByArgs['orderBy'] }
        : { orderBy?: MCPConfigurationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MCPConfigurationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMCPConfigurationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MCPConfiguration model
   */
  readonly fields: MCPConfigurationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MCPConfiguration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MCPConfigurationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the MCPConfiguration model
   */ 
  interface MCPConfigurationFieldRefs {
    readonly id: FieldRef<"MCPConfiguration", 'String'>
    readonly name: FieldRef<"MCPConfiguration", 'String'>
    readonly description: FieldRef<"MCPConfiguration", 'String'>
    readonly configData: FieldRef<"MCPConfiguration", 'Json'>
    readonly status: FieldRef<"MCPConfiguration", 'ConfigStatus'>
    readonly userId: FieldRef<"MCPConfiguration", 'String'>
    readonly createdAt: FieldRef<"MCPConfiguration", 'DateTime'>
    readonly updatedAt: FieldRef<"MCPConfiguration", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * MCPConfiguration findUnique
   */
  export type MCPConfigurationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPConfiguration
     */
    select?: MCPConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCPConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which MCPConfiguration to fetch.
     */
    where: MCPConfigurationWhereUniqueInput
  }


  /**
   * MCPConfiguration findUniqueOrThrow
   */
  export type MCPConfigurationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPConfiguration
     */
    select?: MCPConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCPConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which MCPConfiguration to fetch.
     */
    where: MCPConfigurationWhereUniqueInput
  }


  /**
   * MCPConfiguration findFirst
   */
  export type MCPConfigurationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPConfiguration
     */
    select?: MCPConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCPConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which MCPConfiguration to fetch.
     */
    where?: MCPConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCPConfigurations to fetch.
     */
    orderBy?: MCPConfigurationOrderByWithRelationInput | MCPConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MCPConfigurations.
     */
    cursor?: MCPConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCPConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCPConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MCPConfigurations.
     */
    distinct?: MCPConfigurationScalarFieldEnum | MCPConfigurationScalarFieldEnum[]
  }


  /**
   * MCPConfiguration findFirstOrThrow
   */
  export type MCPConfigurationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPConfiguration
     */
    select?: MCPConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCPConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which MCPConfiguration to fetch.
     */
    where?: MCPConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCPConfigurations to fetch.
     */
    orderBy?: MCPConfigurationOrderByWithRelationInput | MCPConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MCPConfigurations.
     */
    cursor?: MCPConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCPConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCPConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MCPConfigurations.
     */
    distinct?: MCPConfigurationScalarFieldEnum | MCPConfigurationScalarFieldEnum[]
  }


  /**
   * MCPConfiguration findMany
   */
  export type MCPConfigurationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPConfiguration
     */
    select?: MCPConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCPConfigurationInclude<ExtArgs> | null
    /**
     * Filter, which MCPConfigurations to fetch.
     */
    where?: MCPConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MCPConfigurations to fetch.
     */
    orderBy?: MCPConfigurationOrderByWithRelationInput | MCPConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MCPConfigurations.
     */
    cursor?: MCPConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MCPConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MCPConfigurations.
     */
    skip?: number
    distinct?: MCPConfigurationScalarFieldEnum | MCPConfigurationScalarFieldEnum[]
  }


  /**
   * MCPConfiguration create
   */
  export type MCPConfigurationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPConfiguration
     */
    select?: MCPConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCPConfigurationInclude<ExtArgs> | null
    /**
     * The data needed to create a MCPConfiguration.
     */
    data: XOR<MCPConfigurationCreateInput, MCPConfigurationUncheckedCreateInput>
  }


  /**
   * MCPConfiguration createMany
   */
  export type MCPConfigurationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MCPConfigurations.
     */
    data: MCPConfigurationCreateManyInput | MCPConfigurationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MCPConfiguration update
   */
  export type MCPConfigurationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPConfiguration
     */
    select?: MCPConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCPConfigurationInclude<ExtArgs> | null
    /**
     * The data needed to update a MCPConfiguration.
     */
    data: XOR<MCPConfigurationUpdateInput, MCPConfigurationUncheckedUpdateInput>
    /**
     * Choose, which MCPConfiguration to update.
     */
    where: MCPConfigurationWhereUniqueInput
  }


  /**
   * MCPConfiguration updateMany
   */
  export type MCPConfigurationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MCPConfigurations.
     */
    data: XOR<MCPConfigurationUpdateManyMutationInput, MCPConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which MCPConfigurations to update
     */
    where?: MCPConfigurationWhereInput
  }


  /**
   * MCPConfiguration upsert
   */
  export type MCPConfigurationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPConfiguration
     */
    select?: MCPConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCPConfigurationInclude<ExtArgs> | null
    /**
     * The filter to search for the MCPConfiguration to update in case it exists.
     */
    where: MCPConfigurationWhereUniqueInput
    /**
     * In case the MCPConfiguration found by the `where` argument doesn't exist, create a new MCPConfiguration with this data.
     */
    create: XOR<MCPConfigurationCreateInput, MCPConfigurationUncheckedCreateInput>
    /**
     * In case the MCPConfiguration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MCPConfigurationUpdateInput, MCPConfigurationUncheckedUpdateInput>
  }


  /**
   * MCPConfiguration delete
   */
  export type MCPConfigurationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPConfiguration
     */
    select?: MCPConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCPConfigurationInclude<ExtArgs> | null
    /**
     * Filter which MCPConfiguration to delete.
     */
    where: MCPConfigurationWhereUniqueInput
  }


  /**
   * MCPConfiguration deleteMany
   */
  export type MCPConfigurationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which MCPConfigurations to delete
     */
    where?: MCPConfigurationWhereInput
  }


  /**
   * MCPConfiguration without action
   */
  export type MCPConfigurationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MCPConfiguration
     */
    select?: MCPConfigurationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MCPConfigurationInclude<ExtArgs> | null
  }



  /**
   * Model OAuthToken
   */


  export type AggregateOAuthToken = {
    _count: OAuthTokenCountAggregateOutputType | null
    _min: OAuthTokenMinAggregateOutputType | null
    _max: OAuthTokenMaxAggregateOutputType | null
  }

  export type OAuthTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: string | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type OAuthTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: string | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type OAuthTokenCountAggregateOutputType = {
    id: number
    userId: number
    provider: number
    accessToken: number
    refreshToken: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type OAuthTokenMinAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    createdAt?: true
  }

  export type OAuthTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    createdAt?: true
  }

  export type OAuthTokenCountAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type OAuthTokenAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthToken to aggregate.
     */
    where?: OAuthTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthTokens to fetch.
     */
    orderBy?: OAuthTokenOrderByWithRelationInput | OAuthTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OAuthTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OAuthTokens
    **/
    _count?: true | OAuthTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OAuthTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OAuthTokenMaxAggregateInputType
  }

  export type GetOAuthTokenAggregateType<T extends OAuthTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateOAuthToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOAuthToken[P]>
      : GetScalarType<T[P], AggregateOAuthToken[P]>
  }




  export type OAuthTokenGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OAuthTokenWhereInput
    orderBy?: OAuthTokenOrderByWithAggregationInput | OAuthTokenOrderByWithAggregationInput[]
    by: OAuthTokenScalarFieldEnum[] | OAuthTokenScalarFieldEnum
    having?: OAuthTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OAuthTokenCountAggregateInputType | true
    _min?: OAuthTokenMinAggregateInputType
    _max?: OAuthTokenMaxAggregateInputType
  }


  export type OAuthTokenGroupByOutputType = {
    id: string
    userId: string
    provider: string
    accessToken: string
    refreshToken: string | null
    expiresAt: Date
    createdAt: Date
    _count: OAuthTokenCountAggregateOutputType | null
    _min: OAuthTokenMinAggregateOutputType | null
    _max: OAuthTokenMaxAggregateOutputType | null
  }

  type GetOAuthTokenGroupByPayload<T extends OAuthTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OAuthTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OAuthTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OAuthTokenGroupByOutputType[P]>
            : GetScalarType<T[P], OAuthTokenGroupByOutputType[P]>
        }
      >
    >


  export type OAuthTokenSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["oAuthToken"]>

  export type OAuthTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    provider?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type OAuthTokenInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type OAuthTokenGetPayload<S extends boolean | null | undefined | OAuthTokenArgs> = $Types.GetResult<OAuthTokenPayload, S>

  type OAuthTokenCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OAuthTokenFindManyArgs, 'select' | 'include'> & {
      select?: OAuthTokenCountAggregateInputType | true
    }

  export interface OAuthTokenDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OAuthToken'], meta: { name: 'OAuthToken' } }
    /**
     * Find zero or one OAuthToken that matches the filter.
     * @param {OAuthTokenFindUniqueArgs} args - Arguments to find a OAuthToken
     * @example
     * // Get one OAuthToken
     * const oAuthToken = await prisma.oAuthToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OAuthTokenFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__OAuthTokenClient<$Types.GetResult<OAuthTokenPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OAuthToken that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OAuthTokenFindUniqueOrThrowArgs} args - Arguments to find a OAuthToken
     * @example
     * // Get one OAuthToken
     * const oAuthToken = await prisma.oAuthToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OAuthTokenFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OAuthTokenClient<$Types.GetResult<OAuthTokenPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OAuthToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthTokenFindFirstArgs} args - Arguments to find a OAuthToken
     * @example
     * // Get one OAuthToken
     * const oAuthToken = await prisma.oAuthToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OAuthTokenFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthTokenFindFirstArgs<ExtArgs>>
    ): Prisma__OAuthTokenClient<$Types.GetResult<OAuthTokenPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OAuthToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthTokenFindFirstOrThrowArgs} args - Arguments to find a OAuthToken
     * @example
     * // Get one OAuthToken
     * const oAuthToken = await prisma.oAuthToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OAuthTokenFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OAuthTokenClient<$Types.GetResult<OAuthTokenPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OAuthTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OAuthTokens
     * const oAuthTokens = await prisma.oAuthToken.findMany()
     * 
     * // Get first 10 OAuthTokens
     * const oAuthTokens = await prisma.oAuthToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oAuthTokenWithIdOnly = await prisma.oAuthToken.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OAuthTokenFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<OAuthTokenPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OAuthToken.
     * @param {OAuthTokenCreateArgs} args - Arguments to create a OAuthToken.
     * @example
     * // Create one OAuthToken
     * const OAuthToken = await prisma.oAuthToken.create({
     *   data: {
     *     // ... data to create a OAuthToken
     *   }
     * })
     * 
    **/
    create<T extends OAuthTokenCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthTokenCreateArgs<ExtArgs>>
    ): Prisma__OAuthTokenClient<$Types.GetResult<OAuthTokenPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OAuthTokens.
     *     @param {OAuthTokenCreateManyArgs} args - Arguments to create many OAuthTokens.
     *     @example
     *     // Create many OAuthTokens
     *     const oAuthToken = await prisma.oAuthToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OAuthTokenCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OAuthToken.
     * @param {OAuthTokenDeleteArgs} args - Arguments to delete one OAuthToken.
     * @example
     * // Delete one OAuthToken
     * const OAuthToken = await prisma.oAuthToken.delete({
     *   where: {
     *     // ... filter to delete one OAuthToken
     *   }
     * })
     * 
    **/
    delete<T extends OAuthTokenDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthTokenDeleteArgs<ExtArgs>>
    ): Prisma__OAuthTokenClient<$Types.GetResult<OAuthTokenPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OAuthToken.
     * @param {OAuthTokenUpdateArgs} args - Arguments to update one OAuthToken.
     * @example
     * // Update one OAuthToken
     * const oAuthToken = await prisma.oAuthToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OAuthTokenUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthTokenUpdateArgs<ExtArgs>>
    ): Prisma__OAuthTokenClient<$Types.GetResult<OAuthTokenPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OAuthTokens.
     * @param {OAuthTokenDeleteManyArgs} args - Arguments to filter OAuthTokens to delete.
     * @example
     * // Delete a few OAuthTokens
     * const { count } = await prisma.oAuthToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OAuthTokenDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OAuthTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OAuthTokens
     * const oAuthToken = await prisma.oAuthToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OAuthTokenUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OAuthToken.
     * @param {OAuthTokenUpsertArgs} args - Arguments to update or create a OAuthToken.
     * @example
     * // Update or create a OAuthToken
     * const oAuthToken = await prisma.oAuthToken.upsert({
     *   create: {
     *     // ... data to create a OAuthToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OAuthToken we want to update
     *   }
     * })
    **/
    upsert<T extends OAuthTokenUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthTokenUpsertArgs<ExtArgs>>
    ): Prisma__OAuthTokenClient<$Types.GetResult<OAuthTokenPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OAuthTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthTokenCountArgs} args - Arguments to filter OAuthTokens to count.
     * @example
     * // Count the number of OAuthTokens
     * const count = await prisma.oAuthToken.count({
     *   where: {
     *     // ... the filter for the OAuthTokens we want to count
     *   }
     * })
    **/
    count<T extends OAuthTokenCountArgs>(
      args?: Subset<T, OAuthTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OAuthTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OAuthToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OAuthTokenAggregateArgs>(args: Subset<T, OAuthTokenAggregateArgs>): Prisma.PrismaPromise<GetOAuthTokenAggregateType<T>>

    /**
     * Group by OAuthToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OAuthTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OAuthTokenGroupByArgs['orderBy'] }
        : { orderBy?: OAuthTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OAuthTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOAuthTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OAuthToken model
   */
  readonly fields: OAuthTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OAuthToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OAuthTokenClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the OAuthToken model
   */ 
  interface OAuthTokenFieldRefs {
    readonly id: FieldRef<"OAuthToken", 'String'>
    readonly userId: FieldRef<"OAuthToken", 'String'>
    readonly provider: FieldRef<"OAuthToken", 'String'>
    readonly accessToken: FieldRef<"OAuthToken", 'String'>
    readonly refreshToken: FieldRef<"OAuthToken", 'String'>
    readonly expiresAt: FieldRef<"OAuthToken", 'DateTime'>
    readonly createdAt: FieldRef<"OAuthToken", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * OAuthToken findUnique
   */
  export type OAuthTokenFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthTokenInclude<ExtArgs> | null
    /**
     * Filter, which OAuthToken to fetch.
     */
    where: OAuthTokenWhereUniqueInput
  }


  /**
   * OAuthToken findUniqueOrThrow
   */
  export type OAuthTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthTokenInclude<ExtArgs> | null
    /**
     * Filter, which OAuthToken to fetch.
     */
    where: OAuthTokenWhereUniqueInput
  }


  /**
   * OAuthToken findFirst
   */
  export type OAuthTokenFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthTokenInclude<ExtArgs> | null
    /**
     * Filter, which OAuthToken to fetch.
     */
    where?: OAuthTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthTokens to fetch.
     */
    orderBy?: OAuthTokenOrderByWithRelationInput | OAuthTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthTokens.
     */
    cursor?: OAuthTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthTokens.
     */
    distinct?: OAuthTokenScalarFieldEnum | OAuthTokenScalarFieldEnum[]
  }


  /**
   * OAuthToken findFirstOrThrow
   */
  export type OAuthTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthTokenInclude<ExtArgs> | null
    /**
     * Filter, which OAuthToken to fetch.
     */
    where?: OAuthTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthTokens to fetch.
     */
    orderBy?: OAuthTokenOrderByWithRelationInput | OAuthTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthTokens.
     */
    cursor?: OAuthTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthTokens.
     */
    distinct?: OAuthTokenScalarFieldEnum | OAuthTokenScalarFieldEnum[]
  }


  /**
   * OAuthToken findMany
   */
  export type OAuthTokenFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthTokenInclude<ExtArgs> | null
    /**
     * Filter, which OAuthTokens to fetch.
     */
    where?: OAuthTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthTokens to fetch.
     */
    orderBy?: OAuthTokenOrderByWithRelationInput | OAuthTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OAuthTokens.
     */
    cursor?: OAuthTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthTokens.
     */
    skip?: number
    distinct?: OAuthTokenScalarFieldEnum | OAuthTokenScalarFieldEnum[]
  }


  /**
   * OAuthToken create
   */
  export type OAuthTokenCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a OAuthToken.
     */
    data: XOR<OAuthTokenCreateInput, OAuthTokenUncheckedCreateInput>
  }


  /**
   * OAuthToken createMany
   */
  export type OAuthTokenCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OAuthTokens.
     */
    data: OAuthTokenCreateManyInput | OAuthTokenCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * OAuthToken update
   */
  export type OAuthTokenUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a OAuthToken.
     */
    data: XOR<OAuthTokenUpdateInput, OAuthTokenUncheckedUpdateInput>
    /**
     * Choose, which OAuthToken to update.
     */
    where: OAuthTokenWhereUniqueInput
  }


  /**
   * OAuthToken updateMany
   */
  export type OAuthTokenUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OAuthTokens.
     */
    data: XOR<OAuthTokenUpdateManyMutationInput, OAuthTokenUncheckedUpdateManyInput>
    /**
     * Filter which OAuthTokens to update
     */
    where?: OAuthTokenWhereInput
  }


  /**
   * OAuthToken upsert
   */
  export type OAuthTokenUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the OAuthToken to update in case it exists.
     */
    where: OAuthTokenWhereUniqueInput
    /**
     * In case the OAuthToken found by the `where` argument doesn't exist, create a new OAuthToken with this data.
     */
    create: XOR<OAuthTokenCreateInput, OAuthTokenUncheckedCreateInput>
    /**
     * In case the OAuthToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OAuthTokenUpdateInput, OAuthTokenUncheckedUpdateInput>
  }


  /**
   * OAuthToken delete
   */
  export type OAuthTokenDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthTokenInclude<ExtArgs> | null
    /**
     * Filter which OAuthToken to delete.
     */
    where: OAuthTokenWhereUniqueInput
  }


  /**
   * OAuthToken deleteMany
   */
  export type OAuthTokenDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthTokens to delete
     */
    where?: OAuthTokenWhereInput
  }


  /**
   * OAuthToken without action
   */
  export type OAuthTokenArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthToken
     */
    select?: OAuthTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthTokenInclude<ExtArgs> | null
  }



  /**
   * Model OAuthClient
   */


  export type AggregateOAuthClient = {
    _count: OAuthClientCountAggregateOutputType | null
    _min: OAuthClientMinAggregateOutputType | null
    _max: OAuthClientMaxAggregateOutputType | null
  }

  export type OAuthClientMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    clientSecretHash: string | null
    name: string | null
    requirePkce: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OAuthClientMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    clientSecretHash: string | null
    name: string | null
    requirePkce: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OAuthClientCountAggregateOutputType = {
    id: number
    clientId: number
    clientSecretHash: number
    name: number
    redirectUris: number
    allowedScopes: number
    grantTypes: number
    requirePkce: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OAuthClientMinAggregateInputType = {
    id?: true
    clientId?: true
    clientSecretHash?: true
    name?: true
    requirePkce?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OAuthClientMaxAggregateInputType = {
    id?: true
    clientId?: true
    clientSecretHash?: true
    name?: true
    requirePkce?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OAuthClientCountAggregateInputType = {
    id?: true
    clientId?: true
    clientSecretHash?: true
    name?: true
    redirectUris?: true
    allowedScopes?: true
    grantTypes?: true
    requirePkce?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OAuthClientAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthClient to aggregate.
     */
    where?: OAuthClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthClients to fetch.
     */
    orderBy?: OAuthClientOrderByWithRelationInput | OAuthClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OAuthClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OAuthClients
    **/
    _count?: true | OAuthClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OAuthClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OAuthClientMaxAggregateInputType
  }

  export type GetOAuthClientAggregateType<T extends OAuthClientAggregateArgs> = {
        [P in keyof T & keyof AggregateOAuthClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOAuthClient[P]>
      : GetScalarType<T[P], AggregateOAuthClient[P]>
  }




  export type OAuthClientGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OAuthClientWhereInput
    orderBy?: OAuthClientOrderByWithAggregationInput | OAuthClientOrderByWithAggregationInput[]
    by: OAuthClientScalarFieldEnum[] | OAuthClientScalarFieldEnum
    having?: OAuthClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OAuthClientCountAggregateInputType | true
    _min?: OAuthClientMinAggregateInputType
    _max?: OAuthClientMaxAggregateInputType
  }


  export type OAuthClientGroupByOutputType = {
    id: string
    clientId: string
    clientSecretHash: string
    name: string
    redirectUris: string[]
    allowedScopes: string[]
    grantTypes: string[]
    requirePkce: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: OAuthClientCountAggregateOutputType | null
    _min: OAuthClientMinAggregateOutputType | null
    _max: OAuthClientMaxAggregateOutputType | null
  }

  type GetOAuthClientGroupByPayload<T extends OAuthClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OAuthClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OAuthClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OAuthClientGroupByOutputType[P]>
            : GetScalarType<T[P], OAuthClientGroupByOutputType[P]>
        }
      >
    >


  export type OAuthClientSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    clientSecretHash?: boolean
    name?: boolean
    redirectUris?: boolean
    allowedScopes?: boolean
    grantTypes?: boolean
    requirePkce?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    authorizationCodes?: boolean | OAuthClient$authorizationCodesArgs<ExtArgs>
    accessTokens?: boolean | OAuthClient$accessTokensArgs<ExtArgs>
    refreshTokens?: boolean | OAuthClient$refreshTokensArgs<ExtArgs>
    _count?: boolean | OAuthClientCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["oAuthClient"]>

  export type OAuthClientSelectScalar = {
    id?: boolean
    clientId?: boolean
    clientSecretHash?: boolean
    name?: boolean
    redirectUris?: boolean
    allowedScopes?: boolean
    grantTypes?: boolean
    requirePkce?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OAuthClientInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    authorizationCodes?: boolean | OAuthClient$authorizationCodesArgs<ExtArgs>
    accessTokens?: boolean | OAuthClient$accessTokensArgs<ExtArgs>
    refreshTokens?: boolean | OAuthClient$refreshTokensArgs<ExtArgs>
    _count?: boolean | OAuthClientCountOutputTypeArgs<ExtArgs>
  }


  type OAuthClientGetPayload<S extends boolean | null | undefined | OAuthClientArgs> = $Types.GetResult<OAuthClientPayload, S>

  type OAuthClientCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OAuthClientFindManyArgs, 'select' | 'include'> & {
      select?: OAuthClientCountAggregateInputType | true
    }

  export interface OAuthClientDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OAuthClient'], meta: { name: 'OAuthClient' } }
    /**
     * Find zero or one OAuthClient that matches the filter.
     * @param {OAuthClientFindUniqueArgs} args - Arguments to find a OAuthClient
     * @example
     * // Get one OAuthClient
     * const oAuthClient = await prisma.oAuthClient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OAuthClientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthClientFindUniqueArgs<ExtArgs>>
    ): Prisma__OAuthClientClient<$Types.GetResult<OAuthClientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OAuthClient that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OAuthClientFindUniqueOrThrowArgs} args - Arguments to find a OAuthClient
     * @example
     * // Get one OAuthClient
     * const oAuthClient = await prisma.oAuthClient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OAuthClientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthClientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OAuthClientClient<$Types.GetResult<OAuthClientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OAuthClient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthClientFindFirstArgs} args - Arguments to find a OAuthClient
     * @example
     * // Get one OAuthClient
     * const oAuthClient = await prisma.oAuthClient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OAuthClientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthClientFindFirstArgs<ExtArgs>>
    ): Prisma__OAuthClientClient<$Types.GetResult<OAuthClientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OAuthClient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthClientFindFirstOrThrowArgs} args - Arguments to find a OAuthClient
     * @example
     * // Get one OAuthClient
     * const oAuthClient = await prisma.oAuthClient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OAuthClientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthClientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OAuthClientClient<$Types.GetResult<OAuthClientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OAuthClients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthClientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OAuthClients
     * const oAuthClients = await prisma.oAuthClient.findMany()
     * 
     * // Get first 10 OAuthClients
     * const oAuthClients = await prisma.oAuthClient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oAuthClientWithIdOnly = await prisma.oAuthClient.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OAuthClientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthClientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<OAuthClientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OAuthClient.
     * @param {OAuthClientCreateArgs} args - Arguments to create a OAuthClient.
     * @example
     * // Create one OAuthClient
     * const OAuthClient = await prisma.oAuthClient.create({
     *   data: {
     *     // ... data to create a OAuthClient
     *   }
     * })
     * 
    **/
    create<T extends OAuthClientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthClientCreateArgs<ExtArgs>>
    ): Prisma__OAuthClientClient<$Types.GetResult<OAuthClientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OAuthClients.
     *     @param {OAuthClientCreateManyArgs} args - Arguments to create many OAuthClients.
     *     @example
     *     // Create many OAuthClients
     *     const oAuthClient = await prisma.oAuthClient.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OAuthClientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthClientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OAuthClient.
     * @param {OAuthClientDeleteArgs} args - Arguments to delete one OAuthClient.
     * @example
     * // Delete one OAuthClient
     * const OAuthClient = await prisma.oAuthClient.delete({
     *   where: {
     *     // ... filter to delete one OAuthClient
     *   }
     * })
     * 
    **/
    delete<T extends OAuthClientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthClientDeleteArgs<ExtArgs>>
    ): Prisma__OAuthClientClient<$Types.GetResult<OAuthClientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OAuthClient.
     * @param {OAuthClientUpdateArgs} args - Arguments to update one OAuthClient.
     * @example
     * // Update one OAuthClient
     * const oAuthClient = await prisma.oAuthClient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OAuthClientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthClientUpdateArgs<ExtArgs>>
    ): Prisma__OAuthClientClient<$Types.GetResult<OAuthClientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OAuthClients.
     * @param {OAuthClientDeleteManyArgs} args - Arguments to filter OAuthClients to delete.
     * @example
     * // Delete a few OAuthClients
     * const { count } = await prisma.oAuthClient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OAuthClientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthClientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OAuthClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OAuthClients
     * const oAuthClient = await prisma.oAuthClient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OAuthClientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthClientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OAuthClient.
     * @param {OAuthClientUpsertArgs} args - Arguments to update or create a OAuthClient.
     * @example
     * // Update or create a OAuthClient
     * const oAuthClient = await prisma.oAuthClient.upsert({
     *   create: {
     *     // ... data to create a OAuthClient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OAuthClient we want to update
     *   }
     * })
    **/
    upsert<T extends OAuthClientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthClientUpsertArgs<ExtArgs>>
    ): Prisma__OAuthClientClient<$Types.GetResult<OAuthClientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OAuthClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthClientCountArgs} args - Arguments to filter OAuthClients to count.
     * @example
     * // Count the number of OAuthClients
     * const count = await prisma.oAuthClient.count({
     *   where: {
     *     // ... the filter for the OAuthClients we want to count
     *   }
     * })
    **/
    count<T extends OAuthClientCountArgs>(
      args?: Subset<T, OAuthClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OAuthClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OAuthClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OAuthClientAggregateArgs>(args: Subset<T, OAuthClientAggregateArgs>): Prisma.PrismaPromise<GetOAuthClientAggregateType<T>>

    /**
     * Group by OAuthClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OAuthClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OAuthClientGroupByArgs['orderBy'] }
        : { orderBy?: OAuthClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OAuthClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOAuthClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OAuthClient model
   */
  readonly fields: OAuthClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OAuthClient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OAuthClientClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    authorizationCodes<T extends OAuthClient$authorizationCodesArgs<ExtArgs> = {}>(args?: Subset<T, OAuthClient$authorizationCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<OAuthAuthorizationCodePayload<ExtArgs>, T, 'findMany'>| Null>;

    accessTokens<T extends OAuthClient$accessTokensArgs<ExtArgs> = {}>(args?: Subset<T, OAuthClient$accessTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<OAuthAccessTokenPayload<ExtArgs>, T, 'findMany'>| Null>;

    refreshTokens<T extends OAuthClient$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, OAuthClient$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<OAuthRefreshTokenPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the OAuthClient model
   */ 
  interface OAuthClientFieldRefs {
    readonly id: FieldRef<"OAuthClient", 'String'>
    readonly clientId: FieldRef<"OAuthClient", 'String'>
    readonly clientSecretHash: FieldRef<"OAuthClient", 'String'>
    readonly name: FieldRef<"OAuthClient", 'String'>
    readonly redirectUris: FieldRef<"OAuthClient", 'String[]'>
    readonly allowedScopes: FieldRef<"OAuthClient", 'String[]'>
    readonly grantTypes: FieldRef<"OAuthClient", 'String[]'>
    readonly requirePkce: FieldRef<"OAuthClient", 'Boolean'>
    readonly isActive: FieldRef<"OAuthClient", 'Boolean'>
    readonly createdAt: FieldRef<"OAuthClient", 'DateTime'>
    readonly updatedAt: FieldRef<"OAuthClient", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * OAuthClient findUnique
   */
  export type OAuthClientFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthClient
     */
    select?: OAuthClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthClientInclude<ExtArgs> | null
    /**
     * Filter, which OAuthClient to fetch.
     */
    where: OAuthClientWhereUniqueInput
  }


  /**
   * OAuthClient findUniqueOrThrow
   */
  export type OAuthClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthClient
     */
    select?: OAuthClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthClientInclude<ExtArgs> | null
    /**
     * Filter, which OAuthClient to fetch.
     */
    where: OAuthClientWhereUniqueInput
  }


  /**
   * OAuthClient findFirst
   */
  export type OAuthClientFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthClient
     */
    select?: OAuthClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthClientInclude<ExtArgs> | null
    /**
     * Filter, which OAuthClient to fetch.
     */
    where?: OAuthClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthClients to fetch.
     */
    orderBy?: OAuthClientOrderByWithRelationInput | OAuthClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthClients.
     */
    cursor?: OAuthClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthClients.
     */
    distinct?: OAuthClientScalarFieldEnum | OAuthClientScalarFieldEnum[]
  }


  /**
   * OAuthClient findFirstOrThrow
   */
  export type OAuthClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthClient
     */
    select?: OAuthClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthClientInclude<ExtArgs> | null
    /**
     * Filter, which OAuthClient to fetch.
     */
    where?: OAuthClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthClients to fetch.
     */
    orderBy?: OAuthClientOrderByWithRelationInput | OAuthClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthClients.
     */
    cursor?: OAuthClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthClients.
     */
    distinct?: OAuthClientScalarFieldEnum | OAuthClientScalarFieldEnum[]
  }


  /**
   * OAuthClient findMany
   */
  export type OAuthClientFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthClient
     */
    select?: OAuthClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthClientInclude<ExtArgs> | null
    /**
     * Filter, which OAuthClients to fetch.
     */
    where?: OAuthClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthClients to fetch.
     */
    orderBy?: OAuthClientOrderByWithRelationInput | OAuthClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OAuthClients.
     */
    cursor?: OAuthClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthClients.
     */
    skip?: number
    distinct?: OAuthClientScalarFieldEnum | OAuthClientScalarFieldEnum[]
  }


  /**
   * OAuthClient create
   */
  export type OAuthClientCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthClient
     */
    select?: OAuthClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthClientInclude<ExtArgs> | null
    /**
     * The data needed to create a OAuthClient.
     */
    data: XOR<OAuthClientCreateInput, OAuthClientUncheckedCreateInput>
  }


  /**
   * OAuthClient createMany
   */
  export type OAuthClientCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OAuthClients.
     */
    data: OAuthClientCreateManyInput | OAuthClientCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * OAuthClient update
   */
  export type OAuthClientUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthClient
     */
    select?: OAuthClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthClientInclude<ExtArgs> | null
    /**
     * The data needed to update a OAuthClient.
     */
    data: XOR<OAuthClientUpdateInput, OAuthClientUncheckedUpdateInput>
    /**
     * Choose, which OAuthClient to update.
     */
    where: OAuthClientWhereUniqueInput
  }


  /**
   * OAuthClient updateMany
   */
  export type OAuthClientUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OAuthClients.
     */
    data: XOR<OAuthClientUpdateManyMutationInput, OAuthClientUncheckedUpdateManyInput>
    /**
     * Filter which OAuthClients to update
     */
    where?: OAuthClientWhereInput
  }


  /**
   * OAuthClient upsert
   */
  export type OAuthClientUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthClient
     */
    select?: OAuthClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthClientInclude<ExtArgs> | null
    /**
     * The filter to search for the OAuthClient to update in case it exists.
     */
    where: OAuthClientWhereUniqueInput
    /**
     * In case the OAuthClient found by the `where` argument doesn't exist, create a new OAuthClient with this data.
     */
    create: XOR<OAuthClientCreateInput, OAuthClientUncheckedCreateInput>
    /**
     * In case the OAuthClient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OAuthClientUpdateInput, OAuthClientUncheckedUpdateInput>
  }


  /**
   * OAuthClient delete
   */
  export type OAuthClientDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthClient
     */
    select?: OAuthClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthClientInclude<ExtArgs> | null
    /**
     * Filter which OAuthClient to delete.
     */
    where: OAuthClientWhereUniqueInput
  }


  /**
   * OAuthClient deleteMany
   */
  export type OAuthClientDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthClients to delete
     */
    where?: OAuthClientWhereInput
  }


  /**
   * OAuthClient.authorizationCodes
   */
  export type OAuthClient$authorizationCodesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAuthorizationCode
     */
    select?: OAuthAuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthAuthorizationCodeInclude<ExtArgs> | null
    where?: OAuthAuthorizationCodeWhereInput
    orderBy?: OAuthAuthorizationCodeOrderByWithRelationInput | OAuthAuthorizationCodeOrderByWithRelationInput[]
    cursor?: OAuthAuthorizationCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OAuthAuthorizationCodeScalarFieldEnum | OAuthAuthorizationCodeScalarFieldEnum[]
  }


  /**
   * OAuthClient.accessTokens
   */
  export type OAuthClient$accessTokensArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccessToken
     */
    select?: OAuthAccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthAccessTokenInclude<ExtArgs> | null
    where?: OAuthAccessTokenWhereInput
    orderBy?: OAuthAccessTokenOrderByWithRelationInput | OAuthAccessTokenOrderByWithRelationInput[]
    cursor?: OAuthAccessTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OAuthAccessTokenScalarFieldEnum | OAuthAccessTokenScalarFieldEnum[]
  }


  /**
   * OAuthClient.refreshTokens
   */
  export type OAuthClient$refreshTokensArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthRefreshToken
     */
    select?: OAuthRefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthRefreshTokenInclude<ExtArgs> | null
    where?: OAuthRefreshTokenWhereInput
    orderBy?: OAuthRefreshTokenOrderByWithRelationInput | OAuthRefreshTokenOrderByWithRelationInput[]
    cursor?: OAuthRefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OAuthRefreshTokenScalarFieldEnum | OAuthRefreshTokenScalarFieldEnum[]
  }


  /**
   * OAuthClient without action
   */
  export type OAuthClientArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthClient
     */
    select?: OAuthClientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthClientInclude<ExtArgs> | null
  }



  /**
   * Model OAuthAuthorizationCode
   */


  export type AggregateOAuthAuthorizationCode = {
    _count: OAuthAuthorizationCodeCountAggregateOutputType | null
    _min: OAuthAuthorizationCodeMinAggregateOutputType | null
    _max: OAuthAuthorizationCodeMaxAggregateOutputType | null
  }

  export type OAuthAuthorizationCodeMinAggregateOutputType = {
    id: string | null
    code: string | null
    clientId: string | null
    userId: string | null
    redirectUri: string | null
    codeChallenge: string | null
    codeChallengeMethod: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type OAuthAuthorizationCodeMaxAggregateOutputType = {
    id: string | null
    code: string | null
    clientId: string | null
    userId: string | null
    redirectUri: string | null
    codeChallenge: string | null
    codeChallengeMethod: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type OAuthAuthorizationCodeCountAggregateOutputType = {
    id: number
    code: number
    clientId: number
    userId: number
    redirectUri: number
    scopes: number
    codeChallenge: number
    codeChallengeMethod: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type OAuthAuthorizationCodeMinAggregateInputType = {
    id?: true
    code?: true
    clientId?: true
    userId?: true
    redirectUri?: true
    codeChallenge?: true
    codeChallengeMethod?: true
    expiresAt?: true
    createdAt?: true
  }

  export type OAuthAuthorizationCodeMaxAggregateInputType = {
    id?: true
    code?: true
    clientId?: true
    userId?: true
    redirectUri?: true
    codeChallenge?: true
    codeChallengeMethod?: true
    expiresAt?: true
    createdAt?: true
  }

  export type OAuthAuthorizationCodeCountAggregateInputType = {
    id?: true
    code?: true
    clientId?: true
    userId?: true
    redirectUri?: true
    scopes?: true
    codeChallenge?: true
    codeChallengeMethod?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type OAuthAuthorizationCodeAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthAuthorizationCode to aggregate.
     */
    where?: OAuthAuthorizationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthAuthorizationCodes to fetch.
     */
    orderBy?: OAuthAuthorizationCodeOrderByWithRelationInput | OAuthAuthorizationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OAuthAuthorizationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthAuthorizationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthAuthorizationCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OAuthAuthorizationCodes
    **/
    _count?: true | OAuthAuthorizationCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OAuthAuthorizationCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OAuthAuthorizationCodeMaxAggregateInputType
  }

  export type GetOAuthAuthorizationCodeAggregateType<T extends OAuthAuthorizationCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateOAuthAuthorizationCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOAuthAuthorizationCode[P]>
      : GetScalarType<T[P], AggregateOAuthAuthorizationCode[P]>
  }




  export type OAuthAuthorizationCodeGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OAuthAuthorizationCodeWhereInput
    orderBy?: OAuthAuthorizationCodeOrderByWithAggregationInput | OAuthAuthorizationCodeOrderByWithAggregationInput[]
    by: OAuthAuthorizationCodeScalarFieldEnum[] | OAuthAuthorizationCodeScalarFieldEnum
    having?: OAuthAuthorizationCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OAuthAuthorizationCodeCountAggregateInputType | true
    _min?: OAuthAuthorizationCodeMinAggregateInputType
    _max?: OAuthAuthorizationCodeMaxAggregateInputType
  }


  export type OAuthAuthorizationCodeGroupByOutputType = {
    id: string
    code: string
    clientId: string
    userId: string
    redirectUri: string
    scopes: string[]
    codeChallenge: string | null
    codeChallengeMethod: string | null
    expiresAt: Date
    createdAt: Date
    _count: OAuthAuthorizationCodeCountAggregateOutputType | null
    _min: OAuthAuthorizationCodeMinAggregateOutputType | null
    _max: OAuthAuthorizationCodeMaxAggregateOutputType | null
  }

  type GetOAuthAuthorizationCodeGroupByPayload<T extends OAuthAuthorizationCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OAuthAuthorizationCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OAuthAuthorizationCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OAuthAuthorizationCodeGroupByOutputType[P]>
            : GetScalarType<T[P], OAuthAuthorizationCodeGroupByOutputType[P]>
        }
      >
    >


  export type OAuthAuthorizationCodeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    clientId?: boolean
    userId?: boolean
    redirectUri?: boolean
    scopes?: boolean
    codeChallenge?: boolean
    codeChallengeMethod?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    client?: boolean | OAuthClientArgs<ExtArgs>
  }, ExtArgs["result"]["oAuthAuthorizationCode"]>

  export type OAuthAuthorizationCodeSelectScalar = {
    id?: boolean
    code?: boolean
    clientId?: boolean
    userId?: boolean
    redirectUri?: boolean
    scopes?: boolean
    codeChallenge?: boolean
    codeChallengeMethod?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type OAuthAuthorizationCodeInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    client?: boolean | OAuthClientArgs<ExtArgs>
  }


  type OAuthAuthorizationCodeGetPayload<S extends boolean | null | undefined | OAuthAuthorizationCodeArgs> = $Types.GetResult<OAuthAuthorizationCodePayload, S>

  type OAuthAuthorizationCodeCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OAuthAuthorizationCodeFindManyArgs, 'select' | 'include'> & {
      select?: OAuthAuthorizationCodeCountAggregateInputType | true
    }

  export interface OAuthAuthorizationCodeDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OAuthAuthorizationCode'], meta: { name: 'OAuthAuthorizationCode' } }
    /**
     * Find zero or one OAuthAuthorizationCode that matches the filter.
     * @param {OAuthAuthorizationCodeFindUniqueArgs} args - Arguments to find a OAuthAuthorizationCode
     * @example
     * // Get one OAuthAuthorizationCode
     * const oAuthAuthorizationCode = await prisma.oAuthAuthorizationCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OAuthAuthorizationCodeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthAuthorizationCodeFindUniqueArgs<ExtArgs>>
    ): Prisma__OAuthAuthorizationCodeClient<$Types.GetResult<OAuthAuthorizationCodePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OAuthAuthorizationCode that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OAuthAuthorizationCodeFindUniqueOrThrowArgs} args - Arguments to find a OAuthAuthorizationCode
     * @example
     * // Get one OAuthAuthorizationCode
     * const oAuthAuthorizationCode = await prisma.oAuthAuthorizationCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OAuthAuthorizationCodeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthAuthorizationCodeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OAuthAuthorizationCodeClient<$Types.GetResult<OAuthAuthorizationCodePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OAuthAuthorizationCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAuthorizationCodeFindFirstArgs} args - Arguments to find a OAuthAuthorizationCode
     * @example
     * // Get one OAuthAuthorizationCode
     * const oAuthAuthorizationCode = await prisma.oAuthAuthorizationCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OAuthAuthorizationCodeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthAuthorizationCodeFindFirstArgs<ExtArgs>>
    ): Prisma__OAuthAuthorizationCodeClient<$Types.GetResult<OAuthAuthorizationCodePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OAuthAuthorizationCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAuthorizationCodeFindFirstOrThrowArgs} args - Arguments to find a OAuthAuthorizationCode
     * @example
     * // Get one OAuthAuthorizationCode
     * const oAuthAuthorizationCode = await prisma.oAuthAuthorizationCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OAuthAuthorizationCodeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthAuthorizationCodeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OAuthAuthorizationCodeClient<$Types.GetResult<OAuthAuthorizationCodePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OAuthAuthorizationCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAuthorizationCodeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OAuthAuthorizationCodes
     * const oAuthAuthorizationCodes = await prisma.oAuthAuthorizationCode.findMany()
     * 
     * // Get first 10 OAuthAuthorizationCodes
     * const oAuthAuthorizationCodes = await prisma.oAuthAuthorizationCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oAuthAuthorizationCodeWithIdOnly = await prisma.oAuthAuthorizationCode.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OAuthAuthorizationCodeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthAuthorizationCodeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<OAuthAuthorizationCodePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OAuthAuthorizationCode.
     * @param {OAuthAuthorizationCodeCreateArgs} args - Arguments to create a OAuthAuthorizationCode.
     * @example
     * // Create one OAuthAuthorizationCode
     * const OAuthAuthorizationCode = await prisma.oAuthAuthorizationCode.create({
     *   data: {
     *     // ... data to create a OAuthAuthorizationCode
     *   }
     * })
     * 
    **/
    create<T extends OAuthAuthorizationCodeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthAuthorizationCodeCreateArgs<ExtArgs>>
    ): Prisma__OAuthAuthorizationCodeClient<$Types.GetResult<OAuthAuthorizationCodePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OAuthAuthorizationCodes.
     *     @param {OAuthAuthorizationCodeCreateManyArgs} args - Arguments to create many OAuthAuthorizationCodes.
     *     @example
     *     // Create many OAuthAuthorizationCodes
     *     const oAuthAuthorizationCode = await prisma.oAuthAuthorizationCode.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OAuthAuthorizationCodeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthAuthorizationCodeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OAuthAuthorizationCode.
     * @param {OAuthAuthorizationCodeDeleteArgs} args - Arguments to delete one OAuthAuthorizationCode.
     * @example
     * // Delete one OAuthAuthorizationCode
     * const OAuthAuthorizationCode = await prisma.oAuthAuthorizationCode.delete({
     *   where: {
     *     // ... filter to delete one OAuthAuthorizationCode
     *   }
     * })
     * 
    **/
    delete<T extends OAuthAuthorizationCodeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthAuthorizationCodeDeleteArgs<ExtArgs>>
    ): Prisma__OAuthAuthorizationCodeClient<$Types.GetResult<OAuthAuthorizationCodePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OAuthAuthorizationCode.
     * @param {OAuthAuthorizationCodeUpdateArgs} args - Arguments to update one OAuthAuthorizationCode.
     * @example
     * // Update one OAuthAuthorizationCode
     * const oAuthAuthorizationCode = await prisma.oAuthAuthorizationCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OAuthAuthorizationCodeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthAuthorizationCodeUpdateArgs<ExtArgs>>
    ): Prisma__OAuthAuthorizationCodeClient<$Types.GetResult<OAuthAuthorizationCodePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OAuthAuthorizationCodes.
     * @param {OAuthAuthorizationCodeDeleteManyArgs} args - Arguments to filter OAuthAuthorizationCodes to delete.
     * @example
     * // Delete a few OAuthAuthorizationCodes
     * const { count } = await prisma.oAuthAuthorizationCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OAuthAuthorizationCodeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthAuthorizationCodeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OAuthAuthorizationCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAuthorizationCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OAuthAuthorizationCodes
     * const oAuthAuthorizationCode = await prisma.oAuthAuthorizationCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OAuthAuthorizationCodeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthAuthorizationCodeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OAuthAuthorizationCode.
     * @param {OAuthAuthorizationCodeUpsertArgs} args - Arguments to update or create a OAuthAuthorizationCode.
     * @example
     * // Update or create a OAuthAuthorizationCode
     * const oAuthAuthorizationCode = await prisma.oAuthAuthorizationCode.upsert({
     *   create: {
     *     // ... data to create a OAuthAuthorizationCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OAuthAuthorizationCode we want to update
     *   }
     * })
    **/
    upsert<T extends OAuthAuthorizationCodeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthAuthorizationCodeUpsertArgs<ExtArgs>>
    ): Prisma__OAuthAuthorizationCodeClient<$Types.GetResult<OAuthAuthorizationCodePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OAuthAuthorizationCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAuthorizationCodeCountArgs} args - Arguments to filter OAuthAuthorizationCodes to count.
     * @example
     * // Count the number of OAuthAuthorizationCodes
     * const count = await prisma.oAuthAuthorizationCode.count({
     *   where: {
     *     // ... the filter for the OAuthAuthorizationCodes we want to count
     *   }
     * })
    **/
    count<T extends OAuthAuthorizationCodeCountArgs>(
      args?: Subset<T, OAuthAuthorizationCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OAuthAuthorizationCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OAuthAuthorizationCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAuthorizationCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OAuthAuthorizationCodeAggregateArgs>(args: Subset<T, OAuthAuthorizationCodeAggregateArgs>): Prisma.PrismaPromise<GetOAuthAuthorizationCodeAggregateType<T>>

    /**
     * Group by OAuthAuthorizationCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAuthorizationCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OAuthAuthorizationCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OAuthAuthorizationCodeGroupByArgs['orderBy'] }
        : { orderBy?: OAuthAuthorizationCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OAuthAuthorizationCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOAuthAuthorizationCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OAuthAuthorizationCode model
   */
  readonly fields: OAuthAuthorizationCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OAuthAuthorizationCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OAuthAuthorizationCodeClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    client<T extends OAuthClientArgs<ExtArgs> = {}>(args?: Subset<T, OAuthClientArgs<ExtArgs>>): Prisma__OAuthClientClient<$Types.GetResult<OAuthClientPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the OAuthAuthorizationCode model
   */ 
  interface OAuthAuthorizationCodeFieldRefs {
    readonly id: FieldRef<"OAuthAuthorizationCode", 'String'>
    readonly code: FieldRef<"OAuthAuthorizationCode", 'String'>
    readonly clientId: FieldRef<"OAuthAuthorizationCode", 'String'>
    readonly userId: FieldRef<"OAuthAuthorizationCode", 'String'>
    readonly redirectUri: FieldRef<"OAuthAuthorizationCode", 'String'>
    readonly scopes: FieldRef<"OAuthAuthorizationCode", 'String[]'>
    readonly codeChallenge: FieldRef<"OAuthAuthorizationCode", 'String'>
    readonly codeChallengeMethod: FieldRef<"OAuthAuthorizationCode", 'String'>
    readonly expiresAt: FieldRef<"OAuthAuthorizationCode", 'DateTime'>
    readonly createdAt: FieldRef<"OAuthAuthorizationCode", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * OAuthAuthorizationCode findUnique
   */
  export type OAuthAuthorizationCodeFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAuthorizationCode
     */
    select?: OAuthAuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthAuthorizationCodeInclude<ExtArgs> | null
    /**
     * Filter, which OAuthAuthorizationCode to fetch.
     */
    where: OAuthAuthorizationCodeWhereUniqueInput
  }


  /**
   * OAuthAuthorizationCode findUniqueOrThrow
   */
  export type OAuthAuthorizationCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAuthorizationCode
     */
    select?: OAuthAuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthAuthorizationCodeInclude<ExtArgs> | null
    /**
     * Filter, which OAuthAuthorizationCode to fetch.
     */
    where: OAuthAuthorizationCodeWhereUniqueInput
  }


  /**
   * OAuthAuthorizationCode findFirst
   */
  export type OAuthAuthorizationCodeFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAuthorizationCode
     */
    select?: OAuthAuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthAuthorizationCodeInclude<ExtArgs> | null
    /**
     * Filter, which OAuthAuthorizationCode to fetch.
     */
    where?: OAuthAuthorizationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthAuthorizationCodes to fetch.
     */
    orderBy?: OAuthAuthorizationCodeOrderByWithRelationInput | OAuthAuthorizationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthAuthorizationCodes.
     */
    cursor?: OAuthAuthorizationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthAuthorizationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthAuthorizationCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthAuthorizationCodes.
     */
    distinct?: OAuthAuthorizationCodeScalarFieldEnum | OAuthAuthorizationCodeScalarFieldEnum[]
  }


  /**
   * OAuthAuthorizationCode findFirstOrThrow
   */
  export type OAuthAuthorizationCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAuthorizationCode
     */
    select?: OAuthAuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthAuthorizationCodeInclude<ExtArgs> | null
    /**
     * Filter, which OAuthAuthorizationCode to fetch.
     */
    where?: OAuthAuthorizationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthAuthorizationCodes to fetch.
     */
    orderBy?: OAuthAuthorizationCodeOrderByWithRelationInput | OAuthAuthorizationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthAuthorizationCodes.
     */
    cursor?: OAuthAuthorizationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthAuthorizationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthAuthorizationCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthAuthorizationCodes.
     */
    distinct?: OAuthAuthorizationCodeScalarFieldEnum | OAuthAuthorizationCodeScalarFieldEnum[]
  }


  /**
   * OAuthAuthorizationCode findMany
   */
  export type OAuthAuthorizationCodeFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAuthorizationCode
     */
    select?: OAuthAuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthAuthorizationCodeInclude<ExtArgs> | null
    /**
     * Filter, which OAuthAuthorizationCodes to fetch.
     */
    where?: OAuthAuthorizationCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthAuthorizationCodes to fetch.
     */
    orderBy?: OAuthAuthorizationCodeOrderByWithRelationInput | OAuthAuthorizationCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OAuthAuthorizationCodes.
     */
    cursor?: OAuthAuthorizationCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthAuthorizationCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthAuthorizationCodes.
     */
    skip?: number
    distinct?: OAuthAuthorizationCodeScalarFieldEnum | OAuthAuthorizationCodeScalarFieldEnum[]
  }


  /**
   * OAuthAuthorizationCode create
   */
  export type OAuthAuthorizationCodeCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAuthorizationCode
     */
    select?: OAuthAuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthAuthorizationCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a OAuthAuthorizationCode.
     */
    data: XOR<OAuthAuthorizationCodeCreateInput, OAuthAuthorizationCodeUncheckedCreateInput>
  }


  /**
   * OAuthAuthorizationCode createMany
   */
  export type OAuthAuthorizationCodeCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OAuthAuthorizationCodes.
     */
    data: OAuthAuthorizationCodeCreateManyInput | OAuthAuthorizationCodeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * OAuthAuthorizationCode update
   */
  export type OAuthAuthorizationCodeUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAuthorizationCode
     */
    select?: OAuthAuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthAuthorizationCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a OAuthAuthorizationCode.
     */
    data: XOR<OAuthAuthorizationCodeUpdateInput, OAuthAuthorizationCodeUncheckedUpdateInput>
    /**
     * Choose, which OAuthAuthorizationCode to update.
     */
    where: OAuthAuthorizationCodeWhereUniqueInput
  }


  /**
   * OAuthAuthorizationCode updateMany
   */
  export type OAuthAuthorizationCodeUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OAuthAuthorizationCodes.
     */
    data: XOR<OAuthAuthorizationCodeUpdateManyMutationInput, OAuthAuthorizationCodeUncheckedUpdateManyInput>
    /**
     * Filter which OAuthAuthorizationCodes to update
     */
    where?: OAuthAuthorizationCodeWhereInput
  }


  /**
   * OAuthAuthorizationCode upsert
   */
  export type OAuthAuthorizationCodeUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAuthorizationCode
     */
    select?: OAuthAuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthAuthorizationCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the OAuthAuthorizationCode to update in case it exists.
     */
    where: OAuthAuthorizationCodeWhereUniqueInput
    /**
     * In case the OAuthAuthorizationCode found by the `where` argument doesn't exist, create a new OAuthAuthorizationCode with this data.
     */
    create: XOR<OAuthAuthorizationCodeCreateInput, OAuthAuthorizationCodeUncheckedCreateInput>
    /**
     * In case the OAuthAuthorizationCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OAuthAuthorizationCodeUpdateInput, OAuthAuthorizationCodeUncheckedUpdateInput>
  }


  /**
   * OAuthAuthorizationCode delete
   */
  export type OAuthAuthorizationCodeDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAuthorizationCode
     */
    select?: OAuthAuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthAuthorizationCodeInclude<ExtArgs> | null
    /**
     * Filter which OAuthAuthorizationCode to delete.
     */
    where: OAuthAuthorizationCodeWhereUniqueInput
  }


  /**
   * OAuthAuthorizationCode deleteMany
   */
  export type OAuthAuthorizationCodeDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthAuthorizationCodes to delete
     */
    where?: OAuthAuthorizationCodeWhereInput
  }


  /**
   * OAuthAuthorizationCode without action
   */
  export type OAuthAuthorizationCodeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAuthorizationCode
     */
    select?: OAuthAuthorizationCodeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthAuthorizationCodeInclude<ExtArgs> | null
  }



  /**
   * Model OAuthAccessToken
   */


  export type AggregateOAuthAccessToken = {
    _count: OAuthAccessTokenCountAggregateOutputType | null
    _min: OAuthAccessTokenMinAggregateOutputType | null
    _max: OAuthAccessTokenMaxAggregateOutputType | null
  }

  export type OAuthAccessTokenMinAggregateOutputType = {
    id: string | null
    tokenHash: string | null
    clientId: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type OAuthAccessTokenMaxAggregateOutputType = {
    id: string | null
    tokenHash: string | null
    clientId: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type OAuthAccessTokenCountAggregateOutputType = {
    id: number
    tokenHash: number
    clientId: number
    userId: number
    scopes: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type OAuthAccessTokenMinAggregateInputType = {
    id?: true
    tokenHash?: true
    clientId?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
  }

  export type OAuthAccessTokenMaxAggregateInputType = {
    id?: true
    tokenHash?: true
    clientId?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
  }

  export type OAuthAccessTokenCountAggregateInputType = {
    id?: true
    tokenHash?: true
    clientId?: true
    userId?: true
    scopes?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type OAuthAccessTokenAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthAccessToken to aggregate.
     */
    where?: OAuthAccessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthAccessTokens to fetch.
     */
    orderBy?: OAuthAccessTokenOrderByWithRelationInput | OAuthAccessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OAuthAccessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthAccessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthAccessTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OAuthAccessTokens
    **/
    _count?: true | OAuthAccessTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OAuthAccessTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OAuthAccessTokenMaxAggregateInputType
  }

  export type GetOAuthAccessTokenAggregateType<T extends OAuthAccessTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateOAuthAccessToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOAuthAccessToken[P]>
      : GetScalarType<T[P], AggregateOAuthAccessToken[P]>
  }




  export type OAuthAccessTokenGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OAuthAccessTokenWhereInput
    orderBy?: OAuthAccessTokenOrderByWithAggregationInput | OAuthAccessTokenOrderByWithAggregationInput[]
    by: OAuthAccessTokenScalarFieldEnum[] | OAuthAccessTokenScalarFieldEnum
    having?: OAuthAccessTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OAuthAccessTokenCountAggregateInputType | true
    _min?: OAuthAccessTokenMinAggregateInputType
    _max?: OAuthAccessTokenMaxAggregateInputType
  }


  export type OAuthAccessTokenGroupByOutputType = {
    id: string
    tokenHash: string
    clientId: string
    userId: string
    scopes: string[]
    expiresAt: Date
    createdAt: Date
    _count: OAuthAccessTokenCountAggregateOutputType | null
    _min: OAuthAccessTokenMinAggregateOutputType | null
    _max: OAuthAccessTokenMaxAggregateOutputType | null
  }

  type GetOAuthAccessTokenGroupByPayload<T extends OAuthAccessTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OAuthAccessTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OAuthAccessTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OAuthAccessTokenGroupByOutputType[P]>
            : GetScalarType<T[P], OAuthAccessTokenGroupByOutputType[P]>
        }
      >
    >


  export type OAuthAccessTokenSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenHash?: boolean
    clientId?: boolean
    userId?: boolean
    scopes?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    client?: boolean | OAuthClientArgs<ExtArgs>
    refreshToken?: boolean | OAuthAccessToken$refreshTokenArgs<ExtArgs>
    _count?: boolean | OAuthAccessTokenCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["oAuthAccessToken"]>

  export type OAuthAccessTokenSelectScalar = {
    id?: boolean
    tokenHash?: boolean
    clientId?: boolean
    userId?: boolean
    scopes?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type OAuthAccessTokenInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    client?: boolean | OAuthClientArgs<ExtArgs>
    refreshToken?: boolean | OAuthAccessToken$refreshTokenArgs<ExtArgs>
    _count?: boolean | OAuthAccessTokenCountOutputTypeArgs<ExtArgs>
  }


  type OAuthAccessTokenGetPayload<S extends boolean | null | undefined | OAuthAccessTokenArgs> = $Types.GetResult<OAuthAccessTokenPayload, S>

  type OAuthAccessTokenCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OAuthAccessTokenFindManyArgs, 'select' | 'include'> & {
      select?: OAuthAccessTokenCountAggregateInputType | true
    }

  export interface OAuthAccessTokenDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OAuthAccessToken'], meta: { name: 'OAuthAccessToken' } }
    /**
     * Find zero or one OAuthAccessToken that matches the filter.
     * @param {OAuthAccessTokenFindUniqueArgs} args - Arguments to find a OAuthAccessToken
     * @example
     * // Get one OAuthAccessToken
     * const oAuthAccessToken = await prisma.oAuthAccessToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OAuthAccessTokenFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthAccessTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__OAuthAccessTokenClient<$Types.GetResult<OAuthAccessTokenPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OAuthAccessToken that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OAuthAccessTokenFindUniqueOrThrowArgs} args - Arguments to find a OAuthAccessToken
     * @example
     * // Get one OAuthAccessToken
     * const oAuthAccessToken = await prisma.oAuthAccessToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OAuthAccessTokenFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthAccessTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OAuthAccessTokenClient<$Types.GetResult<OAuthAccessTokenPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OAuthAccessToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAccessTokenFindFirstArgs} args - Arguments to find a OAuthAccessToken
     * @example
     * // Get one OAuthAccessToken
     * const oAuthAccessToken = await prisma.oAuthAccessToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OAuthAccessTokenFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthAccessTokenFindFirstArgs<ExtArgs>>
    ): Prisma__OAuthAccessTokenClient<$Types.GetResult<OAuthAccessTokenPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OAuthAccessToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAccessTokenFindFirstOrThrowArgs} args - Arguments to find a OAuthAccessToken
     * @example
     * // Get one OAuthAccessToken
     * const oAuthAccessToken = await prisma.oAuthAccessToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OAuthAccessTokenFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthAccessTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OAuthAccessTokenClient<$Types.GetResult<OAuthAccessTokenPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OAuthAccessTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAccessTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OAuthAccessTokens
     * const oAuthAccessTokens = await prisma.oAuthAccessToken.findMany()
     * 
     * // Get first 10 OAuthAccessTokens
     * const oAuthAccessTokens = await prisma.oAuthAccessToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oAuthAccessTokenWithIdOnly = await prisma.oAuthAccessToken.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OAuthAccessTokenFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthAccessTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<OAuthAccessTokenPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OAuthAccessToken.
     * @param {OAuthAccessTokenCreateArgs} args - Arguments to create a OAuthAccessToken.
     * @example
     * // Create one OAuthAccessToken
     * const OAuthAccessToken = await prisma.oAuthAccessToken.create({
     *   data: {
     *     // ... data to create a OAuthAccessToken
     *   }
     * })
     * 
    **/
    create<T extends OAuthAccessTokenCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthAccessTokenCreateArgs<ExtArgs>>
    ): Prisma__OAuthAccessTokenClient<$Types.GetResult<OAuthAccessTokenPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OAuthAccessTokens.
     *     @param {OAuthAccessTokenCreateManyArgs} args - Arguments to create many OAuthAccessTokens.
     *     @example
     *     // Create many OAuthAccessTokens
     *     const oAuthAccessToken = await prisma.oAuthAccessToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OAuthAccessTokenCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthAccessTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OAuthAccessToken.
     * @param {OAuthAccessTokenDeleteArgs} args - Arguments to delete one OAuthAccessToken.
     * @example
     * // Delete one OAuthAccessToken
     * const OAuthAccessToken = await prisma.oAuthAccessToken.delete({
     *   where: {
     *     // ... filter to delete one OAuthAccessToken
     *   }
     * })
     * 
    **/
    delete<T extends OAuthAccessTokenDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthAccessTokenDeleteArgs<ExtArgs>>
    ): Prisma__OAuthAccessTokenClient<$Types.GetResult<OAuthAccessTokenPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OAuthAccessToken.
     * @param {OAuthAccessTokenUpdateArgs} args - Arguments to update one OAuthAccessToken.
     * @example
     * // Update one OAuthAccessToken
     * const oAuthAccessToken = await prisma.oAuthAccessToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OAuthAccessTokenUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthAccessTokenUpdateArgs<ExtArgs>>
    ): Prisma__OAuthAccessTokenClient<$Types.GetResult<OAuthAccessTokenPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OAuthAccessTokens.
     * @param {OAuthAccessTokenDeleteManyArgs} args - Arguments to filter OAuthAccessTokens to delete.
     * @example
     * // Delete a few OAuthAccessTokens
     * const { count } = await prisma.oAuthAccessToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OAuthAccessTokenDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthAccessTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OAuthAccessTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAccessTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OAuthAccessTokens
     * const oAuthAccessToken = await prisma.oAuthAccessToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OAuthAccessTokenUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthAccessTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OAuthAccessToken.
     * @param {OAuthAccessTokenUpsertArgs} args - Arguments to update or create a OAuthAccessToken.
     * @example
     * // Update or create a OAuthAccessToken
     * const oAuthAccessToken = await prisma.oAuthAccessToken.upsert({
     *   create: {
     *     // ... data to create a OAuthAccessToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OAuthAccessToken we want to update
     *   }
     * })
    **/
    upsert<T extends OAuthAccessTokenUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthAccessTokenUpsertArgs<ExtArgs>>
    ): Prisma__OAuthAccessTokenClient<$Types.GetResult<OAuthAccessTokenPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OAuthAccessTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAccessTokenCountArgs} args - Arguments to filter OAuthAccessTokens to count.
     * @example
     * // Count the number of OAuthAccessTokens
     * const count = await prisma.oAuthAccessToken.count({
     *   where: {
     *     // ... the filter for the OAuthAccessTokens we want to count
     *   }
     * })
    **/
    count<T extends OAuthAccessTokenCountArgs>(
      args?: Subset<T, OAuthAccessTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OAuthAccessTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OAuthAccessToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAccessTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OAuthAccessTokenAggregateArgs>(args: Subset<T, OAuthAccessTokenAggregateArgs>): Prisma.PrismaPromise<GetOAuthAccessTokenAggregateType<T>>

    /**
     * Group by OAuthAccessToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthAccessTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OAuthAccessTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OAuthAccessTokenGroupByArgs['orderBy'] }
        : { orderBy?: OAuthAccessTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OAuthAccessTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOAuthAccessTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OAuthAccessToken model
   */
  readonly fields: OAuthAccessTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OAuthAccessToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OAuthAccessTokenClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    client<T extends OAuthClientArgs<ExtArgs> = {}>(args?: Subset<T, OAuthClientArgs<ExtArgs>>): Prisma__OAuthClientClient<$Types.GetResult<OAuthClientPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    refreshToken<T extends OAuthAccessToken$refreshTokenArgs<ExtArgs> = {}>(args?: Subset<T, OAuthAccessToken$refreshTokenArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<OAuthRefreshTokenPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the OAuthAccessToken model
   */ 
  interface OAuthAccessTokenFieldRefs {
    readonly id: FieldRef<"OAuthAccessToken", 'String'>
    readonly tokenHash: FieldRef<"OAuthAccessToken", 'String'>
    readonly clientId: FieldRef<"OAuthAccessToken", 'String'>
    readonly userId: FieldRef<"OAuthAccessToken", 'String'>
    readonly scopes: FieldRef<"OAuthAccessToken", 'String[]'>
    readonly expiresAt: FieldRef<"OAuthAccessToken", 'DateTime'>
    readonly createdAt: FieldRef<"OAuthAccessToken", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * OAuthAccessToken findUnique
   */
  export type OAuthAccessTokenFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccessToken
     */
    select?: OAuthAccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthAccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which OAuthAccessToken to fetch.
     */
    where: OAuthAccessTokenWhereUniqueInput
  }


  /**
   * OAuthAccessToken findUniqueOrThrow
   */
  export type OAuthAccessTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccessToken
     */
    select?: OAuthAccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthAccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which OAuthAccessToken to fetch.
     */
    where: OAuthAccessTokenWhereUniqueInput
  }


  /**
   * OAuthAccessToken findFirst
   */
  export type OAuthAccessTokenFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccessToken
     */
    select?: OAuthAccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthAccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which OAuthAccessToken to fetch.
     */
    where?: OAuthAccessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthAccessTokens to fetch.
     */
    orderBy?: OAuthAccessTokenOrderByWithRelationInput | OAuthAccessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthAccessTokens.
     */
    cursor?: OAuthAccessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthAccessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthAccessTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthAccessTokens.
     */
    distinct?: OAuthAccessTokenScalarFieldEnum | OAuthAccessTokenScalarFieldEnum[]
  }


  /**
   * OAuthAccessToken findFirstOrThrow
   */
  export type OAuthAccessTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccessToken
     */
    select?: OAuthAccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthAccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which OAuthAccessToken to fetch.
     */
    where?: OAuthAccessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthAccessTokens to fetch.
     */
    orderBy?: OAuthAccessTokenOrderByWithRelationInput | OAuthAccessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthAccessTokens.
     */
    cursor?: OAuthAccessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthAccessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthAccessTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthAccessTokens.
     */
    distinct?: OAuthAccessTokenScalarFieldEnum | OAuthAccessTokenScalarFieldEnum[]
  }


  /**
   * OAuthAccessToken findMany
   */
  export type OAuthAccessTokenFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccessToken
     */
    select?: OAuthAccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthAccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which OAuthAccessTokens to fetch.
     */
    where?: OAuthAccessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthAccessTokens to fetch.
     */
    orderBy?: OAuthAccessTokenOrderByWithRelationInput | OAuthAccessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OAuthAccessTokens.
     */
    cursor?: OAuthAccessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthAccessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthAccessTokens.
     */
    skip?: number
    distinct?: OAuthAccessTokenScalarFieldEnum | OAuthAccessTokenScalarFieldEnum[]
  }


  /**
   * OAuthAccessToken create
   */
  export type OAuthAccessTokenCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccessToken
     */
    select?: OAuthAccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthAccessTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a OAuthAccessToken.
     */
    data: XOR<OAuthAccessTokenCreateInput, OAuthAccessTokenUncheckedCreateInput>
  }


  /**
   * OAuthAccessToken createMany
   */
  export type OAuthAccessTokenCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OAuthAccessTokens.
     */
    data: OAuthAccessTokenCreateManyInput | OAuthAccessTokenCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * OAuthAccessToken update
   */
  export type OAuthAccessTokenUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccessToken
     */
    select?: OAuthAccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthAccessTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a OAuthAccessToken.
     */
    data: XOR<OAuthAccessTokenUpdateInput, OAuthAccessTokenUncheckedUpdateInput>
    /**
     * Choose, which OAuthAccessToken to update.
     */
    where: OAuthAccessTokenWhereUniqueInput
  }


  /**
   * OAuthAccessToken updateMany
   */
  export type OAuthAccessTokenUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OAuthAccessTokens.
     */
    data: XOR<OAuthAccessTokenUpdateManyMutationInput, OAuthAccessTokenUncheckedUpdateManyInput>
    /**
     * Filter which OAuthAccessTokens to update
     */
    where?: OAuthAccessTokenWhereInput
  }


  /**
   * OAuthAccessToken upsert
   */
  export type OAuthAccessTokenUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccessToken
     */
    select?: OAuthAccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthAccessTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the OAuthAccessToken to update in case it exists.
     */
    where: OAuthAccessTokenWhereUniqueInput
    /**
     * In case the OAuthAccessToken found by the `where` argument doesn't exist, create a new OAuthAccessToken with this data.
     */
    create: XOR<OAuthAccessTokenCreateInput, OAuthAccessTokenUncheckedCreateInput>
    /**
     * In case the OAuthAccessToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OAuthAccessTokenUpdateInput, OAuthAccessTokenUncheckedUpdateInput>
  }


  /**
   * OAuthAccessToken delete
   */
  export type OAuthAccessTokenDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccessToken
     */
    select?: OAuthAccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthAccessTokenInclude<ExtArgs> | null
    /**
     * Filter which OAuthAccessToken to delete.
     */
    where: OAuthAccessTokenWhereUniqueInput
  }


  /**
   * OAuthAccessToken deleteMany
   */
  export type OAuthAccessTokenDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthAccessTokens to delete
     */
    where?: OAuthAccessTokenWhereInput
  }


  /**
   * OAuthAccessToken.refreshToken
   */
  export type OAuthAccessToken$refreshTokenArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthRefreshToken
     */
    select?: OAuthRefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthRefreshTokenInclude<ExtArgs> | null
    where?: OAuthRefreshTokenWhereInput
    orderBy?: OAuthRefreshTokenOrderByWithRelationInput | OAuthRefreshTokenOrderByWithRelationInput[]
    cursor?: OAuthRefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OAuthRefreshTokenScalarFieldEnum | OAuthRefreshTokenScalarFieldEnum[]
  }


  /**
   * OAuthAccessToken without action
   */
  export type OAuthAccessTokenArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthAccessToken
     */
    select?: OAuthAccessTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthAccessTokenInclude<ExtArgs> | null
  }



  /**
   * Model OAuthRefreshToken
   */


  export type AggregateOAuthRefreshToken = {
    _count: OAuthRefreshTokenCountAggregateOutputType | null
    _min: OAuthRefreshTokenMinAggregateOutputType | null
    _max: OAuthRefreshTokenMaxAggregateOutputType | null
  }

  export type OAuthRefreshTokenMinAggregateOutputType = {
    id: string | null
    tokenHash: string | null
    accessTokenId: string | null
    clientId: string | null
    userId: string | null
    expiresAt: Date | null
    isRevoked: boolean | null
    createdAt: Date | null
  }

  export type OAuthRefreshTokenMaxAggregateOutputType = {
    id: string | null
    tokenHash: string | null
    accessTokenId: string | null
    clientId: string | null
    userId: string | null
    expiresAt: Date | null
    isRevoked: boolean | null
    createdAt: Date | null
  }

  export type OAuthRefreshTokenCountAggregateOutputType = {
    id: number
    tokenHash: number
    accessTokenId: number
    clientId: number
    userId: number
    scopes: number
    expiresAt: number
    isRevoked: number
    createdAt: number
    _all: number
  }


  export type OAuthRefreshTokenMinAggregateInputType = {
    id?: true
    tokenHash?: true
    accessTokenId?: true
    clientId?: true
    userId?: true
    expiresAt?: true
    isRevoked?: true
    createdAt?: true
  }

  export type OAuthRefreshTokenMaxAggregateInputType = {
    id?: true
    tokenHash?: true
    accessTokenId?: true
    clientId?: true
    userId?: true
    expiresAt?: true
    isRevoked?: true
    createdAt?: true
  }

  export type OAuthRefreshTokenCountAggregateInputType = {
    id?: true
    tokenHash?: true
    accessTokenId?: true
    clientId?: true
    userId?: true
    scopes?: true
    expiresAt?: true
    isRevoked?: true
    createdAt?: true
    _all?: true
  }

  export type OAuthRefreshTokenAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthRefreshToken to aggregate.
     */
    where?: OAuthRefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthRefreshTokens to fetch.
     */
    orderBy?: OAuthRefreshTokenOrderByWithRelationInput | OAuthRefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OAuthRefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthRefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthRefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OAuthRefreshTokens
    **/
    _count?: true | OAuthRefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OAuthRefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OAuthRefreshTokenMaxAggregateInputType
  }

  export type GetOAuthRefreshTokenAggregateType<T extends OAuthRefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateOAuthRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOAuthRefreshToken[P]>
      : GetScalarType<T[P], AggregateOAuthRefreshToken[P]>
  }




  export type OAuthRefreshTokenGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OAuthRefreshTokenWhereInput
    orderBy?: OAuthRefreshTokenOrderByWithAggregationInput | OAuthRefreshTokenOrderByWithAggregationInput[]
    by: OAuthRefreshTokenScalarFieldEnum[] | OAuthRefreshTokenScalarFieldEnum
    having?: OAuthRefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OAuthRefreshTokenCountAggregateInputType | true
    _min?: OAuthRefreshTokenMinAggregateInputType
    _max?: OAuthRefreshTokenMaxAggregateInputType
  }


  export type OAuthRefreshTokenGroupByOutputType = {
    id: string
    tokenHash: string
    accessTokenId: string
    clientId: string
    userId: string
    scopes: string[]
    expiresAt: Date
    isRevoked: boolean
    createdAt: Date
    _count: OAuthRefreshTokenCountAggregateOutputType | null
    _min: OAuthRefreshTokenMinAggregateOutputType | null
    _max: OAuthRefreshTokenMaxAggregateOutputType | null
  }

  type GetOAuthRefreshTokenGroupByPayload<T extends OAuthRefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OAuthRefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OAuthRefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OAuthRefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], OAuthRefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type OAuthRefreshTokenSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tokenHash?: boolean
    accessTokenId?: boolean
    clientId?: boolean
    userId?: boolean
    scopes?: boolean
    expiresAt?: boolean
    isRevoked?: boolean
    createdAt?: boolean
    accessToken?: boolean | OAuthAccessTokenArgs<ExtArgs>
    client?: boolean | OAuthClientArgs<ExtArgs>
  }, ExtArgs["result"]["oAuthRefreshToken"]>

  export type OAuthRefreshTokenSelectScalar = {
    id?: boolean
    tokenHash?: boolean
    accessTokenId?: boolean
    clientId?: boolean
    userId?: boolean
    scopes?: boolean
    expiresAt?: boolean
    isRevoked?: boolean
    createdAt?: boolean
  }

  export type OAuthRefreshTokenInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    accessToken?: boolean | OAuthAccessTokenArgs<ExtArgs>
    client?: boolean | OAuthClientArgs<ExtArgs>
  }


  type OAuthRefreshTokenGetPayload<S extends boolean | null | undefined | OAuthRefreshTokenArgs> = $Types.GetResult<OAuthRefreshTokenPayload, S>

  type OAuthRefreshTokenCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OAuthRefreshTokenFindManyArgs, 'select' | 'include'> & {
      select?: OAuthRefreshTokenCountAggregateInputType | true
    }

  export interface OAuthRefreshTokenDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OAuthRefreshToken'], meta: { name: 'OAuthRefreshToken' } }
    /**
     * Find zero or one OAuthRefreshToken that matches the filter.
     * @param {OAuthRefreshTokenFindUniqueArgs} args - Arguments to find a OAuthRefreshToken
     * @example
     * // Get one OAuthRefreshToken
     * const oAuthRefreshToken = await prisma.oAuthRefreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OAuthRefreshTokenFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthRefreshTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__OAuthRefreshTokenClient<$Types.GetResult<OAuthRefreshTokenPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OAuthRefreshToken that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OAuthRefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a OAuthRefreshToken
     * @example
     * // Get one OAuthRefreshToken
     * const oAuthRefreshToken = await prisma.oAuthRefreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OAuthRefreshTokenFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthRefreshTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OAuthRefreshTokenClient<$Types.GetResult<OAuthRefreshTokenPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OAuthRefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthRefreshTokenFindFirstArgs} args - Arguments to find a OAuthRefreshToken
     * @example
     * // Get one OAuthRefreshToken
     * const oAuthRefreshToken = await prisma.oAuthRefreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OAuthRefreshTokenFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthRefreshTokenFindFirstArgs<ExtArgs>>
    ): Prisma__OAuthRefreshTokenClient<$Types.GetResult<OAuthRefreshTokenPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OAuthRefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthRefreshTokenFindFirstOrThrowArgs} args - Arguments to find a OAuthRefreshToken
     * @example
     * // Get one OAuthRefreshToken
     * const oAuthRefreshToken = await prisma.oAuthRefreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OAuthRefreshTokenFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthRefreshTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OAuthRefreshTokenClient<$Types.GetResult<OAuthRefreshTokenPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OAuthRefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthRefreshTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OAuthRefreshTokens
     * const oAuthRefreshTokens = await prisma.oAuthRefreshToken.findMany()
     * 
     * // Get first 10 OAuthRefreshTokens
     * const oAuthRefreshTokens = await prisma.oAuthRefreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oAuthRefreshTokenWithIdOnly = await prisma.oAuthRefreshToken.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OAuthRefreshTokenFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthRefreshTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<OAuthRefreshTokenPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OAuthRefreshToken.
     * @param {OAuthRefreshTokenCreateArgs} args - Arguments to create a OAuthRefreshToken.
     * @example
     * // Create one OAuthRefreshToken
     * const OAuthRefreshToken = await prisma.oAuthRefreshToken.create({
     *   data: {
     *     // ... data to create a OAuthRefreshToken
     *   }
     * })
     * 
    **/
    create<T extends OAuthRefreshTokenCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthRefreshTokenCreateArgs<ExtArgs>>
    ): Prisma__OAuthRefreshTokenClient<$Types.GetResult<OAuthRefreshTokenPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OAuthRefreshTokens.
     *     @param {OAuthRefreshTokenCreateManyArgs} args - Arguments to create many OAuthRefreshTokens.
     *     @example
     *     // Create many OAuthRefreshTokens
     *     const oAuthRefreshToken = await prisma.oAuthRefreshToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OAuthRefreshTokenCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthRefreshTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OAuthRefreshToken.
     * @param {OAuthRefreshTokenDeleteArgs} args - Arguments to delete one OAuthRefreshToken.
     * @example
     * // Delete one OAuthRefreshToken
     * const OAuthRefreshToken = await prisma.oAuthRefreshToken.delete({
     *   where: {
     *     // ... filter to delete one OAuthRefreshToken
     *   }
     * })
     * 
    **/
    delete<T extends OAuthRefreshTokenDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthRefreshTokenDeleteArgs<ExtArgs>>
    ): Prisma__OAuthRefreshTokenClient<$Types.GetResult<OAuthRefreshTokenPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OAuthRefreshToken.
     * @param {OAuthRefreshTokenUpdateArgs} args - Arguments to update one OAuthRefreshToken.
     * @example
     * // Update one OAuthRefreshToken
     * const oAuthRefreshToken = await prisma.oAuthRefreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OAuthRefreshTokenUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthRefreshTokenUpdateArgs<ExtArgs>>
    ): Prisma__OAuthRefreshTokenClient<$Types.GetResult<OAuthRefreshTokenPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OAuthRefreshTokens.
     * @param {OAuthRefreshTokenDeleteManyArgs} args - Arguments to filter OAuthRefreshTokens to delete.
     * @example
     * // Delete a few OAuthRefreshTokens
     * const { count } = await prisma.oAuthRefreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OAuthRefreshTokenDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OAuthRefreshTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OAuthRefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthRefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OAuthRefreshTokens
     * const oAuthRefreshToken = await prisma.oAuthRefreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OAuthRefreshTokenUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthRefreshTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OAuthRefreshToken.
     * @param {OAuthRefreshTokenUpsertArgs} args - Arguments to update or create a OAuthRefreshToken.
     * @example
     * // Update or create a OAuthRefreshToken
     * const oAuthRefreshToken = await prisma.oAuthRefreshToken.upsert({
     *   create: {
     *     // ... data to create a OAuthRefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OAuthRefreshToken we want to update
     *   }
     * })
    **/
    upsert<T extends OAuthRefreshTokenUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OAuthRefreshTokenUpsertArgs<ExtArgs>>
    ): Prisma__OAuthRefreshTokenClient<$Types.GetResult<OAuthRefreshTokenPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OAuthRefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthRefreshTokenCountArgs} args - Arguments to filter OAuthRefreshTokens to count.
     * @example
     * // Count the number of OAuthRefreshTokens
     * const count = await prisma.oAuthRefreshToken.count({
     *   where: {
     *     // ... the filter for the OAuthRefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends OAuthRefreshTokenCountArgs>(
      args?: Subset<T, OAuthRefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OAuthRefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OAuthRefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthRefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OAuthRefreshTokenAggregateArgs>(args: Subset<T, OAuthRefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetOAuthRefreshTokenAggregateType<T>>

    /**
     * Group by OAuthRefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OAuthRefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OAuthRefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OAuthRefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: OAuthRefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OAuthRefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOAuthRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OAuthRefreshToken model
   */
  readonly fields: OAuthRefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OAuthRefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OAuthRefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    accessToken<T extends OAuthAccessTokenArgs<ExtArgs> = {}>(args?: Subset<T, OAuthAccessTokenArgs<ExtArgs>>): Prisma__OAuthAccessTokenClient<$Types.GetResult<OAuthAccessTokenPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    client<T extends OAuthClientArgs<ExtArgs> = {}>(args?: Subset<T, OAuthClientArgs<ExtArgs>>): Prisma__OAuthClientClient<$Types.GetResult<OAuthClientPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the OAuthRefreshToken model
   */ 
  interface OAuthRefreshTokenFieldRefs {
    readonly id: FieldRef<"OAuthRefreshToken", 'String'>
    readonly tokenHash: FieldRef<"OAuthRefreshToken", 'String'>
    readonly accessTokenId: FieldRef<"OAuthRefreshToken", 'String'>
    readonly clientId: FieldRef<"OAuthRefreshToken", 'String'>
    readonly userId: FieldRef<"OAuthRefreshToken", 'String'>
    readonly scopes: FieldRef<"OAuthRefreshToken", 'String[]'>
    readonly expiresAt: FieldRef<"OAuthRefreshToken", 'DateTime'>
    readonly isRevoked: FieldRef<"OAuthRefreshToken", 'Boolean'>
    readonly createdAt: FieldRef<"OAuthRefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * OAuthRefreshToken findUnique
   */
  export type OAuthRefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthRefreshToken
     */
    select?: OAuthRefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthRefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which OAuthRefreshToken to fetch.
     */
    where: OAuthRefreshTokenWhereUniqueInput
  }


  /**
   * OAuthRefreshToken findUniqueOrThrow
   */
  export type OAuthRefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthRefreshToken
     */
    select?: OAuthRefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthRefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which OAuthRefreshToken to fetch.
     */
    where: OAuthRefreshTokenWhereUniqueInput
  }


  /**
   * OAuthRefreshToken findFirst
   */
  export type OAuthRefreshTokenFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthRefreshToken
     */
    select?: OAuthRefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthRefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which OAuthRefreshToken to fetch.
     */
    where?: OAuthRefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthRefreshTokens to fetch.
     */
    orderBy?: OAuthRefreshTokenOrderByWithRelationInput | OAuthRefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthRefreshTokens.
     */
    cursor?: OAuthRefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthRefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthRefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthRefreshTokens.
     */
    distinct?: OAuthRefreshTokenScalarFieldEnum | OAuthRefreshTokenScalarFieldEnum[]
  }


  /**
   * OAuthRefreshToken findFirstOrThrow
   */
  export type OAuthRefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthRefreshToken
     */
    select?: OAuthRefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthRefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which OAuthRefreshToken to fetch.
     */
    where?: OAuthRefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthRefreshTokens to fetch.
     */
    orderBy?: OAuthRefreshTokenOrderByWithRelationInput | OAuthRefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OAuthRefreshTokens.
     */
    cursor?: OAuthRefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthRefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthRefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OAuthRefreshTokens.
     */
    distinct?: OAuthRefreshTokenScalarFieldEnum | OAuthRefreshTokenScalarFieldEnum[]
  }


  /**
   * OAuthRefreshToken findMany
   */
  export type OAuthRefreshTokenFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthRefreshToken
     */
    select?: OAuthRefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthRefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which OAuthRefreshTokens to fetch.
     */
    where?: OAuthRefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OAuthRefreshTokens to fetch.
     */
    orderBy?: OAuthRefreshTokenOrderByWithRelationInput | OAuthRefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OAuthRefreshTokens.
     */
    cursor?: OAuthRefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OAuthRefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OAuthRefreshTokens.
     */
    skip?: number
    distinct?: OAuthRefreshTokenScalarFieldEnum | OAuthRefreshTokenScalarFieldEnum[]
  }


  /**
   * OAuthRefreshToken create
   */
  export type OAuthRefreshTokenCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthRefreshToken
     */
    select?: OAuthRefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthRefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a OAuthRefreshToken.
     */
    data: XOR<OAuthRefreshTokenCreateInput, OAuthRefreshTokenUncheckedCreateInput>
  }


  /**
   * OAuthRefreshToken createMany
   */
  export type OAuthRefreshTokenCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OAuthRefreshTokens.
     */
    data: OAuthRefreshTokenCreateManyInput | OAuthRefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * OAuthRefreshToken update
   */
  export type OAuthRefreshTokenUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthRefreshToken
     */
    select?: OAuthRefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthRefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a OAuthRefreshToken.
     */
    data: XOR<OAuthRefreshTokenUpdateInput, OAuthRefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which OAuthRefreshToken to update.
     */
    where: OAuthRefreshTokenWhereUniqueInput
  }


  /**
   * OAuthRefreshToken updateMany
   */
  export type OAuthRefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OAuthRefreshTokens.
     */
    data: XOR<OAuthRefreshTokenUpdateManyMutationInput, OAuthRefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which OAuthRefreshTokens to update
     */
    where?: OAuthRefreshTokenWhereInput
  }


  /**
   * OAuthRefreshToken upsert
   */
  export type OAuthRefreshTokenUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthRefreshToken
     */
    select?: OAuthRefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthRefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the OAuthRefreshToken to update in case it exists.
     */
    where: OAuthRefreshTokenWhereUniqueInput
    /**
     * In case the OAuthRefreshToken found by the `where` argument doesn't exist, create a new OAuthRefreshToken with this data.
     */
    create: XOR<OAuthRefreshTokenCreateInput, OAuthRefreshTokenUncheckedCreateInput>
    /**
     * In case the OAuthRefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OAuthRefreshTokenUpdateInput, OAuthRefreshTokenUncheckedUpdateInput>
  }


  /**
   * OAuthRefreshToken delete
   */
  export type OAuthRefreshTokenDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthRefreshToken
     */
    select?: OAuthRefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthRefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which OAuthRefreshToken to delete.
     */
    where: OAuthRefreshTokenWhereUniqueInput
  }


  /**
   * OAuthRefreshToken deleteMany
   */
  export type OAuthRefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OAuthRefreshTokens to delete
     */
    where?: OAuthRefreshTokenWhereInput
  }


  /**
   * OAuthRefreshToken without action
   */
  export type OAuthRefreshTokenArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OAuthRefreshToken
     */
    select?: OAuthRefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OAuthRefreshTokenInclude<ExtArgs> | null
  }



  /**
   * Model DownloadTask
   */


  export type AggregateDownloadTask = {
    _count: DownloadTaskCountAggregateOutputType | null
    _avg: DownloadTaskAvgAggregateOutputType | null
    _sum: DownloadTaskSumAggregateOutputType | null
    _min: DownloadTaskMinAggregateOutputType | null
    _max: DownloadTaskMaxAggregateOutputType | null
  }

  export type DownloadTaskAvgAggregateOutputType = {
    retry_count: number | null
  }

  export type DownloadTaskSumAggregateOutputType = {
    retry_count: number | null
  }

  export type DownloadTaskMinAggregateOutputType = {
    id: string | null
    type: string | null
    priority: string | null
    status: string | null
    created_at: Date | null
    started_at: Date | null
    completed_at: Date | null
    error: string | null
    retry_count: number | null
  }

  export type DownloadTaskMaxAggregateOutputType = {
    id: string | null
    type: string | null
    priority: string | null
    status: string | null
    created_at: Date | null
    started_at: Date | null
    completed_at: Date | null
    error: string | null
    retry_count: number | null
  }

  export type DownloadTaskCountAggregateOutputType = {
    id: number
    type: number
    source: number
    options: number
    priority: number
    status: number
    progress: number
    metadata: number
    created_at: number
    started_at: number
    completed_at: number
    error: number
    retry_count: number
    _all: number
  }


  export type DownloadTaskAvgAggregateInputType = {
    retry_count?: true
  }

  export type DownloadTaskSumAggregateInputType = {
    retry_count?: true
  }

  export type DownloadTaskMinAggregateInputType = {
    id?: true
    type?: true
    priority?: true
    status?: true
    created_at?: true
    started_at?: true
    completed_at?: true
    error?: true
    retry_count?: true
  }

  export type DownloadTaskMaxAggregateInputType = {
    id?: true
    type?: true
    priority?: true
    status?: true
    created_at?: true
    started_at?: true
    completed_at?: true
    error?: true
    retry_count?: true
  }

  export type DownloadTaskCountAggregateInputType = {
    id?: true
    type?: true
    source?: true
    options?: true
    priority?: true
    status?: true
    progress?: true
    metadata?: true
    created_at?: true
    started_at?: true
    completed_at?: true
    error?: true
    retry_count?: true
    _all?: true
  }

  export type DownloadTaskAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DownloadTask to aggregate.
     */
    where?: DownloadTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DownloadTasks to fetch.
     */
    orderBy?: DownloadTaskOrderByWithRelationInput | DownloadTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DownloadTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DownloadTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DownloadTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DownloadTasks
    **/
    _count?: true | DownloadTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DownloadTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DownloadTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DownloadTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DownloadTaskMaxAggregateInputType
  }

  export type GetDownloadTaskAggregateType<T extends DownloadTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateDownloadTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDownloadTask[P]>
      : GetScalarType<T[P], AggregateDownloadTask[P]>
  }




  export type DownloadTaskGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DownloadTaskWhereInput
    orderBy?: DownloadTaskOrderByWithAggregationInput | DownloadTaskOrderByWithAggregationInput[]
    by: DownloadTaskScalarFieldEnum[] | DownloadTaskScalarFieldEnum
    having?: DownloadTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DownloadTaskCountAggregateInputType | true
    _avg?: DownloadTaskAvgAggregateInputType
    _sum?: DownloadTaskSumAggregateInputType
    _min?: DownloadTaskMinAggregateInputType
    _max?: DownloadTaskMaxAggregateInputType
  }


  export type DownloadTaskGroupByOutputType = {
    id: string
    type: string
    source: JsonValue
    options: JsonValue
    priority: string
    status: string
    progress: JsonValue
    metadata: JsonValue | null
    created_at: Date
    started_at: Date | null
    completed_at: Date | null
    error: string | null
    retry_count: number
    _count: DownloadTaskCountAggregateOutputType | null
    _avg: DownloadTaskAvgAggregateOutputType | null
    _sum: DownloadTaskSumAggregateOutputType | null
    _min: DownloadTaskMinAggregateOutputType | null
    _max: DownloadTaskMaxAggregateOutputType | null
  }

  type GetDownloadTaskGroupByPayload<T extends DownloadTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DownloadTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DownloadTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DownloadTaskGroupByOutputType[P]>
            : GetScalarType<T[P], DownloadTaskGroupByOutputType[P]>
        }
      >
    >


  export type DownloadTaskSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    source?: boolean
    options?: boolean
    priority?: boolean
    status?: boolean
    progress?: boolean
    metadata?: boolean
    created_at?: boolean
    started_at?: boolean
    completed_at?: boolean
    error?: boolean
    retry_count?: boolean
    downloadResults?: boolean | DownloadTask$downloadResultsArgs<ExtArgs>
    _count?: boolean | DownloadTaskCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["downloadTask"]>

  export type DownloadTaskSelectScalar = {
    id?: boolean
    type?: boolean
    source?: boolean
    options?: boolean
    priority?: boolean
    status?: boolean
    progress?: boolean
    metadata?: boolean
    created_at?: boolean
    started_at?: boolean
    completed_at?: boolean
    error?: boolean
    retry_count?: boolean
  }

  export type DownloadTaskInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    downloadResults?: boolean | DownloadTask$downloadResultsArgs<ExtArgs>
    _count?: boolean | DownloadTaskCountOutputTypeArgs<ExtArgs>
  }


  type DownloadTaskGetPayload<S extends boolean | null | undefined | DownloadTaskArgs> = $Types.GetResult<DownloadTaskPayload, S>

  type DownloadTaskCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DownloadTaskFindManyArgs, 'select' | 'include'> & {
      select?: DownloadTaskCountAggregateInputType | true
    }

  export interface DownloadTaskDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DownloadTask'], meta: { name: 'DownloadTask' } }
    /**
     * Find zero or one DownloadTask that matches the filter.
     * @param {DownloadTaskFindUniqueArgs} args - Arguments to find a DownloadTask
     * @example
     * // Get one DownloadTask
     * const downloadTask = await prisma.downloadTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DownloadTaskFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DownloadTaskFindUniqueArgs<ExtArgs>>
    ): Prisma__DownloadTaskClient<$Types.GetResult<DownloadTaskPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DownloadTask that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DownloadTaskFindUniqueOrThrowArgs} args - Arguments to find a DownloadTask
     * @example
     * // Get one DownloadTask
     * const downloadTask = await prisma.downloadTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DownloadTaskFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DownloadTaskFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DownloadTaskClient<$Types.GetResult<DownloadTaskPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DownloadTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadTaskFindFirstArgs} args - Arguments to find a DownloadTask
     * @example
     * // Get one DownloadTask
     * const downloadTask = await prisma.downloadTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DownloadTaskFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DownloadTaskFindFirstArgs<ExtArgs>>
    ): Prisma__DownloadTaskClient<$Types.GetResult<DownloadTaskPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DownloadTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadTaskFindFirstOrThrowArgs} args - Arguments to find a DownloadTask
     * @example
     * // Get one DownloadTask
     * const downloadTask = await prisma.downloadTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DownloadTaskFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DownloadTaskFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DownloadTaskClient<$Types.GetResult<DownloadTaskPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DownloadTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadTaskFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DownloadTasks
     * const downloadTasks = await prisma.downloadTask.findMany()
     * 
     * // Get first 10 DownloadTasks
     * const downloadTasks = await prisma.downloadTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const downloadTaskWithIdOnly = await prisma.downloadTask.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DownloadTaskFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DownloadTaskFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DownloadTaskPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DownloadTask.
     * @param {DownloadTaskCreateArgs} args - Arguments to create a DownloadTask.
     * @example
     * // Create one DownloadTask
     * const DownloadTask = await prisma.downloadTask.create({
     *   data: {
     *     // ... data to create a DownloadTask
     *   }
     * })
     * 
    **/
    create<T extends DownloadTaskCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DownloadTaskCreateArgs<ExtArgs>>
    ): Prisma__DownloadTaskClient<$Types.GetResult<DownloadTaskPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DownloadTasks.
     *     @param {DownloadTaskCreateManyArgs} args - Arguments to create many DownloadTasks.
     *     @example
     *     // Create many DownloadTasks
     *     const downloadTask = await prisma.downloadTask.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DownloadTaskCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DownloadTaskCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DownloadTask.
     * @param {DownloadTaskDeleteArgs} args - Arguments to delete one DownloadTask.
     * @example
     * // Delete one DownloadTask
     * const DownloadTask = await prisma.downloadTask.delete({
     *   where: {
     *     // ... filter to delete one DownloadTask
     *   }
     * })
     * 
    **/
    delete<T extends DownloadTaskDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DownloadTaskDeleteArgs<ExtArgs>>
    ): Prisma__DownloadTaskClient<$Types.GetResult<DownloadTaskPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DownloadTask.
     * @param {DownloadTaskUpdateArgs} args - Arguments to update one DownloadTask.
     * @example
     * // Update one DownloadTask
     * const downloadTask = await prisma.downloadTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DownloadTaskUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DownloadTaskUpdateArgs<ExtArgs>>
    ): Prisma__DownloadTaskClient<$Types.GetResult<DownloadTaskPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DownloadTasks.
     * @param {DownloadTaskDeleteManyArgs} args - Arguments to filter DownloadTasks to delete.
     * @example
     * // Delete a few DownloadTasks
     * const { count } = await prisma.downloadTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DownloadTaskDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DownloadTaskDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DownloadTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DownloadTasks
     * const downloadTask = await prisma.downloadTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DownloadTaskUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DownloadTaskUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DownloadTask.
     * @param {DownloadTaskUpsertArgs} args - Arguments to update or create a DownloadTask.
     * @example
     * // Update or create a DownloadTask
     * const downloadTask = await prisma.downloadTask.upsert({
     *   create: {
     *     // ... data to create a DownloadTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DownloadTask we want to update
     *   }
     * })
    **/
    upsert<T extends DownloadTaskUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DownloadTaskUpsertArgs<ExtArgs>>
    ): Prisma__DownloadTaskClient<$Types.GetResult<DownloadTaskPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DownloadTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadTaskCountArgs} args - Arguments to filter DownloadTasks to count.
     * @example
     * // Count the number of DownloadTasks
     * const count = await prisma.downloadTask.count({
     *   where: {
     *     // ... the filter for the DownloadTasks we want to count
     *   }
     * })
    **/
    count<T extends DownloadTaskCountArgs>(
      args?: Subset<T, DownloadTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DownloadTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DownloadTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DownloadTaskAggregateArgs>(args: Subset<T, DownloadTaskAggregateArgs>): Prisma.PrismaPromise<GetDownloadTaskAggregateType<T>>

    /**
     * Group by DownloadTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DownloadTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DownloadTaskGroupByArgs['orderBy'] }
        : { orderBy?: DownloadTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DownloadTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDownloadTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DownloadTask model
   */
  readonly fields: DownloadTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DownloadTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DownloadTaskClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    downloadResults<T extends DownloadTask$downloadResultsArgs<ExtArgs> = {}>(args?: Subset<T, DownloadTask$downloadResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DownloadResultPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the DownloadTask model
   */ 
  interface DownloadTaskFieldRefs {
    readonly id: FieldRef<"DownloadTask", 'String'>
    readonly type: FieldRef<"DownloadTask", 'String'>
    readonly source: FieldRef<"DownloadTask", 'Json'>
    readonly options: FieldRef<"DownloadTask", 'Json'>
    readonly priority: FieldRef<"DownloadTask", 'String'>
    readonly status: FieldRef<"DownloadTask", 'String'>
    readonly progress: FieldRef<"DownloadTask", 'Json'>
    readonly metadata: FieldRef<"DownloadTask", 'Json'>
    readonly created_at: FieldRef<"DownloadTask", 'DateTime'>
    readonly started_at: FieldRef<"DownloadTask", 'DateTime'>
    readonly completed_at: FieldRef<"DownloadTask", 'DateTime'>
    readonly error: FieldRef<"DownloadTask", 'String'>
    readonly retry_count: FieldRef<"DownloadTask", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * DownloadTask findUnique
   */
  export type DownloadTaskFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadTask
     */
    select?: DownloadTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DownloadTaskInclude<ExtArgs> | null
    /**
     * Filter, which DownloadTask to fetch.
     */
    where: DownloadTaskWhereUniqueInput
  }


  /**
   * DownloadTask findUniqueOrThrow
   */
  export type DownloadTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadTask
     */
    select?: DownloadTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DownloadTaskInclude<ExtArgs> | null
    /**
     * Filter, which DownloadTask to fetch.
     */
    where: DownloadTaskWhereUniqueInput
  }


  /**
   * DownloadTask findFirst
   */
  export type DownloadTaskFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadTask
     */
    select?: DownloadTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DownloadTaskInclude<ExtArgs> | null
    /**
     * Filter, which DownloadTask to fetch.
     */
    where?: DownloadTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DownloadTasks to fetch.
     */
    orderBy?: DownloadTaskOrderByWithRelationInput | DownloadTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DownloadTasks.
     */
    cursor?: DownloadTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DownloadTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DownloadTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DownloadTasks.
     */
    distinct?: DownloadTaskScalarFieldEnum | DownloadTaskScalarFieldEnum[]
  }


  /**
   * DownloadTask findFirstOrThrow
   */
  export type DownloadTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadTask
     */
    select?: DownloadTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DownloadTaskInclude<ExtArgs> | null
    /**
     * Filter, which DownloadTask to fetch.
     */
    where?: DownloadTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DownloadTasks to fetch.
     */
    orderBy?: DownloadTaskOrderByWithRelationInput | DownloadTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DownloadTasks.
     */
    cursor?: DownloadTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DownloadTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DownloadTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DownloadTasks.
     */
    distinct?: DownloadTaskScalarFieldEnum | DownloadTaskScalarFieldEnum[]
  }


  /**
   * DownloadTask findMany
   */
  export type DownloadTaskFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadTask
     */
    select?: DownloadTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DownloadTaskInclude<ExtArgs> | null
    /**
     * Filter, which DownloadTasks to fetch.
     */
    where?: DownloadTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DownloadTasks to fetch.
     */
    orderBy?: DownloadTaskOrderByWithRelationInput | DownloadTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DownloadTasks.
     */
    cursor?: DownloadTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DownloadTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DownloadTasks.
     */
    skip?: number
    distinct?: DownloadTaskScalarFieldEnum | DownloadTaskScalarFieldEnum[]
  }


  /**
   * DownloadTask create
   */
  export type DownloadTaskCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadTask
     */
    select?: DownloadTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DownloadTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a DownloadTask.
     */
    data: XOR<DownloadTaskCreateInput, DownloadTaskUncheckedCreateInput>
  }


  /**
   * DownloadTask createMany
   */
  export type DownloadTaskCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DownloadTasks.
     */
    data: DownloadTaskCreateManyInput | DownloadTaskCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * DownloadTask update
   */
  export type DownloadTaskUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadTask
     */
    select?: DownloadTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DownloadTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a DownloadTask.
     */
    data: XOR<DownloadTaskUpdateInput, DownloadTaskUncheckedUpdateInput>
    /**
     * Choose, which DownloadTask to update.
     */
    where: DownloadTaskWhereUniqueInput
  }


  /**
   * DownloadTask updateMany
   */
  export type DownloadTaskUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DownloadTasks.
     */
    data: XOR<DownloadTaskUpdateManyMutationInput, DownloadTaskUncheckedUpdateManyInput>
    /**
     * Filter which DownloadTasks to update
     */
    where?: DownloadTaskWhereInput
  }


  /**
   * DownloadTask upsert
   */
  export type DownloadTaskUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadTask
     */
    select?: DownloadTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DownloadTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the DownloadTask to update in case it exists.
     */
    where: DownloadTaskWhereUniqueInput
    /**
     * In case the DownloadTask found by the `where` argument doesn't exist, create a new DownloadTask with this data.
     */
    create: XOR<DownloadTaskCreateInput, DownloadTaskUncheckedCreateInput>
    /**
     * In case the DownloadTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DownloadTaskUpdateInput, DownloadTaskUncheckedUpdateInput>
  }


  /**
   * DownloadTask delete
   */
  export type DownloadTaskDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadTask
     */
    select?: DownloadTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DownloadTaskInclude<ExtArgs> | null
    /**
     * Filter which DownloadTask to delete.
     */
    where: DownloadTaskWhereUniqueInput
  }


  /**
   * DownloadTask deleteMany
   */
  export type DownloadTaskDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DownloadTasks to delete
     */
    where?: DownloadTaskWhereInput
  }


  /**
   * DownloadTask.downloadResults
   */
  export type DownloadTask$downloadResultsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadResult
     */
    select?: DownloadResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DownloadResultInclude<ExtArgs> | null
    where?: DownloadResultWhereInput
    orderBy?: DownloadResultOrderByWithRelationInput | DownloadResultOrderByWithRelationInput[]
    cursor?: DownloadResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DownloadResultScalarFieldEnum | DownloadResultScalarFieldEnum[]
  }


  /**
   * DownloadTask without action
   */
  export type DownloadTaskArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadTask
     */
    select?: DownloadTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DownloadTaskInclude<ExtArgs> | null
  }



  /**
   * Model DownloadResult
   */


  export type AggregateDownloadResult = {
    _count: DownloadResultCountAggregateOutputType | null
    _min: DownloadResultMinAggregateOutputType | null
    _max: DownloadResultMaxAggregateOutputType | null
  }

  export type DownloadResultMinAggregateOutputType = {
    id: string | null
    task_id: string | null
    success: boolean | null
    local_path: string | null
    created_at: Date | null
  }

  export type DownloadResultMaxAggregateOutputType = {
    id: string | null
    task_id: string | null
    success: boolean | null
    local_path: string | null
    created_at: Date | null
  }

  export type DownloadResultCountAggregateOutputType = {
    id: number
    task_id: number
    success: number
    local_path: number
    metadata: number
    files: number
    errors: number
    created_at: number
    _all: number
  }


  export type DownloadResultMinAggregateInputType = {
    id?: true
    task_id?: true
    success?: true
    local_path?: true
    created_at?: true
  }

  export type DownloadResultMaxAggregateInputType = {
    id?: true
    task_id?: true
    success?: true
    local_path?: true
    created_at?: true
  }

  export type DownloadResultCountAggregateInputType = {
    id?: true
    task_id?: true
    success?: true
    local_path?: true
    metadata?: true
    files?: true
    errors?: true
    created_at?: true
    _all?: true
  }

  export type DownloadResultAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DownloadResult to aggregate.
     */
    where?: DownloadResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DownloadResults to fetch.
     */
    orderBy?: DownloadResultOrderByWithRelationInput | DownloadResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DownloadResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DownloadResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DownloadResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DownloadResults
    **/
    _count?: true | DownloadResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DownloadResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DownloadResultMaxAggregateInputType
  }

  export type GetDownloadResultAggregateType<T extends DownloadResultAggregateArgs> = {
        [P in keyof T & keyof AggregateDownloadResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDownloadResult[P]>
      : GetScalarType<T[P], AggregateDownloadResult[P]>
  }




  export type DownloadResultGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DownloadResultWhereInput
    orderBy?: DownloadResultOrderByWithAggregationInput | DownloadResultOrderByWithAggregationInput[]
    by: DownloadResultScalarFieldEnum[] | DownloadResultScalarFieldEnum
    having?: DownloadResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DownloadResultCountAggregateInputType | true
    _min?: DownloadResultMinAggregateInputType
    _max?: DownloadResultMaxAggregateInputType
  }


  export type DownloadResultGroupByOutputType = {
    id: string
    task_id: string
    success: boolean
    local_path: string
    metadata: JsonValue
    files: JsonValue
    errors: string[]
    created_at: Date
    _count: DownloadResultCountAggregateOutputType | null
    _min: DownloadResultMinAggregateOutputType | null
    _max: DownloadResultMaxAggregateOutputType | null
  }

  type GetDownloadResultGroupByPayload<T extends DownloadResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DownloadResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DownloadResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DownloadResultGroupByOutputType[P]>
            : GetScalarType<T[P], DownloadResultGroupByOutputType[P]>
        }
      >
    >


  export type DownloadResultSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    task_id?: boolean
    success?: boolean
    local_path?: boolean
    metadata?: boolean
    files?: boolean
    errors?: boolean
    created_at?: boolean
    downloadTask?: boolean | DownloadTaskArgs<ExtArgs>
  }, ExtArgs["result"]["downloadResult"]>

  export type DownloadResultSelectScalar = {
    id?: boolean
    task_id?: boolean
    success?: boolean
    local_path?: boolean
    metadata?: boolean
    files?: boolean
    errors?: boolean
    created_at?: boolean
  }

  export type DownloadResultInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    downloadTask?: boolean | DownloadTaskArgs<ExtArgs>
  }


  type DownloadResultGetPayload<S extends boolean | null | undefined | DownloadResultArgs> = $Types.GetResult<DownloadResultPayload, S>

  type DownloadResultCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DownloadResultFindManyArgs, 'select' | 'include'> & {
      select?: DownloadResultCountAggregateInputType | true
    }

  export interface DownloadResultDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DownloadResult'], meta: { name: 'DownloadResult' } }
    /**
     * Find zero or one DownloadResult that matches the filter.
     * @param {DownloadResultFindUniqueArgs} args - Arguments to find a DownloadResult
     * @example
     * // Get one DownloadResult
     * const downloadResult = await prisma.downloadResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DownloadResultFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DownloadResultFindUniqueArgs<ExtArgs>>
    ): Prisma__DownloadResultClient<$Types.GetResult<DownloadResultPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DownloadResult that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DownloadResultFindUniqueOrThrowArgs} args - Arguments to find a DownloadResult
     * @example
     * // Get one DownloadResult
     * const downloadResult = await prisma.downloadResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DownloadResultFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DownloadResultFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DownloadResultClient<$Types.GetResult<DownloadResultPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DownloadResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadResultFindFirstArgs} args - Arguments to find a DownloadResult
     * @example
     * // Get one DownloadResult
     * const downloadResult = await prisma.downloadResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DownloadResultFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DownloadResultFindFirstArgs<ExtArgs>>
    ): Prisma__DownloadResultClient<$Types.GetResult<DownloadResultPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DownloadResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadResultFindFirstOrThrowArgs} args - Arguments to find a DownloadResult
     * @example
     * // Get one DownloadResult
     * const downloadResult = await prisma.downloadResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DownloadResultFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DownloadResultFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DownloadResultClient<$Types.GetResult<DownloadResultPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DownloadResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadResultFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DownloadResults
     * const downloadResults = await prisma.downloadResult.findMany()
     * 
     * // Get first 10 DownloadResults
     * const downloadResults = await prisma.downloadResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const downloadResultWithIdOnly = await prisma.downloadResult.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DownloadResultFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DownloadResultFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DownloadResultPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DownloadResult.
     * @param {DownloadResultCreateArgs} args - Arguments to create a DownloadResult.
     * @example
     * // Create one DownloadResult
     * const DownloadResult = await prisma.downloadResult.create({
     *   data: {
     *     // ... data to create a DownloadResult
     *   }
     * })
     * 
    **/
    create<T extends DownloadResultCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DownloadResultCreateArgs<ExtArgs>>
    ): Prisma__DownloadResultClient<$Types.GetResult<DownloadResultPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DownloadResults.
     *     @param {DownloadResultCreateManyArgs} args - Arguments to create many DownloadResults.
     *     @example
     *     // Create many DownloadResults
     *     const downloadResult = await prisma.downloadResult.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DownloadResultCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DownloadResultCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DownloadResult.
     * @param {DownloadResultDeleteArgs} args - Arguments to delete one DownloadResult.
     * @example
     * // Delete one DownloadResult
     * const DownloadResult = await prisma.downloadResult.delete({
     *   where: {
     *     // ... filter to delete one DownloadResult
     *   }
     * })
     * 
    **/
    delete<T extends DownloadResultDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DownloadResultDeleteArgs<ExtArgs>>
    ): Prisma__DownloadResultClient<$Types.GetResult<DownloadResultPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DownloadResult.
     * @param {DownloadResultUpdateArgs} args - Arguments to update one DownloadResult.
     * @example
     * // Update one DownloadResult
     * const downloadResult = await prisma.downloadResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DownloadResultUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DownloadResultUpdateArgs<ExtArgs>>
    ): Prisma__DownloadResultClient<$Types.GetResult<DownloadResultPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DownloadResults.
     * @param {DownloadResultDeleteManyArgs} args - Arguments to filter DownloadResults to delete.
     * @example
     * // Delete a few DownloadResults
     * const { count } = await prisma.downloadResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DownloadResultDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DownloadResultDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DownloadResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DownloadResults
     * const downloadResult = await prisma.downloadResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DownloadResultUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DownloadResultUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DownloadResult.
     * @param {DownloadResultUpsertArgs} args - Arguments to update or create a DownloadResult.
     * @example
     * // Update or create a DownloadResult
     * const downloadResult = await prisma.downloadResult.upsert({
     *   create: {
     *     // ... data to create a DownloadResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DownloadResult we want to update
     *   }
     * })
    **/
    upsert<T extends DownloadResultUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DownloadResultUpsertArgs<ExtArgs>>
    ): Prisma__DownloadResultClient<$Types.GetResult<DownloadResultPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of DownloadResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadResultCountArgs} args - Arguments to filter DownloadResults to count.
     * @example
     * // Count the number of DownloadResults
     * const count = await prisma.downloadResult.count({
     *   where: {
     *     // ... the filter for the DownloadResults we want to count
     *   }
     * })
    **/
    count<T extends DownloadResultCountArgs>(
      args?: Subset<T, DownloadResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DownloadResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DownloadResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DownloadResultAggregateArgs>(args: Subset<T, DownloadResultAggregateArgs>): Prisma.PrismaPromise<GetDownloadResultAggregateType<T>>

    /**
     * Group by DownloadResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DownloadResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DownloadResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DownloadResultGroupByArgs['orderBy'] }
        : { orderBy?: DownloadResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DownloadResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDownloadResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DownloadResult model
   */
  readonly fields: DownloadResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DownloadResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DownloadResultClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    downloadTask<T extends DownloadTaskArgs<ExtArgs> = {}>(args?: Subset<T, DownloadTaskArgs<ExtArgs>>): Prisma__DownloadTaskClient<$Types.GetResult<DownloadTaskPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the DownloadResult model
   */ 
  interface DownloadResultFieldRefs {
    readonly id: FieldRef<"DownloadResult", 'String'>
    readonly task_id: FieldRef<"DownloadResult", 'String'>
    readonly success: FieldRef<"DownloadResult", 'Boolean'>
    readonly local_path: FieldRef<"DownloadResult", 'String'>
    readonly metadata: FieldRef<"DownloadResult", 'Json'>
    readonly files: FieldRef<"DownloadResult", 'Json'>
    readonly errors: FieldRef<"DownloadResult", 'String[]'>
    readonly created_at: FieldRef<"DownloadResult", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * DownloadResult findUnique
   */
  export type DownloadResultFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadResult
     */
    select?: DownloadResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DownloadResultInclude<ExtArgs> | null
    /**
     * Filter, which DownloadResult to fetch.
     */
    where: DownloadResultWhereUniqueInput
  }


  /**
   * DownloadResult findUniqueOrThrow
   */
  export type DownloadResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadResult
     */
    select?: DownloadResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DownloadResultInclude<ExtArgs> | null
    /**
     * Filter, which DownloadResult to fetch.
     */
    where: DownloadResultWhereUniqueInput
  }


  /**
   * DownloadResult findFirst
   */
  export type DownloadResultFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadResult
     */
    select?: DownloadResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DownloadResultInclude<ExtArgs> | null
    /**
     * Filter, which DownloadResult to fetch.
     */
    where?: DownloadResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DownloadResults to fetch.
     */
    orderBy?: DownloadResultOrderByWithRelationInput | DownloadResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DownloadResults.
     */
    cursor?: DownloadResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DownloadResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DownloadResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DownloadResults.
     */
    distinct?: DownloadResultScalarFieldEnum | DownloadResultScalarFieldEnum[]
  }


  /**
   * DownloadResult findFirstOrThrow
   */
  export type DownloadResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadResult
     */
    select?: DownloadResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DownloadResultInclude<ExtArgs> | null
    /**
     * Filter, which DownloadResult to fetch.
     */
    where?: DownloadResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DownloadResults to fetch.
     */
    orderBy?: DownloadResultOrderByWithRelationInput | DownloadResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DownloadResults.
     */
    cursor?: DownloadResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DownloadResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DownloadResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DownloadResults.
     */
    distinct?: DownloadResultScalarFieldEnum | DownloadResultScalarFieldEnum[]
  }


  /**
   * DownloadResult findMany
   */
  export type DownloadResultFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadResult
     */
    select?: DownloadResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DownloadResultInclude<ExtArgs> | null
    /**
     * Filter, which DownloadResults to fetch.
     */
    where?: DownloadResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DownloadResults to fetch.
     */
    orderBy?: DownloadResultOrderByWithRelationInput | DownloadResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DownloadResults.
     */
    cursor?: DownloadResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DownloadResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DownloadResults.
     */
    skip?: number
    distinct?: DownloadResultScalarFieldEnum | DownloadResultScalarFieldEnum[]
  }


  /**
   * DownloadResult create
   */
  export type DownloadResultCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadResult
     */
    select?: DownloadResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DownloadResultInclude<ExtArgs> | null
    /**
     * The data needed to create a DownloadResult.
     */
    data: XOR<DownloadResultCreateInput, DownloadResultUncheckedCreateInput>
  }


  /**
   * DownloadResult createMany
   */
  export type DownloadResultCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DownloadResults.
     */
    data: DownloadResultCreateManyInput | DownloadResultCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * DownloadResult update
   */
  export type DownloadResultUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadResult
     */
    select?: DownloadResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DownloadResultInclude<ExtArgs> | null
    /**
     * The data needed to update a DownloadResult.
     */
    data: XOR<DownloadResultUpdateInput, DownloadResultUncheckedUpdateInput>
    /**
     * Choose, which DownloadResult to update.
     */
    where: DownloadResultWhereUniqueInput
  }


  /**
   * DownloadResult updateMany
   */
  export type DownloadResultUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DownloadResults.
     */
    data: XOR<DownloadResultUpdateManyMutationInput, DownloadResultUncheckedUpdateManyInput>
    /**
     * Filter which DownloadResults to update
     */
    where?: DownloadResultWhereInput
  }


  /**
   * DownloadResult upsert
   */
  export type DownloadResultUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadResult
     */
    select?: DownloadResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DownloadResultInclude<ExtArgs> | null
    /**
     * The filter to search for the DownloadResult to update in case it exists.
     */
    where: DownloadResultWhereUniqueInput
    /**
     * In case the DownloadResult found by the `where` argument doesn't exist, create a new DownloadResult with this data.
     */
    create: XOR<DownloadResultCreateInput, DownloadResultUncheckedCreateInput>
    /**
     * In case the DownloadResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DownloadResultUpdateInput, DownloadResultUncheckedUpdateInput>
  }


  /**
   * DownloadResult delete
   */
  export type DownloadResultDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadResult
     */
    select?: DownloadResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DownloadResultInclude<ExtArgs> | null
    /**
     * Filter which DownloadResult to delete.
     */
    where: DownloadResultWhereUniqueInput
  }


  /**
   * DownloadResult deleteMany
   */
  export type DownloadResultDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DownloadResults to delete
     */
    where?: DownloadResultWhereInput
  }


  /**
   * DownloadResult without action
   */
  export type DownloadResultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DownloadResult
     */
    select?: DownloadResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DownloadResultInclude<ExtArgs> | null
  }



  /**
   * Model PromptCategory
   */


  export type AggregatePromptCategory = {
    _count: PromptCategoryCountAggregateOutputType | null
    _avg: PromptCategoryAvgAggregateOutputType | null
    _sum: PromptCategorySumAggregateOutputType | null
    _min: PromptCategoryMinAggregateOutputType | null
    _max: PromptCategoryMaxAggregateOutputType | null
  }

  export type PromptCategoryAvgAggregateOutputType = {
    order: number | null
  }

  export type PromptCategorySumAggregateOutputType = {
    order: number | null
  }

  export type PromptCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    parentCategory: string | null
    icon: string | null
    color: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromptCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    parentCategory: string | null
    icon: string | null
    color: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromptCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    parentCategory: number
    icon: number
    color: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PromptCategoryAvgAggregateInputType = {
    order?: true
  }

  export type PromptCategorySumAggregateInputType = {
    order?: true
  }

  export type PromptCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    parentCategory?: true
    icon?: true
    color?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromptCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    parentCategory?: true
    icon?: true
    color?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromptCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    parentCategory?: true
    icon?: true
    color?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PromptCategoryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromptCategory to aggregate.
     */
    where?: PromptCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptCategories to fetch.
     */
    orderBy?: PromptCategoryOrderByWithRelationInput | PromptCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromptCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromptCategories
    **/
    _count?: true | PromptCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromptCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromptCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromptCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromptCategoryMaxAggregateInputType
  }

  export type GetPromptCategoryAggregateType<T extends PromptCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePromptCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromptCategory[P]>
      : GetScalarType<T[P], AggregatePromptCategory[P]>
  }




  export type PromptCategoryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PromptCategoryWhereInput
    orderBy?: PromptCategoryOrderByWithAggregationInput | PromptCategoryOrderByWithAggregationInput[]
    by: PromptCategoryScalarFieldEnum[] | PromptCategoryScalarFieldEnum
    having?: PromptCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromptCategoryCountAggregateInputType | true
    _avg?: PromptCategoryAvgAggregateInputType
    _sum?: PromptCategorySumAggregateInputType
    _min?: PromptCategoryMinAggregateInputType
    _max?: PromptCategoryMaxAggregateInputType
  }


  export type PromptCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    parentCategory: string | null
    icon: string | null
    color: string | null
    order: number
    createdAt: Date
    updatedAt: Date
    _count: PromptCategoryCountAggregateOutputType | null
    _avg: PromptCategoryAvgAggregateOutputType | null
    _sum: PromptCategorySumAggregateOutputType | null
    _min: PromptCategoryMinAggregateOutputType | null
    _max: PromptCategoryMaxAggregateOutputType | null
  }

  type GetPromptCategoryGroupByPayload<T extends PromptCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromptCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromptCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromptCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], PromptCategoryGroupByOutputType[P]>
        }
      >
    >


  export type PromptCategorySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    parentCategory?: boolean
    icon?: boolean
    color?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    templates?: boolean | PromptCategory$templatesArgs<ExtArgs>
    parent?: boolean | PromptCategory$parentArgs<ExtArgs>
    children?: boolean | PromptCategory$childrenArgs<ExtArgs>
    _count?: boolean | PromptCategoryCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["promptCategory"]>

  export type PromptCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    parentCategory?: boolean
    icon?: boolean
    color?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PromptCategoryInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    templates?: boolean | PromptCategory$templatesArgs<ExtArgs>
    parent?: boolean | PromptCategory$parentArgs<ExtArgs>
    children?: boolean | PromptCategory$childrenArgs<ExtArgs>
    _count?: boolean | PromptCategoryCountOutputTypeArgs<ExtArgs>
  }


  type PromptCategoryGetPayload<S extends boolean | null | undefined | PromptCategoryArgs> = $Types.GetResult<PromptCategoryPayload, S>

  type PromptCategoryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PromptCategoryFindManyArgs, 'select' | 'include'> & {
      select?: PromptCategoryCountAggregateInputType | true
    }

  export interface PromptCategoryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromptCategory'], meta: { name: 'PromptCategory' } }
    /**
     * Find zero or one PromptCategory that matches the filter.
     * @param {PromptCategoryFindUniqueArgs} args - Arguments to find a PromptCategory
     * @example
     * // Get one PromptCategory
     * const promptCategory = await prisma.promptCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PromptCategoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PromptCategoryFindUniqueArgs<ExtArgs>>
    ): Prisma__PromptCategoryClient<$Types.GetResult<PromptCategoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PromptCategory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PromptCategoryFindUniqueOrThrowArgs} args - Arguments to find a PromptCategory
     * @example
     * // Get one PromptCategory
     * const promptCategory = await prisma.promptCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PromptCategoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PromptCategoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PromptCategoryClient<$Types.GetResult<PromptCategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PromptCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptCategoryFindFirstArgs} args - Arguments to find a PromptCategory
     * @example
     * // Get one PromptCategory
     * const promptCategory = await prisma.promptCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PromptCategoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PromptCategoryFindFirstArgs<ExtArgs>>
    ): Prisma__PromptCategoryClient<$Types.GetResult<PromptCategoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PromptCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptCategoryFindFirstOrThrowArgs} args - Arguments to find a PromptCategory
     * @example
     * // Get one PromptCategory
     * const promptCategory = await prisma.promptCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PromptCategoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PromptCategoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PromptCategoryClient<$Types.GetResult<PromptCategoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PromptCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptCategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromptCategories
     * const promptCategories = await prisma.promptCategory.findMany()
     * 
     * // Get first 10 PromptCategories
     * const promptCategories = await prisma.promptCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promptCategoryWithIdOnly = await prisma.promptCategory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PromptCategoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PromptCategoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PromptCategoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PromptCategory.
     * @param {PromptCategoryCreateArgs} args - Arguments to create a PromptCategory.
     * @example
     * // Create one PromptCategory
     * const PromptCategory = await prisma.promptCategory.create({
     *   data: {
     *     // ... data to create a PromptCategory
     *   }
     * })
     * 
    **/
    create<T extends PromptCategoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PromptCategoryCreateArgs<ExtArgs>>
    ): Prisma__PromptCategoryClient<$Types.GetResult<PromptCategoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PromptCategories.
     *     @param {PromptCategoryCreateManyArgs} args - Arguments to create many PromptCategories.
     *     @example
     *     // Create many PromptCategories
     *     const promptCategory = await prisma.promptCategory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PromptCategoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PromptCategoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PromptCategory.
     * @param {PromptCategoryDeleteArgs} args - Arguments to delete one PromptCategory.
     * @example
     * // Delete one PromptCategory
     * const PromptCategory = await prisma.promptCategory.delete({
     *   where: {
     *     // ... filter to delete one PromptCategory
     *   }
     * })
     * 
    **/
    delete<T extends PromptCategoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PromptCategoryDeleteArgs<ExtArgs>>
    ): Prisma__PromptCategoryClient<$Types.GetResult<PromptCategoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PromptCategory.
     * @param {PromptCategoryUpdateArgs} args - Arguments to update one PromptCategory.
     * @example
     * // Update one PromptCategory
     * const promptCategory = await prisma.promptCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PromptCategoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PromptCategoryUpdateArgs<ExtArgs>>
    ): Prisma__PromptCategoryClient<$Types.GetResult<PromptCategoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PromptCategories.
     * @param {PromptCategoryDeleteManyArgs} args - Arguments to filter PromptCategories to delete.
     * @example
     * // Delete a few PromptCategories
     * const { count } = await prisma.promptCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PromptCategoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PromptCategoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromptCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromptCategories
     * const promptCategory = await prisma.promptCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PromptCategoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PromptCategoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PromptCategory.
     * @param {PromptCategoryUpsertArgs} args - Arguments to update or create a PromptCategory.
     * @example
     * // Update or create a PromptCategory
     * const promptCategory = await prisma.promptCategory.upsert({
     *   create: {
     *     // ... data to create a PromptCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromptCategory we want to update
     *   }
     * })
    **/
    upsert<T extends PromptCategoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PromptCategoryUpsertArgs<ExtArgs>>
    ): Prisma__PromptCategoryClient<$Types.GetResult<PromptCategoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PromptCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptCategoryCountArgs} args - Arguments to filter PromptCategories to count.
     * @example
     * // Count the number of PromptCategories
     * const count = await prisma.promptCategory.count({
     *   where: {
     *     // ... the filter for the PromptCategories we want to count
     *   }
     * })
    **/
    count<T extends PromptCategoryCountArgs>(
      args?: Subset<T, PromptCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromptCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromptCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromptCategoryAggregateArgs>(args: Subset<T, PromptCategoryAggregateArgs>): Prisma.PrismaPromise<GetPromptCategoryAggregateType<T>>

    /**
     * Group by PromptCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromptCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromptCategoryGroupByArgs['orderBy'] }
        : { orderBy?: PromptCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromptCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromptCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromptCategory model
   */
  readonly fields: PromptCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromptCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PromptCategoryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    templates<T extends PromptCategory$templatesArgs<ExtArgs> = {}>(args?: Subset<T, PromptCategory$templatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PromptTemplatePayload<ExtArgs>, T, 'findMany'>| Null>;

    parent<T extends PromptCategory$parentArgs<ExtArgs> = {}>(args?: Subset<T, PromptCategory$parentArgs<ExtArgs>>): Prisma__PromptCategoryClient<$Types.GetResult<PromptCategoryPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    children<T extends PromptCategory$childrenArgs<ExtArgs> = {}>(args?: Subset<T, PromptCategory$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PromptCategoryPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the PromptCategory model
   */ 
  interface PromptCategoryFieldRefs {
    readonly id: FieldRef<"PromptCategory", 'String'>
    readonly name: FieldRef<"PromptCategory", 'String'>
    readonly description: FieldRef<"PromptCategory", 'String'>
    readonly parentCategory: FieldRef<"PromptCategory", 'String'>
    readonly icon: FieldRef<"PromptCategory", 'String'>
    readonly color: FieldRef<"PromptCategory", 'String'>
    readonly order: FieldRef<"PromptCategory", 'Int'>
    readonly createdAt: FieldRef<"PromptCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"PromptCategory", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * PromptCategory findUnique
   */
  export type PromptCategoryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptCategory
     */
    select?: PromptCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PromptCategory to fetch.
     */
    where: PromptCategoryWhereUniqueInput
  }


  /**
   * PromptCategory findUniqueOrThrow
   */
  export type PromptCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptCategory
     */
    select?: PromptCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PromptCategory to fetch.
     */
    where: PromptCategoryWhereUniqueInput
  }


  /**
   * PromptCategory findFirst
   */
  export type PromptCategoryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptCategory
     */
    select?: PromptCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PromptCategory to fetch.
     */
    where?: PromptCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptCategories to fetch.
     */
    orderBy?: PromptCategoryOrderByWithRelationInput | PromptCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromptCategories.
     */
    cursor?: PromptCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromptCategories.
     */
    distinct?: PromptCategoryScalarFieldEnum | PromptCategoryScalarFieldEnum[]
  }


  /**
   * PromptCategory findFirstOrThrow
   */
  export type PromptCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptCategory
     */
    select?: PromptCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PromptCategory to fetch.
     */
    where?: PromptCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptCategories to fetch.
     */
    orderBy?: PromptCategoryOrderByWithRelationInput | PromptCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromptCategories.
     */
    cursor?: PromptCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromptCategories.
     */
    distinct?: PromptCategoryScalarFieldEnum | PromptCategoryScalarFieldEnum[]
  }


  /**
   * PromptCategory findMany
   */
  export type PromptCategoryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptCategory
     */
    select?: PromptCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptCategoryInclude<ExtArgs> | null
    /**
     * Filter, which PromptCategories to fetch.
     */
    where?: PromptCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptCategories to fetch.
     */
    orderBy?: PromptCategoryOrderByWithRelationInput | PromptCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromptCategories.
     */
    cursor?: PromptCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptCategories.
     */
    skip?: number
    distinct?: PromptCategoryScalarFieldEnum | PromptCategoryScalarFieldEnum[]
  }


  /**
   * PromptCategory create
   */
  export type PromptCategoryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptCategory
     */
    select?: PromptCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PromptCategory.
     */
    data: XOR<PromptCategoryCreateInput, PromptCategoryUncheckedCreateInput>
  }


  /**
   * PromptCategory createMany
   */
  export type PromptCategoryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromptCategories.
     */
    data: PromptCategoryCreateManyInput | PromptCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PromptCategory update
   */
  export type PromptCategoryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptCategory
     */
    select?: PromptCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PromptCategory.
     */
    data: XOR<PromptCategoryUpdateInput, PromptCategoryUncheckedUpdateInput>
    /**
     * Choose, which PromptCategory to update.
     */
    where: PromptCategoryWhereUniqueInput
  }


  /**
   * PromptCategory updateMany
   */
  export type PromptCategoryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromptCategories.
     */
    data: XOR<PromptCategoryUpdateManyMutationInput, PromptCategoryUncheckedUpdateManyInput>
    /**
     * Filter which PromptCategories to update
     */
    where?: PromptCategoryWhereInput
  }


  /**
   * PromptCategory upsert
   */
  export type PromptCategoryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptCategory
     */
    select?: PromptCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PromptCategory to update in case it exists.
     */
    where: PromptCategoryWhereUniqueInput
    /**
     * In case the PromptCategory found by the `where` argument doesn't exist, create a new PromptCategory with this data.
     */
    create: XOR<PromptCategoryCreateInput, PromptCategoryUncheckedCreateInput>
    /**
     * In case the PromptCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromptCategoryUpdateInput, PromptCategoryUncheckedUpdateInput>
  }


  /**
   * PromptCategory delete
   */
  export type PromptCategoryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptCategory
     */
    select?: PromptCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptCategoryInclude<ExtArgs> | null
    /**
     * Filter which PromptCategory to delete.
     */
    where: PromptCategoryWhereUniqueInput
  }


  /**
   * PromptCategory deleteMany
   */
  export type PromptCategoryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromptCategories to delete
     */
    where?: PromptCategoryWhereInput
  }


  /**
   * PromptCategory.templates
   */
  export type PromptCategory$templatesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptTemplate
     */
    select?: PromptTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptTemplateInclude<ExtArgs> | null
    where?: PromptTemplateWhereInput
    orderBy?: PromptTemplateOrderByWithRelationInput | PromptTemplateOrderByWithRelationInput[]
    cursor?: PromptTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromptTemplateScalarFieldEnum | PromptTemplateScalarFieldEnum[]
  }


  /**
   * PromptCategory.parent
   */
  export type PromptCategory$parentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptCategory
     */
    select?: PromptCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptCategoryInclude<ExtArgs> | null
    where?: PromptCategoryWhereInput
  }


  /**
   * PromptCategory.children
   */
  export type PromptCategory$childrenArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptCategory
     */
    select?: PromptCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptCategoryInclude<ExtArgs> | null
    where?: PromptCategoryWhereInput
    orderBy?: PromptCategoryOrderByWithRelationInput | PromptCategoryOrderByWithRelationInput[]
    cursor?: PromptCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromptCategoryScalarFieldEnum | PromptCategoryScalarFieldEnum[]
  }


  /**
   * PromptCategory without action
   */
  export type PromptCategoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptCategory
     */
    select?: PromptCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptCategoryInclude<ExtArgs> | null
  }



  /**
   * Model PromptTemplate
   */


  export type AggregatePromptTemplate = {
    _count: PromptTemplateCountAggregateOutputType | null
    _min: PromptTemplateMinAggregateOutputType | null
    _max: PromptTemplateMaxAggregateOutputType | null
  }

  export type PromptTemplateMinAggregateOutputType = {
    id: string | null
    version: string | null
    name: string | null
    description: string | null
    category: string | null
    status: string | null
    template: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromptTemplateMaxAggregateOutputType = {
    id: string | null
    version: string | null
    name: string | null
    description: string | null
    category: string | null
    status: string | null
    template: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromptTemplateCountAggregateOutputType = {
    id: number
    version: number
    name: number
    description: number
    category: number
    status: number
    template: number
    variables: number
    examples: number
    metadata: number
    constraints: number
    optimization: number
    testing: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PromptTemplateMinAggregateInputType = {
    id?: true
    version?: true
    name?: true
    description?: true
    category?: true
    status?: true
    template?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromptTemplateMaxAggregateInputType = {
    id?: true
    version?: true
    name?: true
    description?: true
    category?: true
    status?: true
    template?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromptTemplateCountAggregateInputType = {
    id?: true
    version?: true
    name?: true
    description?: true
    category?: true
    status?: true
    template?: true
    variables?: true
    examples?: true
    metadata?: true
    constraints?: true
    optimization?: true
    testing?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PromptTemplateAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromptTemplate to aggregate.
     */
    where?: PromptTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptTemplates to fetch.
     */
    orderBy?: PromptTemplateOrderByWithRelationInput | PromptTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromptTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromptTemplates
    **/
    _count?: true | PromptTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromptTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromptTemplateMaxAggregateInputType
  }

  export type GetPromptTemplateAggregateType<T extends PromptTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregatePromptTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromptTemplate[P]>
      : GetScalarType<T[P], AggregatePromptTemplate[P]>
  }




  export type PromptTemplateGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PromptTemplateWhereInput
    orderBy?: PromptTemplateOrderByWithAggregationInput | PromptTemplateOrderByWithAggregationInput[]
    by: PromptTemplateScalarFieldEnum[] | PromptTemplateScalarFieldEnum
    having?: PromptTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromptTemplateCountAggregateInputType | true
    _min?: PromptTemplateMinAggregateInputType
    _max?: PromptTemplateMaxAggregateInputType
  }


  export type PromptTemplateGroupByOutputType = {
    id: string
    version: string
    name: string
    description: string | null
    category: string
    status: string
    template: string
    variables: JsonValue
    examples: JsonValue
    metadata: JsonValue
    constraints: JsonValue
    optimization: JsonValue
    testing: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: PromptTemplateCountAggregateOutputType | null
    _min: PromptTemplateMinAggregateOutputType | null
    _max: PromptTemplateMaxAggregateOutputType | null
  }

  type GetPromptTemplateGroupByPayload<T extends PromptTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromptTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromptTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromptTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], PromptTemplateGroupByOutputType[P]>
        }
      >
    >


  export type PromptTemplateSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    template?: boolean
    variables?: boolean
    examples?: boolean
    metadata?: boolean
    constraints?: boolean
    optimization?: boolean
    testing?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    categoryRel?: boolean | PromptCategoryArgs<ExtArgs>
    executions?: boolean | PromptTemplate$executionsArgs<ExtArgs>
    changes?: boolean | PromptTemplate$changesArgs<ExtArgs>
    optimizations?: boolean | PromptTemplate$optimizationsArgs<ExtArgs>
    _count?: boolean | PromptTemplateCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["promptTemplate"]>

  export type PromptTemplateSelectScalar = {
    id?: boolean
    version?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    template?: boolean
    variables?: boolean
    examples?: boolean
    metadata?: boolean
    constraints?: boolean
    optimization?: boolean
    testing?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PromptTemplateInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    categoryRel?: boolean | PromptCategoryArgs<ExtArgs>
    executions?: boolean | PromptTemplate$executionsArgs<ExtArgs>
    changes?: boolean | PromptTemplate$changesArgs<ExtArgs>
    optimizations?: boolean | PromptTemplate$optimizationsArgs<ExtArgs>
    _count?: boolean | PromptTemplateCountOutputTypeArgs<ExtArgs>
  }


  type PromptTemplateGetPayload<S extends boolean | null | undefined | PromptTemplateArgs> = $Types.GetResult<PromptTemplatePayload, S>

  type PromptTemplateCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PromptTemplateFindManyArgs, 'select' | 'include'> & {
      select?: PromptTemplateCountAggregateInputType | true
    }

  export interface PromptTemplateDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromptTemplate'], meta: { name: 'PromptTemplate' } }
    /**
     * Find zero or one PromptTemplate that matches the filter.
     * @param {PromptTemplateFindUniqueArgs} args - Arguments to find a PromptTemplate
     * @example
     * // Get one PromptTemplate
     * const promptTemplate = await prisma.promptTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PromptTemplateFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PromptTemplateFindUniqueArgs<ExtArgs>>
    ): Prisma__PromptTemplateClient<$Types.GetResult<PromptTemplatePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PromptTemplate that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PromptTemplateFindUniqueOrThrowArgs} args - Arguments to find a PromptTemplate
     * @example
     * // Get one PromptTemplate
     * const promptTemplate = await prisma.promptTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PromptTemplateFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PromptTemplateFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PromptTemplateClient<$Types.GetResult<PromptTemplatePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PromptTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptTemplateFindFirstArgs} args - Arguments to find a PromptTemplate
     * @example
     * // Get one PromptTemplate
     * const promptTemplate = await prisma.promptTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PromptTemplateFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PromptTemplateFindFirstArgs<ExtArgs>>
    ): Prisma__PromptTemplateClient<$Types.GetResult<PromptTemplatePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PromptTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptTemplateFindFirstOrThrowArgs} args - Arguments to find a PromptTemplate
     * @example
     * // Get one PromptTemplate
     * const promptTemplate = await prisma.promptTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PromptTemplateFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PromptTemplateFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PromptTemplateClient<$Types.GetResult<PromptTemplatePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PromptTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptTemplateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromptTemplates
     * const promptTemplates = await prisma.promptTemplate.findMany()
     * 
     * // Get first 10 PromptTemplates
     * const promptTemplates = await prisma.promptTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promptTemplateWithIdOnly = await prisma.promptTemplate.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PromptTemplateFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PromptTemplateFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PromptTemplatePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PromptTemplate.
     * @param {PromptTemplateCreateArgs} args - Arguments to create a PromptTemplate.
     * @example
     * // Create one PromptTemplate
     * const PromptTemplate = await prisma.promptTemplate.create({
     *   data: {
     *     // ... data to create a PromptTemplate
     *   }
     * })
     * 
    **/
    create<T extends PromptTemplateCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PromptTemplateCreateArgs<ExtArgs>>
    ): Prisma__PromptTemplateClient<$Types.GetResult<PromptTemplatePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PromptTemplates.
     *     @param {PromptTemplateCreateManyArgs} args - Arguments to create many PromptTemplates.
     *     @example
     *     // Create many PromptTemplates
     *     const promptTemplate = await prisma.promptTemplate.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PromptTemplateCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PromptTemplateCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PromptTemplate.
     * @param {PromptTemplateDeleteArgs} args - Arguments to delete one PromptTemplate.
     * @example
     * // Delete one PromptTemplate
     * const PromptTemplate = await prisma.promptTemplate.delete({
     *   where: {
     *     // ... filter to delete one PromptTemplate
     *   }
     * })
     * 
    **/
    delete<T extends PromptTemplateDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PromptTemplateDeleteArgs<ExtArgs>>
    ): Prisma__PromptTemplateClient<$Types.GetResult<PromptTemplatePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PromptTemplate.
     * @param {PromptTemplateUpdateArgs} args - Arguments to update one PromptTemplate.
     * @example
     * // Update one PromptTemplate
     * const promptTemplate = await prisma.promptTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PromptTemplateUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PromptTemplateUpdateArgs<ExtArgs>>
    ): Prisma__PromptTemplateClient<$Types.GetResult<PromptTemplatePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PromptTemplates.
     * @param {PromptTemplateDeleteManyArgs} args - Arguments to filter PromptTemplates to delete.
     * @example
     * // Delete a few PromptTemplates
     * const { count } = await prisma.promptTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PromptTemplateDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PromptTemplateDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromptTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromptTemplates
     * const promptTemplate = await prisma.promptTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PromptTemplateUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PromptTemplateUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PromptTemplate.
     * @param {PromptTemplateUpsertArgs} args - Arguments to update or create a PromptTemplate.
     * @example
     * // Update or create a PromptTemplate
     * const promptTemplate = await prisma.promptTemplate.upsert({
     *   create: {
     *     // ... data to create a PromptTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromptTemplate we want to update
     *   }
     * })
    **/
    upsert<T extends PromptTemplateUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PromptTemplateUpsertArgs<ExtArgs>>
    ): Prisma__PromptTemplateClient<$Types.GetResult<PromptTemplatePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PromptTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptTemplateCountArgs} args - Arguments to filter PromptTemplates to count.
     * @example
     * // Count the number of PromptTemplates
     * const count = await prisma.promptTemplate.count({
     *   where: {
     *     // ... the filter for the PromptTemplates we want to count
     *   }
     * })
    **/
    count<T extends PromptTemplateCountArgs>(
      args?: Subset<T, PromptTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromptTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromptTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromptTemplateAggregateArgs>(args: Subset<T, PromptTemplateAggregateArgs>): Prisma.PrismaPromise<GetPromptTemplateAggregateType<T>>

    /**
     * Group by PromptTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromptTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromptTemplateGroupByArgs['orderBy'] }
        : { orderBy?: PromptTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromptTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromptTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromptTemplate model
   */
  readonly fields: PromptTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromptTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PromptTemplateClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    categoryRel<T extends PromptCategoryArgs<ExtArgs> = {}>(args?: Subset<T, PromptCategoryArgs<ExtArgs>>): Prisma__PromptCategoryClient<$Types.GetResult<PromptCategoryPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    executions<T extends PromptTemplate$executionsArgs<ExtArgs> = {}>(args?: Subset<T, PromptTemplate$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PromptExecutionPayload<ExtArgs>, T, 'findMany'>| Null>;

    changes<T extends PromptTemplate$changesArgs<ExtArgs> = {}>(args?: Subset<T, PromptTemplate$changesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<TemplateChangePayload<ExtArgs>, T, 'findMany'>| Null>;

    optimizations<T extends PromptTemplate$optimizationsArgs<ExtArgs> = {}>(args?: Subset<T, PromptTemplate$optimizationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<OptimizationRecordPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the PromptTemplate model
   */ 
  interface PromptTemplateFieldRefs {
    readonly id: FieldRef<"PromptTemplate", 'String'>
    readonly version: FieldRef<"PromptTemplate", 'String'>
    readonly name: FieldRef<"PromptTemplate", 'String'>
    readonly description: FieldRef<"PromptTemplate", 'String'>
    readonly category: FieldRef<"PromptTemplate", 'String'>
    readonly status: FieldRef<"PromptTemplate", 'String'>
    readonly template: FieldRef<"PromptTemplate", 'String'>
    readonly variables: FieldRef<"PromptTemplate", 'Json'>
    readonly examples: FieldRef<"PromptTemplate", 'Json'>
    readonly metadata: FieldRef<"PromptTemplate", 'Json'>
    readonly constraints: FieldRef<"PromptTemplate", 'Json'>
    readonly optimization: FieldRef<"PromptTemplate", 'Json'>
    readonly testing: FieldRef<"PromptTemplate", 'Json'>
    readonly createdAt: FieldRef<"PromptTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"PromptTemplate", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * PromptTemplate findUnique
   */
  export type PromptTemplateFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptTemplate
     */
    select?: PromptTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PromptTemplate to fetch.
     */
    where: PromptTemplateWhereUniqueInput
  }


  /**
   * PromptTemplate findUniqueOrThrow
   */
  export type PromptTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptTemplate
     */
    select?: PromptTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PromptTemplate to fetch.
     */
    where: PromptTemplateWhereUniqueInput
  }


  /**
   * PromptTemplate findFirst
   */
  export type PromptTemplateFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptTemplate
     */
    select?: PromptTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PromptTemplate to fetch.
     */
    where?: PromptTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptTemplates to fetch.
     */
    orderBy?: PromptTemplateOrderByWithRelationInput | PromptTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromptTemplates.
     */
    cursor?: PromptTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromptTemplates.
     */
    distinct?: PromptTemplateScalarFieldEnum | PromptTemplateScalarFieldEnum[]
  }


  /**
   * PromptTemplate findFirstOrThrow
   */
  export type PromptTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptTemplate
     */
    select?: PromptTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PromptTemplate to fetch.
     */
    where?: PromptTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptTemplates to fetch.
     */
    orderBy?: PromptTemplateOrderByWithRelationInput | PromptTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromptTemplates.
     */
    cursor?: PromptTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromptTemplates.
     */
    distinct?: PromptTemplateScalarFieldEnum | PromptTemplateScalarFieldEnum[]
  }


  /**
   * PromptTemplate findMany
   */
  export type PromptTemplateFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptTemplate
     */
    select?: PromptTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PromptTemplates to fetch.
     */
    where?: PromptTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptTemplates to fetch.
     */
    orderBy?: PromptTemplateOrderByWithRelationInput | PromptTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromptTemplates.
     */
    cursor?: PromptTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptTemplates.
     */
    skip?: number
    distinct?: PromptTemplateScalarFieldEnum | PromptTemplateScalarFieldEnum[]
  }


  /**
   * PromptTemplate create
   */
  export type PromptTemplateCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptTemplate
     */
    select?: PromptTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a PromptTemplate.
     */
    data: XOR<PromptTemplateCreateInput, PromptTemplateUncheckedCreateInput>
  }


  /**
   * PromptTemplate createMany
   */
  export type PromptTemplateCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromptTemplates.
     */
    data: PromptTemplateCreateManyInput | PromptTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PromptTemplate update
   */
  export type PromptTemplateUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptTemplate
     */
    select?: PromptTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a PromptTemplate.
     */
    data: XOR<PromptTemplateUpdateInput, PromptTemplateUncheckedUpdateInput>
    /**
     * Choose, which PromptTemplate to update.
     */
    where: PromptTemplateWhereUniqueInput
  }


  /**
   * PromptTemplate updateMany
   */
  export type PromptTemplateUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromptTemplates.
     */
    data: XOR<PromptTemplateUpdateManyMutationInput, PromptTemplateUncheckedUpdateManyInput>
    /**
     * Filter which PromptTemplates to update
     */
    where?: PromptTemplateWhereInput
  }


  /**
   * PromptTemplate upsert
   */
  export type PromptTemplateUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptTemplate
     */
    select?: PromptTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the PromptTemplate to update in case it exists.
     */
    where: PromptTemplateWhereUniqueInput
    /**
     * In case the PromptTemplate found by the `where` argument doesn't exist, create a new PromptTemplate with this data.
     */
    create: XOR<PromptTemplateCreateInput, PromptTemplateUncheckedCreateInput>
    /**
     * In case the PromptTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromptTemplateUpdateInput, PromptTemplateUncheckedUpdateInput>
  }


  /**
   * PromptTemplate delete
   */
  export type PromptTemplateDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptTemplate
     */
    select?: PromptTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptTemplateInclude<ExtArgs> | null
    /**
     * Filter which PromptTemplate to delete.
     */
    where: PromptTemplateWhereUniqueInput
  }


  /**
   * PromptTemplate deleteMany
   */
  export type PromptTemplateDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromptTemplates to delete
     */
    where?: PromptTemplateWhereInput
  }


  /**
   * PromptTemplate.executions
   */
  export type PromptTemplate$executionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptExecution
     */
    select?: PromptExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptExecutionInclude<ExtArgs> | null
    where?: PromptExecutionWhereInput
    orderBy?: PromptExecutionOrderByWithRelationInput | PromptExecutionOrderByWithRelationInput[]
    cursor?: PromptExecutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromptExecutionScalarFieldEnum | PromptExecutionScalarFieldEnum[]
  }


  /**
   * PromptTemplate.changes
   */
  export type PromptTemplate$changesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateChange
     */
    select?: TemplateChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateChangeInclude<ExtArgs> | null
    where?: TemplateChangeWhereInput
    orderBy?: TemplateChangeOrderByWithRelationInput | TemplateChangeOrderByWithRelationInput[]
    cursor?: TemplateChangeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplateChangeScalarFieldEnum | TemplateChangeScalarFieldEnum[]
  }


  /**
   * PromptTemplate.optimizations
   */
  export type PromptTemplate$optimizationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRecord
     */
    select?: OptimizationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OptimizationRecordInclude<ExtArgs> | null
    where?: OptimizationRecordWhereInput
    orderBy?: OptimizationRecordOrderByWithRelationInput | OptimizationRecordOrderByWithRelationInput[]
    cursor?: OptimizationRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OptimizationRecordScalarFieldEnum | OptimizationRecordScalarFieldEnum[]
  }


  /**
   * PromptTemplate without action
   */
  export type PromptTemplateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptTemplate
     */
    select?: PromptTemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptTemplateInclude<ExtArgs> | null
  }



  /**
   * Model TemplateChange
   */


  export type AggregateTemplateChange = {
    _count: TemplateChangeCountAggregateOutputType | null
    _min: TemplateChangeMinAggregateOutputType | null
    _max: TemplateChangeMaxAggregateOutputType | null
  }

  export type TemplateChangeMinAggregateOutputType = {
    id: string | null
    templateId: string | null
    fromVersion: string | null
    toVersion: string | null
    createdAt: Date | null
  }

  export type TemplateChangeMaxAggregateOutputType = {
    id: string | null
    templateId: string | null
    fromVersion: string | null
    toVersion: string | null
    createdAt: Date | null
  }

  export type TemplateChangeCountAggregateOutputType = {
    id: number
    templateId: number
    fromVersion: number
    toVersion: number
    changes: number
    createdAt: number
    _all: number
  }


  export type TemplateChangeMinAggregateInputType = {
    id?: true
    templateId?: true
    fromVersion?: true
    toVersion?: true
    createdAt?: true
  }

  export type TemplateChangeMaxAggregateInputType = {
    id?: true
    templateId?: true
    fromVersion?: true
    toVersion?: true
    createdAt?: true
  }

  export type TemplateChangeCountAggregateInputType = {
    id?: true
    templateId?: true
    fromVersion?: true
    toVersion?: true
    changes?: true
    createdAt?: true
    _all?: true
  }

  export type TemplateChangeAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateChange to aggregate.
     */
    where?: TemplateChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateChanges to fetch.
     */
    orderBy?: TemplateChangeOrderByWithRelationInput | TemplateChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplateChanges
    **/
    _count?: true | TemplateChangeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateChangeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateChangeMaxAggregateInputType
  }

  export type GetTemplateChangeAggregateType<T extends TemplateChangeAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplateChange]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplateChange[P]>
      : GetScalarType<T[P], AggregateTemplateChange[P]>
  }




  export type TemplateChangeGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TemplateChangeWhereInput
    orderBy?: TemplateChangeOrderByWithAggregationInput | TemplateChangeOrderByWithAggregationInput[]
    by: TemplateChangeScalarFieldEnum[] | TemplateChangeScalarFieldEnum
    having?: TemplateChangeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateChangeCountAggregateInputType | true
    _min?: TemplateChangeMinAggregateInputType
    _max?: TemplateChangeMaxAggregateInputType
  }


  export type TemplateChangeGroupByOutputType = {
    id: string
    templateId: string
    fromVersion: string
    toVersion: string
    changes: JsonValue
    createdAt: Date
    _count: TemplateChangeCountAggregateOutputType | null
    _min: TemplateChangeMinAggregateOutputType | null
    _max: TemplateChangeMaxAggregateOutputType | null
  }

  type GetTemplateChangeGroupByPayload<T extends TemplateChangeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateChangeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateChangeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateChangeGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateChangeGroupByOutputType[P]>
        }
      >
    >


  export type TemplateChangeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    templateId?: boolean
    fromVersion?: boolean
    toVersion?: boolean
    changes?: boolean
    createdAt?: boolean
    template?: boolean | PromptTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["templateChange"]>

  export type TemplateChangeSelectScalar = {
    id?: boolean
    templateId?: boolean
    fromVersion?: boolean
    toVersion?: boolean
    changes?: boolean
    createdAt?: boolean
  }

  export type TemplateChangeInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    template?: boolean | PromptTemplateArgs<ExtArgs>
  }


  type TemplateChangeGetPayload<S extends boolean | null | undefined | TemplateChangeArgs> = $Types.GetResult<TemplateChangePayload, S>

  type TemplateChangeCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TemplateChangeFindManyArgs, 'select' | 'include'> & {
      select?: TemplateChangeCountAggregateInputType | true
    }

  export interface TemplateChangeDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TemplateChange'], meta: { name: 'TemplateChange' } }
    /**
     * Find zero or one TemplateChange that matches the filter.
     * @param {TemplateChangeFindUniqueArgs} args - Arguments to find a TemplateChange
     * @example
     * // Get one TemplateChange
     * const templateChange = await prisma.templateChange.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TemplateChangeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateChangeFindUniqueArgs<ExtArgs>>
    ): Prisma__TemplateChangeClient<$Types.GetResult<TemplateChangePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TemplateChange that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TemplateChangeFindUniqueOrThrowArgs} args - Arguments to find a TemplateChange
     * @example
     * // Get one TemplateChange
     * const templateChange = await prisma.templateChange.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TemplateChangeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplateChangeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TemplateChangeClient<$Types.GetResult<TemplateChangePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TemplateChange that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateChangeFindFirstArgs} args - Arguments to find a TemplateChange
     * @example
     * // Get one TemplateChange
     * const templateChange = await prisma.templateChange.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TemplateChangeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplateChangeFindFirstArgs<ExtArgs>>
    ): Prisma__TemplateChangeClient<$Types.GetResult<TemplateChangePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TemplateChange that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateChangeFindFirstOrThrowArgs} args - Arguments to find a TemplateChange
     * @example
     * // Get one TemplateChange
     * const templateChange = await prisma.templateChange.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TemplateChangeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplateChangeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TemplateChangeClient<$Types.GetResult<TemplateChangePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TemplateChanges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateChangeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplateChanges
     * const templateChanges = await prisma.templateChange.findMany()
     * 
     * // Get first 10 TemplateChanges
     * const templateChanges = await prisma.templateChange.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateChangeWithIdOnly = await prisma.templateChange.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TemplateChangeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplateChangeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<TemplateChangePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TemplateChange.
     * @param {TemplateChangeCreateArgs} args - Arguments to create a TemplateChange.
     * @example
     * // Create one TemplateChange
     * const TemplateChange = await prisma.templateChange.create({
     *   data: {
     *     // ... data to create a TemplateChange
     *   }
     * })
     * 
    **/
    create<T extends TemplateChangeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateChangeCreateArgs<ExtArgs>>
    ): Prisma__TemplateChangeClient<$Types.GetResult<TemplateChangePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TemplateChanges.
     *     @param {TemplateChangeCreateManyArgs} args - Arguments to create many TemplateChanges.
     *     @example
     *     // Create many TemplateChanges
     *     const templateChange = await prisma.templateChange.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TemplateChangeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplateChangeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TemplateChange.
     * @param {TemplateChangeDeleteArgs} args - Arguments to delete one TemplateChange.
     * @example
     * // Delete one TemplateChange
     * const TemplateChange = await prisma.templateChange.delete({
     *   where: {
     *     // ... filter to delete one TemplateChange
     *   }
     * })
     * 
    **/
    delete<T extends TemplateChangeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateChangeDeleteArgs<ExtArgs>>
    ): Prisma__TemplateChangeClient<$Types.GetResult<TemplateChangePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TemplateChange.
     * @param {TemplateChangeUpdateArgs} args - Arguments to update one TemplateChange.
     * @example
     * // Update one TemplateChange
     * const templateChange = await prisma.templateChange.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TemplateChangeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateChangeUpdateArgs<ExtArgs>>
    ): Prisma__TemplateChangeClient<$Types.GetResult<TemplateChangePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TemplateChanges.
     * @param {TemplateChangeDeleteManyArgs} args - Arguments to filter TemplateChanges to delete.
     * @example
     * // Delete a few TemplateChanges
     * const { count } = await prisma.templateChange.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TemplateChangeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplateChangeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateChanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateChangeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplateChanges
     * const templateChange = await prisma.templateChange.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TemplateChangeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateChangeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TemplateChange.
     * @param {TemplateChangeUpsertArgs} args - Arguments to update or create a TemplateChange.
     * @example
     * // Update or create a TemplateChange
     * const templateChange = await prisma.templateChange.upsert({
     *   create: {
     *     // ... data to create a TemplateChange
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplateChange we want to update
     *   }
     * })
    **/
    upsert<T extends TemplateChangeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateChangeUpsertArgs<ExtArgs>>
    ): Prisma__TemplateChangeClient<$Types.GetResult<TemplateChangePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TemplateChanges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateChangeCountArgs} args - Arguments to filter TemplateChanges to count.
     * @example
     * // Count the number of TemplateChanges
     * const count = await prisma.templateChange.count({
     *   where: {
     *     // ... the filter for the TemplateChanges we want to count
     *   }
     * })
    **/
    count<T extends TemplateChangeCountArgs>(
      args?: Subset<T, TemplateChangeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateChangeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplateChange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateChangeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateChangeAggregateArgs>(args: Subset<T, TemplateChangeAggregateArgs>): Prisma.PrismaPromise<GetTemplateChangeAggregateType<T>>

    /**
     * Group by TemplateChange.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateChangeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateChangeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateChangeGroupByArgs['orderBy'] }
        : { orderBy?: TemplateChangeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateChangeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateChangeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TemplateChange model
   */
  readonly fields: TemplateChangeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplateChange.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TemplateChangeClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    template<T extends PromptTemplateArgs<ExtArgs> = {}>(args?: Subset<T, PromptTemplateArgs<ExtArgs>>): Prisma__PromptTemplateClient<$Types.GetResult<PromptTemplatePayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the TemplateChange model
   */ 
  interface TemplateChangeFieldRefs {
    readonly id: FieldRef<"TemplateChange", 'String'>
    readonly templateId: FieldRef<"TemplateChange", 'String'>
    readonly fromVersion: FieldRef<"TemplateChange", 'String'>
    readonly toVersion: FieldRef<"TemplateChange", 'String'>
    readonly changes: FieldRef<"TemplateChange", 'Json'>
    readonly createdAt: FieldRef<"TemplateChange", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * TemplateChange findUnique
   */
  export type TemplateChangeFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateChange
     */
    select?: TemplateChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateChangeInclude<ExtArgs> | null
    /**
     * Filter, which TemplateChange to fetch.
     */
    where: TemplateChangeWhereUniqueInput
  }


  /**
   * TemplateChange findUniqueOrThrow
   */
  export type TemplateChangeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateChange
     */
    select?: TemplateChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateChangeInclude<ExtArgs> | null
    /**
     * Filter, which TemplateChange to fetch.
     */
    where: TemplateChangeWhereUniqueInput
  }


  /**
   * TemplateChange findFirst
   */
  export type TemplateChangeFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateChange
     */
    select?: TemplateChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateChangeInclude<ExtArgs> | null
    /**
     * Filter, which TemplateChange to fetch.
     */
    where?: TemplateChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateChanges to fetch.
     */
    orderBy?: TemplateChangeOrderByWithRelationInput | TemplateChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateChanges.
     */
    cursor?: TemplateChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateChanges.
     */
    distinct?: TemplateChangeScalarFieldEnum | TemplateChangeScalarFieldEnum[]
  }


  /**
   * TemplateChange findFirstOrThrow
   */
  export type TemplateChangeFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateChange
     */
    select?: TemplateChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateChangeInclude<ExtArgs> | null
    /**
     * Filter, which TemplateChange to fetch.
     */
    where?: TemplateChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateChanges to fetch.
     */
    orderBy?: TemplateChangeOrderByWithRelationInput | TemplateChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateChanges.
     */
    cursor?: TemplateChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateChanges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateChanges.
     */
    distinct?: TemplateChangeScalarFieldEnum | TemplateChangeScalarFieldEnum[]
  }


  /**
   * TemplateChange findMany
   */
  export type TemplateChangeFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateChange
     */
    select?: TemplateChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateChangeInclude<ExtArgs> | null
    /**
     * Filter, which TemplateChanges to fetch.
     */
    where?: TemplateChangeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateChanges to fetch.
     */
    orderBy?: TemplateChangeOrderByWithRelationInput | TemplateChangeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplateChanges.
     */
    cursor?: TemplateChangeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateChanges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateChanges.
     */
    skip?: number
    distinct?: TemplateChangeScalarFieldEnum | TemplateChangeScalarFieldEnum[]
  }


  /**
   * TemplateChange create
   */
  export type TemplateChangeCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateChange
     */
    select?: TemplateChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateChangeInclude<ExtArgs> | null
    /**
     * The data needed to create a TemplateChange.
     */
    data: XOR<TemplateChangeCreateInput, TemplateChangeUncheckedCreateInput>
  }


  /**
   * TemplateChange createMany
   */
  export type TemplateChangeCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TemplateChanges.
     */
    data: TemplateChangeCreateManyInput | TemplateChangeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * TemplateChange update
   */
  export type TemplateChangeUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateChange
     */
    select?: TemplateChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateChangeInclude<ExtArgs> | null
    /**
     * The data needed to update a TemplateChange.
     */
    data: XOR<TemplateChangeUpdateInput, TemplateChangeUncheckedUpdateInput>
    /**
     * Choose, which TemplateChange to update.
     */
    where: TemplateChangeWhereUniqueInput
  }


  /**
   * TemplateChange updateMany
   */
  export type TemplateChangeUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TemplateChanges.
     */
    data: XOR<TemplateChangeUpdateManyMutationInput, TemplateChangeUncheckedUpdateManyInput>
    /**
     * Filter which TemplateChanges to update
     */
    where?: TemplateChangeWhereInput
  }


  /**
   * TemplateChange upsert
   */
  export type TemplateChangeUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateChange
     */
    select?: TemplateChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateChangeInclude<ExtArgs> | null
    /**
     * The filter to search for the TemplateChange to update in case it exists.
     */
    where: TemplateChangeWhereUniqueInput
    /**
     * In case the TemplateChange found by the `where` argument doesn't exist, create a new TemplateChange with this data.
     */
    create: XOR<TemplateChangeCreateInput, TemplateChangeUncheckedCreateInput>
    /**
     * In case the TemplateChange was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateChangeUpdateInput, TemplateChangeUncheckedUpdateInput>
  }


  /**
   * TemplateChange delete
   */
  export type TemplateChangeDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateChange
     */
    select?: TemplateChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateChangeInclude<ExtArgs> | null
    /**
     * Filter which TemplateChange to delete.
     */
    where: TemplateChangeWhereUniqueInput
  }


  /**
   * TemplateChange deleteMany
   */
  export type TemplateChangeDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateChanges to delete
     */
    where?: TemplateChangeWhereInput
  }


  /**
   * TemplateChange without action
   */
  export type TemplateChangeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateChange
     */
    select?: TemplateChangeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateChangeInclude<ExtArgs> | null
  }



  /**
   * Model PromptExecution
   */


  export type AggregatePromptExecution = {
    _count: PromptExecutionCountAggregateOutputType | null
    _min: PromptExecutionMinAggregateOutputType | null
    _max: PromptExecutionMaxAggregateOutputType | null
  }

  export type PromptExecutionMinAggregateOutputType = {
    id: string | null
    templateId: string | null
    templateVersion: string | null
    renderedPrompt: string | null
    model: string | null
    provider: string | null
    response: string | null
    abTestVariant: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type PromptExecutionMaxAggregateOutputType = {
    id: string | null
    templateId: string | null
    templateVersion: string | null
    renderedPrompt: string | null
    model: string | null
    provider: string | null
    response: string | null
    abTestVariant: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type PromptExecutionCountAggregateOutputType = {
    id: number
    templateId: number
    templateVersion: number
    variables: number
    renderedPrompt: number
    context: number
    model: number
    provider: number
    response: number
    metrics: number
    quality: number
    feedback: number
    abTestVariant: number
    userId: number
    createdAt: number
    _all: number
  }


  export type PromptExecutionMinAggregateInputType = {
    id?: true
    templateId?: true
    templateVersion?: true
    renderedPrompt?: true
    model?: true
    provider?: true
    response?: true
    abTestVariant?: true
    userId?: true
    createdAt?: true
  }

  export type PromptExecutionMaxAggregateInputType = {
    id?: true
    templateId?: true
    templateVersion?: true
    renderedPrompt?: true
    model?: true
    provider?: true
    response?: true
    abTestVariant?: true
    userId?: true
    createdAt?: true
  }

  export type PromptExecutionCountAggregateInputType = {
    id?: true
    templateId?: true
    templateVersion?: true
    variables?: true
    renderedPrompt?: true
    context?: true
    model?: true
    provider?: true
    response?: true
    metrics?: true
    quality?: true
    feedback?: true
    abTestVariant?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type PromptExecutionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromptExecution to aggregate.
     */
    where?: PromptExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptExecutions to fetch.
     */
    orderBy?: PromptExecutionOrderByWithRelationInput | PromptExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromptExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromptExecutions
    **/
    _count?: true | PromptExecutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromptExecutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromptExecutionMaxAggregateInputType
  }

  export type GetPromptExecutionAggregateType<T extends PromptExecutionAggregateArgs> = {
        [P in keyof T & keyof AggregatePromptExecution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromptExecution[P]>
      : GetScalarType<T[P], AggregatePromptExecution[P]>
  }




  export type PromptExecutionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PromptExecutionWhereInput
    orderBy?: PromptExecutionOrderByWithAggregationInput | PromptExecutionOrderByWithAggregationInput[]
    by: PromptExecutionScalarFieldEnum[] | PromptExecutionScalarFieldEnum
    having?: PromptExecutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromptExecutionCountAggregateInputType | true
    _min?: PromptExecutionMinAggregateInputType
    _max?: PromptExecutionMaxAggregateInputType
  }


  export type PromptExecutionGroupByOutputType = {
    id: string
    templateId: string
    templateVersion: string
    variables: JsonValue
    renderedPrompt: string
    context: JsonValue | null
    model: string
    provider: string
    response: string | null
    metrics: JsonValue
    quality: JsonValue
    feedback: JsonValue | null
    abTestVariant: string | null
    userId: string | null
    createdAt: Date
    _count: PromptExecutionCountAggregateOutputType | null
    _min: PromptExecutionMinAggregateOutputType | null
    _max: PromptExecutionMaxAggregateOutputType | null
  }

  type GetPromptExecutionGroupByPayload<T extends PromptExecutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromptExecutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromptExecutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromptExecutionGroupByOutputType[P]>
            : GetScalarType<T[P], PromptExecutionGroupByOutputType[P]>
        }
      >
    >


  export type PromptExecutionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    templateId?: boolean
    templateVersion?: boolean
    variables?: boolean
    renderedPrompt?: boolean
    context?: boolean
    model?: boolean
    provider?: boolean
    response?: boolean
    metrics?: boolean
    quality?: boolean
    feedback?: boolean
    abTestVariant?: boolean
    userId?: boolean
    createdAt?: boolean
    template?: boolean | PromptTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["promptExecution"]>

  export type PromptExecutionSelectScalar = {
    id?: boolean
    templateId?: boolean
    templateVersion?: boolean
    variables?: boolean
    renderedPrompt?: boolean
    context?: boolean
    model?: boolean
    provider?: boolean
    response?: boolean
    metrics?: boolean
    quality?: boolean
    feedback?: boolean
    abTestVariant?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type PromptExecutionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    template?: boolean | PromptTemplateArgs<ExtArgs>
  }


  type PromptExecutionGetPayload<S extends boolean | null | undefined | PromptExecutionArgs> = $Types.GetResult<PromptExecutionPayload, S>

  type PromptExecutionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PromptExecutionFindManyArgs, 'select' | 'include'> & {
      select?: PromptExecutionCountAggregateInputType | true
    }

  export interface PromptExecutionDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromptExecution'], meta: { name: 'PromptExecution' } }
    /**
     * Find zero or one PromptExecution that matches the filter.
     * @param {PromptExecutionFindUniqueArgs} args - Arguments to find a PromptExecution
     * @example
     * // Get one PromptExecution
     * const promptExecution = await prisma.promptExecution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PromptExecutionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PromptExecutionFindUniqueArgs<ExtArgs>>
    ): Prisma__PromptExecutionClient<$Types.GetResult<PromptExecutionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PromptExecution that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PromptExecutionFindUniqueOrThrowArgs} args - Arguments to find a PromptExecution
     * @example
     * // Get one PromptExecution
     * const promptExecution = await prisma.promptExecution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PromptExecutionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PromptExecutionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PromptExecutionClient<$Types.GetResult<PromptExecutionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PromptExecution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptExecutionFindFirstArgs} args - Arguments to find a PromptExecution
     * @example
     * // Get one PromptExecution
     * const promptExecution = await prisma.promptExecution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PromptExecutionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PromptExecutionFindFirstArgs<ExtArgs>>
    ): Prisma__PromptExecutionClient<$Types.GetResult<PromptExecutionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PromptExecution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptExecutionFindFirstOrThrowArgs} args - Arguments to find a PromptExecution
     * @example
     * // Get one PromptExecution
     * const promptExecution = await prisma.promptExecution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PromptExecutionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PromptExecutionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PromptExecutionClient<$Types.GetResult<PromptExecutionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PromptExecutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptExecutionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromptExecutions
     * const promptExecutions = await prisma.promptExecution.findMany()
     * 
     * // Get first 10 PromptExecutions
     * const promptExecutions = await prisma.promptExecution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promptExecutionWithIdOnly = await prisma.promptExecution.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PromptExecutionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PromptExecutionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PromptExecutionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PromptExecution.
     * @param {PromptExecutionCreateArgs} args - Arguments to create a PromptExecution.
     * @example
     * // Create one PromptExecution
     * const PromptExecution = await prisma.promptExecution.create({
     *   data: {
     *     // ... data to create a PromptExecution
     *   }
     * })
     * 
    **/
    create<T extends PromptExecutionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PromptExecutionCreateArgs<ExtArgs>>
    ): Prisma__PromptExecutionClient<$Types.GetResult<PromptExecutionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PromptExecutions.
     *     @param {PromptExecutionCreateManyArgs} args - Arguments to create many PromptExecutions.
     *     @example
     *     // Create many PromptExecutions
     *     const promptExecution = await prisma.promptExecution.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PromptExecutionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PromptExecutionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PromptExecution.
     * @param {PromptExecutionDeleteArgs} args - Arguments to delete one PromptExecution.
     * @example
     * // Delete one PromptExecution
     * const PromptExecution = await prisma.promptExecution.delete({
     *   where: {
     *     // ... filter to delete one PromptExecution
     *   }
     * })
     * 
    **/
    delete<T extends PromptExecutionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PromptExecutionDeleteArgs<ExtArgs>>
    ): Prisma__PromptExecutionClient<$Types.GetResult<PromptExecutionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PromptExecution.
     * @param {PromptExecutionUpdateArgs} args - Arguments to update one PromptExecution.
     * @example
     * // Update one PromptExecution
     * const promptExecution = await prisma.promptExecution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PromptExecutionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PromptExecutionUpdateArgs<ExtArgs>>
    ): Prisma__PromptExecutionClient<$Types.GetResult<PromptExecutionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PromptExecutions.
     * @param {PromptExecutionDeleteManyArgs} args - Arguments to filter PromptExecutions to delete.
     * @example
     * // Delete a few PromptExecutions
     * const { count } = await prisma.promptExecution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PromptExecutionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PromptExecutionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromptExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptExecutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromptExecutions
     * const promptExecution = await prisma.promptExecution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PromptExecutionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PromptExecutionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PromptExecution.
     * @param {PromptExecutionUpsertArgs} args - Arguments to update or create a PromptExecution.
     * @example
     * // Update or create a PromptExecution
     * const promptExecution = await prisma.promptExecution.upsert({
     *   create: {
     *     // ... data to create a PromptExecution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromptExecution we want to update
     *   }
     * })
    **/
    upsert<T extends PromptExecutionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PromptExecutionUpsertArgs<ExtArgs>>
    ): Prisma__PromptExecutionClient<$Types.GetResult<PromptExecutionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PromptExecutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptExecutionCountArgs} args - Arguments to filter PromptExecutions to count.
     * @example
     * // Count the number of PromptExecutions
     * const count = await prisma.promptExecution.count({
     *   where: {
     *     // ... the filter for the PromptExecutions we want to count
     *   }
     * })
    **/
    count<T extends PromptExecutionCountArgs>(
      args?: Subset<T, PromptExecutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromptExecutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromptExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromptExecutionAggregateArgs>(args: Subset<T, PromptExecutionAggregateArgs>): Prisma.PrismaPromise<GetPromptExecutionAggregateType<T>>

    /**
     * Group by PromptExecution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptExecutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromptExecutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromptExecutionGroupByArgs['orderBy'] }
        : { orderBy?: PromptExecutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromptExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromptExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromptExecution model
   */
  readonly fields: PromptExecutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromptExecution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PromptExecutionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    template<T extends PromptTemplateArgs<ExtArgs> = {}>(args?: Subset<T, PromptTemplateArgs<ExtArgs>>): Prisma__PromptTemplateClient<$Types.GetResult<PromptTemplatePayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the PromptExecution model
   */ 
  interface PromptExecutionFieldRefs {
    readonly id: FieldRef<"PromptExecution", 'String'>
    readonly templateId: FieldRef<"PromptExecution", 'String'>
    readonly templateVersion: FieldRef<"PromptExecution", 'String'>
    readonly variables: FieldRef<"PromptExecution", 'Json'>
    readonly renderedPrompt: FieldRef<"PromptExecution", 'String'>
    readonly context: FieldRef<"PromptExecution", 'Json'>
    readonly model: FieldRef<"PromptExecution", 'String'>
    readonly provider: FieldRef<"PromptExecution", 'String'>
    readonly response: FieldRef<"PromptExecution", 'String'>
    readonly metrics: FieldRef<"PromptExecution", 'Json'>
    readonly quality: FieldRef<"PromptExecution", 'Json'>
    readonly feedback: FieldRef<"PromptExecution", 'Json'>
    readonly abTestVariant: FieldRef<"PromptExecution", 'String'>
    readonly userId: FieldRef<"PromptExecution", 'String'>
    readonly createdAt: FieldRef<"PromptExecution", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * PromptExecution findUnique
   */
  export type PromptExecutionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptExecution
     */
    select?: PromptExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptExecutionInclude<ExtArgs> | null
    /**
     * Filter, which PromptExecution to fetch.
     */
    where: PromptExecutionWhereUniqueInput
  }


  /**
   * PromptExecution findUniqueOrThrow
   */
  export type PromptExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptExecution
     */
    select?: PromptExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptExecutionInclude<ExtArgs> | null
    /**
     * Filter, which PromptExecution to fetch.
     */
    where: PromptExecutionWhereUniqueInput
  }


  /**
   * PromptExecution findFirst
   */
  export type PromptExecutionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptExecution
     */
    select?: PromptExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptExecutionInclude<ExtArgs> | null
    /**
     * Filter, which PromptExecution to fetch.
     */
    where?: PromptExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptExecutions to fetch.
     */
    orderBy?: PromptExecutionOrderByWithRelationInput | PromptExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromptExecutions.
     */
    cursor?: PromptExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromptExecutions.
     */
    distinct?: PromptExecutionScalarFieldEnum | PromptExecutionScalarFieldEnum[]
  }


  /**
   * PromptExecution findFirstOrThrow
   */
  export type PromptExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptExecution
     */
    select?: PromptExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptExecutionInclude<ExtArgs> | null
    /**
     * Filter, which PromptExecution to fetch.
     */
    where?: PromptExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptExecutions to fetch.
     */
    orderBy?: PromptExecutionOrderByWithRelationInput | PromptExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromptExecutions.
     */
    cursor?: PromptExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptExecutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromptExecutions.
     */
    distinct?: PromptExecutionScalarFieldEnum | PromptExecutionScalarFieldEnum[]
  }


  /**
   * PromptExecution findMany
   */
  export type PromptExecutionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptExecution
     */
    select?: PromptExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptExecutionInclude<ExtArgs> | null
    /**
     * Filter, which PromptExecutions to fetch.
     */
    where?: PromptExecutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptExecutions to fetch.
     */
    orderBy?: PromptExecutionOrderByWithRelationInput | PromptExecutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromptExecutions.
     */
    cursor?: PromptExecutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptExecutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptExecutions.
     */
    skip?: number
    distinct?: PromptExecutionScalarFieldEnum | PromptExecutionScalarFieldEnum[]
  }


  /**
   * PromptExecution create
   */
  export type PromptExecutionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptExecution
     */
    select?: PromptExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptExecutionInclude<ExtArgs> | null
    /**
     * The data needed to create a PromptExecution.
     */
    data: XOR<PromptExecutionCreateInput, PromptExecutionUncheckedCreateInput>
  }


  /**
   * PromptExecution createMany
   */
  export type PromptExecutionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromptExecutions.
     */
    data: PromptExecutionCreateManyInput | PromptExecutionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PromptExecution update
   */
  export type PromptExecutionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptExecution
     */
    select?: PromptExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptExecutionInclude<ExtArgs> | null
    /**
     * The data needed to update a PromptExecution.
     */
    data: XOR<PromptExecutionUpdateInput, PromptExecutionUncheckedUpdateInput>
    /**
     * Choose, which PromptExecution to update.
     */
    where: PromptExecutionWhereUniqueInput
  }


  /**
   * PromptExecution updateMany
   */
  export type PromptExecutionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromptExecutions.
     */
    data: XOR<PromptExecutionUpdateManyMutationInput, PromptExecutionUncheckedUpdateManyInput>
    /**
     * Filter which PromptExecutions to update
     */
    where?: PromptExecutionWhereInput
  }


  /**
   * PromptExecution upsert
   */
  export type PromptExecutionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptExecution
     */
    select?: PromptExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptExecutionInclude<ExtArgs> | null
    /**
     * The filter to search for the PromptExecution to update in case it exists.
     */
    where: PromptExecutionWhereUniqueInput
    /**
     * In case the PromptExecution found by the `where` argument doesn't exist, create a new PromptExecution with this data.
     */
    create: XOR<PromptExecutionCreateInput, PromptExecutionUncheckedCreateInput>
    /**
     * In case the PromptExecution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromptExecutionUpdateInput, PromptExecutionUncheckedUpdateInput>
  }


  /**
   * PromptExecution delete
   */
  export type PromptExecutionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptExecution
     */
    select?: PromptExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptExecutionInclude<ExtArgs> | null
    /**
     * Filter which PromptExecution to delete.
     */
    where: PromptExecutionWhereUniqueInput
  }


  /**
   * PromptExecution deleteMany
   */
  export type PromptExecutionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromptExecutions to delete
     */
    where?: PromptExecutionWhereInput
  }


  /**
   * PromptExecution without action
   */
  export type PromptExecutionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptExecution
     */
    select?: PromptExecutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PromptExecutionInclude<ExtArgs> | null
  }



  /**
   * Model PromptExecutionError
   */


  export type AggregatePromptExecutionError = {
    _count: PromptExecutionErrorCountAggregateOutputType | null
    _min: PromptExecutionErrorMinAggregateOutputType | null
    _max: PromptExecutionErrorMaxAggregateOutputType | null
  }

  export type PromptExecutionErrorMinAggregateOutputType = {
    id: string | null
    templateId: string | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type PromptExecutionErrorMaxAggregateOutputType = {
    id: string | null
    templateId: string | null
    errorMessage: string | null
    createdAt: Date | null
  }

  export type PromptExecutionErrorCountAggregateOutputType = {
    id: number
    templateId: number
    variables: number
    errorMessage: number
    context: number
    createdAt: number
    _all: number
  }


  export type PromptExecutionErrorMinAggregateInputType = {
    id?: true
    templateId?: true
    errorMessage?: true
    createdAt?: true
  }

  export type PromptExecutionErrorMaxAggregateInputType = {
    id?: true
    templateId?: true
    errorMessage?: true
    createdAt?: true
  }

  export type PromptExecutionErrorCountAggregateInputType = {
    id?: true
    templateId?: true
    variables?: true
    errorMessage?: true
    context?: true
    createdAt?: true
    _all?: true
  }

  export type PromptExecutionErrorAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromptExecutionError to aggregate.
     */
    where?: PromptExecutionErrorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptExecutionErrors to fetch.
     */
    orderBy?: PromptExecutionErrorOrderByWithRelationInput | PromptExecutionErrorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromptExecutionErrorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptExecutionErrors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptExecutionErrors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromptExecutionErrors
    **/
    _count?: true | PromptExecutionErrorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromptExecutionErrorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromptExecutionErrorMaxAggregateInputType
  }

  export type GetPromptExecutionErrorAggregateType<T extends PromptExecutionErrorAggregateArgs> = {
        [P in keyof T & keyof AggregatePromptExecutionError]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromptExecutionError[P]>
      : GetScalarType<T[P], AggregatePromptExecutionError[P]>
  }




  export type PromptExecutionErrorGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PromptExecutionErrorWhereInput
    orderBy?: PromptExecutionErrorOrderByWithAggregationInput | PromptExecutionErrorOrderByWithAggregationInput[]
    by: PromptExecutionErrorScalarFieldEnum[] | PromptExecutionErrorScalarFieldEnum
    having?: PromptExecutionErrorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromptExecutionErrorCountAggregateInputType | true
    _min?: PromptExecutionErrorMinAggregateInputType
    _max?: PromptExecutionErrorMaxAggregateInputType
  }


  export type PromptExecutionErrorGroupByOutputType = {
    id: string
    templateId: string
    variables: JsonValue
    errorMessage: string
    context: JsonValue | null
    createdAt: Date
    _count: PromptExecutionErrorCountAggregateOutputType | null
    _min: PromptExecutionErrorMinAggregateOutputType | null
    _max: PromptExecutionErrorMaxAggregateOutputType | null
  }

  type GetPromptExecutionErrorGroupByPayload<T extends PromptExecutionErrorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromptExecutionErrorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromptExecutionErrorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromptExecutionErrorGroupByOutputType[P]>
            : GetScalarType<T[P], PromptExecutionErrorGroupByOutputType[P]>
        }
      >
    >


  export type PromptExecutionErrorSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    templateId?: boolean
    variables?: boolean
    errorMessage?: boolean
    context?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["promptExecutionError"]>

  export type PromptExecutionErrorSelectScalar = {
    id?: boolean
    templateId?: boolean
    variables?: boolean
    errorMessage?: boolean
    context?: boolean
    createdAt?: boolean
  }


  type PromptExecutionErrorGetPayload<S extends boolean | null | undefined | PromptExecutionErrorArgs> = $Types.GetResult<PromptExecutionErrorPayload, S>

  type PromptExecutionErrorCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PromptExecutionErrorFindManyArgs, 'select' | 'include'> & {
      select?: PromptExecutionErrorCountAggregateInputType | true
    }

  export interface PromptExecutionErrorDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromptExecutionError'], meta: { name: 'PromptExecutionError' } }
    /**
     * Find zero or one PromptExecutionError that matches the filter.
     * @param {PromptExecutionErrorFindUniqueArgs} args - Arguments to find a PromptExecutionError
     * @example
     * // Get one PromptExecutionError
     * const promptExecutionError = await prisma.promptExecutionError.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PromptExecutionErrorFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PromptExecutionErrorFindUniqueArgs<ExtArgs>>
    ): Prisma__PromptExecutionErrorClient<$Types.GetResult<PromptExecutionErrorPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PromptExecutionError that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PromptExecutionErrorFindUniqueOrThrowArgs} args - Arguments to find a PromptExecutionError
     * @example
     * // Get one PromptExecutionError
     * const promptExecutionError = await prisma.promptExecutionError.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PromptExecutionErrorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PromptExecutionErrorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PromptExecutionErrorClient<$Types.GetResult<PromptExecutionErrorPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PromptExecutionError that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptExecutionErrorFindFirstArgs} args - Arguments to find a PromptExecutionError
     * @example
     * // Get one PromptExecutionError
     * const promptExecutionError = await prisma.promptExecutionError.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PromptExecutionErrorFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PromptExecutionErrorFindFirstArgs<ExtArgs>>
    ): Prisma__PromptExecutionErrorClient<$Types.GetResult<PromptExecutionErrorPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PromptExecutionError that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptExecutionErrorFindFirstOrThrowArgs} args - Arguments to find a PromptExecutionError
     * @example
     * // Get one PromptExecutionError
     * const promptExecutionError = await prisma.promptExecutionError.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PromptExecutionErrorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PromptExecutionErrorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PromptExecutionErrorClient<$Types.GetResult<PromptExecutionErrorPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PromptExecutionErrors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptExecutionErrorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromptExecutionErrors
     * const promptExecutionErrors = await prisma.promptExecutionError.findMany()
     * 
     * // Get first 10 PromptExecutionErrors
     * const promptExecutionErrors = await prisma.promptExecutionError.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promptExecutionErrorWithIdOnly = await prisma.promptExecutionError.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PromptExecutionErrorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PromptExecutionErrorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PromptExecutionErrorPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PromptExecutionError.
     * @param {PromptExecutionErrorCreateArgs} args - Arguments to create a PromptExecutionError.
     * @example
     * // Create one PromptExecutionError
     * const PromptExecutionError = await prisma.promptExecutionError.create({
     *   data: {
     *     // ... data to create a PromptExecutionError
     *   }
     * })
     * 
    **/
    create<T extends PromptExecutionErrorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PromptExecutionErrorCreateArgs<ExtArgs>>
    ): Prisma__PromptExecutionErrorClient<$Types.GetResult<PromptExecutionErrorPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PromptExecutionErrors.
     *     @param {PromptExecutionErrorCreateManyArgs} args - Arguments to create many PromptExecutionErrors.
     *     @example
     *     // Create many PromptExecutionErrors
     *     const promptExecutionError = await prisma.promptExecutionError.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PromptExecutionErrorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PromptExecutionErrorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PromptExecutionError.
     * @param {PromptExecutionErrorDeleteArgs} args - Arguments to delete one PromptExecutionError.
     * @example
     * // Delete one PromptExecutionError
     * const PromptExecutionError = await prisma.promptExecutionError.delete({
     *   where: {
     *     // ... filter to delete one PromptExecutionError
     *   }
     * })
     * 
    **/
    delete<T extends PromptExecutionErrorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PromptExecutionErrorDeleteArgs<ExtArgs>>
    ): Prisma__PromptExecutionErrorClient<$Types.GetResult<PromptExecutionErrorPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PromptExecutionError.
     * @param {PromptExecutionErrorUpdateArgs} args - Arguments to update one PromptExecutionError.
     * @example
     * // Update one PromptExecutionError
     * const promptExecutionError = await prisma.promptExecutionError.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PromptExecutionErrorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PromptExecutionErrorUpdateArgs<ExtArgs>>
    ): Prisma__PromptExecutionErrorClient<$Types.GetResult<PromptExecutionErrorPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PromptExecutionErrors.
     * @param {PromptExecutionErrorDeleteManyArgs} args - Arguments to filter PromptExecutionErrors to delete.
     * @example
     * // Delete a few PromptExecutionErrors
     * const { count } = await prisma.promptExecutionError.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PromptExecutionErrorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PromptExecutionErrorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromptExecutionErrors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptExecutionErrorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromptExecutionErrors
     * const promptExecutionError = await prisma.promptExecutionError.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PromptExecutionErrorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PromptExecutionErrorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PromptExecutionError.
     * @param {PromptExecutionErrorUpsertArgs} args - Arguments to update or create a PromptExecutionError.
     * @example
     * // Update or create a PromptExecutionError
     * const promptExecutionError = await prisma.promptExecutionError.upsert({
     *   create: {
     *     // ... data to create a PromptExecutionError
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromptExecutionError we want to update
     *   }
     * })
    **/
    upsert<T extends PromptExecutionErrorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PromptExecutionErrorUpsertArgs<ExtArgs>>
    ): Prisma__PromptExecutionErrorClient<$Types.GetResult<PromptExecutionErrorPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PromptExecutionErrors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptExecutionErrorCountArgs} args - Arguments to filter PromptExecutionErrors to count.
     * @example
     * // Count the number of PromptExecutionErrors
     * const count = await prisma.promptExecutionError.count({
     *   where: {
     *     // ... the filter for the PromptExecutionErrors we want to count
     *   }
     * })
    **/
    count<T extends PromptExecutionErrorCountArgs>(
      args?: Subset<T, PromptExecutionErrorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromptExecutionErrorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromptExecutionError.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptExecutionErrorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromptExecutionErrorAggregateArgs>(args: Subset<T, PromptExecutionErrorAggregateArgs>): Prisma.PrismaPromise<GetPromptExecutionErrorAggregateType<T>>

    /**
     * Group by PromptExecutionError.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptExecutionErrorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromptExecutionErrorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromptExecutionErrorGroupByArgs['orderBy'] }
        : { orderBy?: PromptExecutionErrorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromptExecutionErrorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromptExecutionErrorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromptExecutionError model
   */
  readonly fields: PromptExecutionErrorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromptExecutionError.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PromptExecutionErrorClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the PromptExecutionError model
   */ 
  interface PromptExecutionErrorFieldRefs {
    readonly id: FieldRef<"PromptExecutionError", 'String'>
    readonly templateId: FieldRef<"PromptExecutionError", 'String'>
    readonly variables: FieldRef<"PromptExecutionError", 'Json'>
    readonly errorMessage: FieldRef<"PromptExecutionError", 'String'>
    readonly context: FieldRef<"PromptExecutionError", 'Json'>
    readonly createdAt: FieldRef<"PromptExecutionError", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * PromptExecutionError findUnique
   */
  export type PromptExecutionErrorFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptExecutionError
     */
    select?: PromptExecutionErrorSelect<ExtArgs> | null
    /**
     * Filter, which PromptExecutionError to fetch.
     */
    where: PromptExecutionErrorWhereUniqueInput
  }


  /**
   * PromptExecutionError findUniqueOrThrow
   */
  export type PromptExecutionErrorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptExecutionError
     */
    select?: PromptExecutionErrorSelect<ExtArgs> | null
    /**
     * Filter, which PromptExecutionError to fetch.
     */
    where: PromptExecutionErrorWhereUniqueInput
  }


  /**
   * PromptExecutionError findFirst
   */
  export type PromptExecutionErrorFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptExecutionError
     */
    select?: PromptExecutionErrorSelect<ExtArgs> | null
    /**
     * Filter, which PromptExecutionError to fetch.
     */
    where?: PromptExecutionErrorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptExecutionErrors to fetch.
     */
    orderBy?: PromptExecutionErrorOrderByWithRelationInput | PromptExecutionErrorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromptExecutionErrors.
     */
    cursor?: PromptExecutionErrorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptExecutionErrors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptExecutionErrors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromptExecutionErrors.
     */
    distinct?: PromptExecutionErrorScalarFieldEnum | PromptExecutionErrorScalarFieldEnum[]
  }


  /**
   * PromptExecutionError findFirstOrThrow
   */
  export type PromptExecutionErrorFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptExecutionError
     */
    select?: PromptExecutionErrorSelect<ExtArgs> | null
    /**
     * Filter, which PromptExecutionError to fetch.
     */
    where?: PromptExecutionErrorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptExecutionErrors to fetch.
     */
    orderBy?: PromptExecutionErrorOrderByWithRelationInput | PromptExecutionErrorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromptExecutionErrors.
     */
    cursor?: PromptExecutionErrorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptExecutionErrors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptExecutionErrors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromptExecutionErrors.
     */
    distinct?: PromptExecutionErrorScalarFieldEnum | PromptExecutionErrorScalarFieldEnum[]
  }


  /**
   * PromptExecutionError findMany
   */
  export type PromptExecutionErrorFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptExecutionError
     */
    select?: PromptExecutionErrorSelect<ExtArgs> | null
    /**
     * Filter, which PromptExecutionErrors to fetch.
     */
    where?: PromptExecutionErrorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromptExecutionErrors to fetch.
     */
    orderBy?: PromptExecutionErrorOrderByWithRelationInput | PromptExecutionErrorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromptExecutionErrors.
     */
    cursor?: PromptExecutionErrorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromptExecutionErrors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromptExecutionErrors.
     */
    skip?: number
    distinct?: PromptExecutionErrorScalarFieldEnum | PromptExecutionErrorScalarFieldEnum[]
  }


  /**
   * PromptExecutionError create
   */
  export type PromptExecutionErrorCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptExecutionError
     */
    select?: PromptExecutionErrorSelect<ExtArgs> | null
    /**
     * The data needed to create a PromptExecutionError.
     */
    data: XOR<PromptExecutionErrorCreateInput, PromptExecutionErrorUncheckedCreateInput>
  }


  /**
   * PromptExecutionError createMany
   */
  export type PromptExecutionErrorCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromptExecutionErrors.
     */
    data: PromptExecutionErrorCreateManyInput | PromptExecutionErrorCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PromptExecutionError update
   */
  export type PromptExecutionErrorUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptExecutionError
     */
    select?: PromptExecutionErrorSelect<ExtArgs> | null
    /**
     * The data needed to update a PromptExecutionError.
     */
    data: XOR<PromptExecutionErrorUpdateInput, PromptExecutionErrorUncheckedUpdateInput>
    /**
     * Choose, which PromptExecutionError to update.
     */
    where: PromptExecutionErrorWhereUniqueInput
  }


  /**
   * PromptExecutionError updateMany
   */
  export type PromptExecutionErrorUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromptExecutionErrors.
     */
    data: XOR<PromptExecutionErrorUpdateManyMutationInput, PromptExecutionErrorUncheckedUpdateManyInput>
    /**
     * Filter which PromptExecutionErrors to update
     */
    where?: PromptExecutionErrorWhereInput
  }


  /**
   * PromptExecutionError upsert
   */
  export type PromptExecutionErrorUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptExecutionError
     */
    select?: PromptExecutionErrorSelect<ExtArgs> | null
    /**
     * The filter to search for the PromptExecutionError to update in case it exists.
     */
    where: PromptExecutionErrorWhereUniqueInput
    /**
     * In case the PromptExecutionError found by the `where` argument doesn't exist, create a new PromptExecutionError with this data.
     */
    create: XOR<PromptExecutionErrorCreateInput, PromptExecutionErrorUncheckedCreateInput>
    /**
     * In case the PromptExecutionError was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromptExecutionErrorUpdateInput, PromptExecutionErrorUncheckedUpdateInput>
  }


  /**
   * PromptExecutionError delete
   */
  export type PromptExecutionErrorDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptExecutionError
     */
    select?: PromptExecutionErrorSelect<ExtArgs> | null
    /**
     * Filter which PromptExecutionError to delete.
     */
    where: PromptExecutionErrorWhereUniqueInput
  }


  /**
   * PromptExecutionError deleteMany
   */
  export type PromptExecutionErrorDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromptExecutionErrors to delete
     */
    where?: PromptExecutionErrorWhereInput
  }


  /**
   * PromptExecutionError without action
   */
  export type PromptExecutionErrorArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptExecutionError
     */
    select?: PromptExecutionErrorSelect<ExtArgs> | null
  }



  /**
   * Model ABTest
   */


  export type AggregateABTest = {
    _count: ABTestCountAggregateOutputType | null
    _avg: ABTestAvgAggregateOutputType | null
    _sum: ABTestSumAggregateOutputType | null
    _min: ABTestMinAggregateOutputType | null
    _max: ABTestMaxAggregateOutputType | null
  }

  export type ABTestAvgAggregateOutputType = {
    sampleSize: number | null
    confidence: Decimal | null
  }

  export type ABTestSumAggregateOutputType = {
    sampleSize: number | null
    confidence: Decimal | null
  }

  export type ABTestMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    sampleSize: number | null
    confidence: Decimal | null
    createdAt: Date | null
  }

  export type ABTestMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    sampleSize: number | null
    confidence: Decimal | null
    createdAt: Date | null
  }

  export type ABTestCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    variants: number
    trafficSplit: number
    startDate: number
    endDate: number
    sampleSize: number
    confidence: number
    results: number
    createdAt: number
    _all: number
  }


  export type ABTestAvgAggregateInputType = {
    sampleSize?: true
    confidence?: true
  }

  export type ABTestSumAggregateInputType = {
    sampleSize?: true
    confidence?: true
  }

  export type ABTestMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    startDate?: true
    endDate?: true
    sampleSize?: true
    confidence?: true
    createdAt?: true
  }

  export type ABTestMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    startDate?: true
    endDate?: true
    sampleSize?: true
    confidence?: true
    createdAt?: true
  }

  export type ABTestCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    variants?: true
    trafficSplit?: true
    startDate?: true
    endDate?: true
    sampleSize?: true
    confidence?: true
    results?: true
    createdAt?: true
    _all?: true
  }

  export type ABTestAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ABTest to aggregate.
     */
    where?: ABTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ABTests to fetch.
     */
    orderBy?: ABTestOrderByWithRelationInput | ABTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ABTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ABTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ABTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ABTests
    **/
    _count?: true | ABTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ABTestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ABTestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ABTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ABTestMaxAggregateInputType
  }

  export type GetABTestAggregateType<T extends ABTestAggregateArgs> = {
        [P in keyof T & keyof AggregateABTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateABTest[P]>
      : GetScalarType<T[P], AggregateABTest[P]>
  }




  export type ABTestGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ABTestWhereInput
    orderBy?: ABTestOrderByWithAggregationInput | ABTestOrderByWithAggregationInput[]
    by: ABTestScalarFieldEnum[] | ABTestScalarFieldEnum
    having?: ABTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ABTestCountAggregateInputType | true
    _avg?: ABTestAvgAggregateInputType
    _sum?: ABTestSumAggregateInputType
    _min?: ABTestMinAggregateInputType
    _max?: ABTestMaxAggregateInputType
  }


  export type ABTestGroupByOutputType = {
    id: string
    name: string
    description: string | null
    status: string
    variants: JsonValue
    trafficSplit: JsonValue
    startDate: Date | null
    endDate: Date | null
    sampleSize: number
    confidence: Decimal
    results: JsonValue | null
    createdAt: Date
    _count: ABTestCountAggregateOutputType | null
    _avg: ABTestAvgAggregateOutputType | null
    _sum: ABTestSumAggregateOutputType | null
    _min: ABTestMinAggregateOutputType | null
    _max: ABTestMaxAggregateOutputType | null
  }

  type GetABTestGroupByPayload<T extends ABTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ABTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ABTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ABTestGroupByOutputType[P]>
            : GetScalarType<T[P], ABTestGroupByOutputType[P]>
        }
      >
    >


  export type ABTestSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    variants?: boolean
    trafficSplit?: boolean
    startDate?: boolean
    endDate?: boolean
    sampleSize?: boolean
    confidence?: boolean
    results?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aBTest"]>

  export type ABTestSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    variants?: boolean
    trafficSplit?: boolean
    startDate?: boolean
    endDate?: boolean
    sampleSize?: boolean
    confidence?: boolean
    results?: boolean
    createdAt?: boolean
  }


  type ABTestGetPayload<S extends boolean | null | undefined | ABTestArgs> = $Types.GetResult<ABTestPayload, S>

  type ABTestCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ABTestFindManyArgs, 'select' | 'include'> & {
      select?: ABTestCountAggregateInputType | true
    }

  export interface ABTestDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ABTest'], meta: { name: 'ABTest' } }
    /**
     * Find zero or one ABTest that matches the filter.
     * @param {ABTestFindUniqueArgs} args - Arguments to find a ABTest
     * @example
     * // Get one ABTest
     * const aBTest = await prisma.aBTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ABTestFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ABTestFindUniqueArgs<ExtArgs>>
    ): Prisma__ABTestClient<$Types.GetResult<ABTestPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ABTest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ABTestFindUniqueOrThrowArgs} args - Arguments to find a ABTest
     * @example
     * // Get one ABTest
     * const aBTest = await prisma.aBTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ABTestFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ABTestFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ABTestClient<$Types.GetResult<ABTestPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ABTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestFindFirstArgs} args - Arguments to find a ABTest
     * @example
     * // Get one ABTest
     * const aBTest = await prisma.aBTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ABTestFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ABTestFindFirstArgs<ExtArgs>>
    ): Prisma__ABTestClient<$Types.GetResult<ABTestPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ABTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestFindFirstOrThrowArgs} args - Arguments to find a ABTest
     * @example
     * // Get one ABTest
     * const aBTest = await prisma.aBTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ABTestFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ABTestFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ABTestClient<$Types.GetResult<ABTestPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ABTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ABTests
     * const aBTests = await prisma.aBTest.findMany()
     * 
     * // Get first 10 ABTests
     * const aBTests = await prisma.aBTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aBTestWithIdOnly = await prisma.aBTest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ABTestFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ABTestFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ABTestPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ABTest.
     * @param {ABTestCreateArgs} args - Arguments to create a ABTest.
     * @example
     * // Create one ABTest
     * const ABTest = await prisma.aBTest.create({
     *   data: {
     *     // ... data to create a ABTest
     *   }
     * })
     * 
    **/
    create<T extends ABTestCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ABTestCreateArgs<ExtArgs>>
    ): Prisma__ABTestClient<$Types.GetResult<ABTestPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ABTests.
     *     @param {ABTestCreateManyArgs} args - Arguments to create many ABTests.
     *     @example
     *     // Create many ABTests
     *     const aBTest = await prisma.aBTest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ABTestCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ABTestCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ABTest.
     * @param {ABTestDeleteArgs} args - Arguments to delete one ABTest.
     * @example
     * // Delete one ABTest
     * const ABTest = await prisma.aBTest.delete({
     *   where: {
     *     // ... filter to delete one ABTest
     *   }
     * })
     * 
    **/
    delete<T extends ABTestDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ABTestDeleteArgs<ExtArgs>>
    ): Prisma__ABTestClient<$Types.GetResult<ABTestPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ABTest.
     * @param {ABTestUpdateArgs} args - Arguments to update one ABTest.
     * @example
     * // Update one ABTest
     * const aBTest = await prisma.aBTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ABTestUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ABTestUpdateArgs<ExtArgs>>
    ): Prisma__ABTestClient<$Types.GetResult<ABTestPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ABTests.
     * @param {ABTestDeleteManyArgs} args - Arguments to filter ABTests to delete.
     * @example
     * // Delete a few ABTests
     * const { count } = await prisma.aBTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ABTestDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ABTestDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ABTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ABTests
     * const aBTest = await prisma.aBTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ABTestUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ABTestUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ABTest.
     * @param {ABTestUpsertArgs} args - Arguments to update or create a ABTest.
     * @example
     * // Update or create a ABTest
     * const aBTest = await prisma.aBTest.upsert({
     *   create: {
     *     // ... data to create a ABTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ABTest we want to update
     *   }
     * })
    **/
    upsert<T extends ABTestUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ABTestUpsertArgs<ExtArgs>>
    ): Prisma__ABTestClient<$Types.GetResult<ABTestPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ABTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestCountArgs} args - Arguments to filter ABTests to count.
     * @example
     * // Count the number of ABTests
     * const count = await prisma.aBTest.count({
     *   where: {
     *     // ... the filter for the ABTests we want to count
     *   }
     * })
    **/
    count<T extends ABTestCountArgs>(
      args?: Subset<T, ABTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ABTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ABTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ABTestAggregateArgs>(args: Subset<T, ABTestAggregateArgs>): Prisma.PrismaPromise<GetABTestAggregateType<T>>

    /**
     * Group by ABTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ABTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ABTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ABTestGroupByArgs['orderBy'] }
        : { orderBy?: ABTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ABTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetABTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ABTest model
   */
  readonly fields: ABTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ABTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ABTestClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the ABTest model
   */ 
  interface ABTestFieldRefs {
    readonly id: FieldRef<"ABTest", 'String'>
    readonly name: FieldRef<"ABTest", 'String'>
    readonly description: FieldRef<"ABTest", 'String'>
    readonly status: FieldRef<"ABTest", 'String'>
    readonly variants: FieldRef<"ABTest", 'Json'>
    readonly trafficSplit: FieldRef<"ABTest", 'Json'>
    readonly startDate: FieldRef<"ABTest", 'DateTime'>
    readonly endDate: FieldRef<"ABTest", 'DateTime'>
    readonly sampleSize: FieldRef<"ABTest", 'Int'>
    readonly confidence: FieldRef<"ABTest", 'Decimal'>
    readonly results: FieldRef<"ABTest", 'Json'>
    readonly createdAt: FieldRef<"ABTest", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ABTest findUnique
   */
  export type ABTestFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * Filter, which ABTest to fetch.
     */
    where: ABTestWhereUniqueInput
  }


  /**
   * ABTest findUniqueOrThrow
   */
  export type ABTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * Filter, which ABTest to fetch.
     */
    where: ABTestWhereUniqueInput
  }


  /**
   * ABTest findFirst
   */
  export type ABTestFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * Filter, which ABTest to fetch.
     */
    where?: ABTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ABTests to fetch.
     */
    orderBy?: ABTestOrderByWithRelationInput | ABTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ABTests.
     */
    cursor?: ABTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ABTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ABTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ABTests.
     */
    distinct?: ABTestScalarFieldEnum | ABTestScalarFieldEnum[]
  }


  /**
   * ABTest findFirstOrThrow
   */
  export type ABTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * Filter, which ABTest to fetch.
     */
    where?: ABTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ABTests to fetch.
     */
    orderBy?: ABTestOrderByWithRelationInput | ABTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ABTests.
     */
    cursor?: ABTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ABTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ABTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ABTests.
     */
    distinct?: ABTestScalarFieldEnum | ABTestScalarFieldEnum[]
  }


  /**
   * ABTest findMany
   */
  export type ABTestFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * Filter, which ABTests to fetch.
     */
    where?: ABTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ABTests to fetch.
     */
    orderBy?: ABTestOrderByWithRelationInput | ABTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ABTests.
     */
    cursor?: ABTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ABTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ABTests.
     */
    skip?: number
    distinct?: ABTestScalarFieldEnum | ABTestScalarFieldEnum[]
  }


  /**
   * ABTest create
   */
  export type ABTestCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * The data needed to create a ABTest.
     */
    data: XOR<ABTestCreateInput, ABTestUncheckedCreateInput>
  }


  /**
   * ABTest createMany
   */
  export type ABTestCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ABTests.
     */
    data: ABTestCreateManyInput | ABTestCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ABTest update
   */
  export type ABTestUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * The data needed to update a ABTest.
     */
    data: XOR<ABTestUpdateInput, ABTestUncheckedUpdateInput>
    /**
     * Choose, which ABTest to update.
     */
    where: ABTestWhereUniqueInput
  }


  /**
   * ABTest updateMany
   */
  export type ABTestUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ABTests.
     */
    data: XOR<ABTestUpdateManyMutationInput, ABTestUncheckedUpdateManyInput>
    /**
     * Filter which ABTests to update
     */
    where?: ABTestWhereInput
  }


  /**
   * ABTest upsert
   */
  export type ABTestUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * The filter to search for the ABTest to update in case it exists.
     */
    where: ABTestWhereUniqueInput
    /**
     * In case the ABTest found by the `where` argument doesn't exist, create a new ABTest with this data.
     */
    create: XOR<ABTestCreateInput, ABTestUncheckedCreateInput>
    /**
     * In case the ABTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ABTestUpdateInput, ABTestUncheckedUpdateInput>
  }


  /**
   * ABTest delete
   */
  export type ABTestDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
    /**
     * Filter which ABTest to delete.
     */
    where: ABTestWhereUniqueInput
  }


  /**
   * ABTest deleteMany
   */
  export type ABTestDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ABTests to delete
     */
    where?: ABTestWhereInput
  }


  /**
   * ABTest without action
   */
  export type ABTestArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ABTest
     */
    select?: ABTestSelect<ExtArgs> | null
  }



  /**
   * Model OptimizationRecord
   */


  export type AggregateOptimizationRecord = {
    _count: OptimizationRecordCountAggregateOutputType | null
    _avg: OptimizationRecordAvgAggregateOutputType | null
    _sum: OptimizationRecordSumAggregateOutputType | null
    _min: OptimizationRecordMinAggregateOutputType | null
    _max: OptimizationRecordMaxAggregateOutputType | null
  }

  export type OptimizationRecordAvgAggregateOutputType = {
    improvement: Decimal | null
  }

  export type OptimizationRecordSumAggregateOutputType = {
    improvement: Decimal | null
  }

  export type OptimizationRecordMinAggregateOutputType = {
    id: string | null
    templateId: string | null
    timestamp: Date | null
    type: string | null
    reason: string | null
    improvement: Decimal | null
    createdAt: Date | null
  }

  export type OptimizationRecordMaxAggregateOutputType = {
    id: string | null
    templateId: string | null
    timestamp: Date | null
    type: string | null
    reason: string | null
    improvement: Decimal | null
    createdAt: Date | null
  }

  export type OptimizationRecordCountAggregateOutputType = {
    id: number
    templateId: number
    timestamp: number
    type: number
    reason: number
    changes: number
    metricsBefore: number
    metricsAfter: number
    improvement: number
    createdAt: number
    _all: number
  }


  export type OptimizationRecordAvgAggregateInputType = {
    improvement?: true
  }

  export type OptimizationRecordSumAggregateInputType = {
    improvement?: true
  }

  export type OptimizationRecordMinAggregateInputType = {
    id?: true
    templateId?: true
    timestamp?: true
    type?: true
    reason?: true
    improvement?: true
    createdAt?: true
  }

  export type OptimizationRecordMaxAggregateInputType = {
    id?: true
    templateId?: true
    timestamp?: true
    type?: true
    reason?: true
    improvement?: true
    createdAt?: true
  }

  export type OptimizationRecordCountAggregateInputType = {
    id?: true
    templateId?: true
    timestamp?: true
    type?: true
    reason?: true
    changes?: true
    metricsBefore?: true
    metricsAfter?: true
    improvement?: true
    createdAt?: true
    _all?: true
  }

  export type OptimizationRecordAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OptimizationRecord to aggregate.
     */
    where?: OptimizationRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptimizationRecords to fetch.
     */
    orderBy?: OptimizationRecordOrderByWithRelationInput | OptimizationRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OptimizationRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptimizationRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptimizationRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OptimizationRecords
    **/
    _count?: true | OptimizationRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OptimizationRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OptimizationRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OptimizationRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OptimizationRecordMaxAggregateInputType
  }

  export type GetOptimizationRecordAggregateType<T extends OptimizationRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateOptimizationRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOptimizationRecord[P]>
      : GetScalarType<T[P], AggregateOptimizationRecord[P]>
  }




  export type OptimizationRecordGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OptimizationRecordWhereInput
    orderBy?: OptimizationRecordOrderByWithAggregationInput | OptimizationRecordOrderByWithAggregationInput[]
    by: OptimizationRecordScalarFieldEnum[] | OptimizationRecordScalarFieldEnum
    having?: OptimizationRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OptimizationRecordCountAggregateInputType | true
    _avg?: OptimizationRecordAvgAggregateInputType
    _sum?: OptimizationRecordSumAggregateInputType
    _min?: OptimizationRecordMinAggregateInputType
    _max?: OptimizationRecordMaxAggregateInputType
  }


  export type OptimizationRecordGroupByOutputType = {
    id: string
    templateId: string
    timestamp: Date
    type: string
    reason: string | null
    changes: JsonValue
    metricsBefore: JsonValue
    metricsAfter: JsonValue
    improvement: Decimal | null
    createdAt: Date
    _count: OptimizationRecordCountAggregateOutputType | null
    _avg: OptimizationRecordAvgAggregateOutputType | null
    _sum: OptimizationRecordSumAggregateOutputType | null
    _min: OptimizationRecordMinAggregateOutputType | null
    _max: OptimizationRecordMaxAggregateOutputType | null
  }

  type GetOptimizationRecordGroupByPayload<T extends OptimizationRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OptimizationRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OptimizationRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OptimizationRecordGroupByOutputType[P]>
            : GetScalarType<T[P], OptimizationRecordGroupByOutputType[P]>
        }
      >
    >


  export type OptimizationRecordSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    templateId?: boolean
    timestamp?: boolean
    type?: boolean
    reason?: boolean
    changes?: boolean
    metricsBefore?: boolean
    metricsAfter?: boolean
    improvement?: boolean
    createdAt?: boolean
    template?: boolean | PromptTemplateArgs<ExtArgs>
  }, ExtArgs["result"]["optimizationRecord"]>

  export type OptimizationRecordSelectScalar = {
    id?: boolean
    templateId?: boolean
    timestamp?: boolean
    type?: boolean
    reason?: boolean
    changes?: boolean
    metricsBefore?: boolean
    metricsAfter?: boolean
    improvement?: boolean
    createdAt?: boolean
  }

  export type OptimizationRecordInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    template?: boolean | PromptTemplateArgs<ExtArgs>
  }


  type OptimizationRecordGetPayload<S extends boolean | null | undefined | OptimizationRecordArgs> = $Types.GetResult<OptimizationRecordPayload, S>

  type OptimizationRecordCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OptimizationRecordFindManyArgs, 'select' | 'include'> & {
      select?: OptimizationRecordCountAggregateInputType | true
    }

  export interface OptimizationRecordDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OptimizationRecord'], meta: { name: 'OptimizationRecord' } }
    /**
     * Find zero or one OptimizationRecord that matches the filter.
     * @param {OptimizationRecordFindUniqueArgs} args - Arguments to find a OptimizationRecord
     * @example
     * // Get one OptimizationRecord
     * const optimizationRecord = await prisma.optimizationRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OptimizationRecordFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OptimizationRecordFindUniqueArgs<ExtArgs>>
    ): Prisma__OptimizationRecordClient<$Types.GetResult<OptimizationRecordPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OptimizationRecord that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OptimizationRecordFindUniqueOrThrowArgs} args - Arguments to find a OptimizationRecord
     * @example
     * // Get one OptimizationRecord
     * const optimizationRecord = await prisma.optimizationRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OptimizationRecordFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OptimizationRecordFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OptimizationRecordClient<$Types.GetResult<OptimizationRecordPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OptimizationRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptimizationRecordFindFirstArgs} args - Arguments to find a OptimizationRecord
     * @example
     * // Get one OptimizationRecord
     * const optimizationRecord = await prisma.optimizationRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OptimizationRecordFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OptimizationRecordFindFirstArgs<ExtArgs>>
    ): Prisma__OptimizationRecordClient<$Types.GetResult<OptimizationRecordPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OptimizationRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptimizationRecordFindFirstOrThrowArgs} args - Arguments to find a OptimizationRecord
     * @example
     * // Get one OptimizationRecord
     * const optimizationRecord = await prisma.optimizationRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OptimizationRecordFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OptimizationRecordFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OptimizationRecordClient<$Types.GetResult<OptimizationRecordPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OptimizationRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptimizationRecordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OptimizationRecords
     * const optimizationRecords = await prisma.optimizationRecord.findMany()
     * 
     * // Get first 10 OptimizationRecords
     * const optimizationRecords = await prisma.optimizationRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const optimizationRecordWithIdOnly = await prisma.optimizationRecord.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OptimizationRecordFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OptimizationRecordFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<OptimizationRecordPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OptimizationRecord.
     * @param {OptimizationRecordCreateArgs} args - Arguments to create a OptimizationRecord.
     * @example
     * // Create one OptimizationRecord
     * const OptimizationRecord = await prisma.optimizationRecord.create({
     *   data: {
     *     // ... data to create a OptimizationRecord
     *   }
     * })
     * 
    **/
    create<T extends OptimizationRecordCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OptimizationRecordCreateArgs<ExtArgs>>
    ): Prisma__OptimizationRecordClient<$Types.GetResult<OptimizationRecordPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OptimizationRecords.
     *     @param {OptimizationRecordCreateManyArgs} args - Arguments to create many OptimizationRecords.
     *     @example
     *     // Create many OptimizationRecords
     *     const optimizationRecord = await prisma.optimizationRecord.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OptimizationRecordCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OptimizationRecordCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OptimizationRecord.
     * @param {OptimizationRecordDeleteArgs} args - Arguments to delete one OptimizationRecord.
     * @example
     * // Delete one OptimizationRecord
     * const OptimizationRecord = await prisma.optimizationRecord.delete({
     *   where: {
     *     // ... filter to delete one OptimizationRecord
     *   }
     * })
     * 
    **/
    delete<T extends OptimizationRecordDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OptimizationRecordDeleteArgs<ExtArgs>>
    ): Prisma__OptimizationRecordClient<$Types.GetResult<OptimizationRecordPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OptimizationRecord.
     * @param {OptimizationRecordUpdateArgs} args - Arguments to update one OptimizationRecord.
     * @example
     * // Update one OptimizationRecord
     * const optimizationRecord = await prisma.optimizationRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OptimizationRecordUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OptimizationRecordUpdateArgs<ExtArgs>>
    ): Prisma__OptimizationRecordClient<$Types.GetResult<OptimizationRecordPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OptimizationRecords.
     * @param {OptimizationRecordDeleteManyArgs} args - Arguments to filter OptimizationRecords to delete.
     * @example
     * // Delete a few OptimizationRecords
     * const { count } = await prisma.optimizationRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OptimizationRecordDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OptimizationRecordDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OptimizationRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptimizationRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OptimizationRecords
     * const optimizationRecord = await prisma.optimizationRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OptimizationRecordUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OptimizationRecordUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OptimizationRecord.
     * @param {OptimizationRecordUpsertArgs} args - Arguments to update or create a OptimizationRecord.
     * @example
     * // Update or create a OptimizationRecord
     * const optimizationRecord = await prisma.optimizationRecord.upsert({
     *   create: {
     *     // ... data to create a OptimizationRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OptimizationRecord we want to update
     *   }
     * })
    **/
    upsert<T extends OptimizationRecordUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OptimizationRecordUpsertArgs<ExtArgs>>
    ): Prisma__OptimizationRecordClient<$Types.GetResult<OptimizationRecordPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of OptimizationRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptimizationRecordCountArgs} args - Arguments to filter OptimizationRecords to count.
     * @example
     * // Count the number of OptimizationRecords
     * const count = await prisma.optimizationRecord.count({
     *   where: {
     *     // ... the filter for the OptimizationRecords we want to count
     *   }
     * })
    **/
    count<T extends OptimizationRecordCountArgs>(
      args?: Subset<T, OptimizationRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OptimizationRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OptimizationRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptimizationRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OptimizationRecordAggregateArgs>(args: Subset<T, OptimizationRecordAggregateArgs>): Prisma.PrismaPromise<GetOptimizationRecordAggregateType<T>>

    /**
     * Group by OptimizationRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptimizationRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OptimizationRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OptimizationRecordGroupByArgs['orderBy'] }
        : { orderBy?: OptimizationRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OptimizationRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOptimizationRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OptimizationRecord model
   */
  readonly fields: OptimizationRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OptimizationRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OptimizationRecordClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    template<T extends PromptTemplateArgs<ExtArgs> = {}>(args?: Subset<T, PromptTemplateArgs<ExtArgs>>): Prisma__PromptTemplateClient<$Types.GetResult<PromptTemplatePayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the OptimizationRecord model
   */ 
  interface OptimizationRecordFieldRefs {
    readonly id: FieldRef<"OptimizationRecord", 'String'>
    readonly templateId: FieldRef<"OptimizationRecord", 'String'>
    readonly timestamp: FieldRef<"OptimizationRecord", 'DateTime'>
    readonly type: FieldRef<"OptimizationRecord", 'String'>
    readonly reason: FieldRef<"OptimizationRecord", 'String'>
    readonly changes: FieldRef<"OptimizationRecord", 'Json'>
    readonly metricsBefore: FieldRef<"OptimizationRecord", 'Json'>
    readonly metricsAfter: FieldRef<"OptimizationRecord", 'Json'>
    readonly improvement: FieldRef<"OptimizationRecord", 'Decimal'>
    readonly createdAt: FieldRef<"OptimizationRecord", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * OptimizationRecord findUnique
   */
  export type OptimizationRecordFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRecord
     */
    select?: OptimizationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OptimizationRecordInclude<ExtArgs> | null
    /**
     * Filter, which OptimizationRecord to fetch.
     */
    where: OptimizationRecordWhereUniqueInput
  }


  /**
   * OptimizationRecord findUniqueOrThrow
   */
  export type OptimizationRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRecord
     */
    select?: OptimizationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OptimizationRecordInclude<ExtArgs> | null
    /**
     * Filter, which OptimizationRecord to fetch.
     */
    where: OptimizationRecordWhereUniqueInput
  }


  /**
   * OptimizationRecord findFirst
   */
  export type OptimizationRecordFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRecord
     */
    select?: OptimizationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OptimizationRecordInclude<ExtArgs> | null
    /**
     * Filter, which OptimizationRecord to fetch.
     */
    where?: OptimizationRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptimizationRecords to fetch.
     */
    orderBy?: OptimizationRecordOrderByWithRelationInput | OptimizationRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OptimizationRecords.
     */
    cursor?: OptimizationRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptimizationRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptimizationRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OptimizationRecords.
     */
    distinct?: OptimizationRecordScalarFieldEnum | OptimizationRecordScalarFieldEnum[]
  }


  /**
   * OptimizationRecord findFirstOrThrow
   */
  export type OptimizationRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRecord
     */
    select?: OptimizationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OptimizationRecordInclude<ExtArgs> | null
    /**
     * Filter, which OptimizationRecord to fetch.
     */
    where?: OptimizationRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptimizationRecords to fetch.
     */
    orderBy?: OptimizationRecordOrderByWithRelationInput | OptimizationRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OptimizationRecords.
     */
    cursor?: OptimizationRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptimizationRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptimizationRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OptimizationRecords.
     */
    distinct?: OptimizationRecordScalarFieldEnum | OptimizationRecordScalarFieldEnum[]
  }


  /**
   * OptimizationRecord findMany
   */
  export type OptimizationRecordFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRecord
     */
    select?: OptimizationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OptimizationRecordInclude<ExtArgs> | null
    /**
     * Filter, which OptimizationRecords to fetch.
     */
    where?: OptimizationRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OptimizationRecords to fetch.
     */
    orderBy?: OptimizationRecordOrderByWithRelationInput | OptimizationRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OptimizationRecords.
     */
    cursor?: OptimizationRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OptimizationRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OptimizationRecords.
     */
    skip?: number
    distinct?: OptimizationRecordScalarFieldEnum | OptimizationRecordScalarFieldEnum[]
  }


  /**
   * OptimizationRecord create
   */
  export type OptimizationRecordCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRecord
     */
    select?: OptimizationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OptimizationRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a OptimizationRecord.
     */
    data: XOR<OptimizationRecordCreateInput, OptimizationRecordUncheckedCreateInput>
  }


  /**
   * OptimizationRecord createMany
   */
  export type OptimizationRecordCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OptimizationRecords.
     */
    data: OptimizationRecordCreateManyInput | OptimizationRecordCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * OptimizationRecord update
   */
  export type OptimizationRecordUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRecord
     */
    select?: OptimizationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OptimizationRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a OptimizationRecord.
     */
    data: XOR<OptimizationRecordUpdateInput, OptimizationRecordUncheckedUpdateInput>
    /**
     * Choose, which OptimizationRecord to update.
     */
    where: OptimizationRecordWhereUniqueInput
  }


  /**
   * OptimizationRecord updateMany
   */
  export type OptimizationRecordUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OptimizationRecords.
     */
    data: XOR<OptimizationRecordUpdateManyMutationInput, OptimizationRecordUncheckedUpdateManyInput>
    /**
     * Filter which OptimizationRecords to update
     */
    where?: OptimizationRecordWhereInput
  }


  /**
   * OptimizationRecord upsert
   */
  export type OptimizationRecordUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRecord
     */
    select?: OptimizationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OptimizationRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the OptimizationRecord to update in case it exists.
     */
    where: OptimizationRecordWhereUniqueInput
    /**
     * In case the OptimizationRecord found by the `where` argument doesn't exist, create a new OptimizationRecord with this data.
     */
    create: XOR<OptimizationRecordCreateInput, OptimizationRecordUncheckedCreateInput>
    /**
     * In case the OptimizationRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OptimizationRecordUpdateInput, OptimizationRecordUncheckedUpdateInput>
  }


  /**
   * OptimizationRecord delete
   */
  export type OptimizationRecordDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRecord
     */
    select?: OptimizationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OptimizationRecordInclude<ExtArgs> | null
    /**
     * Filter which OptimizationRecord to delete.
     */
    where: OptimizationRecordWhereUniqueInput
  }


  /**
   * OptimizationRecord deleteMany
   */
  export type OptimizationRecordDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which OptimizationRecords to delete
     */
    where?: OptimizationRecordWhereInput
  }


  /**
   * OptimizationRecord without action
   */
  export type OptimizationRecordArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OptimizationRecord
     */
    select?: OptimizationRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OptimizationRecordInclude<ExtArgs> | null
  }



  /**
   * Model Conversation
   */


  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    metadata: number
    settings: number
    analytics: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    metadata?: true
    settings?: true
    analytics?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }


  export type ConversationGroupByOutputType = {
    id: string
    userId: string
    title: string
    metadata: JsonValue
    settings: JsonValue
    analytics: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    metadata?: boolean
    settings?: boolean
    analytics?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    shares?: boolean | Conversation$sharesArgs<ExtArgs>
    exports?: boolean | Conversation$exportsArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    metadata?: boolean
    settings?: boolean
    analytics?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConversationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    shares?: boolean | Conversation$sharesArgs<ExtArgs>
    exports?: boolean | Conversation$exportsArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeArgs<ExtArgs>
  }


  type ConversationGetPayload<S extends boolean | null | undefined | ConversationArgs> = $Types.GetResult<ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ConversationFindManyArgs, 'select' | 'include'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConversationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Types.GetResult<ConversationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Conversation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Types.GetResult<ConversationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConversationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Types.GetResult<ConversationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Types.GetResult<ConversationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConversationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ConversationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
    **/
    create<T extends ConversationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Types.GetResult<ConversationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Conversations.
     *     @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     *     @example
     *     // Create many Conversations
     *     const conversation = await prisma.conversation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConversationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
    **/
    delete<T extends ConversationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Types.GetResult<ConversationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConversationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Types.GetResult<ConversationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConversationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConversationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
    **/
    upsert<T extends ConversationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Types.GetResult<ConversationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<MessagePayload<ExtArgs>, T, 'findMany'>| Null>;

    shares<T extends Conversation$sharesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$sharesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ConversationSharePayload<ExtArgs>, T, 'findMany'>| Null>;

    exports<T extends Conversation$exportsArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$exportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ConversationExportPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the Conversation model
   */ 
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly userId: FieldRef<"Conversation", 'String'>
    readonly title: FieldRef<"Conversation", 'String'>
    readonly metadata: FieldRef<"Conversation", 'Json'>
    readonly settings: FieldRef<"Conversation", 'Json'>
    readonly analytics: FieldRef<"Conversation", 'Json'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
    readonly updatedAt: FieldRef<"Conversation", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }


  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }


  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }


  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }


  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }


  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }


  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }


  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
  }


  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }


  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }


  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
  }


  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * Conversation.shares
   */
  export type Conversation$sharesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationShare
     */
    select?: ConversationShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationShareInclude<ExtArgs> | null
    where?: ConversationShareWhereInput
    orderBy?: ConversationShareOrderByWithRelationInput | ConversationShareOrderByWithRelationInput[]
    cursor?: ConversationShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationShareScalarFieldEnum | ConversationShareScalarFieldEnum[]
  }


  /**
   * Conversation.exports
   */
  export type Conversation$exportsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationExport
     */
    select?: ConversationExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationExportInclude<ExtArgs> | null
    where?: ConversationExportWhereInput
    orderBy?: ConversationExportOrderByWithRelationInput | ConversationExportOrderByWithRelationInput[]
    cursor?: ConversationExportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationExportScalarFieldEnum | ConversationExportScalarFieldEnum[]
  }


  /**
   * Conversation without action
   */
  export type ConversationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
  }



  /**
   * Model Message
   */


  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    role: string | null
    content: string | null
    timestamp: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    role: string | null
    content: string | null
    timestamp: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    conversationId: number
    role: number
    content: number
    timestamp: number
    metadata: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    timestamp?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    timestamp?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    timestamp?: true
    metadata?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }


  export type MessageGroupByOutputType = {
    id: string
    conversationId: string
    role: string
    content: string
    timestamp: Date
    metadata: JsonValue
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    timestamp?: boolean
    metadata?: boolean
    conversation?: boolean | ConversationArgs<ExtArgs>
    reactions?: boolean | Message$reactionsArgs<ExtArgs>
    attachments?: boolean | Message$attachmentsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    timestamp?: boolean
    metadata?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationArgs<ExtArgs>
    reactions?: boolean | Message$reactionsArgs<ExtArgs>
    attachments?: boolean | Message$attachmentsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeArgs<ExtArgs>
  }


  type MessageGetPayload<S extends boolean | null | undefined | MessageArgs> = $Types.GetResult<MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>
    ): Prisma__MessageClient<$Types.GetResult<MessagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MessageClient<$Types.GetResult<MessagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>
    ): Prisma__MessageClient<$Types.GetResult<MessagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MessageClient<$Types.GetResult<MessagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MessageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<MessagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
    **/
    create<T extends MessageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MessageCreateArgs<ExtArgs>>
    ): Prisma__MessageClient<$Types.GetResult<MessagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Messages.
     *     @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     *     @example
     *     // Create many Messages
     *     const message = await prisma.message.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MessageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
    **/
    delete<T extends MessageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>
    ): Prisma__MessageClient<$Types.GetResult<MessagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>
    ): Prisma__MessageClient<$Types.GetResult<MessagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
    **/
    upsert<T extends MessageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>
    ): Prisma__MessageClient<$Types.GetResult<MessagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    conversation<T extends ConversationArgs<ExtArgs> = {}>(args?: Subset<T, ConversationArgs<ExtArgs>>): Prisma__ConversationClient<$Types.GetResult<ConversationPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    reactions<T extends Message$reactionsArgs<ExtArgs> = {}>(args?: Subset<T, Message$reactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<MessageReactionPayload<ExtArgs>, T, 'findMany'>| Null>;

    attachments<T extends Message$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Message$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<MessageAttachmentPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly conversationId: FieldRef<"Message", 'String'>
    readonly role: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly timestamp: FieldRef<"Message", 'DateTime'>
    readonly metadata: FieldRef<"Message", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }


  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }


  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }


  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }


  /**
   * Message.reactions
   */
  export type Message$reactionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageReactionInclude<ExtArgs> | null
    where?: MessageReactionWhereInput
    orderBy?: MessageReactionOrderByWithRelationInput | MessageReactionOrderByWithRelationInput[]
    cursor?: MessageReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageReactionScalarFieldEnum | MessageReactionScalarFieldEnum[]
  }


  /**
   * Message.attachments
   */
  export type Message$attachmentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    where?: MessageAttachmentWhereInput
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    cursor?: MessageAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }


  /**
   * Message without action
   */
  export type MessageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
  }



  /**
   * Model MessageReaction
   */


  export type AggregateMessageReaction = {
    _count: MessageReactionCountAggregateOutputType | null
    _min: MessageReactionMinAggregateOutputType | null
    _max: MessageReactionMaxAggregateOutputType | null
  }

  export type MessageReactionMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    emoji: string | null
    timestamp: Date | null
  }

  export type MessageReactionMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    emoji: string | null
    timestamp: Date | null
  }

  export type MessageReactionCountAggregateOutputType = {
    id: number
    messageId: number
    userId: number
    emoji: number
    timestamp: number
    _all: number
  }


  export type MessageReactionMinAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    emoji?: true
    timestamp?: true
  }

  export type MessageReactionMaxAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    emoji?: true
    timestamp?: true
  }

  export type MessageReactionCountAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    emoji?: true
    timestamp?: true
    _all?: true
  }

  export type MessageReactionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageReaction to aggregate.
     */
    where?: MessageReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReactions to fetch.
     */
    orderBy?: MessageReactionOrderByWithRelationInput | MessageReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageReactions
    **/
    _count?: true | MessageReactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageReactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageReactionMaxAggregateInputType
  }

  export type GetMessageReactionAggregateType<T extends MessageReactionAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageReaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageReaction[P]>
      : GetScalarType<T[P], AggregateMessageReaction[P]>
  }




  export type MessageReactionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MessageReactionWhereInput
    orderBy?: MessageReactionOrderByWithAggregationInput | MessageReactionOrderByWithAggregationInput[]
    by: MessageReactionScalarFieldEnum[] | MessageReactionScalarFieldEnum
    having?: MessageReactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageReactionCountAggregateInputType | true
    _min?: MessageReactionMinAggregateInputType
    _max?: MessageReactionMaxAggregateInputType
  }


  export type MessageReactionGroupByOutputType = {
    id: string
    messageId: string
    userId: string
    emoji: string
    timestamp: Date
    _count: MessageReactionCountAggregateOutputType | null
    _min: MessageReactionMinAggregateOutputType | null
    _max: MessageReactionMaxAggregateOutputType | null
  }

  type GetMessageReactionGroupByPayload<T extends MessageReactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageReactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageReactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageReactionGroupByOutputType[P]>
            : GetScalarType<T[P], MessageReactionGroupByOutputType[P]>
        }
      >
    >


  export type MessageReactionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    emoji?: boolean
    timestamp?: boolean
    message?: boolean | MessageArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["messageReaction"]>

  export type MessageReactionSelectScalar = {
    id?: boolean
    messageId?: boolean
    userId?: boolean
    emoji?: boolean
    timestamp?: boolean
  }

  export type MessageReactionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    message?: boolean | MessageArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
  }


  type MessageReactionGetPayload<S extends boolean | null | undefined | MessageReactionArgs> = $Types.GetResult<MessageReactionPayload, S>

  type MessageReactionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<MessageReactionFindManyArgs, 'select' | 'include'> & {
      select?: MessageReactionCountAggregateInputType | true
    }

  export interface MessageReactionDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageReaction'], meta: { name: 'MessageReaction' } }
    /**
     * Find zero or one MessageReaction that matches the filter.
     * @param {MessageReactionFindUniqueArgs} args - Arguments to find a MessageReaction
     * @example
     * // Get one MessageReaction
     * const messageReaction = await prisma.messageReaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessageReactionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MessageReactionFindUniqueArgs<ExtArgs>>
    ): Prisma__MessageReactionClient<$Types.GetResult<MessageReactionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MessageReaction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MessageReactionFindUniqueOrThrowArgs} args - Arguments to find a MessageReaction
     * @example
     * // Get one MessageReaction
     * const messageReaction = await prisma.messageReaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MessageReactionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageReactionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MessageReactionClient<$Types.GetResult<MessageReactionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MessageReaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReactionFindFirstArgs} args - Arguments to find a MessageReaction
     * @example
     * // Get one MessageReaction
     * const messageReaction = await prisma.messageReaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessageReactionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageReactionFindFirstArgs<ExtArgs>>
    ): Prisma__MessageReactionClient<$Types.GetResult<MessageReactionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MessageReaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReactionFindFirstOrThrowArgs} args - Arguments to find a MessageReaction
     * @example
     * // Get one MessageReaction
     * const messageReaction = await prisma.messageReaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MessageReactionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageReactionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MessageReactionClient<$Types.GetResult<MessageReactionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MessageReactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageReactions
     * const messageReactions = await prisma.messageReaction.findMany()
     * 
     * // Get first 10 MessageReactions
     * const messageReactions = await prisma.messageReaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageReactionWithIdOnly = await prisma.messageReaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MessageReactionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageReactionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<MessageReactionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MessageReaction.
     * @param {MessageReactionCreateArgs} args - Arguments to create a MessageReaction.
     * @example
     * // Create one MessageReaction
     * const MessageReaction = await prisma.messageReaction.create({
     *   data: {
     *     // ... data to create a MessageReaction
     *   }
     * })
     * 
    **/
    create<T extends MessageReactionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MessageReactionCreateArgs<ExtArgs>>
    ): Prisma__MessageReactionClient<$Types.GetResult<MessageReactionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MessageReactions.
     *     @param {MessageReactionCreateManyArgs} args - Arguments to create many MessageReactions.
     *     @example
     *     // Create many MessageReactions
     *     const messageReaction = await prisma.messageReaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MessageReactionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageReactionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MessageReaction.
     * @param {MessageReactionDeleteArgs} args - Arguments to delete one MessageReaction.
     * @example
     * // Delete one MessageReaction
     * const MessageReaction = await prisma.messageReaction.delete({
     *   where: {
     *     // ... filter to delete one MessageReaction
     *   }
     * })
     * 
    **/
    delete<T extends MessageReactionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MessageReactionDeleteArgs<ExtArgs>>
    ): Prisma__MessageReactionClient<$Types.GetResult<MessageReactionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MessageReaction.
     * @param {MessageReactionUpdateArgs} args - Arguments to update one MessageReaction.
     * @example
     * // Update one MessageReaction
     * const messageReaction = await prisma.messageReaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessageReactionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MessageReactionUpdateArgs<ExtArgs>>
    ): Prisma__MessageReactionClient<$Types.GetResult<MessageReactionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MessageReactions.
     * @param {MessageReactionDeleteManyArgs} args - Arguments to filter MessageReactions to delete.
     * @example
     * // Delete a few MessageReactions
     * const { count } = await prisma.messageReaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessageReactionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageReactionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageReactions
     * const messageReaction = await prisma.messageReaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessageReactionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MessageReactionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageReaction.
     * @param {MessageReactionUpsertArgs} args - Arguments to update or create a MessageReaction.
     * @example
     * // Update or create a MessageReaction
     * const messageReaction = await prisma.messageReaction.upsert({
     *   create: {
     *     // ... data to create a MessageReaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageReaction we want to update
     *   }
     * })
    **/
    upsert<T extends MessageReactionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MessageReactionUpsertArgs<ExtArgs>>
    ): Prisma__MessageReactionClient<$Types.GetResult<MessageReactionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MessageReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReactionCountArgs} args - Arguments to filter MessageReactions to count.
     * @example
     * // Count the number of MessageReactions
     * const count = await prisma.messageReaction.count({
     *   where: {
     *     // ... the filter for the MessageReactions we want to count
     *   }
     * })
    **/
    count<T extends MessageReactionCountArgs>(
      args?: Subset<T, MessageReactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageReactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageReactionAggregateArgs>(args: Subset<T, MessageReactionAggregateArgs>): Prisma.PrismaPromise<GetMessageReactionAggregateType<T>>

    /**
     * Group by MessageReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageReactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageReactionGroupByArgs['orderBy'] }
        : { orderBy?: MessageReactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageReactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageReactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageReaction model
   */
  readonly fields: MessageReactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageReaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MessageReactionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    message<T extends MessageArgs<ExtArgs> = {}>(args?: Subset<T, MessageArgs<ExtArgs>>): Prisma__MessageClient<$Types.GetResult<MessagePayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the MessageReaction model
   */ 
  interface MessageReactionFieldRefs {
    readonly id: FieldRef<"MessageReaction", 'String'>
    readonly messageId: FieldRef<"MessageReaction", 'String'>
    readonly userId: FieldRef<"MessageReaction", 'String'>
    readonly emoji: FieldRef<"MessageReaction", 'String'>
    readonly timestamp: FieldRef<"MessageReaction", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * MessageReaction findUnique
   */
  export type MessageReactionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageReactionInclude<ExtArgs> | null
    /**
     * Filter, which MessageReaction to fetch.
     */
    where: MessageReactionWhereUniqueInput
  }


  /**
   * MessageReaction findUniqueOrThrow
   */
  export type MessageReactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageReactionInclude<ExtArgs> | null
    /**
     * Filter, which MessageReaction to fetch.
     */
    where: MessageReactionWhereUniqueInput
  }


  /**
   * MessageReaction findFirst
   */
  export type MessageReactionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageReactionInclude<ExtArgs> | null
    /**
     * Filter, which MessageReaction to fetch.
     */
    where?: MessageReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReactions to fetch.
     */
    orderBy?: MessageReactionOrderByWithRelationInput | MessageReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageReactions.
     */
    cursor?: MessageReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageReactions.
     */
    distinct?: MessageReactionScalarFieldEnum | MessageReactionScalarFieldEnum[]
  }


  /**
   * MessageReaction findFirstOrThrow
   */
  export type MessageReactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageReactionInclude<ExtArgs> | null
    /**
     * Filter, which MessageReaction to fetch.
     */
    where?: MessageReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReactions to fetch.
     */
    orderBy?: MessageReactionOrderByWithRelationInput | MessageReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageReactions.
     */
    cursor?: MessageReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageReactions.
     */
    distinct?: MessageReactionScalarFieldEnum | MessageReactionScalarFieldEnum[]
  }


  /**
   * MessageReaction findMany
   */
  export type MessageReactionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageReactionInclude<ExtArgs> | null
    /**
     * Filter, which MessageReactions to fetch.
     */
    where?: MessageReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReactions to fetch.
     */
    orderBy?: MessageReactionOrderByWithRelationInput | MessageReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageReactions.
     */
    cursor?: MessageReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReactions.
     */
    skip?: number
    distinct?: MessageReactionScalarFieldEnum | MessageReactionScalarFieldEnum[]
  }


  /**
   * MessageReaction create
   */
  export type MessageReactionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageReactionInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageReaction.
     */
    data: XOR<MessageReactionCreateInput, MessageReactionUncheckedCreateInput>
  }


  /**
   * MessageReaction createMany
   */
  export type MessageReactionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageReactions.
     */
    data: MessageReactionCreateManyInput | MessageReactionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MessageReaction update
   */
  export type MessageReactionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageReactionInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageReaction.
     */
    data: XOR<MessageReactionUpdateInput, MessageReactionUncheckedUpdateInput>
    /**
     * Choose, which MessageReaction to update.
     */
    where: MessageReactionWhereUniqueInput
  }


  /**
   * MessageReaction updateMany
   */
  export type MessageReactionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageReactions.
     */
    data: XOR<MessageReactionUpdateManyMutationInput, MessageReactionUncheckedUpdateManyInput>
    /**
     * Filter which MessageReactions to update
     */
    where?: MessageReactionWhereInput
  }


  /**
   * MessageReaction upsert
   */
  export type MessageReactionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageReactionInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageReaction to update in case it exists.
     */
    where: MessageReactionWhereUniqueInput
    /**
     * In case the MessageReaction found by the `where` argument doesn't exist, create a new MessageReaction with this data.
     */
    create: XOR<MessageReactionCreateInput, MessageReactionUncheckedCreateInput>
    /**
     * In case the MessageReaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageReactionUpdateInput, MessageReactionUncheckedUpdateInput>
  }


  /**
   * MessageReaction delete
   */
  export type MessageReactionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageReactionInclude<ExtArgs> | null
    /**
     * Filter which MessageReaction to delete.
     */
    where: MessageReactionWhereUniqueInput
  }


  /**
   * MessageReaction deleteMany
   */
  export type MessageReactionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageReactions to delete
     */
    where?: MessageReactionWhereInput
  }


  /**
   * MessageReaction without action
   */
  export type MessageReactionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReaction
     */
    select?: MessageReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageReactionInclude<ExtArgs> | null
  }



  /**
   * Model MessageAttachment
   */


  export type AggregateMessageAttachment = {
    _count: MessageAttachmentCountAggregateOutputType | null
    _avg: MessageAttachmentAvgAggregateOutputType | null
    _sum: MessageAttachmentSumAggregateOutputType | null
    _min: MessageAttachmentMinAggregateOutputType | null
    _max: MessageAttachmentMaxAggregateOutputType | null
  }

  export type MessageAttachmentAvgAggregateOutputType = {
    size: number | null
  }

  export type MessageAttachmentSumAggregateOutputType = {
    size: bigint | null
  }

  export type MessageAttachmentMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    type: string | null
    name: string | null
    url: string | null
    size: bigint | null
    mimeType: string | null
    thumbnail: string | null
  }

  export type MessageAttachmentMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    type: string | null
    name: string | null
    url: string | null
    size: bigint | null
    mimeType: string | null
    thumbnail: string | null
  }

  export type MessageAttachmentCountAggregateOutputType = {
    id: number
    messageId: number
    type: number
    name: number
    url: number
    size: number
    mimeType: number
    metadata: number
    thumbnail: number
    _all: number
  }


  export type MessageAttachmentAvgAggregateInputType = {
    size?: true
  }

  export type MessageAttachmentSumAggregateInputType = {
    size?: true
  }

  export type MessageAttachmentMinAggregateInputType = {
    id?: true
    messageId?: true
    type?: true
    name?: true
    url?: true
    size?: true
    mimeType?: true
    thumbnail?: true
  }

  export type MessageAttachmentMaxAggregateInputType = {
    id?: true
    messageId?: true
    type?: true
    name?: true
    url?: true
    size?: true
    mimeType?: true
    thumbnail?: true
  }

  export type MessageAttachmentCountAggregateInputType = {
    id?: true
    messageId?: true
    type?: true
    name?: true
    url?: true
    size?: true
    mimeType?: true
    metadata?: true
    thumbnail?: true
    _all?: true
  }

  export type MessageAttachmentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageAttachment to aggregate.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageAttachments
    **/
    _count?: true | MessageAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageAttachmentMaxAggregateInputType
  }

  export type GetMessageAttachmentAggregateType<T extends MessageAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageAttachment[P]>
      : GetScalarType<T[P], AggregateMessageAttachment[P]>
  }




  export type MessageAttachmentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MessageAttachmentWhereInput
    orderBy?: MessageAttachmentOrderByWithAggregationInput | MessageAttachmentOrderByWithAggregationInput[]
    by: MessageAttachmentScalarFieldEnum[] | MessageAttachmentScalarFieldEnum
    having?: MessageAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageAttachmentCountAggregateInputType | true
    _avg?: MessageAttachmentAvgAggregateInputType
    _sum?: MessageAttachmentSumAggregateInputType
    _min?: MessageAttachmentMinAggregateInputType
    _max?: MessageAttachmentMaxAggregateInputType
  }


  export type MessageAttachmentGroupByOutputType = {
    id: string
    messageId: string
    type: string
    name: string
    url: string
    size: bigint | null
    mimeType: string | null
    metadata: JsonValue
    thumbnail: string | null
    _count: MessageAttachmentCountAggregateOutputType | null
    _avg: MessageAttachmentAvgAggregateOutputType | null
    _sum: MessageAttachmentSumAggregateOutputType | null
    _min: MessageAttachmentMinAggregateOutputType | null
    _max: MessageAttachmentMaxAggregateOutputType | null
  }

  type GetMessageAttachmentGroupByPayload<T extends MessageAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], MessageAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type MessageAttachmentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    type?: boolean
    name?: boolean
    url?: boolean
    size?: boolean
    mimeType?: boolean
    metadata?: boolean
    thumbnail?: boolean
    message?: boolean | MessageArgs<ExtArgs>
  }, ExtArgs["result"]["messageAttachment"]>

  export type MessageAttachmentSelectScalar = {
    id?: boolean
    messageId?: boolean
    type?: boolean
    name?: boolean
    url?: boolean
    size?: boolean
    mimeType?: boolean
    metadata?: boolean
    thumbnail?: boolean
  }

  export type MessageAttachmentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    message?: boolean | MessageArgs<ExtArgs>
  }


  type MessageAttachmentGetPayload<S extends boolean | null | undefined | MessageAttachmentArgs> = $Types.GetResult<MessageAttachmentPayload, S>

  type MessageAttachmentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<MessageAttachmentFindManyArgs, 'select' | 'include'> & {
      select?: MessageAttachmentCountAggregateInputType | true
    }

  export interface MessageAttachmentDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageAttachment'], meta: { name: 'MessageAttachment' } }
    /**
     * Find zero or one MessageAttachment that matches the filter.
     * @param {MessageAttachmentFindUniqueArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessageAttachmentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MessageAttachmentFindUniqueArgs<ExtArgs>>
    ): Prisma__MessageAttachmentClient<$Types.GetResult<MessageAttachmentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MessageAttachment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MessageAttachmentFindUniqueOrThrowArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MessageAttachmentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageAttachmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MessageAttachmentClient<$Types.GetResult<MessageAttachmentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MessageAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentFindFirstArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessageAttachmentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageAttachmentFindFirstArgs<ExtArgs>>
    ): Prisma__MessageAttachmentClient<$Types.GetResult<MessageAttachmentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MessageAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentFindFirstOrThrowArgs} args - Arguments to find a MessageAttachment
     * @example
     * // Get one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MessageAttachmentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageAttachmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MessageAttachmentClient<$Types.GetResult<MessageAttachmentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MessageAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageAttachments
     * const messageAttachments = await prisma.messageAttachment.findMany()
     * 
     * // Get first 10 MessageAttachments
     * const messageAttachments = await prisma.messageAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageAttachmentWithIdOnly = await prisma.messageAttachment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MessageAttachmentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageAttachmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<MessageAttachmentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MessageAttachment.
     * @param {MessageAttachmentCreateArgs} args - Arguments to create a MessageAttachment.
     * @example
     * // Create one MessageAttachment
     * const MessageAttachment = await prisma.messageAttachment.create({
     *   data: {
     *     // ... data to create a MessageAttachment
     *   }
     * })
     * 
    **/
    create<T extends MessageAttachmentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MessageAttachmentCreateArgs<ExtArgs>>
    ): Prisma__MessageAttachmentClient<$Types.GetResult<MessageAttachmentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MessageAttachments.
     *     @param {MessageAttachmentCreateManyArgs} args - Arguments to create many MessageAttachments.
     *     @example
     *     // Create many MessageAttachments
     *     const messageAttachment = await prisma.messageAttachment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MessageAttachmentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageAttachmentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MessageAttachment.
     * @param {MessageAttachmentDeleteArgs} args - Arguments to delete one MessageAttachment.
     * @example
     * // Delete one MessageAttachment
     * const MessageAttachment = await prisma.messageAttachment.delete({
     *   where: {
     *     // ... filter to delete one MessageAttachment
     *   }
     * })
     * 
    **/
    delete<T extends MessageAttachmentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MessageAttachmentDeleteArgs<ExtArgs>>
    ): Prisma__MessageAttachmentClient<$Types.GetResult<MessageAttachmentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MessageAttachment.
     * @param {MessageAttachmentUpdateArgs} args - Arguments to update one MessageAttachment.
     * @example
     * // Update one MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessageAttachmentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MessageAttachmentUpdateArgs<ExtArgs>>
    ): Prisma__MessageAttachmentClient<$Types.GetResult<MessageAttachmentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MessageAttachments.
     * @param {MessageAttachmentDeleteManyArgs} args - Arguments to filter MessageAttachments to delete.
     * @example
     * // Delete a few MessageAttachments
     * const { count } = await prisma.messageAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessageAttachmentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageAttachmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageAttachments
     * const messageAttachment = await prisma.messageAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessageAttachmentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MessageAttachmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageAttachment.
     * @param {MessageAttachmentUpsertArgs} args - Arguments to update or create a MessageAttachment.
     * @example
     * // Update or create a MessageAttachment
     * const messageAttachment = await prisma.messageAttachment.upsert({
     *   create: {
     *     // ... data to create a MessageAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageAttachment we want to update
     *   }
     * })
    **/
    upsert<T extends MessageAttachmentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MessageAttachmentUpsertArgs<ExtArgs>>
    ): Prisma__MessageAttachmentClient<$Types.GetResult<MessageAttachmentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MessageAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentCountArgs} args - Arguments to filter MessageAttachments to count.
     * @example
     * // Count the number of MessageAttachments
     * const count = await prisma.messageAttachment.count({
     *   where: {
     *     // ... the filter for the MessageAttachments we want to count
     *   }
     * })
    **/
    count<T extends MessageAttachmentCountArgs>(
      args?: Subset<T, MessageAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAttachmentAggregateArgs>(args: Subset<T, MessageAttachmentAggregateArgs>): Prisma.PrismaPromise<GetMessageAttachmentAggregateType<T>>

    /**
     * Group by MessageAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: MessageAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageAttachment model
   */
  readonly fields: MessageAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MessageAttachmentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    message<T extends MessageArgs<ExtArgs> = {}>(args?: Subset<T, MessageArgs<ExtArgs>>): Prisma__MessageClient<$Types.GetResult<MessagePayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the MessageAttachment model
   */ 
  interface MessageAttachmentFieldRefs {
    readonly id: FieldRef<"MessageAttachment", 'String'>
    readonly messageId: FieldRef<"MessageAttachment", 'String'>
    readonly type: FieldRef<"MessageAttachment", 'String'>
    readonly name: FieldRef<"MessageAttachment", 'String'>
    readonly url: FieldRef<"MessageAttachment", 'String'>
    readonly size: FieldRef<"MessageAttachment", 'BigInt'>
    readonly mimeType: FieldRef<"MessageAttachment", 'String'>
    readonly metadata: FieldRef<"MessageAttachment", 'Json'>
    readonly thumbnail: FieldRef<"MessageAttachment", 'String'>
  }
    

  // Custom InputTypes

  /**
   * MessageAttachment findUnique
   */
  export type MessageAttachmentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where: MessageAttachmentWhereUniqueInput
  }


  /**
   * MessageAttachment findUniqueOrThrow
   */
  export type MessageAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where: MessageAttachmentWhereUniqueInput
  }


  /**
   * MessageAttachment findFirst
   */
  export type MessageAttachmentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageAttachments.
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageAttachments.
     */
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }


  /**
   * MessageAttachment findFirstOrThrow
   */
  export type MessageAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachment to fetch.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageAttachments.
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageAttachments.
     */
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }


  /**
   * MessageAttachment findMany
   */
  export type MessageAttachmentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which MessageAttachments to fetch.
     */
    where?: MessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageAttachments to fetch.
     */
    orderBy?: MessageAttachmentOrderByWithRelationInput | MessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageAttachments.
     */
    cursor?: MessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageAttachments.
     */
    skip?: number
    distinct?: MessageAttachmentScalarFieldEnum | MessageAttachmentScalarFieldEnum[]
  }


  /**
   * MessageAttachment create
   */
  export type MessageAttachmentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageAttachment.
     */
    data: XOR<MessageAttachmentCreateInput, MessageAttachmentUncheckedCreateInput>
  }


  /**
   * MessageAttachment createMany
   */
  export type MessageAttachmentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageAttachments.
     */
    data: MessageAttachmentCreateManyInput | MessageAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * MessageAttachment update
   */
  export type MessageAttachmentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageAttachment.
     */
    data: XOR<MessageAttachmentUpdateInput, MessageAttachmentUncheckedUpdateInput>
    /**
     * Choose, which MessageAttachment to update.
     */
    where: MessageAttachmentWhereUniqueInput
  }


  /**
   * MessageAttachment updateMany
   */
  export type MessageAttachmentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageAttachments.
     */
    data: XOR<MessageAttachmentUpdateManyMutationInput, MessageAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which MessageAttachments to update
     */
    where?: MessageAttachmentWhereInput
  }


  /**
   * MessageAttachment upsert
   */
  export type MessageAttachmentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageAttachment to update in case it exists.
     */
    where: MessageAttachmentWhereUniqueInput
    /**
     * In case the MessageAttachment found by the `where` argument doesn't exist, create a new MessageAttachment with this data.
     */
    create: XOR<MessageAttachmentCreateInput, MessageAttachmentUncheckedCreateInput>
    /**
     * In case the MessageAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageAttachmentUpdateInput, MessageAttachmentUncheckedUpdateInput>
  }


  /**
   * MessageAttachment delete
   */
  export type MessageAttachmentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter which MessageAttachment to delete.
     */
    where: MessageAttachmentWhereUniqueInput
  }


  /**
   * MessageAttachment deleteMany
   */
  export type MessageAttachmentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageAttachments to delete
     */
    where?: MessageAttachmentWhereInput
  }


  /**
   * MessageAttachment without action
   */
  export type MessageAttachmentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageAttachment
     */
    select?: MessageAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageAttachmentInclude<ExtArgs> | null
  }



  /**
   * Model ConversationShare
   */


  export type AggregateConversationShare = {
    _count: ConversationShareCountAggregateOutputType | null
    _min: ConversationShareMinAggregateOutputType | null
    _max: ConversationShareMaxAggregateOutputType | null
  }

  export type ConversationShareMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    shareId: string | null
    createdBy: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type ConversationShareMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    shareId: string | null
    createdBy: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type ConversationShareCountAggregateOutputType = {
    id: number
    conversationId: number
    shareId: number
    createdBy: number
    createdAt: number
    expiresAt: number
    permissions: number
    settings: number
    analytics: number
    _all: number
  }


  export type ConversationShareMinAggregateInputType = {
    id?: true
    conversationId?: true
    shareId?: true
    createdBy?: true
    createdAt?: true
    expiresAt?: true
  }

  export type ConversationShareMaxAggregateInputType = {
    id?: true
    conversationId?: true
    shareId?: true
    createdBy?: true
    createdAt?: true
    expiresAt?: true
  }

  export type ConversationShareCountAggregateInputType = {
    id?: true
    conversationId?: true
    shareId?: true
    createdBy?: true
    createdAt?: true
    expiresAt?: true
    permissions?: true
    settings?: true
    analytics?: true
    _all?: true
  }

  export type ConversationShareAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationShare to aggregate.
     */
    where?: ConversationShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationShares to fetch.
     */
    orderBy?: ConversationShareOrderByWithRelationInput | ConversationShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConversationShares
    **/
    _count?: true | ConversationShareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationShareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationShareMaxAggregateInputType
  }

  export type GetConversationShareAggregateType<T extends ConversationShareAggregateArgs> = {
        [P in keyof T & keyof AggregateConversationShare]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversationShare[P]>
      : GetScalarType<T[P], AggregateConversationShare[P]>
  }




  export type ConversationShareGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ConversationShareWhereInput
    orderBy?: ConversationShareOrderByWithAggregationInput | ConversationShareOrderByWithAggregationInput[]
    by: ConversationShareScalarFieldEnum[] | ConversationShareScalarFieldEnum
    having?: ConversationShareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationShareCountAggregateInputType | true
    _min?: ConversationShareMinAggregateInputType
    _max?: ConversationShareMaxAggregateInputType
  }


  export type ConversationShareGroupByOutputType = {
    id: string
    conversationId: string
    shareId: string
    createdBy: string
    createdAt: Date
    expiresAt: Date | null
    permissions: JsonValue
    settings: JsonValue
    analytics: JsonValue
    _count: ConversationShareCountAggregateOutputType | null
    _min: ConversationShareMinAggregateOutputType | null
    _max: ConversationShareMaxAggregateOutputType | null
  }

  type GetConversationShareGroupByPayload<T extends ConversationShareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationShareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationShareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationShareGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationShareGroupByOutputType[P]>
        }
      >
    >


  export type ConversationShareSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    shareId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    permissions?: boolean
    settings?: boolean
    analytics?: boolean
    conversation?: boolean | ConversationArgs<ExtArgs>
    creator?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["conversationShare"]>

  export type ConversationShareSelectScalar = {
    id?: boolean
    conversationId?: boolean
    shareId?: boolean
    createdBy?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    permissions?: boolean
    settings?: boolean
    analytics?: boolean
  }

  export type ConversationShareInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationArgs<ExtArgs>
    creator?: boolean | UserArgs<ExtArgs>
  }


  type ConversationShareGetPayload<S extends boolean | null | undefined | ConversationShareArgs> = $Types.GetResult<ConversationSharePayload, S>

  type ConversationShareCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ConversationShareFindManyArgs, 'select' | 'include'> & {
      select?: ConversationShareCountAggregateInputType | true
    }

  export interface ConversationShareDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConversationShare'], meta: { name: 'ConversationShare' } }
    /**
     * Find zero or one ConversationShare that matches the filter.
     * @param {ConversationShareFindUniqueArgs} args - Arguments to find a ConversationShare
     * @example
     * // Get one ConversationShare
     * const conversationShare = await prisma.conversationShare.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConversationShareFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationShareFindUniqueArgs<ExtArgs>>
    ): Prisma__ConversationShareClient<$Types.GetResult<ConversationSharePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ConversationShare that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConversationShareFindUniqueOrThrowArgs} args - Arguments to find a ConversationShare
     * @example
     * // Get one ConversationShare
     * const conversationShare = await prisma.conversationShare.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConversationShareFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationShareFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConversationShareClient<$Types.GetResult<ConversationSharePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ConversationShare that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationShareFindFirstArgs} args - Arguments to find a ConversationShare
     * @example
     * // Get one ConversationShare
     * const conversationShare = await prisma.conversationShare.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConversationShareFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationShareFindFirstArgs<ExtArgs>>
    ): Prisma__ConversationShareClient<$Types.GetResult<ConversationSharePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ConversationShare that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationShareFindFirstOrThrowArgs} args - Arguments to find a ConversationShare
     * @example
     * // Get one ConversationShare
     * const conversationShare = await prisma.conversationShare.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConversationShareFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationShareFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConversationShareClient<$Types.GetResult<ConversationSharePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ConversationShares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationShareFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConversationShares
     * const conversationShares = await prisma.conversationShare.findMany()
     * 
     * // Get first 10 ConversationShares
     * const conversationShares = await prisma.conversationShare.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationShareWithIdOnly = await prisma.conversationShare.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConversationShareFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationShareFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ConversationSharePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ConversationShare.
     * @param {ConversationShareCreateArgs} args - Arguments to create a ConversationShare.
     * @example
     * // Create one ConversationShare
     * const ConversationShare = await prisma.conversationShare.create({
     *   data: {
     *     // ... data to create a ConversationShare
     *   }
     * })
     * 
    **/
    create<T extends ConversationShareCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationShareCreateArgs<ExtArgs>>
    ): Prisma__ConversationShareClient<$Types.GetResult<ConversationSharePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ConversationShares.
     *     @param {ConversationShareCreateManyArgs} args - Arguments to create many ConversationShares.
     *     @example
     *     // Create many ConversationShares
     *     const conversationShare = await prisma.conversationShare.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConversationShareCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationShareCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ConversationShare.
     * @param {ConversationShareDeleteArgs} args - Arguments to delete one ConversationShare.
     * @example
     * // Delete one ConversationShare
     * const ConversationShare = await prisma.conversationShare.delete({
     *   where: {
     *     // ... filter to delete one ConversationShare
     *   }
     * })
     * 
    **/
    delete<T extends ConversationShareDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationShareDeleteArgs<ExtArgs>>
    ): Prisma__ConversationShareClient<$Types.GetResult<ConversationSharePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ConversationShare.
     * @param {ConversationShareUpdateArgs} args - Arguments to update one ConversationShare.
     * @example
     * // Update one ConversationShare
     * const conversationShare = await prisma.conversationShare.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConversationShareUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationShareUpdateArgs<ExtArgs>>
    ): Prisma__ConversationShareClient<$Types.GetResult<ConversationSharePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ConversationShares.
     * @param {ConversationShareDeleteManyArgs} args - Arguments to filter ConversationShares to delete.
     * @example
     * // Delete a few ConversationShares
     * const { count } = await prisma.conversationShare.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConversationShareDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationShareDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationShareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConversationShares
     * const conversationShare = await prisma.conversationShare.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConversationShareUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationShareUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConversationShare.
     * @param {ConversationShareUpsertArgs} args - Arguments to update or create a ConversationShare.
     * @example
     * // Update or create a ConversationShare
     * const conversationShare = await prisma.conversationShare.upsert({
     *   create: {
     *     // ... data to create a ConversationShare
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConversationShare we want to update
     *   }
     * })
    **/
    upsert<T extends ConversationShareUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationShareUpsertArgs<ExtArgs>>
    ): Prisma__ConversationShareClient<$Types.GetResult<ConversationSharePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ConversationShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationShareCountArgs} args - Arguments to filter ConversationShares to count.
     * @example
     * // Count the number of ConversationShares
     * const count = await prisma.conversationShare.count({
     *   where: {
     *     // ... the filter for the ConversationShares we want to count
     *   }
     * })
    **/
    count<T extends ConversationShareCountArgs>(
      args?: Subset<T, ConversationShareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationShareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConversationShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationShareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationShareAggregateArgs>(args: Subset<T, ConversationShareAggregateArgs>): Prisma.PrismaPromise<GetConversationShareAggregateType<T>>

    /**
     * Group by ConversationShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationShareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationShareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationShareGroupByArgs['orderBy'] }
        : { orderBy?: ConversationShareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationShareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationShareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConversationShare model
   */
  readonly fields: ConversationShareFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConversationShare.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ConversationShareClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    conversation<T extends ConversationArgs<ExtArgs> = {}>(args?: Subset<T, ConversationArgs<ExtArgs>>): Prisma__ConversationClient<$Types.GetResult<ConversationPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    creator<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the ConversationShare model
   */ 
  interface ConversationShareFieldRefs {
    readonly id: FieldRef<"ConversationShare", 'String'>
    readonly conversationId: FieldRef<"ConversationShare", 'String'>
    readonly shareId: FieldRef<"ConversationShare", 'String'>
    readonly createdBy: FieldRef<"ConversationShare", 'String'>
    readonly createdAt: FieldRef<"ConversationShare", 'DateTime'>
    readonly expiresAt: FieldRef<"ConversationShare", 'DateTime'>
    readonly permissions: FieldRef<"ConversationShare", 'Json'>
    readonly settings: FieldRef<"ConversationShare", 'Json'>
    readonly analytics: FieldRef<"ConversationShare", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * ConversationShare findUnique
   */
  export type ConversationShareFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationShare
     */
    select?: ConversationShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationShareInclude<ExtArgs> | null
    /**
     * Filter, which ConversationShare to fetch.
     */
    where: ConversationShareWhereUniqueInput
  }


  /**
   * ConversationShare findUniqueOrThrow
   */
  export type ConversationShareFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationShare
     */
    select?: ConversationShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationShareInclude<ExtArgs> | null
    /**
     * Filter, which ConversationShare to fetch.
     */
    where: ConversationShareWhereUniqueInput
  }


  /**
   * ConversationShare findFirst
   */
  export type ConversationShareFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationShare
     */
    select?: ConversationShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationShareInclude<ExtArgs> | null
    /**
     * Filter, which ConversationShare to fetch.
     */
    where?: ConversationShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationShares to fetch.
     */
    orderBy?: ConversationShareOrderByWithRelationInput | ConversationShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationShares.
     */
    cursor?: ConversationShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationShares.
     */
    distinct?: ConversationShareScalarFieldEnum | ConversationShareScalarFieldEnum[]
  }


  /**
   * ConversationShare findFirstOrThrow
   */
  export type ConversationShareFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationShare
     */
    select?: ConversationShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationShareInclude<ExtArgs> | null
    /**
     * Filter, which ConversationShare to fetch.
     */
    where?: ConversationShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationShares to fetch.
     */
    orderBy?: ConversationShareOrderByWithRelationInput | ConversationShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationShares.
     */
    cursor?: ConversationShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationShares.
     */
    distinct?: ConversationShareScalarFieldEnum | ConversationShareScalarFieldEnum[]
  }


  /**
   * ConversationShare findMany
   */
  export type ConversationShareFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationShare
     */
    select?: ConversationShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationShareInclude<ExtArgs> | null
    /**
     * Filter, which ConversationShares to fetch.
     */
    where?: ConversationShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationShares to fetch.
     */
    orderBy?: ConversationShareOrderByWithRelationInput | ConversationShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConversationShares.
     */
    cursor?: ConversationShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationShares.
     */
    skip?: number
    distinct?: ConversationShareScalarFieldEnum | ConversationShareScalarFieldEnum[]
  }


  /**
   * ConversationShare create
   */
  export type ConversationShareCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationShare
     */
    select?: ConversationShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationShareInclude<ExtArgs> | null
    /**
     * The data needed to create a ConversationShare.
     */
    data: XOR<ConversationShareCreateInput, ConversationShareUncheckedCreateInput>
  }


  /**
   * ConversationShare createMany
   */
  export type ConversationShareCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConversationShares.
     */
    data: ConversationShareCreateManyInput | ConversationShareCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ConversationShare update
   */
  export type ConversationShareUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationShare
     */
    select?: ConversationShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationShareInclude<ExtArgs> | null
    /**
     * The data needed to update a ConversationShare.
     */
    data: XOR<ConversationShareUpdateInput, ConversationShareUncheckedUpdateInput>
    /**
     * Choose, which ConversationShare to update.
     */
    where: ConversationShareWhereUniqueInput
  }


  /**
   * ConversationShare updateMany
   */
  export type ConversationShareUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConversationShares.
     */
    data: XOR<ConversationShareUpdateManyMutationInput, ConversationShareUncheckedUpdateManyInput>
    /**
     * Filter which ConversationShares to update
     */
    where?: ConversationShareWhereInput
  }


  /**
   * ConversationShare upsert
   */
  export type ConversationShareUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationShare
     */
    select?: ConversationShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationShareInclude<ExtArgs> | null
    /**
     * The filter to search for the ConversationShare to update in case it exists.
     */
    where: ConversationShareWhereUniqueInput
    /**
     * In case the ConversationShare found by the `where` argument doesn't exist, create a new ConversationShare with this data.
     */
    create: XOR<ConversationShareCreateInput, ConversationShareUncheckedCreateInput>
    /**
     * In case the ConversationShare was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationShareUpdateInput, ConversationShareUncheckedUpdateInput>
  }


  /**
   * ConversationShare delete
   */
  export type ConversationShareDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationShare
     */
    select?: ConversationShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationShareInclude<ExtArgs> | null
    /**
     * Filter which ConversationShare to delete.
     */
    where: ConversationShareWhereUniqueInput
  }


  /**
   * ConversationShare deleteMany
   */
  export type ConversationShareDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationShares to delete
     */
    where?: ConversationShareWhereInput
  }


  /**
   * ConversationShare without action
   */
  export type ConversationShareArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationShare
     */
    select?: ConversationShareSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationShareInclude<ExtArgs> | null
  }



  /**
   * Model ConversationExport
   */


  export type AggregateConversationExport = {
    _count: ConversationExportCountAggregateOutputType | null
    _min: ConversationExportMinAggregateOutputType | null
    _max: ConversationExportMaxAggregateOutputType | null
  }

  export type ConversationExportMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    format: string | null
    status: string | null
    downloadUrl: string | null
    expiresAt: Date | null
    createdAt: Date | null
    completedAt: Date | null
    error: string | null
  }

  export type ConversationExportMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    format: string | null
    status: string | null
    downloadUrl: string | null
    expiresAt: Date | null
    createdAt: Date | null
    completedAt: Date | null
    error: string | null
  }

  export type ConversationExportCountAggregateOutputType = {
    id: number
    conversationId: number
    format: number
    options: number
    status: number
    downloadUrl: number
    expiresAt: number
    createdAt: number
    completedAt: number
    error: number
    _all: number
  }


  export type ConversationExportMinAggregateInputType = {
    id?: true
    conversationId?: true
    format?: true
    status?: true
    downloadUrl?: true
    expiresAt?: true
    createdAt?: true
    completedAt?: true
    error?: true
  }

  export type ConversationExportMaxAggregateInputType = {
    id?: true
    conversationId?: true
    format?: true
    status?: true
    downloadUrl?: true
    expiresAt?: true
    createdAt?: true
    completedAt?: true
    error?: true
  }

  export type ConversationExportCountAggregateInputType = {
    id?: true
    conversationId?: true
    format?: true
    options?: true
    status?: true
    downloadUrl?: true
    expiresAt?: true
    createdAt?: true
    completedAt?: true
    error?: true
    _all?: true
  }

  export type ConversationExportAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationExport to aggregate.
     */
    where?: ConversationExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationExports to fetch.
     */
    orderBy?: ConversationExportOrderByWithRelationInput | ConversationExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationExports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConversationExports
    **/
    _count?: true | ConversationExportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationExportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationExportMaxAggregateInputType
  }

  export type GetConversationExportAggregateType<T extends ConversationExportAggregateArgs> = {
        [P in keyof T & keyof AggregateConversationExport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversationExport[P]>
      : GetScalarType<T[P], AggregateConversationExport[P]>
  }




  export type ConversationExportGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ConversationExportWhereInput
    orderBy?: ConversationExportOrderByWithAggregationInput | ConversationExportOrderByWithAggregationInput[]
    by: ConversationExportScalarFieldEnum[] | ConversationExportScalarFieldEnum
    having?: ConversationExportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationExportCountAggregateInputType | true
    _min?: ConversationExportMinAggregateInputType
    _max?: ConversationExportMaxAggregateInputType
  }


  export type ConversationExportGroupByOutputType = {
    id: string
    conversationId: string
    format: string
    options: JsonValue
    status: string
    downloadUrl: string | null
    expiresAt: Date | null
    createdAt: Date
    completedAt: Date | null
    error: string | null
    _count: ConversationExportCountAggregateOutputType | null
    _min: ConversationExportMinAggregateOutputType | null
    _max: ConversationExportMaxAggregateOutputType | null
  }

  type GetConversationExportGroupByPayload<T extends ConversationExportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationExportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationExportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationExportGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationExportGroupByOutputType[P]>
        }
      >
    >


  export type ConversationExportSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    format?: boolean
    options?: boolean
    status?: boolean
    downloadUrl?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    completedAt?: boolean
    error?: boolean
    conversation?: boolean | ConversationArgs<ExtArgs>
  }, ExtArgs["result"]["conversationExport"]>

  export type ConversationExportSelectScalar = {
    id?: boolean
    conversationId?: boolean
    format?: boolean
    options?: boolean
    status?: boolean
    downloadUrl?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    completedAt?: boolean
    error?: boolean
  }

  export type ConversationExportInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationArgs<ExtArgs>
  }


  type ConversationExportGetPayload<S extends boolean | null | undefined | ConversationExportArgs> = $Types.GetResult<ConversationExportPayload, S>

  type ConversationExportCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ConversationExportFindManyArgs, 'select' | 'include'> & {
      select?: ConversationExportCountAggregateInputType | true
    }

  export interface ConversationExportDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConversationExport'], meta: { name: 'ConversationExport' } }
    /**
     * Find zero or one ConversationExport that matches the filter.
     * @param {ConversationExportFindUniqueArgs} args - Arguments to find a ConversationExport
     * @example
     * // Get one ConversationExport
     * const conversationExport = await prisma.conversationExport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConversationExportFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationExportFindUniqueArgs<ExtArgs>>
    ): Prisma__ConversationExportClient<$Types.GetResult<ConversationExportPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ConversationExport that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConversationExportFindUniqueOrThrowArgs} args - Arguments to find a ConversationExport
     * @example
     * // Get one ConversationExport
     * const conversationExport = await prisma.conversationExport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConversationExportFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationExportFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConversationExportClient<$Types.GetResult<ConversationExportPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ConversationExport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationExportFindFirstArgs} args - Arguments to find a ConversationExport
     * @example
     * // Get one ConversationExport
     * const conversationExport = await prisma.conversationExport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConversationExportFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationExportFindFirstArgs<ExtArgs>>
    ): Prisma__ConversationExportClient<$Types.GetResult<ConversationExportPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ConversationExport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationExportFindFirstOrThrowArgs} args - Arguments to find a ConversationExport
     * @example
     * // Get one ConversationExport
     * const conversationExport = await prisma.conversationExport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConversationExportFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationExportFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConversationExportClient<$Types.GetResult<ConversationExportPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ConversationExports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationExportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConversationExports
     * const conversationExports = await prisma.conversationExport.findMany()
     * 
     * // Get first 10 ConversationExports
     * const conversationExports = await prisma.conversationExport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationExportWithIdOnly = await prisma.conversationExport.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConversationExportFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationExportFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ConversationExportPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ConversationExport.
     * @param {ConversationExportCreateArgs} args - Arguments to create a ConversationExport.
     * @example
     * // Create one ConversationExport
     * const ConversationExport = await prisma.conversationExport.create({
     *   data: {
     *     // ... data to create a ConversationExport
     *   }
     * })
     * 
    **/
    create<T extends ConversationExportCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationExportCreateArgs<ExtArgs>>
    ): Prisma__ConversationExportClient<$Types.GetResult<ConversationExportPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ConversationExports.
     *     @param {ConversationExportCreateManyArgs} args - Arguments to create many ConversationExports.
     *     @example
     *     // Create many ConversationExports
     *     const conversationExport = await prisma.conversationExport.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConversationExportCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationExportCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ConversationExport.
     * @param {ConversationExportDeleteArgs} args - Arguments to delete one ConversationExport.
     * @example
     * // Delete one ConversationExport
     * const ConversationExport = await prisma.conversationExport.delete({
     *   where: {
     *     // ... filter to delete one ConversationExport
     *   }
     * })
     * 
    **/
    delete<T extends ConversationExportDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationExportDeleteArgs<ExtArgs>>
    ): Prisma__ConversationExportClient<$Types.GetResult<ConversationExportPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ConversationExport.
     * @param {ConversationExportUpdateArgs} args - Arguments to update one ConversationExport.
     * @example
     * // Update one ConversationExport
     * const conversationExport = await prisma.conversationExport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConversationExportUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationExportUpdateArgs<ExtArgs>>
    ): Prisma__ConversationExportClient<$Types.GetResult<ConversationExportPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ConversationExports.
     * @param {ConversationExportDeleteManyArgs} args - Arguments to filter ConversationExports to delete.
     * @example
     * // Delete a few ConversationExports
     * const { count } = await prisma.conversationExport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConversationExportDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationExportDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationExports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationExportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConversationExports
     * const conversationExport = await prisma.conversationExport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConversationExportUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationExportUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConversationExport.
     * @param {ConversationExportUpsertArgs} args - Arguments to update or create a ConversationExport.
     * @example
     * // Update or create a ConversationExport
     * const conversationExport = await prisma.conversationExport.upsert({
     *   create: {
     *     // ... data to create a ConversationExport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConversationExport we want to update
     *   }
     * })
    **/
    upsert<T extends ConversationExportUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationExportUpsertArgs<ExtArgs>>
    ): Prisma__ConversationExportClient<$Types.GetResult<ConversationExportPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ConversationExports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationExportCountArgs} args - Arguments to filter ConversationExports to count.
     * @example
     * // Count the number of ConversationExports
     * const count = await prisma.conversationExport.count({
     *   where: {
     *     // ... the filter for the ConversationExports we want to count
     *   }
     * })
    **/
    count<T extends ConversationExportCountArgs>(
      args?: Subset<T, ConversationExportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationExportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConversationExport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationExportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationExportAggregateArgs>(args: Subset<T, ConversationExportAggregateArgs>): Prisma.PrismaPromise<GetConversationExportAggregateType<T>>

    /**
     * Group by ConversationExport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationExportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationExportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationExportGroupByArgs['orderBy'] }
        : { orderBy?: ConversationExportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationExportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationExportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConversationExport model
   */
  readonly fields: ConversationExportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConversationExport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ConversationExportClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    conversation<T extends ConversationArgs<ExtArgs> = {}>(args?: Subset<T, ConversationArgs<ExtArgs>>): Prisma__ConversationClient<$Types.GetResult<ConversationPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the ConversationExport model
   */ 
  interface ConversationExportFieldRefs {
    readonly id: FieldRef<"ConversationExport", 'String'>
    readonly conversationId: FieldRef<"ConversationExport", 'String'>
    readonly format: FieldRef<"ConversationExport", 'String'>
    readonly options: FieldRef<"ConversationExport", 'Json'>
    readonly status: FieldRef<"ConversationExport", 'String'>
    readonly downloadUrl: FieldRef<"ConversationExport", 'String'>
    readonly expiresAt: FieldRef<"ConversationExport", 'DateTime'>
    readonly createdAt: FieldRef<"ConversationExport", 'DateTime'>
    readonly completedAt: FieldRef<"ConversationExport", 'DateTime'>
    readonly error: FieldRef<"ConversationExport", 'String'>
  }
    

  // Custom InputTypes

  /**
   * ConversationExport findUnique
   */
  export type ConversationExportFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationExport
     */
    select?: ConversationExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationExportInclude<ExtArgs> | null
    /**
     * Filter, which ConversationExport to fetch.
     */
    where: ConversationExportWhereUniqueInput
  }


  /**
   * ConversationExport findUniqueOrThrow
   */
  export type ConversationExportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationExport
     */
    select?: ConversationExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationExportInclude<ExtArgs> | null
    /**
     * Filter, which ConversationExport to fetch.
     */
    where: ConversationExportWhereUniqueInput
  }


  /**
   * ConversationExport findFirst
   */
  export type ConversationExportFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationExport
     */
    select?: ConversationExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationExportInclude<ExtArgs> | null
    /**
     * Filter, which ConversationExport to fetch.
     */
    where?: ConversationExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationExports to fetch.
     */
    orderBy?: ConversationExportOrderByWithRelationInput | ConversationExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationExports.
     */
    cursor?: ConversationExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationExports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationExports.
     */
    distinct?: ConversationExportScalarFieldEnum | ConversationExportScalarFieldEnum[]
  }


  /**
   * ConversationExport findFirstOrThrow
   */
  export type ConversationExportFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationExport
     */
    select?: ConversationExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationExportInclude<ExtArgs> | null
    /**
     * Filter, which ConversationExport to fetch.
     */
    where?: ConversationExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationExports to fetch.
     */
    orderBy?: ConversationExportOrderByWithRelationInput | ConversationExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationExports.
     */
    cursor?: ConversationExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationExports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationExports.
     */
    distinct?: ConversationExportScalarFieldEnum | ConversationExportScalarFieldEnum[]
  }


  /**
   * ConversationExport findMany
   */
  export type ConversationExportFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationExport
     */
    select?: ConversationExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationExportInclude<ExtArgs> | null
    /**
     * Filter, which ConversationExports to fetch.
     */
    where?: ConversationExportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationExports to fetch.
     */
    orderBy?: ConversationExportOrderByWithRelationInput | ConversationExportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConversationExports.
     */
    cursor?: ConversationExportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationExports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationExports.
     */
    skip?: number
    distinct?: ConversationExportScalarFieldEnum | ConversationExportScalarFieldEnum[]
  }


  /**
   * ConversationExport create
   */
  export type ConversationExportCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationExport
     */
    select?: ConversationExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationExportInclude<ExtArgs> | null
    /**
     * The data needed to create a ConversationExport.
     */
    data: XOR<ConversationExportCreateInput, ConversationExportUncheckedCreateInput>
  }


  /**
   * ConversationExport createMany
   */
  export type ConversationExportCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConversationExports.
     */
    data: ConversationExportCreateManyInput | ConversationExportCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ConversationExport update
   */
  export type ConversationExportUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationExport
     */
    select?: ConversationExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationExportInclude<ExtArgs> | null
    /**
     * The data needed to update a ConversationExport.
     */
    data: XOR<ConversationExportUpdateInput, ConversationExportUncheckedUpdateInput>
    /**
     * Choose, which ConversationExport to update.
     */
    where: ConversationExportWhereUniqueInput
  }


  /**
   * ConversationExport updateMany
   */
  export type ConversationExportUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConversationExports.
     */
    data: XOR<ConversationExportUpdateManyMutationInput, ConversationExportUncheckedUpdateManyInput>
    /**
     * Filter which ConversationExports to update
     */
    where?: ConversationExportWhereInput
  }


  /**
   * ConversationExport upsert
   */
  export type ConversationExportUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationExport
     */
    select?: ConversationExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationExportInclude<ExtArgs> | null
    /**
     * The filter to search for the ConversationExport to update in case it exists.
     */
    where: ConversationExportWhereUniqueInput
    /**
     * In case the ConversationExport found by the `where` argument doesn't exist, create a new ConversationExport with this data.
     */
    create: XOR<ConversationExportCreateInput, ConversationExportUncheckedCreateInput>
    /**
     * In case the ConversationExport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationExportUpdateInput, ConversationExportUncheckedUpdateInput>
  }


  /**
   * ConversationExport delete
   */
  export type ConversationExportDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationExport
     */
    select?: ConversationExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationExportInclude<ExtArgs> | null
    /**
     * Filter which ConversationExport to delete.
     */
    where: ConversationExportWhereUniqueInput
  }


  /**
   * ConversationExport deleteMany
   */
  export type ConversationExportDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationExports to delete
     */
    where?: ConversationExportWhereInput
  }


  /**
   * ConversationExport without action
   */
  export type ConversationExportArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationExport
     */
    select?: ConversationExportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationExportInclude<ExtArgs> | null
  }



  /**
   * Model ContextSource
   */


  export type AggregateContextSource = {
    _count: ContextSourceCountAggregateOutputType | null
    _avg: ContextSourceAvgAggregateOutputType | null
    _sum: ContextSourceSumAggregateOutputType | null
    _min: ContextSourceMinAggregateOutputType | null
    _max: ContextSourceMaxAggregateOutputType | null
  }

  export type ContextSourceAvgAggregateOutputType = {
    relevanceScore: number | null
    freshness: number | null
    popularity: number | null
  }

  export type ContextSourceSumAggregateOutputType = {
    relevanceScore: number | null
    freshness: number | null
    popularity: number | null
  }

  export type ContextSourceMinAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    content: string | null
    url: string | null
    libraryId: string | null
    version: string | null
    language: string | null
    relevanceScore: number | null
    freshness: number | null
    popularity: number | null
    lastUpdated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContextSourceMaxAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    content: string | null
    url: string | null
    libraryId: string | null
    version: string | null
    language: string | null
    relevanceScore: number | null
    freshness: number | null
    popularity: number | null
    lastUpdated: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContextSourceCountAggregateOutputType = {
    id: number
    type: number
    title: number
    content: number
    url: number
    libraryId: number
    version: number
    language: number
    tags: number
    relevanceScore: number
    freshness: number
    popularity: number
    lastUpdated: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContextSourceAvgAggregateInputType = {
    relevanceScore?: true
    freshness?: true
    popularity?: true
  }

  export type ContextSourceSumAggregateInputType = {
    relevanceScore?: true
    freshness?: true
    popularity?: true
  }

  export type ContextSourceMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    content?: true
    url?: true
    libraryId?: true
    version?: true
    language?: true
    relevanceScore?: true
    freshness?: true
    popularity?: true
    lastUpdated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContextSourceMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    content?: true
    url?: true
    libraryId?: true
    version?: true
    language?: true
    relevanceScore?: true
    freshness?: true
    popularity?: true
    lastUpdated?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContextSourceCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    content?: true
    url?: true
    libraryId?: true
    version?: true
    language?: true
    tags?: true
    relevanceScore?: true
    freshness?: true
    popularity?: true
    lastUpdated?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContextSourceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContextSource to aggregate.
     */
    where?: ContextSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextSources to fetch.
     */
    orderBy?: ContextSourceOrderByWithRelationInput | ContextSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContextSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContextSources
    **/
    _count?: true | ContextSourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContextSourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContextSourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContextSourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContextSourceMaxAggregateInputType
  }

  export type GetContextSourceAggregateType<T extends ContextSourceAggregateArgs> = {
        [P in keyof T & keyof AggregateContextSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContextSource[P]>
      : GetScalarType<T[P], AggregateContextSource[P]>
  }




  export type ContextSourceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ContextSourceWhereInput
    orderBy?: ContextSourceOrderByWithAggregationInput | ContextSourceOrderByWithAggregationInput[]
    by: ContextSourceScalarFieldEnum[] | ContextSourceScalarFieldEnum
    having?: ContextSourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContextSourceCountAggregateInputType | true
    _avg?: ContextSourceAvgAggregateInputType
    _sum?: ContextSourceSumAggregateInputType
    _min?: ContextSourceMinAggregateInputType
    _max?: ContextSourceMaxAggregateInputType
  }


  export type ContextSourceGroupByOutputType = {
    id: string
    type: string
    title: string
    content: string
    url: string | null
    libraryId: string | null
    version: string | null
    language: string
    tags: string[]
    relevanceScore: number
    freshness: number
    popularity: number
    lastUpdated: Date
    createdAt: Date
    updatedAt: Date
    _count: ContextSourceCountAggregateOutputType | null
    _avg: ContextSourceAvgAggregateOutputType | null
    _sum: ContextSourceSumAggregateOutputType | null
    _min: ContextSourceMinAggregateOutputType | null
    _max: ContextSourceMaxAggregateOutputType | null
  }

  type GetContextSourceGroupByPayload<T extends ContextSourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContextSourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContextSourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContextSourceGroupByOutputType[P]>
            : GetScalarType<T[P], ContextSourceGroupByOutputType[P]>
        }
      >
    >


  export type ContextSourceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    url?: boolean
    libraryId?: boolean
    version?: boolean
    language?: boolean
    tags?: boolean
    relevanceScore?: boolean
    freshness?: boolean
    popularity?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    chunks?: boolean | ContextSource$chunksArgs<ExtArgs>
    _count?: boolean | ContextSourceCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["contextSource"]>

  export type ContextSourceSelectScalar = {
    id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    url?: boolean
    libraryId?: boolean
    version?: boolean
    language?: boolean
    tags?: boolean
    relevanceScore?: boolean
    freshness?: boolean
    popularity?: boolean
    lastUpdated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContextSourceInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    chunks?: boolean | ContextSource$chunksArgs<ExtArgs>
    _count?: boolean | ContextSourceCountOutputTypeArgs<ExtArgs>
  }


  type ContextSourceGetPayload<S extends boolean | null | undefined | ContextSourceArgs> = $Types.GetResult<ContextSourcePayload, S>

  type ContextSourceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ContextSourceFindManyArgs, 'select' | 'include'> & {
      select?: ContextSourceCountAggregateInputType | true
    }

  export interface ContextSourceDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContextSource'], meta: { name: 'ContextSource' } }
    /**
     * Find zero or one ContextSource that matches the filter.
     * @param {ContextSourceFindUniqueArgs} args - Arguments to find a ContextSource
     * @example
     * // Get one ContextSource
     * const contextSource = await prisma.contextSource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContextSourceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ContextSourceFindUniqueArgs<ExtArgs>>
    ): Prisma__ContextSourceClient<$Types.GetResult<ContextSourcePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ContextSource that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ContextSourceFindUniqueOrThrowArgs} args - Arguments to find a ContextSource
     * @example
     * // Get one ContextSource
     * const contextSource = await prisma.contextSource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ContextSourceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextSourceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ContextSourceClient<$Types.GetResult<ContextSourcePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ContextSource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextSourceFindFirstArgs} args - Arguments to find a ContextSource
     * @example
     * // Get one ContextSource
     * const contextSource = await prisma.contextSource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContextSourceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextSourceFindFirstArgs<ExtArgs>>
    ): Prisma__ContextSourceClient<$Types.GetResult<ContextSourcePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ContextSource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextSourceFindFirstOrThrowArgs} args - Arguments to find a ContextSource
     * @example
     * // Get one ContextSource
     * const contextSource = await prisma.contextSource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ContextSourceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextSourceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ContextSourceClient<$Types.GetResult<ContextSourcePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ContextSources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextSourceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContextSources
     * const contextSources = await prisma.contextSource.findMany()
     * 
     * // Get first 10 ContextSources
     * const contextSources = await prisma.contextSource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contextSourceWithIdOnly = await prisma.contextSource.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContextSourceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextSourceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ContextSourcePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ContextSource.
     * @param {ContextSourceCreateArgs} args - Arguments to create a ContextSource.
     * @example
     * // Create one ContextSource
     * const ContextSource = await prisma.contextSource.create({
     *   data: {
     *     // ... data to create a ContextSource
     *   }
     * })
     * 
    **/
    create<T extends ContextSourceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ContextSourceCreateArgs<ExtArgs>>
    ): Prisma__ContextSourceClient<$Types.GetResult<ContextSourcePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ContextSources.
     *     @param {ContextSourceCreateManyArgs} args - Arguments to create many ContextSources.
     *     @example
     *     // Create many ContextSources
     *     const contextSource = await prisma.contextSource.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContextSourceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextSourceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContextSource.
     * @param {ContextSourceDeleteArgs} args - Arguments to delete one ContextSource.
     * @example
     * // Delete one ContextSource
     * const ContextSource = await prisma.contextSource.delete({
     *   where: {
     *     // ... filter to delete one ContextSource
     *   }
     * })
     * 
    **/
    delete<T extends ContextSourceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ContextSourceDeleteArgs<ExtArgs>>
    ): Prisma__ContextSourceClient<$Types.GetResult<ContextSourcePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ContextSource.
     * @param {ContextSourceUpdateArgs} args - Arguments to update one ContextSource.
     * @example
     * // Update one ContextSource
     * const contextSource = await prisma.contextSource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContextSourceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ContextSourceUpdateArgs<ExtArgs>>
    ): Prisma__ContextSourceClient<$Types.GetResult<ContextSourcePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ContextSources.
     * @param {ContextSourceDeleteManyArgs} args - Arguments to filter ContextSources to delete.
     * @example
     * // Delete a few ContextSources
     * const { count } = await prisma.contextSource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContextSourceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextSourceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContextSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextSourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContextSources
     * const contextSource = await prisma.contextSource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContextSourceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ContextSourceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContextSource.
     * @param {ContextSourceUpsertArgs} args - Arguments to update or create a ContextSource.
     * @example
     * // Update or create a ContextSource
     * const contextSource = await prisma.contextSource.upsert({
     *   create: {
     *     // ... data to create a ContextSource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContextSource we want to update
     *   }
     * })
    **/
    upsert<T extends ContextSourceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ContextSourceUpsertArgs<ExtArgs>>
    ): Prisma__ContextSourceClient<$Types.GetResult<ContextSourcePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ContextSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextSourceCountArgs} args - Arguments to filter ContextSources to count.
     * @example
     * // Count the number of ContextSources
     * const count = await prisma.contextSource.count({
     *   where: {
     *     // ... the filter for the ContextSources we want to count
     *   }
     * })
    **/
    count<T extends ContextSourceCountArgs>(
      args?: Subset<T, ContextSourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContextSourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContextSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextSourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContextSourceAggregateArgs>(args: Subset<T, ContextSourceAggregateArgs>): Prisma.PrismaPromise<GetContextSourceAggregateType<T>>

    /**
     * Group by ContextSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextSourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContextSourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContextSourceGroupByArgs['orderBy'] }
        : { orderBy?: ContextSourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContextSourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContextSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContextSource model
   */
  readonly fields: ContextSourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContextSource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ContextSourceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    chunks<T extends ContextSource$chunksArgs<ExtArgs> = {}>(args?: Subset<T, ContextSource$chunksArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ContextChunkPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the ContextSource model
   */ 
  interface ContextSourceFieldRefs {
    readonly id: FieldRef<"ContextSource", 'String'>
    readonly type: FieldRef<"ContextSource", 'String'>
    readonly title: FieldRef<"ContextSource", 'String'>
    readonly content: FieldRef<"ContextSource", 'String'>
    readonly url: FieldRef<"ContextSource", 'String'>
    readonly libraryId: FieldRef<"ContextSource", 'String'>
    readonly version: FieldRef<"ContextSource", 'String'>
    readonly language: FieldRef<"ContextSource", 'String'>
    readonly tags: FieldRef<"ContextSource", 'String[]'>
    readonly relevanceScore: FieldRef<"ContextSource", 'Float'>
    readonly freshness: FieldRef<"ContextSource", 'Float'>
    readonly popularity: FieldRef<"ContextSource", 'Float'>
    readonly lastUpdated: FieldRef<"ContextSource", 'DateTime'>
    readonly createdAt: FieldRef<"ContextSource", 'DateTime'>
    readonly updatedAt: FieldRef<"ContextSource", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ContextSource findUnique
   */
  export type ContextSourceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextSource
     */
    select?: ContextSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextSourceInclude<ExtArgs> | null
    /**
     * Filter, which ContextSource to fetch.
     */
    where: ContextSourceWhereUniqueInput
  }


  /**
   * ContextSource findUniqueOrThrow
   */
  export type ContextSourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextSource
     */
    select?: ContextSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextSourceInclude<ExtArgs> | null
    /**
     * Filter, which ContextSource to fetch.
     */
    where: ContextSourceWhereUniqueInput
  }


  /**
   * ContextSource findFirst
   */
  export type ContextSourceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextSource
     */
    select?: ContextSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextSourceInclude<ExtArgs> | null
    /**
     * Filter, which ContextSource to fetch.
     */
    where?: ContextSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextSources to fetch.
     */
    orderBy?: ContextSourceOrderByWithRelationInput | ContextSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContextSources.
     */
    cursor?: ContextSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContextSources.
     */
    distinct?: ContextSourceScalarFieldEnum | ContextSourceScalarFieldEnum[]
  }


  /**
   * ContextSource findFirstOrThrow
   */
  export type ContextSourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextSource
     */
    select?: ContextSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextSourceInclude<ExtArgs> | null
    /**
     * Filter, which ContextSource to fetch.
     */
    where?: ContextSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextSources to fetch.
     */
    orderBy?: ContextSourceOrderByWithRelationInput | ContextSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContextSources.
     */
    cursor?: ContextSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContextSources.
     */
    distinct?: ContextSourceScalarFieldEnum | ContextSourceScalarFieldEnum[]
  }


  /**
   * ContextSource findMany
   */
  export type ContextSourceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextSource
     */
    select?: ContextSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextSourceInclude<ExtArgs> | null
    /**
     * Filter, which ContextSources to fetch.
     */
    where?: ContextSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextSources to fetch.
     */
    orderBy?: ContextSourceOrderByWithRelationInput | ContextSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContextSources.
     */
    cursor?: ContextSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextSources.
     */
    skip?: number
    distinct?: ContextSourceScalarFieldEnum | ContextSourceScalarFieldEnum[]
  }


  /**
   * ContextSource create
   */
  export type ContextSourceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextSource
     */
    select?: ContextSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextSourceInclude<ExtArgs> | null
    /**
     * The data needed to create a ContextSource.
     */
    data: XOR<ContextSourceCreateInput, ContextSourceUncheckedCreateInput>
  }


  /**
   * ContextSource createMany
   */
  export type ContextSourceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContextSources.
     */
    data: ContextSourceCreateManyInput | ContextSourceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ContextSource update
   */
  export type ContextSourceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextSource
     */
    select?: ContextSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextSourceInclude<ExtArgs> | null
    /**
     * The data needed to update a ContextSource.
     */
    data: XOR<ContextSourceUpdateInput, ContextSourceUncheckedUpdateInput>
    /**
     * Choose, which ContextSource to update.
     */
    where: ContextSourceWhereUniqueInput
  }


  /**
   * ContextSource updateMany
   */
  export type ContextSourceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContextSources.
     */
    data: XOR<ContextSourceUpdateManyMutationInput, ContextSourceUncheckedUpdateManyInput>
    /**
     * Filter which ContextSources to update
     */
    where?: ContextSourceWhereInput
  }


  /**
   * ContextSource upsert
   */
  export type ContextSourceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextSource
     */
    select?: ContextSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextSourceInclude<ExtArgs> | null
    /**
     * The filter to search for the ContextSource to update in case it exists.
     */
    where: ContextSourceWhereUniqueInput
    /**
     * In case the ContextSource found by the `where` argument doesn't exist, create a new ContextSource with this data.
     */
    create: XOR<ContextSourceCreateInput, ContextSourceUncheckedCreateInput>
    /**
     * In case the ContextSource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContextSourceUpdateInput, ContextSourceUncheckedUpdateInput>
  }


  /**
   * ContextSource delete
   */
  export type ContextSourceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextSource
     */
    select?: ContextSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextSourceInclude<ExtArgs> | null
    /**
     * Filter which ContextSource to delete.
     */
    where: ContextSourceWhereUniqueInput
  }


  /**
   * ContextSource deleteMany
   */
  export type ContextSourceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContextSources to delete
     */
    where?: ContextSourceWhereInput
  }


  /**
   * ContextSource.chunks
   */
  export type ContextSource$chunksArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextChunk
     */
    select?: ContextChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextChunkInclude<ExtArgs> | null
    where?: ContextChunkWhereInput
    orderBy?: ContextChunkOrderByWithRelationInput | ContextChunkOrderByWithRelationInput[]
    cursor?: ContextChunkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContextChunkScalarFieldEnum | ContextChunkScalarFieldEnum[]
  }


  /**
   * ContextSource without action
   */
  export type ContextSourceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextSource
     */
    select?: ContextSourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextSourceInclude<ExtArgs> | null
  }



  /**
   * Model ContextChunk
   */


  export type AggregateContextChunk = {
    _count: ContextChunkCountAggregateOutputType | null
    _avg: ContextChunkAvgAggregateOutputType | null
    _sum: ContextChunkSumAggregateOutputType | null
    _min: ContextChunkMinAggregateOutputType | null
    _max: ContextChunkMaxAggregateOutputType | null
  }

  export type ContextChunkAvgAggregateOutputType = {
    positionStart: number | null
    positionEnd: number | null
    positionIndex: number | null
    positionTotal: number | null
    codeBlocks: number | null
    links: number | null
    images: number | null
    embedding: number | null
  }

  export type ContextChunkSumAggregateOutputType = {
    positionStart: number | null
    positionEnd: number | null
    positionIndex: number | null
    positionTotal: number | null
    codeBlocks: number | null
    links: number | null
    images: number | null
    embedding: number[] | null
  }

  export type ContextChunkMinAggregateOutputType = {
    id: string | null
    sourceId: string | null
    content: string | null
    positionStart: number | null
    positionEnd: number | null
    positionIndex: number | null
    positionTotal: number | null
    sectionTitle: string | null
    codeBlocks: number | null
    links: number | null
    images: number | null
    complexity: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContextChunkMaxAggregateOutputType = {
    id: string | null
    sourceId: string | null
    content: string | null
    positionStart: number | null
    positionEnd: number | null
    positionIndex: number | null
    positionTotal: number | null
    sectionTitle: string | null
    codeBlocks: number | null
    links: number | null
    images: number | null
    complexity: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContextChunkCountAggregateOutputType = {
    id: number
    sourceId: number
    content: number
    positionStart: number
    positionEnd: number
    positionIndex: number
    positionTotal: number
    sectionTitle: number
    codeBlocks: number
    links: number
    images: number
    complexity: number
    embedding: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContextChunkAvgAggregateInputType = {
    positionStart?: true
    positionEnd?: true
    positionIndex?: true
    positionTotal?: true
    codeBlocks?: true
    links?: true
    images?: true
    embedding?: true
  }

  export type ContextChunkSumAggregateInputType = {
    positionStart?: true
    positionEnd?: true
    positionIndex?: true
    positionTotal?: true
    codeBlocks?: true
    links?: true
    images?: true
    embedding?: true
  }

  export type ContextChunkMinAggregateInputType = {
    id?: true
    sourceId?: true
    content?: true
    positionStart?: true
    positionEnd?: true
    positionIndex?: true
    positionTotal?: true
    sectionTitle?: true
    codeBlocks?: true
    links?: true
    images?: true
    complexity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContextChunkMaxAggregateInputType = {
    id?: true
    sourceId?: true
    content?: true
    positionStart?: true
    positionEnd?: true
    positionIndex?: true
    positionTotal?: true
    sectionTitle?: true
    codeBlocks?: true
    links?: true
    images?: true
    complexity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContextChunkCountAggregateInputType = {
    id?: true
    sourceId?: true
    content?: true
    positionStart?: true
    positionEnd?: true
    positionIndex?: true
    positionTotal?: true
    sectionTitle?: true
    codeBlocks?: true
    links?: true
    images?: true
    complexity?: true
    embedding?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContextChunkAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContextChunk to aggregate.
     */
    where?: ContextChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextChunks to fetch.
     */
    orderBy?: ContextChunkOrderByWithRelationInput | ContextChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContextChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContextChunks
    **/
    _count?: true | ContextChunkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContextChunkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContextChunkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContextChunkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContextChunkMaxAggregateInputType
  }

  export type GetContextChunkAggregateType<T extends ContextChunkAggregateArgs> = {
        [P in keyof T & keyof AggregateContextChunk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContextChunk[P]>
      : GetScalarType<T[P], AggregateContextChunk[P]>
  }




  export type ContextChunkGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ContextChunkWhereInput
    orderBy?: ContextChunkOrderByWithAggregationInput | ContextChunkOrderByWithAggregationInput[]
    by: ContextChunkScalarFieldEnum[] | ContextChunkScalarFieldEnum
    having?: ContextChunkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContextChunkCountAggregateInputType | true
    _avg?: ContextChunkAvgAggregateInputType
    _sum?: ContextChunkSumAggregateInputType
    _min?: ContextChunkMinAggregateInputType
    _max?: ContextChunkMaxAggregateInputType
  }


  export type ContextChunkGroupByOutputType = {
    id: string
    sourceId: string
    content: string
    positionStart: number
    positionEnd: number
    positionIndex: number
    positionTotal: number
    sectionTitle: string | null
    codeBlocks: number
    links: number
    images: number
    complexity: string
    embedding: number[]
    createdAt: Date
    updatedAt: Date
    _count: ContextChunkCountAggregateOutputType | null
    _avg: ContextChunkAvgAggregateOutputType | null
    _sum: ContextChunkSumAggregateOutputType | null
    _min: ContextChunkMinAggregateOutputType | null
    _max: ContextChunkMaxAggregateOutputType | null
  }

  type GetContextChunkGroupByPayload<T extends ContextChunkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContextChunkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContextChunkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContextChunkGroupByOutputType[P]>
            : GetScalarType<T[P], ContextChunkGroupByOutputType[P]>
        }
      >
    >


  export type ContextChunkSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceId?: boolean
    content?: boolean
    positionStart?: boolean
    positionEnd?: boolean
    positionIndex?: boolean
    positionTotal?: boolean
    sectionTitle?: boolean
    codeBlocks?: boolean
    links?: boolean
    images?: boolean
    complexity?: boolean
    embedding?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    source?: boolean | ContextSourceArgs<ExtArgs>
  }, ExtArgs["result"]["contextChunk"]>

  export type ContextChunkSelectScalar = {
    id?: boolean
    sourceId?: boolean
    content?: boolean
    positionStart?: boolean
    positionEnd?: boolean
    positionIndex?: boolean
    positionTotal?: boolean
    sectionTitle?: boolean
    codeBlocks?: boolean
    links?: boolean
    images?: boolean
    complexity?: boolean
    embedding?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContextChunkInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    source?: boolean | ContextSourceArgs<ExtArgs>
  }


  type ContextChunkGetPayload<S extends boolean | null | undefined | ContextChunkArgs> = $Types.GetResult<ContextChunkPayload, S>

  type ContextChunkCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ContextChunkFindManyArgs, 'select' | 'include'> & {
      select?: ContextChunkCountAggregateInputType | true
    }

  export interface ContextChunkDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContextChunk'], meta: { name: 'ContextChunk' } }
    /**
     * Find zero or one ContextChunk that matches the filter.
     * @param {ContextChunkFindUniqueArgs} args - Arguments to find a ContextChunk
     * @example
     * // Get one ContextChunk
     * const contextChunk = await prisma.contextChunk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContextChunkFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ContextChunkFindUniqueArgs<ExtArgs>>
    ): Prisma__ContextChunkClient<$Types.GetResult<ContextChunkPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ContextChunk that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ContextChunkFindUniqueOrThrowArgs} args - Arguments to find a ContextChunk
     * @example
     * // Get one ContextChunk
     * const contextChunk = await prisma.contextChunk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ContextChunkFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextChunkFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ContextChunkClient<$Types.GetResult<ContextChunkPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ContextChunk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextChunkFindFirstArgs} args - Arguments to find a ContextChunk
     * @example
     * // Get one ContextChunk
     * const contextChunk = await prisma.contextChunk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContextChunkFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextChunkFindFirstArgs<ExtArgs>>
    ): Prisma__ContextChunkClient<$Types.GetResult<ContextChunkPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ContextChunk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextChunkFindFirstOrThrowArgs} args - Arguments to find a ContextChunk
     * @example
     * // Get one ContextChunk
     * const contextChunk = await prisma.contextChunk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ContextChunkFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextChunkFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ContextChunkClient<$Types.GetResult<ContextChunkPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ContextChunks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextChunkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContextChunks
     * const contextChunks = await prisma.contextChunk.findMany()
     * 
     * // Get first 10 ContextChunks
     * const contextChunks = await prisma.contextChunk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contextChunkWithIdOnly = await prisma.contextChunk.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContextChunkFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextChunkFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ContextChunkPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ContextChunk.
     * @param {ContextChunkCreateArgs} args - Arguments to create a ContextChunk.
     * @example
     * // Create one ContextChunk
     * const ContextChunk = await prisma.contextChunk.create({
     *   data: {
     *     // ... data to create a ContextChunk
     *   }
     * })
     * 
    **/
    create<T extends ContextChunkCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ContextChunkCreateArgs<ExtArgs>>
    ): Prisma__ContextChunkClient<$Types.GetResult<ContextChunkPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ContextChunks.
     *     @param {ContextChunkCreateManyArgs} args - Arguments to create many ContextChunks.
     *     @example
     *     // Create many ContextChunks
     *     const contextChunk = await prisma.contextChunk.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContextChunkCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextChunkCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContextChunk.
     * @param {ContextChunkDeleteArgs} args - Arguments to delete one ContextChunk.
     * @example
     * // Delete one ContextChunk
     * const ContextChunk = await prisma.contextChunk.delete({
     *   where: {
     *     // ... filter to delete one ContextChunk
     *   }
     * })
     * 
    **/
    delete<T extends ContextChunkDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ContextChunkDeleteArgs<ExtArgs>>
    ): Prisma__ContextChunkClient<$Types.GetResult<ContextChunkPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ContextChunk.
     * @param {ContextChunkUpdateArgs} args - Arguments to update one ContextChunk.
     * @example
     * // Update one ContextChunk
     * const contextChunk = await prisma.contextChunk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContextChunkUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ContextChunkUpdateArgs<ExtArgs>>
    ): Prisma__ContextChunkClient<$Types.GetResult<ContextChunkPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ContextChunks.
     * @param {ContextChunkDeleteManyArgs} args - Arguments to filter ContextChunks to delete.
     * @example
     * // Delete a few ContextChunks
     * const { count } = await prisma.contextChunk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContextChunkDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextChunkDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContextChunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextChunkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContextChunks
     * const contextChunk = await prisma.contextChunk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContextChunkUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ContextChunkUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContextChunk.
     * @param {ContextChunkUpsertArgs} args - Arguments to update or create a ContextChunk.
     * @example
     * // Update or create a ContextChunk
     * const contextChunk = await prisma.contextChunk.upsert({
     *   create: {
     *     // ... data to create a ContextChunk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContextChunk we want to update
     *   }
     * })
    **/
    upsert<T extends ContextChunkUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ContextChunkUpsertArgs<ExtArgs>>
    ): Prisma__ContextChunkClient<$Types.GetResult<ContextChunkPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ContextChunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextChunkCountArgs} args - Arguments to filter ContextChunks to count.
     * @example
     * // Count the number of ContextChunks
     * const count = await prisma.contextChunk.count({
     *   where: {
     *     // ... the filter for the ContextChunks we want to count
     *   }
     * })
    **/
    count<T extends ContextChunkCountArgs>(
      args?: Subset<T, ContextChunkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContextChunkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContextChunk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextChunkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContextChunkAggregateArgs>(args: Subset<T, ContextChunkAggregateArgs>): Prisma.PrismaPromise<GetContextChunkAggregateType<T>>

    /**
     * Group by ContextChunk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextChunkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContextChunkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContextChunkGroupByArgs['orderBy'] }
        : { orderBy?: ContextChunkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContextChunkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContextChunkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContextChunk model
   */
  readonly fields: ContextChunkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContextChunk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ContextChunkClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    source<T extends ContextSourceArgs<ExtArgs> = {}>(args?: Subset<T, ContextSourceArgs<ExtArgs>>): Prisma__ContextSourceClient<$Types.GetResult<ContextSourcePayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the ContextChunk model
   */ 
  interface ContextChunkFieldRefs {
    readonly id: FieldRef<"ContextChunk", 'String'>
    readonly sourceId: FieldRef<"ContextChunk", 'String'>
    readonly content: FieldRef<"ContextChunk", 'String'>
    readonly positionStart: FieldRef<"ContextChunk", 'Int'>
    readonly positionEnd: FieldRef<"ContextChunk", 'Int'>
    readonly positionIndex: FieldRef<"ContextChunk", 'Int'>
    readonly positionTotal: FieldRef<"ContextChunk", 'Int'>
    readonly sectionTitle: FieldRef<"ContextChunk", 'String'>
    readonly codeBlocks: FieldRef<"ContextChunk", 'Int'>
    readonly links: FieldRef<"ContextChunk", 'Int'>
    readonly images: FieldRef<"ContextChunk", 'Int'>
    readonly complexity: FieldRef<"ContextChunk", 'String'>
    readonly embedding: FieldRef<"ContextChunk", 'Float[]'>
    readonly createdAt: FieldRef<"ContextChunk", 'DateTime'>
    readonly updatedAt: FieldRef<"ContextChunk", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ContextChunk findUnique
   */
  export type ContextChunkFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextChunk
     */
    select?: ContextChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextChunkInclude<ExtArgs> | null
    /**
     * Filter, which ContextChunk to fetch.
     */
    where: ContextChunkWhereUniqueInput
  }


  /**
   * ContextChunk findUniqueOrThrow
   */
  export type ContextChunkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextChunk
     */
    select?: ContextChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextChunkInclude<ExtArgs> | null
    /**
     * Filter, which ContextChunk to fetch.
     */
    where: ContextChunkWhereUniqueInput
  }


  /**
   * ContextChunk findFirst
   */
  export type ContextChunkFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextChunk
     */
    select?: ContextChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextChunkInclude<ExtArgs> | null
    /**
     * Filter, which ContextChunk to fetch.
     */
    where?: ContextChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextChunks to fetch.
     */
    orderBy?: ContextChunkOrderByWithRelationInput | ContextChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContextChunks.
     */
    cursor?: ContextChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContextChunks.
     */
    distinct?: ContextChunkScalarFieldEnum | ContextChunkScalarFieldEnum[]
  }


  /**
   * ContextChunk findFirstOrThrow
   */
  export type ContextChunkFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextChunk
     */
    select?: ContextChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextChunkInclude<ExtArgs> | null
    /**
     * Filter, which ContextChunk to fetch.
     */
    where?: ContextChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextChunks to fetch.
     */
    orderBy?: ContextChunkOrderByWithRelationInput | ContextChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContextChunks.
     */
    cursor?: ContextChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContextChunks.
     */
    distinct?: ContextChunkScalarFieldEnum | ContextChunkScalarFieldEnum[]
  }


  /**
   * ContextChunk findMany
   */
  export type ContextChunkFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextChunk
     */
    select?: ContextChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextChunkInclude<ExtArgs> | null
    /**
     * Filter, which ContextChunks to fetch.
     */
    where?: ContextChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextChunks to fetch.
     */
    orderBy?: ContextChunkOrderByWithRelationInput | ContextChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContextChunks.
     */
    cursor?: ContextChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextChunks.
     */
    skip?: number
    distinct?: ContextChunkScalarFieldEnum | ContextChunkScalarFieldEnum[]
  }


  /**
   * ContextChunk create
   */
  export type ContextChunkCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextChunk
     */
    select?: ContextChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextChunkInclude<ExtArgs> | null
    /**
     * The data needed to create a ContextChunk.
     */
    data: XOR<ContextChunkCreateInput, ContextChunkUncheckedCreateInput>
  }


  /**
   * ContextChunk createMany
   */
  export type ContextChunkCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContextChunks.
     */
    data: ContextChunkCreateManyInput | ContextChunkCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ContextChunk update
   */
  export type ContextChunkUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextChunk
     */
    select?: ContextChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextChunkInclude<ExtArgs> | null
    /**
     * The data needed to update a ContextChunk.
     */
    data: XOR<ContextChunkUpdateInput, ContextChunkUncheckedUpdateInput>
    /**
     * Choose, which ContextChunk to update.
     */
    where: ContextChunkWhereUniqueInput
  }


  /**
   * ContextChunk updateMany
   */
  export type ContextChunkUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContextChunks.
     */
    data: XOR<ContextChunkUpdateManyMutationInput, ContextChunkUncheckedUpdateManyInput>
    /**
     * Filter which ContextChunks to update
     */
    where?: ContextChunkWhereInput
  }


  /**
   * ContextChunk upsert
   */
  export type ContextChunkUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextChunk
     */
    select?: ContextChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextChunkInclude<ExtArgs> | null
    /**
     * The filter to search for the ContextChunk to update in case it exists.
     */
    where: ContextChunkWhereUniqueInput
    /**
     * In case the ContextChunk found by the `where` argument doesn't exist, create a new ContextChunk with this data.
     */
    create: XOR<ContextChunkCreateInput, ContextChunkUncheckedCreateInput>
    /**
     * In case the ContextChunk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContextChunkUpdateInput, ContextChunkUncheckedUpdateInput>
  }


  /**
   * ContextChunk delete
   */
  export type ContextChunkDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextChunk
     */
    select?: ContextChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextChunkInclude<ExtArgs> | null
    /**
     * Filter which ContextChunk to delete.
     */
    where: ContextChunkWhereUniqueInput
  }


  /**
   * ContextChunk deleteMany
   */
  export type ContextChunkDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContextChunks to delete
     */
    where?: ContextChunkWhereInput
  }


  /**
   * ContextChunk without action
   */
  export type ContextChunkArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextChunk
     */
    select?: ContextChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextChunkInclude<ExtArgs> | null
  }



  /**
   * Model ContextQuery
   */


  export type AggregateContextQuery = {
    _count: ContextQueryCountAggregateOutputType | null
    _avg: ContextQueryAvgAggregateOutputType | null
    _sum: ContextQuerySumAggregateOutputType | null
    _min: ContextQueryMinAggregateOutputType | null
    _max: ContextQueryMaxAggregateOutputType | null
  }

  export type ContextQueryAvgAggregateOutputType = {
    intentConfidence: number | null
  }

  export type ContextQuerySumAggregateOutputType = {
    intentConfidence: number | null
  }

  export type ContextQueryMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    messageId: string | null
    queryText: string | null
    intentType: string | null
    intentConfidence: number | null
    intentCategory: string | null
    intentSubcategory: string | null
    createdAt: Date | null
  }

  export type ContextQueryMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    messageId: string | null
    queryText: string | null
    intentType: string | null
    intentConfidence: number | null
    intentCategory: string | null
    intentSubcategory: string | null
    createdAt: Date | null
  }

  export type ContextQueryCountAggregateOutputType = {
    id: number
    conversationId: number
    messageId: number
    queryText: number
    intentType: number
    intentConfidence: number
    intentKeywords: number
    intentCategory: number
    intentSubcategory: number
    entities: number
    filters: number
    options: number
    createdAt: number
    _all: number
  }


  export type ContextQueryAvgAggregateInputType = {
    intentConfidence?: true
  }

  export type ContextQuerySumAggregateInputType = {
    intentConfidence?: true
  }

  export type ContextQueryMinAggregateInputType = {
    id?: true
    conversationId?: true
    messageId?: true
    queryText?: true
    intentType?: true
    intentConfidence?: true
    intentCategory?: true
    intentSubcategory?: true
    createdAt?: true
  }

  export type ContextQueryMaxAggregateInputType = {
    id?: true
    conversationId?: true
    messageId?: true
    queryText?: true
    intentType?: true
    intentConfidence?: true
    intentCategory?: true
    intentSubcategory?: true
    createdAt?: true
  }

  export type ContextQueryCountAggregateInputType = {
    id?: true
    conversationId?: true
    messageId?: true
    queryText?: true
    intentType?: true
    intentConfidence?: true
    intentKeywords?: true
    intentCategory?: true
    intentSubcategory?: true
    entities?: true
    filters?: true
    options?: true
    createdAt?: true
    _all?: true
  }

  export type ContextQueryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContextQuery to aggregate.
     */
    where?: ContextQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextQueries to fetch.
     */
    orderBy?: ContextQueryOrderByWithRelationInput | ContextQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContextQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextQueries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContextQueries
    **/
    _count?: true | ContextQueryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContextQueryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContextQuerySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContextQueryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContextQueryMaxAggregateInputType
  }

  export type GetContextQueryAggregateType<T extends ContextQueryAggregateArgs> = {
        [P in keyof T & keyof AggregateContextQuery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContextQuery[P]>
      : GetScalarType<T[P], AggregateContextQuery[P]>
  }




  export type ContextQueryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ContextQueryWhereInput
    orderBy?: ContextQueryOrderByWithAggregationInput | ContextQueryOrderByWithAggregationInput[]
    by: ContextQueryScalarFieldEnum[] | ContextQueryScalarFieldEnum
    having?: ContextQueryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContextQueryCountAggregateInputType | true
    _avg?: ContextQueryAvgAggregateInputType
    _sum?: ContextQuerySumAggregateInputType
    _min?: ContextQueryMinAggregateInputType
    _max?: ContextQueryMaxAggregateInputType
  }


  export type ContextQueryGroupByOutputType = {
    id: string
    conversationId: string
    messageId: string
    queryText: string
    intentType: string | null
    intentConfidence: number | null
    intentKeywords: string[]
    intentCategory: string | null
    intentSubcategory: string | null
    entities: JsonValue
    filters: JsonValue
    options: JsonValue
    createdAt: Date
    _count: ContextQueryCountAggregateOutputType | null
    _avg: ContextQueryAvgAggregateOutputType | null
    _sum: ContextQuerySumAggregateOutputType | null
    _min: ContextQueryMinAggregateOutputType | null
    _max: ContextQueryMaxAggregateOutputType | null
  }

  type GetContextQueryGroupByPayload<T extends ContextQueryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContextQueryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContextQueryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContextQueryGroupByOutputType[P]>
            : GetScalarType<T[P], ContextQueryGroupByOutputType[P]>
        }
      >
    >


  export type ContextQuerySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    messageId?: boolean
    queryText?: boolean
    intentType?: boolean
    intentConfidence?: boolean
    intentKeywords?: boolean
    intentCategory?: boolean
    intentSubcategory?: boolean
    entities?: boolean
    filters?: boolean
    options?: boolean
    createdAt?: boolean
    results?: boolean | ContextQuery$resultsArgs<ExtArgs>
    analytics?: boolean | ContextQuery$analyticsArgs<ExtArgs>
    _count?: boolean | ContextQueryCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["contextQuery"]>

  export type ContextQuerySelectScalar = {
    id?: boolean
    conversationId?: boolean
    messageId?: boolean
    queryText?: boolean
    intentType?: boolean
    intentConfidence?: boolean
    intentKeywords?: boolean
    intentCategory?: boolean
    intentSubcategory?: boolean
    entities?: boolean
    filters?: boolean
    options?: boolean
    createdAt?: boolean
  }

  export type ContextQueryInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    results?: boolean | ContextQuery$resultsArgs<ExtArgs>
    analytics?: boolean | ContextQuery$analyticsArgs<ExtArgs>
    _count?: boolean | ContextQueryCountOutputTypeArgs<ExtArgs>
  }


  type ContextQueryGetPayload<S extends boolean | null | undefined | ContextQueryArgs> = $Types.GetResult<ContextQueryPayload, S>

  type ContextQueryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ContextQueryFindManyArgs, 'select' | 'include'> & {
      select?: ContextQueryCountAggregateInputType | true
    }

  export interface ContextQueryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContextQuery'], meta: { name: 'ContextQuery' } }
    /**
     * Find zero or one ContextQuery that matches the filter.
     * @param {ContextQueryFindUniqueArgs} args - Arguments to find a ContextQuery
     * @example
     * // Get one ContextQuery
     * const contextQuery = await prisma.contextQuery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContextQueryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ContextQueryFindUniqueArgs<ExtArgs>>
    ): Prisma__ContextQueryClient<$Types.GetResult<ContextQueryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ContextQuery that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ContextQueryFindUniqueOrThrowArgs} args - Arguments to find a ContextQuery
     * @example
     * // Get one ContextQuery
     * const contextQuery = await prisma.contextQuery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ContextQueryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextQueryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ContextQueryClient<$Types.GetResult<ContextQueryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ContextQuery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextQueryFindFirstArgs} args - Arguments to find a ContextQuery
     * @example
     * // Get one ContextQuery
     * const contextQuery = await prisma.contextQuery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContextQueryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextQueryFindFirstArgs<ExtArgs>>
    ): Prisma__ContextQueryClient<$Types.GetResult<ContextQueryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ContextQuery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextQueryFindFirstOrThrowArgs} args - Arguments to find a ContextQuery
     * @example
     * // Get one ContextQuery
     * const contextQuery = await prisma.contextQuery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ContextQueryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextQueryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ContextQueryClient<$Types.GetResult<ContextQueryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ContextQueries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextQueryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContextQueries
     * const contextQueries = await prisma.contextQuery.findMany()
     * 
     * // Get first 10 ContextQueries
     * const contextQueries = await prisma.contextQuery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contextQueryWithIdOnly = await prisma.contextQuery.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContextQueryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextQueryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ContextQueryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ContextQuery.
     * @param {ContextQueryCreateArgs} args - Arguments to create a ContextQuery.
     * @example
     * // Create one ContextQuery
     * const ContextQuery = await prisma.contextQuery.create({
     *   data: {
     *     // ... data to create a ContextQuery
     *   }
     * })
     * 
    **/
    create<T extends ContextQueryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ContextQueryCreateArgs<ExtArgs>>
    ): Prisma__ContextQueryClient<$Types.GetResult<ContextQueryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ContextQueries.
     *     @param {ContextQueryCreateManyArgs} args - Arguments to create many ContextQueries.
     *     @example
     *     // Create many ContextQueries
     *     const contextQuery = await prisma.contextQuery.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContextQueryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextQueryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContextQuery.
     * @param {ContextQueryDeleteArgs} args - Arguments to delete one ContextQuery.
     * @example
     * // Delete one ContextQuery
     * const ContextQuery = await prisma.contextQuery.delete({
     *   where: {
     *     // ... filter to delete one ContextQuery
     *   }
     * })
     * 
    **/
    delete<T extends ContextQueryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ContextQueryDeleteArgs<ExtArgs>>
    ): Prisma__ContextQueryClient<$Types.GetResult<ContextQueryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ContextQuery.
     * @param {ContextQueryUpdateArgs} args - Arguments to update one ContextQuery.
     * @example
     * // Update one ContextQuery
     * const contextQuery = await prisma.contextQuery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContextQueryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ContextQueryUpdateArgs<ExtArgs>>
    ): Prisma__ContextQueryClient<$Types.GetResult<ContextQueryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ContextQueries.
     * @param {ContextQueryDeleteManyArgs} args - Arguments to filter ContextQueries to delete.
     * @example
     * // Delete a few ContextQueries
     * const { count } = await prisma.contextQuery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContextQueryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextQueryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContextQueries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextQueryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContextQueries
     * const contextQuery = await prisma.contextQuery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContextQueryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ContextQueryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContextQuery.
     * @param {ContextQueryUpsertArgs} args - Arguments to update or create a ContextQuery.
     * @example
     * // Update or create a ContextQuery
     * const contextQuery = await prisma.contextQuery.upsert({
     *   create: {
     *     // ... data to create a ContextQuery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContextQuery we want to update
     *   }
     * })
    **/
    upsert<T extends ContextQueryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ContextQueryUpsertArgs<ExtArgs>>
    ): Prisma__ContextQueryClient<$Types.GetResult<ContextQueryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ContextQueries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextQueryCountArgs} args - Arguments to filter ContextQueries to count.
     * @example
     * // Count the number of ContextQueries
     * const count = await prisma.contextQuery.count({
     *   where: {
     *     // ... the filter for the ContextQueries we want to count
     *   }
     * })
    **/
    count<T extends ContextQueryCountArgs>(
      args?: Subset<T, ContextQueryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContextQueryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContextQuery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextQueryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContextQueryAggregateArgs>(args: Subset<T, ContextQueryAggregateArgs>): Prisma.PrismaPromise<GetContextQueryAggregateType<T>>

    /**
     * Group by ContextQuery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextQueryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContextQueryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContextQueryGroupByArgs['orderBy'] }
        : { orderBy?: ContextQueryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContextQueryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContextQueryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContextQuery model
   */
  readonly fields: ContextQueryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContextQuery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ContextQueryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    results<T extends ContextQuery$resultsArgs<ExtArgs> = {}>(args?: Subset<T, ContextQuery$resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ContextResultPayload<ExtArgs>, T, 'findMany'>| Null>;

    analytics<T extends ContextQuery$analyticsArgs<ExtArgs> = {}>(args?: Subset<T, ContextQuery$analyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ContextQueryAnalyticsPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the ContextQuery model
   */ 
  interface ContextQueryFieldRefs {
    readonly id: FieldRef<"ContextQuery", 'String'>
    readonly conversationId: FieldRef<"ContextQuery", 'String'>
    readonly messageId: FieldRef<"ContextQuery", 'String'>
    readonly queryText: FieldRef<"ContextQuery", 'String'>
    readonly intentType: FieldRef<"ContextQuery", 'String'>
    readonly intentConfidence: FieldRef<"ContextQuery", 'Float'>
    readonly intentKeywords: FieldRef<"ContextQuery", 'String[]'>
    readonly intentCategory: FieldRef<"ContextQuery", 'String'>
    readonly intentSubcategory: FieldRef<"ContextQuery", 'String'>
    readonly entities: FieldRef<"ContextQuery", 'Json'>
    readonly filters: FieldRef<"ContextQuery", 'Json'>
    readonly options: FieldRef<"ContextQuery", 'Json'>
    readonly createdAt: FieldRef<"ContextQuery", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ContextQuery findUnique
   */
  export type ContextQueryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextQuery
     */
    select?: ContextQuerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextQueryInclude<ExtArgs> | null
    /**
     * Filter, which ContextQuery to fetch.
     */
    where: ContextQueryWhereUniqueInput
  }


  /**
   * ContextQuery findUniqueOrThrow
   */
  export type ContextQueryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextQuery
     */
    select?: ContextQuerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextQueryInclude<ExtArgs> | null
    /**
     * Filter, which ContextQuery to fetch.
     */
    where: ContextQueryWhereUniqueInput
  }


  /**
   * ContextQuery findFirst
   */
  export type ContextQueryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextQuery
     */
    select?: ContextQuerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextQueryInclude<ExtArgs> | null
    /**
     * Filter, which ContextQuery to fetch.
     */
    where?: ContextQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextQueries to fetch.
     */
    orderBy?: ContextQueryOrderByWithRelationInput | ContextQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContextQueries.
     */
    cursor?: ContextQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextQueries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContextQueries.
     */
    distinct?: ContextQueryScalarFieldEnum | ContextQueryScalarFieldEnum[]
  }


  /**
   * ContextQuery findFirstOrThrow
   */
  export type ContextQueryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextQuery
     */
    select?: ContextQuerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextQueryInclude<ExtArgs> | null
    /**
     * Filter, which ContextQuery to fetch.
     */
    where?: ContextQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextQueries to fetch.
     */
    orderBy?: ContextQueryOrderByWithRelationInput | ContextQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContextQueries.
     */
    cursor?: ContextQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextQueries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContextQueries.
     */
    distinct?: ContextQueryScalarFieldEnum | ContextQueryScalarFieldEnum[]
  }


  /**
   * ContextQuery findMany
   */
  export type ContextQueryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextQuery
     */
    select?: ContextQuerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextQueryInclude<ExtArgs> | null
    /**
     * Filter, which ContextQueries to fetch.
     */
    where?: ContextQueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextQueries to fetch.
     */
    orderBy?: ContextQueryOrderByWithRelationInput | ContextQueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContextQueries.
     */
    cursor?: ContextQueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextQueries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextQueries.
     */
    skip?: number
    distinct?: ContextQueryScalarFieldEnum | ContextQueryScalarFieldEnum[]
  }


  /**
   * ContextQuery create
   */
  export type ContextQueryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextQuery
     */
    select?: ContextQuerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextQueryInclude<ExtArgs> | null
    /**
     * The data needed to create a ContextQuery.
     */
    data: XOR<ContextQueryCreateInput, ContextQueryUncheckedCreateInput>
  }


  /**
   * ContextQuery createMany
   */
  export type ContextQueryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContextQueries.
     */
    data: ContextQueryCreateManyInput | ContextQueryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ContextQuery update
   */
  export type ContextQueryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextQuery
     */
    select?: ContextQuerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextQueryInclude<ExtArgs> | null
    /**
     * The data needed to update a ContextQuery.
     */
    data: XOR<ContextQueryUpdateInput, ContextQueryUncheckedUpdateInput>
    /**
     * Choose, which ContextQuery to update.
     */
    where: ContextQueryWhereUniqueInput
  }


  /**
   * ContextQuery updateMany
   */
  export type ContextQueryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContextQueries.
     */
    data: XOR<ContextQueryUpdateManyMutationInput, ContextQueryUncheckedUpdateManyInput>
    /**
     * Filter which ContextQueries to update
     */
    where?: ContextQueryWhereInput
  }


  /**
   * ContextQuery upsert
   */
  export type ContextQueryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextQuery
     */
    select?: ContextQuerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextQueryInclude<ExtArgs> | null
    /**
     * The filter to search for the ContextQuery to update in case it exists.
     */
    where: ContextQueryWhereUniqueInput
    /**
     * In case the ContextQuery found by the `where` argument doesn't exist, create a new ContextQuery with this data.
     */
    create: XOR<ContextQueryCreateInput, ContextQueryUncheckedCreateInput>
    /**
     * In case the ContextQuery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContextQueryUpdateInput, ContextQueryUncheckedUpdateInput>
  }


  /**
   * ContextQuery delete
   */
  export type ContextQueryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextQuery
     */
    select?: ContextQuerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextQueryInclude<ExtArgs> | null
    /**
     * Filter which ContextQuery to delete.
     */
    where: ContextQueryWhereUniqueInput
  }


  /**
   * ContextQuery deleteMany
   */
  export type ContextQueryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContextQueries to delete
     */
    where?: ContextQueryWhereInput
  }


  /**
   * ContextQuery.results
   */
  export type ContextQuery$resultsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextResult
     */
    select?: ContextResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextResultInclude<ExtArgs> | null
    where?: ContextResultWhereInput
    orderBy?: ContextResultOrderByWithRelationInput | ContextResultOrderByWithRelationInput[]
    cursor?: ContextResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContextResultScalarFieldEnum | ContextResultScalarFieldEnum[]
  }


  /**
   * ContextQuery.analytics
   */
  export type ContextQuery$analyticsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextQueryAnalytics
     */
    select?: ContextQueryAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextQueryAnalyticsInclude<ExtArgs> | null
    where?: ContextQueryAnalyticsWhereInput
    orderBy?: ContextQueryAnalyticsOrderByWithRelationInput | ContextQueryAnalyticsOrderByWithRelationInput[]
    cursor?: ContextQueryAnalyticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContextQueryAnalyticsScalarFieldEnum | ContextQueryAnalyticsScalarFieldEnum[]
  }


  /**
   * ContextQuery without action
   */
  export type ContextQueryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextQuery
     */
    select?: ContextQuerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextQueryInclude<ExtArgs> | null
  }



  /**
   * Model ContextResult
   */


  export type AggregateContextResult = {
    _count: ContextResultCountAggregateOutputType | null
    _avg: ContextResultAvgAggregateOutputType | null
    _sum: ContextResultSumAggregateOutputType | null
    _min: ContextResultMinAggregateOutputType | null
    _max: ContextResultMaxAggregateOutputType | null
  }

  export type ContextResultAvgAggregateOutputType = {
    totalSources: number | null
    totalChunks: number | null
    queryTime: number | null
    relevanceScore: number | null
    coverage: number | null
    freshness: number | null
  }

  export type ContextResultSumAggregateOutputType = {
    totalSources: number | null
    totalChunks: number | null
    queryTime: number | null
    relevanceScore: number | null
    coverage: number | null
    freshness: number | null
  }

  export type ContextResultMinAggregateOutputType = {
    id: string | null
    queryId: string | null
    summary: string | null
    totalSources: number | null
    totalChunks: number | null
    queryTime: number | null
    relevanceScore: number | null
    coverage: number | null
    freshness: number | null
    createdAt: Date | null
  }

  export type ContextResultMaxAggregateOutputType = {
    id: string | null
    queryId: string | null
    summary: string | null
    totalSources: number | null
    totalChunks: number | null
    queryTime: number | null
    relevanceScore: number | null
    coverage: number | null
    freshness: number | null
    createdAt: Date | null
  }

  export type ContextResultCountAggregateOutputType = {
    id: number
    queryId: number
    sources: number
    chunks: number
    summary: number
    totalSources: number
    totalChunks: number
    queryTime: number
    relevanceScore: number
    coverage: number
    freshness: number
    suggestions: number
    createdAt: number
    _all: number
  }


  export type ContextResultAvgAggregateInputType = {
    totalSources?: true
    totalChunks?: true
    queryTime?: true
    relevanceScore?: true
    coverage?: true
    freshness?: true
  }

  export type ContextResultSumAggregateInputType = {
    totalSources?: true
    totalChunks?: true
    queryTime?: true
    relevanceScore?: true
    coverage?: true
    freshness?: true
  }

  export type ContextResultMinAggregateInputType = {
    id?: true
    queryId?: true
    summary?: true
    totalSources?: true
    totalChunks?: true
    queryTime?: true
    relevanceScore?: true
    coverage?: true
    freshness?: true
    createdAt?: true
  }

  export type ContextResultMaxAggregateInputType = {
    id?: true
    queryId?: true
    summary?: true
    totalSources?: true
    totalChunks?: true
    queryTime?: true
    relevanceScore?: true
    coverage?: true
    freshness?: true
    createdAt?: true
  }

  export type ContextResultCountAggregateInputType = {
    id?: true
    queryId?: true
    sources?: true
    chunks?: true
    summary?: true
    totalSources?: true
    totalChunks?: true
    queryTime?: true
    relevanceScore?: true
    coverage?: true
    freshness?: true
    suggestions?: true
    createdAt?: true
    _all?: true
  }

  export type ContextResultAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContextResult to aggregate.
     */
    where?: ContextResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextResults to fetch.
     */
    orderBy?: ContextResultOrderByWithRelationInput | ContextResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContextResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContextResults
    **/
    _count?: true | ContextResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContextResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContextResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContextResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContextResultMaxAggregateInputType
  }

  export type GetContextResultAggregateType<T extends ContextResultAggregateArgs> = {
        [P in keyof T & keyof AggregateContextResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContextResult[P]>
      : GetScalarType<T[P], AggregateContextResult[P]>
  }




  export type ContextResultGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ContextResultWhereInput
    orderBy?: ContextResultOrderByWithAggregationInput | ContextResultOrderByWithAggregationInput[]
    by: ContextResultScalarFieldEnum[] | ContextResultScalarFieldEnum
    having?: ContextResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContextResultCountAggregateInputType | true
    _avg?: ContextResultAvgAggregateInputType
    _sum?: ContextResultSumAggregateInputType
    _min?: ContextResultMinAggregateInputType
    _max?: ContextResultMaxAggregateInputType
  }


  export type ContextResultGroupByOutputType = {
    id: string
    queryId: string
    sources: JsonValue
    chunks: JsonValue
    summary: string | null
    totalSources: number
    totalChunks: number
    queryTime: number
    relevanceScore: number
    coverage: number
    freshness: number
    suggestions: JsonValue
    createdAt: Date
    _count: ContextResultCountAggregateOutputType | null
    _avg: ContextResultAvgAggregateOutputType | null
    _sum: ContextResultSumAggregateOutputType | null
    _min: ContextResultMinAggregateOutputType | null
    _max: ContextResultMaxAggregateOutputType | null
  }

  type GetContextResultGroupByPayload<T extends ContextResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContextResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContextResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContextResultGroupByOutputType[P]>
            : GetScalarType<T[P], ContextResultGroupByOutputType[P]>
        }
      >
    >


  export type ContextResultSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryId?: boolean
    sources?: boolean
    chunks?: boolean
    summary?: boolean
    totalSources?: boolean
    totalChunks?: boolean
    queryTime?: boolean
    relevanceScore?: boolean
    coverage?: boolean
    freshness?: boolean
    suggestions?: boolean
    createdAt?: boolean
    query?: boolean | ContextQueryArgs<ExtArgs>
  }, ExtArgs["result"]["contextResult"]>

  export type ContextResultSelectScalar = {
    id?: boolean
    queryId?: boolean
    sources?: boolean
    chunks?: boolean
    summary?: boolean
    totalSources?: boolean
    totalChunks?: boolean
    queryTime?: boolean
    relevanceScore?: boolean
    coverage?: boolean
    freshness?: boolean
    suggestions?: boolean
    createdAt?: boolean
  }

  export type ContextResultInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    query?: boolean | ContextQueryArgs<ExtArgs>
  }


  type ContextResultGetPayload<S extends boolean | null | undefined | ContextResultArgs> = $Types.GetResult<ContextResultPayload, S>

  type ContextResultCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ContextResultFindManyArgs, 'select' | 'include'> & {
      select?: ContextResultCountAggregateInputType | true
    }

  export interface ContextResultDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContextResult'], meta: { name: 'ContextResult' } }
    /**
     * Find zero or one ContextResult that matches the filter.
     * @param {ContextResultFindUniqueArgs} args - Arguments to find a ContextResult
     * @example
     * // Get one ContextResult
     * const contextResult = await prisma.contextResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContextResultFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ContextResultFindUniqueArgs<ExtArgs>>
    ): Prisma__ContextResultClient<$Types.GetResult<ContextResultPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ContextResult that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ContextResultFindUniqueOrThrowArgs} args - Arguments to find a ContextResult
     * @example
     * // Get one ContextResult
     * const contextResult = await prisma.contextResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ContextResultFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextResultFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ContextResultClient<$Types.GetResult<ContextResultPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ContextResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextResultFindFirstArgs} args - Arguments to find a ContextResult
     * @example
     * // Get one ContextResult
     * const contextResult = await prisma.contextResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContextResultFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextResultFindFirstArgs<ExtArgs>>
    ): Prisma__ContextResultClient<$Types.GetResult<ContextResultPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ContextResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextResultFindFirstOrThrowArgs} args - Arguments to find a ContextResult
     * @example
     * // Get one ContextResult
     * const contextResult = await prisma.contextResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ContextResultFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextResultFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ContextResultClient<$Types.GetResult<ContextResultPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ContextResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextResultFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContextResults
     * const contextResults = await prisma.contextResult.findMany()
     * 
     * // Get first 10 ContextResults
     * const contextResults = await prisma.contextResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contextResultWithIdOnly = await prisma.contextResult.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContextResultFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextResultFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ContextResultPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ContextResult.
     * @param {ContextResultCreateArgs} args - Arguments to create a ContextResult.
     * @example
     * // Create one ContextResult
     * const ContextResult = await prisma.contextResult.create({
     *   data: {
     *     // ... data to create a ContextResult
     *   }
     * })
     * 
    **/
    create<T extends ContextResultCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ContextResultCreateArgs<ExtArgs>>
    ): Prisma__ContextResultClient<$Types.GetResult<ContextResultPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ContextResults.
     *     @param {ContextResultCreateManyArgs} args - Arguments to create many ContextResults.
     *     @example
     *     // Create many ContextResults
     *     const contextResult = await prisma.contextResult.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContextResultCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextResultCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContextResult.
     * @param {ContextResultDeleteArgs} args - Arguments to delete one ContextResult.
     * @example
     * // Delete one ContextResult
     * const ContextResult = await prisma.contextResult.delete({
     *   where: {
     *     // ... filter to delete one ContextResult
     *   }
     * })
     * 
    **/
    delete<T extends ContextResultDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ContextResultDeleteArgs<ExtArgs>>
    ): Prisma__ContextResultClient<$Types.GetResult<ContextResultPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ContextResult.
     * @param {ContextResultUpdateArgs} args - Arguments to update one ContextResult.
     * @example
     * // Update one ContextResult
     * const contextResult = await prisma.contextResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContextResultUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ContextResultUpdateArgs<ExtArgs>>
    ): Prisma__ContextResultClient<$Types.GetResult<ContextResultPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ContextResults.
     * @param {ContextResultDeleteManyArgs} args - Arguments to filter ContextResults to delete.
     * @example
     * // Delete a few ContextResults
     * const { count } = await prisma.contextResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContextResultDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextResultDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContextResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContextResults
     * const contextResult = await prisma.contextResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContextResultUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ContextResultUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContextResult.
     * @param {ContextResultUpsertArgs} args - Arguments to update or create a ContextResult.
     * @example
     * // Update or create a ContextResult
     * const contextResult = await prisma.contextResult.upsert({
     *   create: {
     *     // ... data to create a ContextResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContextResult we want to update
     *   }
     * })
    **/
    upsert<T extends ContextResultUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ContextResultUpsertArgs<ExtArgs>>
    ): Prisma__ContextResultClient<$Types.GetResult<ContextResultPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ContextResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextResultCountArgs} args - Arguments to filter ContextResults to count.
     * @example
     * // Count the number of ContextResults
     * const count = await prisma.contextResult.count({
     *   where: {
     *     // ... the filter for the ContextResults we want to count
     *   }
     * })
    **/
    count<T extends ContextResultCountArgs>(
      args?: Subset<T, ContextResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContextResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContextResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContextResultAggregateArgs>(args: Subset<T, ContextResultAggregateArgs>): Prisma.PrismaPromise<GetContextResultAggregateType<T>>

    /**
     * Group by ContextResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContextResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContextResultGroupByArgs['orderBy'] }
        : { orderBy?: ContextResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContextResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContextResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContextResult model
   */
  readonly fields: ContextResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContextResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ContextResultClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    query<T extends ContextQueryArgs<ExtArgs> = {}>(args?: Subset<T, ContextQueryArgs<ExtArgs>>): Prisma__ContextQueryClient<$Types.GetResult<ContextQueryPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the ContextResult model
   */ 
  interface ContextResultFieldRefs {
    readonly id: FieldRef<"ContextResult", 'String'>
    readonly queryId: FieldRef<"ContextResult", 'String'>
    readonly sources: FieldRef<"ContextResult", 'Json'>
    readonly chunks: FieldRef<"ContextResult", 'Json'>
    readonly summary: FieldRef<"ContextResult", 'String'>
    readonly totalSources: FieldRef<"ContextResult", 'Int'>
    readonly totalChunks: FieldRef<"ContextResult", 'Int'>
    readonly queryTime: FieldRef<"ContextResult", 'Int'>
    readonly relevanceScore: FieldRef<"ContextResult", 'Float'>
    readonly coverage: FieldRef<"ContextResult", 'Float'>
    readonly freshness: FieldRef<"ContextResult", 'Float'>
    readonly suggestions: FieldRef<"ContextResult", 'Json'>
    readonly createdAt: FieldRef<"ContextResult", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ContextResult findUnique
   */
  export type ContextResultFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextResult
     */
    select?: ContextResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextResultInclude<ExtArgs> | null
    /**
     * Filter, which ContextResult to fetch.
     */
    where: ContextResultWhereUniqueInput
  }


  /**
   * ContextResult findUniqueOrThrow
   */
  export type ContextResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextResult
     */
    select?: ContextResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextResultInclude<ExtArgs> | null
    /**
     * Filter, which ContextResult to fetch.
     */
    where: ContextResultWhereUniqueInput
  }


  /**
   * ContextResult findFirst
   */
  export type ContextResultFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextResult
     */
    select?: ContextResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextResultInclude<ExtArgs> | null
    /**
     * Filter, which ContextResult to fetch.
     */
    where?: ContextResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextResults to fetch.
     */
    orderBy?: ContextResultOrderByWithRelationInput | ContextResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContextResults.
     */
    cursor?: ContextResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContextResults.
     */
    distinct?: ContextResultScalarFieldEnum | ContextResultScalarFieldEnum[]
  }


  /**
   * ContextResult findFirstOrThrow
   */
  export type ContextResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextResult
     */
    select?: ContextResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextResultInclude<ExtArgs> | null
    /**
     * Filter, which ContextResult to fetch.
     */
    where?: ContextResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextResults to fetch.
     */
    orderBy?: ContextResultOrderByWithRelationInput | ContextResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContextResults.
     */
    cursor?: ContextResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContextResults.
     */
    distinct?: ContextResultScalarFieldEnum | ContextResultScalarFieldEnum[]
  }


  /**
   * ContextResult findMany
   */
  export type ContextResultFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextResult
     */
    select?: ContextResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextResultInclude<ExtArgs> | null
    /**
     * Filter, which ContextResults to fetch.
     */
    where?: ContextResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextResults to fetch.
     */
    orderBy?: ContextResultOrderByWithRelationInput | ContextResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContextResults.
     */
    cursor?: ContextResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextResults.
     */
    skip?: number
    distinct?: ContextResultScalarFieldEnum | ContextResultScalarFieldEnum[]
  }


  /**
   * ContextResult create
   */
  export type ContextResultCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextResult
     */
    select?: ContextResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextResultInclude<ExtArgs> | null
    /**
     * The data needed to create a ContextResult.
     */
    data: XOR<ContextResultCreateInput, ContextResultUncheckedCreateInput>
  }


  /**
   * ContextResult createMany
   */
  export type ContextResultCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContextResults.
     */
    data: ContextResultCreateManyInput | ContextResultCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ContextResult update
   */
  export type ContextResultUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextResult
     */
    select?: ContextResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextResultInclude<ExtArgs> | null
    /**
     * The data needed to update a ContextResult.
     */
    data: XOR<ContextResultUpdateInput, ContextResultUncheckedUpdateInput>
    /**
     * Choose, which ContextResult to update.
     */
    where: ContextResultWhereUniqueInput
  }


  /**
   * ContextResult updateMany
   */
  export type ContextResultUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContextResults.
     */
    data: XOR<ContextResultUpdateManyMutationInput, ContextResultUncheckedUpdateManyInput>
    /**
     * Filter which ContextResults to update
     */
    where?: ContextResultWhereInput
  }


  /**
   * ContextResult upsert
   */
  export type ContextResultUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextResult
     */
    select?: ContextResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextResultInclude<ExtArgs> | null
    /**
     * The filter to search for the ContextResult to update in case it exists.
     */
    where: ContextResultWhereUniqueInput
    /**
     * In case the ContextResult found by the `where` argument doesn't exist, create a new ContextResult with this data.
     */
    create: XOR<ContextResultCreateInput, ContextResultUncheckedCreateInput>
    /**
     * In case the ContextResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContextResultUpdateInput, ContextResultUncheckedUpdateInput>
  }


  /**
   * ContextResult delete
   */
  export type ContextResultDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextResult
     */
    select?: ContextResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextResultInclude<ExtArgs> | null
    /**
     * Filter which ContextResult to delete.
     */
    where: ContextResultWhereUniqueInput
  }


  /**
   * ContextResult deleteMany
   */
  export type ContextResultDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContextResults to delete
     */
    where?: ContextResultWhereInput
  }


  /**
   * ContextResult without action
   */
  export type ContextResultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextResult
     */
    select?: ContextResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextResultInclude<ExtArgs> | null
  }



  /**
   * Model ContextInjection
   */


  export type AggregateContextInjection = {
    _count: ContextInjectionCountAggregateOutputType | null
    _avg: ContextInjectionAvgAggregateOutputType | null
    _sum: ContextInjectionSumAggregateOutputType | null
    _min: ContextInjectionMinAggregateOutputType | null
    _max: ContextInjectionMaxAggregateOutputType | null
  }

  export type ContextInjectionAvgAggregateOutputType = {
    originalLength: number | null
    injectedLength: number | null
    compressionRatio: number | null
    relevanceScore: number | null
  }

  export type ContextInjectionSumAggregateOutputType = {
    originalLength: number | null
    injectedLength: number | null
    compressionRatio: number | null
    relevanceScore: number | null
  }

  export type ContextInjectionMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    messageId: string | null
    templateId: string | null
    injectedPrompt: string | null
    originalLength: number | null
    injectedLength: number | null
    compressionRatio: number | null
    relevanceScore: number | null
    createdAt: Date | null
  }

  export type ContextInjectionMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    messageId: string | null
    templateId: string | null
    injectedPrompt: string | null
    originalLength: number | null
    injectedLength: number | null
    compressionRatio: number | null
    relevanceScore: number | null
    createdAt: Date | null
  }

  export type ContextInjectionCountAggregateOutputType = {
    id: number
    conversationId: number
    messageId: number
    context: number
    templateId: number
    injectedPrompt: number
    originalLength: number
    injectedLength: number
    compressionRatio: number
    relevanceScore: number
    createdAt: number
    _all: number
  }


  export type ContextInjectionAvgAggregateInputType = {
    originalLength?: true
    injectedLength?: true
    compressionRatio?: true
    relevanceScore?: true
  }

  export type ContextInjectionSumAggregateInputType = {
    originalLength?: true
    injectedLength?: true
    compressionRatio?: true
    relevanceScore?: true
  }

  export type ContextInjectionMinAggregateInputType = {
    id?: true
    conversationId?: true
    messageId?: true
    templateId?: true
    injectedPrompt?: true
    originalLength?: true
    injectedLength?: true
    compressionRatio?: true
    relevanceScore?: true
    createdAt?: true
  }

  export type ContextInjectionMaxAggregateInputType = {
    id?: true
    conversationId?: true
    messageId?: true
    templateId?: true
    injectedPrompt?: true
    originalLength?: true
    injectedLength?: true
    compressionRatio?: true
    relevanceScore?: true
    createdAt?: true
  }

  export type ContextInjectionCountAggregateInputType = {
    id?: true
    conversationId?: true
    messageId?: true
    context?: true
    templateId?: true
    injectedPrompt?: true
    originalLength?: true
    injectedLength?: true
    compressionRatio?: true
    relevanceScore?: true
    createdAt?: true
    _all?: true
  }

  export type ContextInjectionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContextInjection to aggregate.
     */
    where?: ContextInjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextInjections to fetch.
     */
    orderBy?: ContextInjectionOrderByWithRelationInput | ContextInjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContextInjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextInjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextInjections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContextInjections
    **/
    _count?: true | ContextInjectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContextInjectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContextInjectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContextInjectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContextInjectionMaxAggregateInputType
  }

  export type GetContextInjectionAggregateType<T extends ContextInjectionAggregateArgs> = {
        [P in keyof T & keyof AggregateContextInjection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContextInjection[P]>
      : GetScalarType<T[P], AggregateContextInjection[P]>
  }




  export type ContextInjectionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ContextInjectionWhereInput
    orderBy?: ContextInjectionOrderByWithAggregationInput | ContextInjectionOrderByWithAggregationInput[]
    by: ContextInjectionScalarFieldEnum[] | ContextInjectionScalarFieldEnum
    having?: ContextInjectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContextInjectionCountAggregateInputType | true
    _avg?: ContextInjectionAvgAggregateInputType
    _sum?: ContextInjectionSumAggregateInputType
    _min?: ContextInjectionMinAggregateInputType
    _max?: ContextInjectionMaxAggregateInputType
  }


  export type ContextInjectionGroupByOutputType = {
    id: string
    conversationId: string
    messageId: string
    context: JsonValue
    templateId: string | null
    injectedPrompt: string
    originalLength: number
    injectedLength: number
    compressionRatio: number
    relevanceScore: number
    createdAt: Date
    _count: ContextInjectionCountAggregateOutputType | null
    _avg: ContextInjectionAvgAggregateOutputType | null
    _sum: ContextInjectionSumAggregateOutputType | null
    _min: ContextInjectionMinAggregateOutputType | null
    _max: ContextInjectionMaxAggregateOutputType | null
  }

  type GetContextInjectionGroupByPayload<T extends ContextInjectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContextInjectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContextInjectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContextInjectionGroupByOutputType[P]>
            : GetScalarType<T[P], ContextInjectionGroupByOutputType[P]>
        }
      >
    >


  export type ContextInjectionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    messageId?: boolean
    context?: boolean
    templateId?: boolean
    injectedPrompt?: boolean
    originalLength?: boolean
    injectedLength?: boolean
    compressionRatio?: boolean
    relevanceScore?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contextInjection"]>

  export type ContextInjectionSelectScalar = {
    id?: boolean
    conversationId?: boolean
    messageId?: boolean
    context?: boolean
    templateId?: boolean
    injectedPrompt?: boolean
    originalLength?: boolean
    injectedLength?: boolean
    compressionRatio?: boolean
    relevanceScore?: boolean
    createdAt?: boolean
  }


  type ContextInjectionGetPayload<S extends boolean | null | undefined | ContextInjectionArgs> = $Types.GetResult<ContextInjectionPayload, S>

  type ContextInjectionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ContextInjectionFindManyArgs, 'select' | 'include'> & {
      select?: ContextInjectionCountAggregateInputType | true
    }

  export interface ContextInjectionDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContextInjection'], meta: { name: 'ContextInjection' } }
    /**
     * Find zero or one ContextInjection that matches the filter.
     * @param {ContextInjectionFindUniqueArgs} args - Arguments to find a ContextInjection
     * @example
     * // Get one ContextInjection
     * const contextInjection = await prisma.contextInjection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContextInjectionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ContextInjectionFindUniqueArgs<ExtArgs>>
    ): Prisma__ContextInjectionClient<$Types.GetResult<ContextInjectionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ContextInjection that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ContextInjectionFindUniqueOrThrowArgs} args - Arguments to find a ContextInjection
     * @example
     * // Get one ContextInjection
     * const contextInjection = await prisma.contextInjection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ContextInjectionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextInjectionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ContextInjectionClient<$Types.GetResult<ContextInjectionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ContextInjection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextInjectionFindFirstArgs} args - Arguments to find a ContextInjection
     * @example
     * // Get one ContextInjection
     * const contextInjection = await prisma.contextInjection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContextInjectionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextInjectionFindFirstArgs<ExtArgs>>
    ): Prisma__ContextInjectionClient<$Types.GetResult<ContextInjectionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ContextInjection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextInjectionFindFirstOrThrowArgs} args - Arguments to find a ContextInjection
     * @example
     * // Get one ContextInjection
     * const contextInjection = await prisma.contextInjection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ContextInjectionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextInjectionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ContextInjectionClient<$Types.GetResult<ContextInjectionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ContextInjections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextInjectionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContextInjections
     * const contextInjections = await prisma.contextInjection.findMany()
     * 
     * // Get first 10 ContextInjections
     * const contextInjections = await prisma.contextInjection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contextInjectionWithIdOnly = await prisma.contextInjection.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContextInjectionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextInjectionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ContextInjectionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ContextInjection.
     * @param {ContextInjectionCreateArgs} args - Arguments to create a ContextInjection.
     * @example
     * // Create one ContextInjection
     * const ContextInjection = await prisma.contextInjection.create({
     *   data: {
     *     // ... data to create a ContextInjection
     *   }
     * })
     * 
    **/
    create<T extends ContextInjectionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ContextInjectionCreateArgs<ExtArgs>>
    ): Prisma__ContextInjectionClient<$Types.GetResult<ContextInjectionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ContextInjections.
     *     @param {ContextInjectionCreateManyArgs} args - Arguments to create many ContextInjections.
     *     @example
     *     // Create many ContextInjections
     *     const contextInjection = await prisma.contextInjection.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContextInjectionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextInjectionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContextInjection.
     * @param {ContextInjectionDeleteArgs} args - Arguments to delete one ContextInjection.
     * @example
     * // Delete one ContextInjection
     * const ContextInjection = await prisma.contextInjection.delete({
     *   where: {
     *     // ... filter to delete one ContextInjection
     *   }
     * })
     * 
    **/
    delete<T extends ContextInjectionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ContextInjectionDeleteArgs<ExtArgs>>
    ): Prisma__ContextInjectionClient<$Types.GetResult<ContextInjectionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ContextInjection.
     * @param {ContextInjectionUpdateArgs} args - Arguments to update one ContextInjection.
     * @example
     * // Update one ContextInjection
     * const contextInjection = await prisma.contextInjection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContextInjectionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ContextInjectionUpdateArgs<ExtArgs>>
    ): Prisma__ContextInjectionClient<$Types.GetResult<ContextInjectionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ContextInjections.
     * @param {ContextInjectionDeleteManyArgs} args - Arguments to filter ContextInjections to delete.
     * @example
     * // Delete a few ContextInjections
     * const { count } = await prisma.contextInjection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContextInjectionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextInjectionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContextInjections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextInjectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContextInjections
     * const contextInjection = await prisma.contextInjection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContextInjectionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ContextInjectionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContextInjection.
     * @param {ContextInjectionUpsertArgs} args - Arguments to update or create a ContextInjection.
     * @example
     * // Update or create a ContextInjection
     * const contextInjection = await prisma.contextInjection.upsert({
     *   create: {
     *     // ... data to create a ContextInjection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContextInjection we want to update
     *   }
     * })
    **/
    upsert<T extends ContextInjectionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ContextInjectionUpsertArgs<ExtArgs>>
    ): Prisma__ContextInjectionClient<$Types.GetResult<ContextInjectionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ContextInjections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextInjectionCountArgs} args - Arguments to filter ContextInjections to count.
     * @example
     * // Count the number of ContextInjections
     * const count = await prisma.contextInjection.count({
     *   where: {
     *     // ... the filter for the ContextInjections we want to count
     *   }
     * })
    **/
    count<T extends ContextInjectionCountArgs>(
      args?: Subset<T, ContextInjectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContextInjectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContextInjection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextInjectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContextInjectionAggregateArgs>(args: Subset<T, ContextInjectionAggregateArgs>): Prisma.PrismaPromise<GetContextInjectionAggregateType<T>>

    /**
     * Group by ContextInjection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextInjectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContextInjectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContextInjectionGroupByArgs['orderBy'] }
        : { orderBy?: ContextInjectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContextInjectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContextInjectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContextInjection model
   */
  readonly fields: ContextInjectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContextInjection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ContextInjectionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the ContextInjection model
   */ 
  interface ContextInjectionFieldRefs {
    readonly id: FieldRef<"ContextInjection", 'String'>
    readonly conversationId: FieldRef<"ContextInjection", 'String'>
    readonly messageId: FieldRef<"ContextInjection", 'String'>
    readonly context: FieldRef<"ContextInjection", 'Json'>
    readonly templateId: FieldRef<"ContextInjection", 'String'>
    readonly injectedPrompt: FieldRef<"ContextInjection", 'String'>
    readonly originalLength: FieldRef<"ContextInjection", 'Int'>
    readonly injectedLength: FieldRef<"ContextInjection", 'Int'>
    readonly compressionRatio: FieldRef<"ContextInjection", 'Float'>
    readonly relevanceScore: FieldRef<"ContextInjection", 'Float'>
    readonly createdAt: FieldRef<"ContextInjection", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ContextInjection findUnique
   */
  export type ContextInjectionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextInjection
     */
    select?: ContextInjectionSelect<ExtArgs> | null
    /**
     * Filter, which ContextInjection to fetch.
     */
    where: ContextInjectionWhereUniqueInput
  }


  /**
   * ContextInjection findUniqueOrThrow
   */
  export type ContextInjectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextInjection
     */
    select?: ContextInjectionSelect<ExtArgs> | null
    /**
     * Filter, which ContextInjection to fetch.
     */
    where: ContextInjectionWhereUniqueInput
  }


  /**
   * ContextInjection findFirst
   */
  export type ContextInjectionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextInjection
     */
    select?: ContextInjectionSelect<ExtArgs> | null
    /**
     * Filter, which ContextInjection to fetch.
     */
    where?: ContextInjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextInjections to fetch.
     */
    orderBy?: ContextInjectionOrderByWithRelationInput | ContextInjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContextInjections.
     */
    cursor?: ContextInjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextInjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextInjections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContextInjections.
     */
    distinct?: ContextInjectionScalarFieldEnum | ContextInjectionScalarFieldEnum[]
  }


  /**
   * ContextInjection findFirstOrThrow
   */
  export type ContextInjectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextInjection
     */
    select?: ContextInjectionSelect<ExtArgs> | null
    /**
     * Filter, which ContextInjection to fetch.
     */
    where?: ContextInjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextInjections to fetch.
     */
    orderBy?: ContextInjectionOrderByWithRelationInput | ContextInjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContextInjections.
     */
    cursor?: ContextInjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextInjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextInjections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContextInjections.
     */
    distinct?: ContextInjectionScalarFieldEnum | ContextInjectionScalarFieldEnum[]
  }


  /**
   * ContextInjection findMany
   */
  export type ContextInjectionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextInjection
     */
    select?: ContextInjectionSelect<ExtArgs> | null
    /**
     * Filter, which ContextInjections to fetch.
     */
    where?: ContextInjectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextInjections to fetch.
     */
    orderBy?: ContextInjectionOrderByWithRelationInput | ContextInjectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContextInjections.
     */
    cursor?: ContextInjectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextInjections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextInjections.
     */
    skip?: number
    distinct?: ContextInjectionScalarFieldEnum | ContextInjectionScalarFieldEnum[]
  }


  /**
   * ContextInjection create
   */
  export type ContextInjectionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextInjection
     */
    select?: ContextInjectionSelect<ExtArgs> | null
    /**
     * The data needed to create a ContextInjection.
     */
    data: XOR<ContextInjectionCreateInput, ContextInjectionUncheckedCreateInput>
  }


  /**
   * ContextInjection createMany
   */
  export type ContextInjectionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContextInjections.
     */
    data: ContextInjectionCreateManyInput | ContextInjectionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ContextInjection update
   */
  export type ContextInjectionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextInjection
     */
    select?: ContextInjectionSelect<ExtArgs> | null
    /**
     * The data needed to update a ContextInjection.
     */
    data: XOR<ContextInjectionUpdateInput, ContextInjectionUncheckedUpdateInput>
    /**
     * Choose, which ContextInjection to update.
     */
    where: ContextInjectionWhereUniqueInput
  }


  /**
   * ContextInjection updateMany
   */
  export type ContextInjectionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContextInjections.
     */
    data: XOR<ContextInjectionUpdateManyMutationInput, ContextInjectionUncheckedUpdateManyInput>
    /**
     * Filter which ContextInjections to update
     */
    where?: ContextInjectionWhereInput
  }


  /**
   * ContextInjection upsert
   */
  export type ContextInjectionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextInjection
     */
    select?: ContextInjectionSelect<ExtArgs> | null
    /**
     * The filter to search for the ContextInjection to update in case it exists.
     */
    where: ContextInjectionWhereUniqueInput
    /**
     * In case the ContextInjection found by the `where` argument doesn't exist, create a new ContextInjection with this data.
     */
    create: XOR<ContextInjectionCreateInput, ContextInjectionUncheckedCreateInput>
    /**
     * In case the ContextInjection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContextInjectionUpdateInput, ContextInjectionUncheckedUpdateInput>
  }


  /**
   * ContextInjection delete
   */
  export type ContextInjectionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextInjection
     */
    select?: ContextInjectionSelect<ExtArgs> | null
    /**
     * Filter which ContextInjection to delete.
     */
    where: ContextInjectionWhereUniqueInput
  }


  /**
   * ContextInjection deleteMany
   */
  export type ContextInjectionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContextInjections to delete
     */
    where?: ContextInjectionWhereInput
  }


  /**
   * ContextInjection without action
   */
  export type ContextInjectionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextInjection
     */
    select?: ContextInjectionSelect<ExtArgs> | null
  }



  /**
   * Model ContextTemplate
   */


  export type AggregateContextTemplate = {
    _count: ContextTemplateCountAggregateOutputType | null
    _avg: ContextTemplateAvgAggregateOutputType | null
    _sum: ContextTemplateSumAggregateOutputType | null
    _min: ContextTemplateMinAggregateOutputType | null
    _max: ContextTemplateMaxAggregateOutputType | null
  }

  export type ContextTemplateAvgAggregateOutputType = {
    usageCount: number | null
  }

  export type ContextTemplateSumAggregateOutputType = {
    usageCount: number | null
  }

  export type ContextTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    template: string | null
    description: string | null
    version: string | null
    usageCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContextTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    template: string | null
    description: string | null
    version: string | null
    usageCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContextTemplateCountAggregateOutputType = {
    id: number
    name: number
    type: number
    template: number
    variables: number
    description: number
    version: number
    usageCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContextTemplateAvgAggregateInputType = {
    usageCount?: true
  }

  export type ContextTemplateSumAggregateInputType = {
    usageCount?: true
  }

  export type ContextTemplateMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    template?: true
    description?: true
    version?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContextTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    template?: true
    description?: true
    version?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContextTemplateCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    template?: true
    variables?: true
    description?: true
    version?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContextTemplateAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContextTemplate to aggregate.
     */
    where?: ContextTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextTemplates to fetch.
     */
    orderBy?: ContextTemplateOrderByWithRelationInput | ContextTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContextTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContextTemplates
    **/
    _count?: true | ContextTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContextTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContextTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContextTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContextTemplateMaxAggregateInputType
  }

  export type GetContextTemplateAggregateType<T extends ContextTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateContextTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContextTemplate[P]>
      : GetScalarType<T[P], AggregateContextTemplate[P]>
  }




  export type ContextTemplateGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ContextTemplateWhereInput
    orderBy?: ContextTemplateOrderByWithAggregationInput | ContextTemplateOrderByWithAggregationInput[]
    by: ContextTemplateScalarFieldEnum[] | ContextTemplateScalarFieldEnum
    having?: ContextTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContextTemplateCountAggregateInputType | true
    _avg?: ContextTemplateAvgAggregateInputType
    _sum?: ContextTemplateSumAggregateInputType
    _min?: ContextTemplateMinAggregateInputType
    _max?: ContextTemplateMaxAggregateInputType
  }


  export type ContextTemplateGroupByOutputType = {
    id: string
    name: string
    type: string
    template: string
    variables: string[]
    description: string | null
    version: string
    usageCount: number
    createdAt: Date
    updatedAt: Date
    _count: ContextTemplateCountAggregateOutputType | null
    _avg: ContextTemplateAvgAggregateOutputType | null
    _sum: ContextTemplateSumAggregateOutputType | null
    _min: ContextTemplateMinAggregateOutputType | null
    _max: ContextTemplateMaxAggregateOutputType | null
  }

  type GetContextTemplateGroupByPayload<T extends ContextTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContextTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContextTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContextTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], ContextTemplateGroupByOutputType[P]>
        }
      >
    >


  export type ContextTemplateSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    template?: boolean
    variables?: boolean
    description?: boolean
    version?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contextTemplate"]>

  export type ContextTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    template?: boolean
    variables?: boolean
    description?: boolean
    version?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  type ContextTemplateGetPayload<S extends boolean | null | undefined | ContextTemplateArgs> = $Types.GetResult<ContextTemplatePayload, S>

  type ContextTemplateCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ContextTemplateFindManyArgs, 'select' | 'include'> & {
      select?: ContextTemplateCountAggregateInputType | true
    }

  export interface ContextTemplateDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContextTemplate'], meta: { name: 'ContextTemplate' } }
    /**
     * Find zero or one ContextTemplate that matches the filter.
     * @param {ContextTemplateFindUniqueArgs} args - Arguments to find a ContextTemplate
     * @example
     * // Get one ContextTemplate
     * const contextTemplate = await prisma.contextTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContextTemplateFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ContextTemplateFindUniqueArgs<ExtArgs>>
    ): Prisma__ContextTemplateClient<$Types.GetResult<ContextTemplatePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ContextTemplate that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ContextTemplateFindUniqueOrThrowArgs} args - Arguments to find a ContextTemplate
     * @example
     * // Get one ContextTemplate
     * const contextTemplate = await prisma.contextTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ContextTemplateFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextTemplateFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ContextTemplateClient<$Types.GetResult<ContextTemplatePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ContextTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextTemplateFindFirstArgs} args - Arguments to find a ContextTemplate
     * @example
     * // Get one ContextTemplate
     * const contextTemplate = await prisma.contextTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContextTemplateFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextTemplateFindFirstArgs<ExtArgs>>
    ): Prisma__ContextTemplateClient<$Types.GetResult<ContextTemplatePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ContextTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextTemplateFindFirstOrThrowArgs} args - Arguments to find a ContextTemplate
     * @example
     * // Get one ContextTemplate
     * const contextTemplate = await prisma.contextTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ContextTemplateFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextTemplateFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ContextTemplateClient<$Types.GetResult<ContextTemplatePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ContextTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextTemplateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContextTemplates
     * const contextTemplates = await prisma.contextTemplate.findMany()
     * 
     * // Get first 10 ContextTemplates
     * const contextTemplates = await prisma.contextTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contextTemplateWithIdOnly = await prisma.contextTemplate.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContextTemplateFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextTemplateFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ContextTemplatePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ContextTemplate.
     * @param {ContextTemplateCreateArgs} args - Arguments to create a ContextTemplate.
     * @example
     * // Create one ContextTemplate
     * const ContextTemplate = await prisma.contextTemplate.create({
     *   data: {
     *     // ... data to create a ContextTemplate
     *   }
     * })
     * 
    **/
    create<T extends ContextTemplateCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ContextTemplateCreateArgs<ExtArgs>>
    ): Prisma__ContextTemplateClient<$Types.GetResult<ContextTemplatePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ContextTemplates.
     *     @param {ContextTemplateCreateManyArgs} args - Arguments to create many ContextTemplates.
     *     @example
     *     // Create many ContextTemplates
     *     const contextTemplate = await prisma.contextTemplate.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContextTemplateCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextTemplateCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContextTemplate.
     * @param {ContextTemplateDeleteArgs} args - Arguments to delete one ContextTemplate.
     * @example
     * // Delete one ContextTemplate
     * const ContextTemplate = await prisma.contextTemplate.delete({
     *   where: {
     *     // ... filter to delete one ContextTemplate
     *   }
     * })
     * 
    **/
    delete<T extends ContextTemplateDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ContextTemplateDeleteArgs<ExtArgs>>
    ): Prisma__ContextTemplateClient<$Types.GetResult<ContextTemplatePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ContextTemplate.
     * @param {ContextTemplateUpdateArgs} args - Arguments to update one ContextTemplate.
     * @example
     * // Update one ContextTemplate
     * const contextTemplate = await prisma.contextTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContextTemplateUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ContextTemplateUpdateArgs<ExtArgs>>
    ): Prisma__ContextTemplateClient<$Types.GetResult<ContextTemplatePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ContextTemplates.
     * @param {ContextTemplateDeleteManyArgs} args - Arguments to filter ContextTemplates to delete.
     * @example
     * // Delete a few ContextTemplates
     * const { count } = await prisma.contextTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContextTemplateDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextTemplateDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContextTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContextTemplates
     * const contextTemplate = await prisma.contextTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContextTemplateUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ContextTemplateUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContextTemplate.
     * @param {ContextTemplateUpsertArgs} args - Arguments to update or create a ContextTemplate.
     * @example
     * // Update or create a ContextTemplate
     * const contextTemplate = await prisma.contextTemplate.upsert({
     *   create: {
     *     // ... data to create a ContextTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContextTemplate we want to update
     *   }
     * })
    **/
    upsert<T extends ContextTemplateUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ContextTemplateUpsertArgs<ExtArgs>>
    ): Prisma__ContextTemplateClient<$Types.GetResult<ContextTemplatePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ContextTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextTemplateCountArgs} args - Arguments to filter ContextTemplates to count.
     * @example
     * // Count the number of ContextTemplates
     * const count = await prisma.contextTemplate.count({
     *   where: {
     *     // ... the filter for the ContextTemplates we want to count
     *   }
     * })
    **/
    count<T extends ContextTemplateCountArgs>(
      args?: Subset<T, ContextTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContextTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContextTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContextTemplateAggregateArgs>(args: Subset<T, ContextTemplateAggregateArgs>): Prisma.PrismaPromise<GetContextTemplateAggregateType<T>>

    /**
     * Group by ContextTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContextTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContextTemplateGroupByArgs['orderBy'] }
        : { orderBy?: ContextTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContextTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContextTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContextTemplate model
   */
  readonly fields: ContextTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContextTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ContextTemplateClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the ContextTemplate model
   */ 
  interface ContextTemplateFieldRefs {
    readonly id: FieldRef<"ContextTemplate", 'String'>
    readonly name: FieldRef<"ContextTemplate", 'String'>
    readonly type: FieldRef<"ContextTemplate", 'String'>
    readonly template: FieldRef<"ContextTemplate", 'String'>
    readonly variables: FieldRef<"ContextTemplate", 'String[]'>
    readonly description: FieldRef<"ContextTemplate", 'String'>
    readonly version: FieldRef<"ContextTemplate", 'String'>
    readonly usageCount: FieldRef<"ContextTemplate", 'Int'>
    readonly createdAt: FieldRef<"ContextTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"ContextTemplate", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ContextTemplate findUnique
   */
  export type ContextTemplateFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextTemplate
     */
    select?: ContextTemplateSelect<ExtArgs> | null
    /**
     * Filter, which ContextTemplate to fetch.
     */
    where: ContextTemplateWhereUniqueInput
  }


  /**
   * ContextTemplate findUniqueOrThrow
   */
  export type ContextTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextTemplate
     */
    select?: ContextTemplateSelect<ExtArgs> | null
    /**
     * Filter, which ContextTemplate to fetch.
     */
    where: ContextTemplateWhereUniqueInput
  }


  /**
   * ContextTemplate findFirst
   */
  export type ContextTemplateFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextTemplate
     */
    select?: ContextTemplateSelect<ExtArgs> | null
    /**
     * Filter, which ContextTemplate to fetch.
     */
    where?: ContextTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextTemplates to fetch.
     */
    orderBy?: ContextTemplateOrderByWithRelationInput | ContextTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContextTemplates.
     */
    cursor?: ContextTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContextTemplates.
     */
    distinct?: ContextTemplateScalarFieldEnum | ContextTemplateScalarFieldEnum[]
  }


  /**
   * ContextTemplate findFirstOrThrow
   */
  export type ContextTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextTemplate
     */
    select?: ContextTemplateSelect<ExtArgs> | null
    /**
     * Filter, which ContextTemplate to fetch.
     */
    where?: ContextTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextTemplates to fetch.
     */
    orderBy?: ContextTemplateOrderByWithRelationInput | ContextTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContextTemplates.
     */
    cursor?: ContextTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContextTemplates.
     */
    distinct?: ContextTemplateScalarFieldEnum | ContextTemplateScalarFieldEnum[]
  }


  /**
   * ContextTemplate findMany
   */
  export type ContextTemplateFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextTemplate
     */
    select?: ContextTemplateSelect<ExtArgs> | null
    /**
     * Filter, which ContextTemplates to fetch.
     */
    where?: ContextTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextTemplates to fetch.
     */
    orderBy?: ContextTemplateOrderByWithRelationInput | ContextTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContextTemplates.
     */
    cursor?: ContextTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextTemplates.
     */
    skip?: number
    distinct?: ContextTemplateScalarFieldEnum | ContextTemplateScalarFieldEnum[]
  }


  /**
   * ContextTemplate create
   */
  export type ContextTemplateCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextTemplate
     */
    select?: ContextTemplateSelect<ExtArgs> | null
    /**
     * The data needed to create a ContextTemplate.
     */
    data: XOR<ContextTemplateCreateInput, ContextTemplateUncheckedCreateInput>
  }


  /**
   * ContextTemplate createMany
   */
  export type ContextTemplateCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContextTemplates.
     */
    data: ContextTemplateCreateManyInput | ContextTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ContextTemplate update
   */
  export type ContextTemplateUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextTemplate
     */
    select?: ContextTemplateSelect<ExtArgs> | null
    /**
     * The data needed to update a ContextTemplate.
     */
    data: XOR<ContextTemplateUpdateInput, ContextTemplateUncheckedUpdateInput>
    /**
     * Choose, which ContextTemplate to update.
     */
    where: ContextTemplateWhereUniqueInput
  }


  /**
   * ContextTemplate updateMany
   */
  export type ContextTemplateUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContextTemplates.
     */
    data: XOR<ContextTemplateUpdateManyMutationInput, ContextTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ContextTemplates to update
     */
    where?: ContextTemplateWhereInput
  }


  /**
   * ContextTemplate upsert
   */
  export type ContextTemplateUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextTemplate
     */
    select?: ContextTemplateSelect<ExtArgs> | null
    /**
     * The filter to search for the ContextTemplate to update in case it exists.
     */
    where: ContextTemplateWhereUniqueInput
    /**
     * In case the ContextTemplate found by the `where` argument doesn't exist, create a new ContextTemplate with this data.
     */
    create: XOR<ContextTemplateCreateInput, ContextTemplateUncheckedCreateInput>
    /**
     * In case the ContextTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContextTemplateUpdateInput, ContextTemplateUncheckedUpdateInput>
  }


  /**
   * ContextTemplate delete
   */
  export type ContextTemplateDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextTemplate
     */
    select?: ContextTemplateSelect<ExtArgs> | null
    /**
     * Filter which ContextTemplate to delete.
     */
    where: ContextTemplateWhereUniqueInput
  }


  /**
   * ContextTemplate deleteMany
   */
  export type ContextTemplateDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContextTemplates to delete
     */
    where?: ContextTemplateWhereInput
  }


  /**
   * ContextTemplate without action
   */
  export type ContextTemplateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextTemplate
     */
    select?: ContextTemplateSelect<ExtArgs> | null
  }



  /**
   * Model ContextQueryAnalytics
   */


  export type AggregateContextQueryAnalytics = {
    _count: ContextQueryAnalyticsCountAggregateOutputType | null
    _min: ContextQueryAnalyticsMinAggregateOutputType | null
    _max: ContextQueryAnalyticsMaxAggregateOutputType | null
  }

  export type ContextQueryAnalyticsMinAggregateOutputType = {
    id: string | null
    queryId: string | null
    conversationId: string | null
    queryText: string | null
    createdAt: Date | null
  }

  export type ContextQueryAnalyticsMaxAggregateOutputType = {
    id: string | null
    queryId: string | null
    conversationId: string | null
    queryText: string | null
    createdAt: Date | null
  }

  export type ContextQueryAnalyticsCountAggregateOutputType = {
    id: number
    queryId: number
    conversationId: number
    queryText: number
    intent: number
    entities: number
    filters: number
    options: number
    resultMetadata: number
    createdAt: number
    _all: number
  }


  export type ContextQueryAnalyticsMinAggregateInputType = {
    id?: true
    queryId?: true
    conversationId?: true
    queryText?: true
    createdAt?: true
  }

  export type ContextQueryAnalyticsMaxAggregateInputType = {
    id?: true
    queryId?: true
    conversationId?: true
    queryText?: true
    createdAt?: true
  }

  export type ContextQueryAnalyticsCountAggregateInputType = {
    id?: true
    queryId?: true
    conversationId?: true
    queryText?: true
    intent?: true
    entities?: true
    filters?: true
    options?: true
    resultMetadata?: true
    createdAt?: true
    _all?: true
  }

  export type ContextQueryAnalyticsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContextQueryAnalytics to aggregate.
     */
    where?: ContextQueryAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextQueryAnalytics to fetch.
     */
    orderBy?: ContextQueryAnalyticsOrderByWithRelationInput | ContextQueryAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContextQueryAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextQueryAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextQueryAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContextQueryAnalytics
    **/
    _count?: true | ContextQueryAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContextQueryAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContextQueryAnalyticsMaxAggregateInputType
  }

  export type GetContextQueryAnalyticsAggregateType<T extends ContextQueryAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateContextQueryAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContextQueryAnalytics[P]>
      : GetScalarType<T[P], AggregateContextQueryAnalytics[P]>
  }




  export type ContextQueryAnalyticsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ContextQueryAnalyticsWhereInput
    orderBy?: ContextQueryAnalyticsOrderByWithAggregationInput | ContextQueryAnalyticsOrderByWithAggregationInput[]
    by: ContextQueryAnalyticsScalarFieldEnum[] | ContextQueryAnalyticsScalarFieldEnum
    having?: ContextQueryAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContextQueryAnalyticsCountAggregateInputType | true
    _min?: ContextQueryAnalyticsMinAggregateInputType
    _max?: ContextQueryAnalyticsMaxAggregateInputType
  }


  export type ContextQueryAnalyticsGroupByOutputType = {
    id: string
    queryId: string | null
    conversationId: string
    queryText: string
    intent: JsonValue
    entities: JsonValue
    filters: JsonValue
    options: JsonValue
    resultMetadata: JsonValue
    createdAt: Date
    _count: ContextQueryAnalyticsCountAggregateOutputType | null
    _min: ContextQueryAnalyticsMinAggregateOutputType | null
    _max: ContextQueryAnalyticsMaxAggregateOutputType | null
  }

  type GetContextQueryAnalyticsGroupByPayload<T extends ContextQueryAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContextQueryAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContextQueryAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContextQueryAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], ContextQueryAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type ContextQueryAnalyticsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryId?: boolean
    conversationId?: boolean
    queryText?: boolean
    intent?: boolean
    entities?: boolean
    filters?: boolean
    options?: boolean
    resultMetadata?: boolean
    createdAt?: boolean
    query?: boolean | ContextQueryAnalytics$queryArgs<ExtArgs>
  }, ExtArgs["result"]["contextQueryAnalytics"]>

  export type ContextQueryAnalyticsSelectScalar = {
    id?: boolean
    queryId?: boolean
    conversationId?: boolean
    queryText?: boolean
    intent?: boolean
    entities?: boolean
    filters?: boolean
    options?: boolean
    resultMetadata?: boolean
    createdAt?: boolean
  }

  export type ContextQueryAnalyticsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    query?: boolean | ContextQueryAnalytics$queryArgs<ExtArgs>
  }


  type ContextQueryAnalyticsGetPayload<S extends boolean | null | undefined | ContextQueryAnalyticsArgs> = $Types.GetResult<ContextQueryAnalyticsPayload, S>

  type ContextQueryAnalyticsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ContextQueryAnalyticsFindManyArgs, 'select' | 'include'> & {
      select?: ContextQueryAnalyticsCountAggregateInputType | true
    }

  export interface ContextQueryAnalyticsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContextQueryAnalytics'], meta: { name: 'ContextQueryAnalytics' } }
    /**
     * Find zero or one ContextQueryAnalytics that matches the filter.
     * @param {ContextQueryAnalyticsFindUniqueArgs} args - Arguments to find a ContextQueryAnalytics
     * @example
     * // Get one ContextQueryAnalytics
     * const contextQueryAnalytics = await prisma.contextQueryAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContextQueryAnalyticsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ContextQueryAnalyticsFindUniqueArgs<ExtArgs>>
    ): Prisma__ContextQueryAnalyticsClient<$Types.GetResult<ContextQueryAnalyticsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ContextQueryAnalytics that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ContextQueryAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a ContextQueryAnalytics
     * @example
     * // Get one ContextQueryAnalytics
     * const contextQueryAnalytics = await prisma.contextQueryAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ContextQueryAnalyticsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextQueryAnalyticsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ContextQueryAnalyticsClient<$Types.GetResult<ContextQueryAnalyticsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ContextQueryAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextQueryAnalyticsFindFirstArgs} args - Arguments to find a ContextQueryAnalytics
     * @example
     * // Get one ContextQueryAnalytics
     * const contextQueryAnalytics = await prisma.contextQueryAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContextQueryAnalyticsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextQueryAnalyticsFindFirstArgs<ExtArgs>>
    ): Prisma__ContextQueryAnalyticsClient<$Types.GetResult<ContextQueryAnalyticsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ContextQueryAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextQueryAnalyticsFindFirstOrThrowArgs} args - Arguments to find a ContextQueryAnalytics
     * @example
     * // Get one ContextQueryAnalytics
     * const contextQueryAnalytics = await prisma.contextQueryAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ContextQueryAnalyticsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextQueryAnalyticsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ContextQueryAnalyticsClient<$Types.GetResult<ContextQueryAnalyticsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ContextQueryAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextQueryAnalyticsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContextQueryAnalytics
     * const contextQueryAnalytics = await prisma.contextQueryAnalytics.findMany()
     * 
     * // Get first 10 ContextQueryAnalytics
     * const contextQueryAnalytics = await prisma.contextQueryAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contextQueryAnalyticsWithIdOnly = await prisma.contextQueryAnalytics.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContextQueryAnalyticsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextQueryAnalyticsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ContextQueryAnalyticsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ContextQueryAnalytics.
     * @param {ContextQueryAnalyticsCreateArgs} args - Arguments to create a ContextQueryAnalytics.
     * @example
     * // Create one ContextQueryAnalytics
     * const ContextQueryAnalytics = await prisma.contextQueryAnalytics.create({
     *   data: {
     *     // ... data to create a ContextQueryAnalytics
     *   }
     * })
     * 
    **/
    create<T extends ContextQueryAnalyticsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ContextQueryAnalyticsCreateArgs<ExtArgs>>
    ): Prisma__ContextQueryAnalyticsClient<$Types.GetResult<ContextQueryAnalyticsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ContextQueryAnalytics.
     *     @param {ContextQueryAnalyticsCreateManyArgs} args - Arguments to create many ContextQueryAnalytics.
     *     @example
     *     // Create many ContextQueryAnalytics
     *     const contextQueryAnalytics = await prisma.contextQueryAnalytics.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContextQueryAnalyticsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextQueryAnalyticsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContextQueryAnalytics.
     * @param {ContextQueryAnalyticsDeleteArgs} args - Arguments to delete one ContextQueryAnalytics.
     * @example
     * // Delete one ContextQueryAnalytics
     * const ContextQueryAnalytics = await prisma.contextQueryAnalytics.delete({
     *   where: {
     *     // ... filter to delete one ContextQueryAnalytics
     *   }
     * })
     * 
    **/
    delete<T extends ContextQueryAnalyticsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ContextQueryAnalyticsDeleteArgs<ExtArgs>>
    ): Prisma__ContextQueryAnalyticsClient<$Types.GetResult<ContextQueryAnalyticsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ContextQueryAnalytics.
     * @param {ContextQueryAnalyticsUpdateArgs} args - Arguments to update one ContextQueryAnalytics.
     * @example
     * // Update one ContextQueryAnalytics
     * const contextQueryAnalytics = await prisma.contextQueryAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContextQueryAnalyticsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ContextQueryAnalyticsUpdateArgs<ExtArgs>>
    ): Prisma__ContextQueryAnalyticsClient<$Types.GetResult<ContextQueryAnalyticsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ContextQueryAnalytics.
     * @param {ContextQueryAnalyticsDeleteManyArgs} args - Arguments to filter ContextQueryAnalytics to delete.
     * @example
     * // Delete a few ContextQueryAnalytics
     * const { count } = await prisma.contextQueryAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContextQueryAnalyticsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextQueryAnalyticsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContextQueryAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextQueryAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContextQueryAnalytics
     * const contextQueryAnalytics = await prisma.contextQueryAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContextQueryAnalyticsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ContextQueryAnalyticsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContextQueryAnalytics.
     * @param {ContextQueryAnalyticsUpsertArgs} args - Arguments to update or create a ContextQueryAnalytics.
     * @example
     * // Update or create a ContextQueryAnalytics
     * const contextQueryAnalytics = await prisma.contextQueryAnalytics.upsert({
     *   create: {
     *     // ... data to create a ContextQueryAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContextQueryAnalytics we want to update
     *   }
     * })
    **/
    upsert<T extends ContextQueryAnalyticsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ContextQueryAnalyticsUpsertArgs<ExtArgs>>
    ): Prisma__ContextQueryAnalyticsClient<$Types.GetResult<ContextQueryAnalyticsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ContextQueryAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextQueryAnalyticsCountArgs} args - Arguments to filter ContextQueryAnalytics to count.
     * @example
     * // Count the number of ContextQueryAnalytics
     * const count = await prisma.contextQueryAnalytics.count({
     *   where: {
     *     // ... the filter for the ContextQueryAnalytics we want to count
     *   }
     * })
    **/
    count<T extends ContextQueryAnalyticsCountArgs>(
      args?: Subset<T, ContextQueryAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContextQueryAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContextQueryAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextQueryAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContextQueryAnalyticsAggregateArgs>(args: Subset<T, ContextQueryAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetContextQueryAnalyticsAggregateType<T>>

    /**
     * Group by ContextQueryAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextQueryAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContextQueryAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContextQueryAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: ContextQueryAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContextQueryAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContextQueryAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContextQueryAnalytics model
   */
  readonly fields: ContextQueryAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContextQueryAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ContextQueryAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    query<T extends ContextQueryAnalytics$queryArgs<ExtArgs> = {}>(args?: Subset<T, ContextQueryAnalytics$queryArgs<ExtArgs>>): Prisma__ContextQueryClient<$Types.GetResult<ContextQueryPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the ContextQueryAnalytics model
   */ 
  interface ContextQueryAnalyticsFieldRefs {
    readonly id: FieldRef<"ContextQueryAnalytics", 'String'>
    readonly queryId: FieldRef<"ContextQueryAnalytics", 'String'>
    readonly conversationId: FieldRef<"ContextQueryAnalytics", 'String'>
    readonly queryText: FieldRef<"ContextQueryAnalytics", 'String'>
    readonly intent: FieldRef<"ContextQueryAnalytics", 'Json'>
    readonly entities: FieldRef<"ContextQueryAnalytics", 'Json'>
    readonly filters: FieldRef<"ContextQueryAnalytics", 'Json'>
    readonly options: FieldRef<"ContextQueryAnalytics", 'Json'>
    readonly resultMetadata: FieldRef<"ContextQueryAnalytics", 'Json'>
    readonly createdAt: FieldRef<"ContextQueryAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ContextQueryAnalytics findUnique
   */
  export type ContextQueryAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextQueryAnalytics
     */
    select?: ContextQueryAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextQueryAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which ContextQueryAnalytics to fetch.
     */
    where: ContextQueryAnalyticsWhereUniqueInput
  }


  /**
   * ContextQueryAnalytics findUniqueOrThrow
   */
  export type ContextQueryAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextQueryAnalytics
     */
    select?: ContextQueryAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextQueryAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which ContextQueryAnalytics to fetch.
     */
    where: ContextQueryAnalyticsWhereUniqueInput
  }


  /**
   * ContextQueryAnalytics findFirst
   */
  export type ContextQueryAnalyticsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextQueryAnalytics
     */
    select?: ContextQueryAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextQueryAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which ContextQueryAnalytics to fetch.
     */
    where?: ContextQueryAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextQueryAnalytics to fetch.
     */
    orderBy?: ContextQueryAnalyticsOrderByWithRelationInput | ContextQueryAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContextQueryAnalytics.
     */
    cursor?: ContextQueryAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextQueryAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextQueryAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContextQueryAnalytics.
     */
    distinct?: ContextQueryAnalyticsScalarFieldEnum | ContextQueryAnalyticsScalarFieldEnum[]
  }


  /**
   * ContextQueryAnalytics findFirstOrThrow
   */
  export type ContextQueryAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextQueryAnalytics
     */
    select?: ContextQueryAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextQueryAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which ContextQueryAnalytics to fetch.
     */
    where?: ContextQueryAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextQueryAnalytics to fetch.
     */
    orderBy?: ContextQueryAnalyticsOrderByWithRelationInput | ContextQueryAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContextQueryAnalytics.
     */
    cursor?: ContextQueryAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextQueryAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextQueryAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContextQueryAnalytics.
     */
    distinct?: ContextQueryAnalyticsScalarFieldEnum | ContextQueryAnalyticsScalarFieldEnum[]
  }


  /**
   * ContextQueryAnalytics findMany
   */
  export type ContextQueryAnalyticsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextQueryAnalytics
     */
    select?: ContextQueryAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextQueryAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which ContextQueryAnalytics to fetch.
     */
    where?: ContextQueryAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextQueryAnalytics to fetch.
     */
    orderBy?: ContextQueryAnalyticsOrderByWithRelationInput | ContextQueryAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContextQueryAnalytics.
     */
    cursor?: ContextQueryAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextQueryAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextQueryAnalytics.
     */
    skip?: number
    distinct?: ContextQueryAnalyticsScalarFieldEnum | ContextQueryAnalyticsScalarFieldEnum[]
  }


  /**
   * ContextQueryAnalytics create
   */
  export type ContextQueryAnalyticsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextQueryAnalytics
     */
    select?: ContextQueryAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextQueryAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a ContextQueryAnalytics.
     */
    data: XOR<ContextQueryAnalyticsCreateInput, ContextQueryAnalyticsUncheckedCreateInput>
  }


  /**
   * ContextQueryAnalytics createMany
   */
  export type ContextQueryAnalyticsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContextQueryAnalytics.
     */
    data: ContextQueryAnalyticsCreateManyInput | ContextQueryAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ContextQueryAnalytics update
   */
  export type ContextQueryAnalyticsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextQueryAnalytics
     */
    select?: ContextQueryAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextQueryAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a ContextQueryAnalytics.
     */
    data: XOR<ContextQueryAnalyticsUpdateInput, ContextQueryAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which ContextQueryAnalytics to update.
     */
    where: ContextQueryAnalyticsWhereUniqueInput
  }


  /**
   * ContextQueryAnalytics updateMany
   */
  export type ContextQueryAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContextQueryAnalytics.
     */
    data: XOR<ContextQueryAnalyticsUpdateManyMutationInput, ContextQueryAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which ContextQueryAnalytics to update
     */
    where?: ContextQueryAnalyticsWhereInput
  }


  /**
   * ContextQueryAnalytics upsert
   */
  export type ContextQueryAnalyticsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextQueryAnalytics
     */
    select?: ContextQueryAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextQueryAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the ContextQueryAnalytics to update in case it exists.
     */
    where: ContextQueryAnalyticsWhereUniqueInput
    /**
     * In case the ContextQueryAnalytics found by the `where` argument doesn't exist, create a new ContextQueryAnalytics with this data.
     */
    create: XOR<ContextQueryAnalyticsCreateInput, ContextQueryAnalyticsUncheckedCreateInput>
    /**
     * In case the ContextQueryAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContextQueryAnalyticsUpdateInput, ContextQueryAnalyticsUncheckedUpdateInput>
  }


  /**
   * ContextQueryAnalytics delete
   */
  export type ContextQueryAnalyticsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextQueryAnalytics
     */
    select?: ContextQueryAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextQueryAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which ContextQueryAnalytics to delete.
     */
    where: ContextQueryAnalyticsWhereUniqueInput
  }


  /**
   * ContextQueryAnalytics deleteMany
   */
  export type ContextQueryAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContextQueryAnalytics to delete
     */
    where?: ContextQueryAnalyticsWhereInput
  }


  /**
   * ContextQueryAnalytics.query
   */
  export type ContextQueryAnalytics$queryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextQuery
     */
    select?: ContextQuerySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextQueryInclude<ExtArgs> | null
    where?: ContextQueryWhereInput
  }


  /**
   * ContextQueryAnalytics without action
   */
  export type ContextQueryAnalyticsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextQueryAnalytics
     */
    select?: ContextQueryAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContextQueryAnalyticsInclude<ExtArgs> | null
  }



  /**
   * Model ContextCache
   */


  export type AggregateContextCache = {
    _count: ContextCacheCountAggregateOutputType | null
    _avg: ContextCacheAvgAggregateOutputType | null
    _sum: ContextCacheSumAggregateOutputType | null
    _min: ContextCacheMinAggregateOutputType | null
    _max: ContextCacheMaxAggregateOutputType | null
  }

  export type ContextCacheAvgAggregateOutputType = {
    hitCount: number | null
  }

  export type ContextCacheSumAggregateOutputType = {
    hitCount: number | null
  }

  export type ContextCacheMinAggregateOutputType = {
    id: string | null
    cacheKey: string | null
    queryText: string | null
    expiresAt: Date | null
    hitCount: number | null
    lastAccessed: Date | null
    createdAt: Date | null
  }

  export type ContextCacheMaxAggregateOutputType = {
    id: string | null
    cacheKey: string | null
    queryText: string | null
    expiresAt: Date | null
    hitCount: number | null
    lastAccessed: Date | null
    createdAt: Date | null
  }

  export type ContextCacheCountAggregateOutputType = {
    id: number
    cacheKey: number
    queryText: number
    result: number
    expiresAt: number
    hitCount: number
    lastAccessed: number
    createdAt: number
    _all: number
  }


  export type ContextCacheAvgAggregateInputType = {
    hitCount?: true
  }

  export type ContextCacheSumAggregateInputType = {
    hitCount?: true
  }

  export type ContextCacheMinAggregateInputType = {
    id?: true
    cacheKey?: true
    queryText?: true
    expiresAt?: true
    hitCount?: true
    lastAccessed?: true
    createdAt?: true
  }

  export type ContextCacheMaxAggregateInputType = {
    id?: true
    cacheKey?: true
    queryText?: true
    expiresAt?: true
    hitCount?: true
    lastAccessed?: true
    createdAt?: true
  }

  export type ContextCacheCountAggregateInputType = {
    id?: true
    cacheKey?: true
    queryText?: true
    result?: true
    expiresAt?: true
    hitCount?: true
    lastAccessed?: true
    createdAt?: true
    _all?: true
  }

  export type ContextCacheAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContextCache to aggregate.
     */
    where?: ContextCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextCaches to fetch.
     */
    orderBy?: ContextCacheOrderByWithRelationInput | ContextCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContextCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextCaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContextCaches
    **/
    _count?: true | ContextCacheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContextCacheAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContextCacheSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContextCacheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContextCacheMaxAggregateInputType
  }

  export type GetContextCacheAggregateType<T extends ContextCacheAggregateArgs> = {
        [P in keyof T & keyof AggregateContextCache]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContextCache[P]>
      : GetScalarType<T[P], AggregateContextCache[P]>
  }




  export type ContextCacheGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ContextCacheWhereInput
    orderBy?: ContextCacheOrderByWithAggregationInput | ContextCacheOrderByWithAggregationInput[]
    by: ContextCacheScalarFieldEnum[] | ContextCacheScalarFieldEnum
    having?: ContextCacheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContextCacheCountAggregateInputType | true
    _avg?: ContextCacheAvgAggregateInputType
    _sum?: ContextCacheSumAggregateInputType
    _min?: ContextCacheMinAggregateInputType
    _max?: ContextCacheMaxAggregateInputType
  }


  export type ContextCacheGroupByOutputType = {
    id: string
    cacheKey: string
    queryText: string
    result: JsonValue
    expiresAt: Date
    hitCount: number
    lastAccessed: Date
    createdAt: Date
    _count: ContextCacheCountAggregateOutputType | null
    _avg: ContextCacheAvgAggregateOutputType | null
    _sum: ContextCacheSumAggregateOutputType | null
    _min: ContextCacheMinAggregateOutputType | null
    _max: ContextCacheMaxAggregateOutputType | null
  }

  type GetContextCacheGroupByPayload<T extends ContextCacheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContextCacheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContextCacheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContextCacheGroupByOutputType[P]>
            : GetScalarType<T[P], ContextCacheGroupByOutputType[P]>
        }
      >
    >


  export type ContextCacheSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cacheKey?: boolean
    queryText?: boolean
    result?: boolean
    expiresAt?: boolean
    hitCount?: boolean
    lastAccessed?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contextCache"]>

  export type ContextCacheSelectScalar = {
    id?: boolean
    cacheKey?: boolean
    queryText?: boolean
    result?: boolean
    expiresAt?: boolean
    hitCount?: boolean
    lastAccessed?: boolean
    createdAt?: boolean
  }


  type ContextCacheGetPayload<S extends boolean | null | undefined | ContextCacheArgs> = $Types.GetResult<ContextCachePayload, S>

  type ContextCacheCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ContextCacheFindManyArgs, 'select' | 'include'> & {
      select?: ContextCacheCountAggregateInputType | true
    }

  export interface ContextCacheDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContextCache'], meta: { name: 'ContextCache' } }
    /**
     * Find zero or one ContextCache that matches the filter.
     * @param {ContextCacheFindUniqueArgs} args - Arguments to find a ContextCache
     * @example
     * // Get one ContextCache
     * const contextCache = await prisma.contextCache.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContextCacheFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ContextCacheFindUniqueArgs<ExtArgs>>
    ): Prisma__ContextCacheClient<$Types.GetResult<ContextCachePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ContextCache that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ContextCacheFindUniqueOrThrowArgs} args - Arguments to find a ContextCache
     * @example
     * // Get one ContextCache
     * const contextCache = await prisma.contextCache.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ContextCacheFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextCacheFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ContextCacheClient<$Types.GetResult<ContextCachePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ContextCache that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextCacheFindFirstArgs} args - Arguments to find a ContextCache
     * @example
     * // Get one ContextCache
     * const contextCache = await prisma.contextCache.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContextCacheFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextCacheFindFirstArgs<ExtArgs>>
    ): Prisma__ContextCacheClient<$Types.GetResult<ContextCachePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ContextCache that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextCacheFindFirstOrThrowArgs} args - Arguments to find a ContextCache
     * @example
     * // Get one ContextCache
     * const contextCache = await prisma.contextCache.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ContextCacheFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextCacheFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ContextCacheClient<$Types.GetResult<ContextCachePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ContextCaches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextCacheFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContextCaches
     * const contextCaches = await prisma.contextCache.findMany()
     * 
     * // Get first 10 ContextCaches
     * const contextCaches = await prisma.contextCache.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contextCacheWithIdOnly = await prisma.contextCache.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContextCacheFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextCacheFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ContextCachePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ContextCache.
     * @param {ContextCacheCreateArgs} args - Arguments to create a ContextCache.
     * @example
     * // Create one ContextCache
     * const ContextCache = await prisma.contextCache.create({
     *   data: {
     *     // ... data to create a ContextCache
     *   }
     * })
     * 
    **/
    create<T extends ContextCacheCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ContextCacheCreateArgs<ExtArgs>>
    ): Prisma__ContextCacheClient<$Types.GetResult<ContextCachePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ContextCaches.
     *     @param {ContextCacheCreateManyArgs} args - Arguments to create many ContextCaches.
     *     @example
     *     // Create many ContextCaches
     *     const contextCache = await prisma.contextCache.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContextCacheCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextCacheCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContextCache.
     * @param {ContextCacheDeleteArgs} args - Arguments to delete one ContextCache.
     * @example
     * // Delete one ContextCache
     * const ContextCache = await prisma.contextCache.delete({
     *   where: {
     *     // ... filter to delete one ContextCache
     *   }
     * })
     * 
    **/
    delete<T extends ContextCacheDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ContextCacheDeleteArgs<ExtArgs>>
    ): Prisma__ContextCacheClient<$Types.GetResult<ContextCachePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ContextCache.
     * @param {ContextCacheUpdateArgs} args - Arguments to update one ContextCache.
     * @example
     * // Update one ContextCache
     * const contextCache = await prisma.contextCache.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContextCacheUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ContextCacheUpdateArgs<ExtArgs>>
    ): Prisma__ContextCacheClient<$Types.GetResult<ContextCachePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ContextCaches.
     * @param {ContextCacheDeleteManyArgs} args - Arguments to filter ContextCaches to delete.
     * @example
     * // Delete a few ContextCaches
     * const { count } = await prisma.contextCache.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContextCacheDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContextCacheDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContextCaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextCacheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContextCaches
     * const contextCache = await prisma.contextCache.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContextCacheUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ContextCacheUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContextCache.
     * @param {ContextCacheUpsertArgs} args - Arguments to update or create a ContextCache.
     * @example
     * // Update or create a ContextCache
     * const contextCache = await prisma.contextCache.upsert({
     *   create: {
     *     // ... data to create a ContextCache
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContextCache we want to update
     *   }
     * })
    **/
    upsert<T extends ContextCacheUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ContextCacheUpsertArgs<ExtArgs>>
    ): Prisma__ContextCacheClient<$Types.GetResult<ContextCachePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ContextCaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextCacheCountArgs} args - Arguments to filter ContextCaches to count.
     * @example
     * // Count the number of ContextCaches
     * const count = await prisma.contextCache.count({
     *   where: {
     *     // ... the filter for the ContextCaches we want to count
     *   }
     * })
    **/
    count<T extends ContextCacheCountArgs>(
      args?: Subset<T, ContextCacheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContextCacheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContextCache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextCacheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContextCacheAggregateArgs>(args: Subset<T, ContextCacheAggregateArgs>): Prisma.PrismaPromise<GetContextCacheAggregateType<T>>

    /**
     * Group by ContextCache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContextCacheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContextCacheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContextCacheGroupByArgs['orderBy'] }
        : { orderBy?: ContextCacheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContextCacheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContextCacheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContextCache model
   */
  readonly fields: ContextCacheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContextCache.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ContextCacheClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the ContextCache model
   */ 
  interface ContextCacheFieldRefs {
    readonly id: FieldRef<"ContextCache", 'String'>
    readonly cacheKey: FieldRef<"ContextCache", 'String'>
    readonly queryText: FieldRef<"ContextCache", 'String'>
    readonly result: FieldRef<"ContextCache", 'Json'>
    readonly expiresAt: FieldRef<"ContextCache", 'DateTime'>
    readonly hitCount: FieldRef<"ContextCache", 'Int'>
    readonly lastAccessed: FieldRef<"ContextCache", 'DateTime'>
    readonly createdAt: FieldRef<"ContextCache", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * ContextCache findUnique
   */
  export type ContextCacheFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextCache
     */
    select?: ContextCacheSelect<ExtArgs> | null
    /**
     * Filter, which ContextCache to fetch.
     */
    where: ContextCacheWhereUniqueInput
  }


  /**
   * ContextCache findUniqueOrThrow
   */
  export type ContextCacheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextCache
     */
    select?: ContextCacheSelect<ExtArgs> | null
    /**
     * Filter, which ContextCache to fetch.
     */
    where: ContextCacheWhereUniqueInput
  }


  /**
   * ContextCache findFirst
   */
  export type ContextCacheFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextCache
     */
    select?: ContextCacheSelect<ExtArgs> | null
    /**
     * Filter, which ContextCache to fetch.
     */
    where?: ContextCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextCaches to fetch.
     */
    orderBy?: ContextCacheOrderByWithRelationInput | ContextCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContextCaches.
     */
    cursor?: ContextCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextCaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContextCaches.
     */
    distinct?: ContextCacheScalarFieldEnum | ContextCacheScalarFieldEnum[]
  }


  /**
   * ContextCache findFirstOrThrow
   */
  export type ContextCacheFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextCache
     */
    select?: ContextCacheSelect<ExtArgs> | null
    /**
     * Filter, which ContextCache to fetch.
     */
    where?: ContextCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextCaches to fetch.
     */
    orderBy?: ContextCacheOrderByWithRelationInput | ContextCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContextCaches.
     */
    cursor?: ContextCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextCaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContextCaches.
     */
    distinct?: ContextCacheScalarFieldEnum | ContextCacheScalarFieldEnum[]
  }


  /**
   * ContextCache findMany
   */
  export type ContextCacheFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextCache
     */
    select?: ContextCacheSelect<ExtArgs> | null
    /**
     * Filter, which ContextCaches to fetch.
     */
    where?: ContextCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContextCaches to fetch.
     */
    orderBy?: ContextCacheOrderByWithRelationInput | ContextCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContextCaches.
     */
    cursor?: ContextCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContextCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContextCaches.
     */
    skip?: number
    distinct?: ContextCacheScalarFieldEnum | ContextCacheScalarFieldEnum[]
  }


  /**
   * ContextCache create
   */
  export type ContextCacheCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextCache
     */
    select?: ContextCacheSelect<ExtArgs> | null
    /**
     * The data needed to create a ContextCache.
     */
    data: XOR<ContextCacheCreateInput, ContextCacheUncheckedCreateInput>
  }


  /**
   * ContextCache createMany
   */
  export type ContextCacheCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContextCaches.
     */
    data: ContextCacheCreateManyInput | ContextCacheCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ContextCache update
   */
  export type ContextCacheUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextCache
     */
    select?: ContextCacheSelect<ExtArgs> | null
    /**
     * The data needed to update a ContextCache.
     */
    data: XOR<ContextCacheUpdateInput, ContextCacheUncheckedUpdateInput>
    /**
     * Choose, which ContextCache to update.
     */
    where: ContextCacheWhereUniqueInput
  }


  /**
   * ContextCache updateMany
   */
  export type ContextCacheUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContextCaches.
     */
    data: XOR<ContextCacheUpdateManyMutationInput, ContextCacheUncheckedUpdateManyInput>
    /**
     * Filter which ContextCaches to update
     */
    where?: ContextCacheWhereInput
  }


  /**
   * ContextCache upsert
   */
  export type ContextCacheUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextCache
     */
    select?: ContextCacheSelect<ExtArgs> | null
    /**
     * The filter to search for the ContextCache to update in case it exists.
     */
    where: ContextCacheWhereUniqueInput
    /**
     * In case the ContextCache found by the `where` argument doesn't exist, create a new ContextCache with this data.
     */
    create: XOR<ContextCacheCreateInput, ContextCacheUncheckedCreateInput>
    /**
     * In case the ContextCache was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContextCacheUpdateInput, ContextCacheUncheckedUpdateInput>
  }


  /**
   * ContextCache delete
   */
  export type ContextCacheDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextCache
     */
    select?: ContextCacheSelect<ExtArgs> | null
    /**
     * Filter which ContextCache to delete.
     */
    where: ContextCacheWhereUniqueInput
  }


  /**
   * ContextCache deleteMany
   */
  export type ContextCacheDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContextCaches to delete
     */
    where?: ContextCacheWhereInput
  }


  /**
   * ContextCache without action
   */
  export type ContextCacheArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContextCache
     */
    select?: ContextCacheSelect<ExtArgs> | null
  }



  /**
   * Model UserPreferences
   */


  export type AggregateUserPreferences = {
    _count: UserPreferencesCountAggregateOutputType | null
    _min: UserPreferencesMinAggregateOutputType | null
    _max: UserPreferencesMaxAggregateOutputType | null
  }

  export type UserPreferencesMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPreferencesMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPreferencesCountAggregateOutputType = {
    id: number
    userId: number
    preferences: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserPreferencesMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPreferencesMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPreferencesCountAggregateInputType = {
    id?: true
    userId?: true
    preferences?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserPreferencesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferences to aggregate.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPreferences
    **/
    _count?: true | UserPreferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPreferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPreferencesMaxAggregateInputType
  }

  export type GetUserPreferencesAggregateType<T extends UserPreferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPreferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPreferences[P]>
      : GetScalarType<T[P], AggregateUserPreferences[P]>
  }




  export type UserPreferencesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserPreferencesWhereInput
    orderBy?: UserPreferencesOrderByWithAggregationInput | UserPreferencesOrderByWithAggregationInput[]
    by: UserPreferencesScalarFieldEnum[] | UserPreferencesScalarFieldEnum
    having?: UserPreferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPreferencesCountAggregateInputType | true
    _min?: UserPreferencesMinAggregateInputType
    _max?: UserPreferencesMaxAggregateInputType
  }


  export type UserPreferencesGroupByOutputType = {
    id: string
    userId: string
    preferences: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: UserPreferencesCountAggregateOutputType | null
    _min: UserPreferencesMinAggregateOutputType | null
    _max: UserPreferencesMaxAggregateOutputType | null
  }

  type GetUserPreferencesGroupByPayload<T extends UserPreferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPreferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPreferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPreferencesGroupByOutputType[P]>
            : GetScalarType<T[P], UserPreferencesGroupByOutputType[P]>
        }
      >
    >


  export type UserPreferencesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserPreferences$userArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectScalar = {
    id?: boolean
    userId?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserPreferencesInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserPreferences$userArgs<ExtArgs>
  }


  type UserPreferencesGetPayload<S extends boolean | null | undefined | UserPreferencesArgs> = $Types.GetResult<UserPreferencesPayload, S>

  type UserPreferencesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserPreferencesFindManyArgs, 'select' | 'include'> & {
      select?: UserPreferencesCountAggregateInputType | true
    }

  export interface UserPreferencesDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPreferences'], meta: { name: 'UserPreferences' } }
    /**
     * Find zero or one UserPreferences that matches the filter.
     * @param {UserPreferencesFindUniqueArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserPreferencesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserPreferencesFindUniqueArgs<ExtArgs>>
    ): Prisma__UserPreferencesClient<$Types.GetResult<UserPreferencesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserPreferences that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserPreferencesFindUniqueOrThrowArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserPreferencesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPreferencesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserPreferencesClient<$Types.GetResult<UserPreferencesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindFirstArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserPreferencesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPreferencesFindFirstArgs<ExtArgs>>
    ): Prisma__UserPreferencesClient<$Types.GetResult<UserPreferencesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserPreferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindFirstOrThrowArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserPreferencesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPreferencesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserPreferencesClient<$Types.GetResult<UserPreferencesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPreferences
     * const userPreferences = await prisma.userPreferences.findMany()
     * 
     * // Get first 10 UserPreferences
     * const userPreferences = await prisma.userPreferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserPreferencesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPreferencesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserPreferencesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserPreferences.
     * @param {UserPreferencesCreateArgs} args - Arguments to create a UserPreferences.
     * @example
     * // Create one UserPreferences
     * const UserPreferences = await prisma.userPreferences.create({
     *   data: {
     *     // ... data to create a UserPreferences
     *   }
     * })
     * 
    **/
    create<T extends UserPreferencesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserPreferencesCreateArgs<ExtArgs>>
    ): Prisma__UserPreferencesClient<$Types.GetResult<UserPreferencesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserPreferences.
     *     @param {UserPreferencesCreateManyArgs} args - Arguments to create many UserPreferences.
     *     @example
     *     // Create many UserPreferences
     *     const userPreferences = await prisma.userPreferences.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserPreferencesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPreferencesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserPreferences.
     * @param {UserPreferencesDeleteArgs} args - Arguments to delete one UserPreferences.
     * @example
     * // Delete one UserPreferences
     * const UserPreferences = await prisma.userPreferences.delete({
     *   where: {
     *     // ... filter to delete one UserPreferences
     *   }
     * })
     * 
    **/
    delete<T extends UserPreferencesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserPreferencesDeleteArgs<ExtArgs>>
    ): Prisma__UserPreferencesClient<$Types.GetResult<UserPreferencesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserPreferences.
     * @param {UserPreferencesUpdateArgs} args - Arguments to update one UserPreferences.
     * @example
     * // Update one UserPreferences
     * const userPreferences = await prisma.userPreferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserPreferencesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserPreferencesUpdateArgs<ExtArgs>>
    ): Prisma__UserPreferencesClient<$Types.GetResult<UserPreferencesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserPreferences.
     * @param {UserPreferencesDeleteManyArgs} args - Arguments to filter UserPreferences to delete.
     * @example
     * // Delete a few UserPreferences
     * const { count } = await prisma.userPreferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserPreferencesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserPreferencesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPreferences
     * const userPreferences = await prisma.userPreferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserPreferencesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserPreferencesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserPreferences.
     * @param {UserPreferencesUpsertArgs} args - Arguments to update or create a UserPreferences.
     * @example
     * // Update or create a UserPreferences
     * const userPreferences = await prisma.userPreferences.upsert({
     *   create: {
     *     // ... data to create a UserPreferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPreferences we want to update
     *   }
     * })
    **/
    upsert<T extends UserPreferencesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserPreferencesUpsertArgs<ExtArgs>>
    ): Prisma__UserPreferencesClient<$Types.GetResult<UserPreferencesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesCountArgs} args - Arguments to filter UserPreferences to count.
     * @example
     * // Count the number of UserPreferences
     * const count = await prisma.userPreferences.count({
     *   where: {
     *     // ... the filter for the UserPreferences we want to count
     *   }
     * })
    **/
    count<T extends UserPreferencesCountArgs>(
      args?: Subset<T, UserPreferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPreferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPreferencesAggregateArgs>(args: Subset<T, UserPreferencesAggregateArgs>): Prisma.PrismaPromise<GetUserPreferencesAggregateType<T>>

    /**
     * Group by UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPreferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPreferencesGroupByArgs['orderBy'] }
        : { orderBy?: UserPreferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPreferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPreferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPreferences model
   */
  readonly fields: UserPreferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPreferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserPreferencesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserPreferences$userArgs<ExtArgs> = {}>(args?: Subset<T, UserPreferences$userArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the UserPreferences model
   */ 
  interface UserPreferencesFieldRefs {
    readonly id: FieldRef<"UserPreferences", 'String'>
    readonly userId: FieldRef<"UserPreferences", 'String'>
    readonly preferences: FieldRef<"UserPreferences", 'Json'>
    readonly createdAt: FieldRef<"UserPreferences", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPreferences", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * UserPreferences findUnique
   */
  export type UserPreferencesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where: UserPreferencesWhereUniqueInput
  }


  /**
   * UserPreferences findUniqueOrThrow
   */
  export type UserPreferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where: UserPreferencesWhereUniqueInput
  }


  /**
   * UserPreferences findFirst
   */
  export type UserPreferencesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }


  /**
   * UserPreferences findFirstOrThrow
   */
  export type UserPreferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }


  /**
   * UserPreferences findMany
   */
  export type UserPreferencesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }


  /**
   * UserPreferences create
   */
  export type UserPreferencesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPreferences.
     */
    data: XOR<UserPreferencesCreateInput, UserPreferencesUncheckedCreateInput>
  }


  /**
   * UserPreferences createMany
   */
  export type UserPreferencesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferencesCreateManyInput | UserPreferencesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UserPreferences update
   */
  export type UserPreferencesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPreferences.
     */
    data: XOR<UserPreferencesUpdateInput, UserPreferencesUncheckedUpdateInput>
    /**
     * Choose, which UserPreferences to update.
     */
    where: UserPreferencesWhereUniqueInput
  }


  /**
   * UserPreferences updateMany
   */
  export type UserPreferencesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferencesUpdateManyMutationInput, UserPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferencesWhereInput
  }


  /**
   * UserPreferences upsert
   */
  export type UserPreferencesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPreferences to update in case it exists.
     */
    where: UserPreferencesWhereUniqueInput
    /**
     * In case the UserPreferences found by the `where` argument doesn't exist, create a new UserPreferences with this data.
     */
    create: XOR<UserPreferencesCreateInput, UserPreferencesUncheckedCreateInput>
    /**
     * In case the UserPreferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPreferencesUpdateInput, UserPreferencesUncheckedUpdateInput>
  }


  /**
   * UserPreferences delete
   */
  export type UserPreferencesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter which UserPreferences to delete.
     */
    where: UserPreferencesWhereUniqueInput
  }


  /**
   * UserPreferences deleteMany
   */
  export type UserPreferencesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferences to delete
     */
    where?: UserPreferencesWhereInput
  }


  /**
   * UserPreferences.user
   */
  export type UserPreferences$userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * UserPreferences without action
   */
  export type UserPreferencesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserPreferencesInclude<ExtArgs> | null
  }



  /**
   * Model Theme
   */


  export type AggregateTheme = {
    _count: ThemeCountAggregateOutputType | null
    _min: ThemeMinAggregateOutputType | null
    _max: ThemeMaxAggregateOutputType | null
  }

  export type ThemeMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    custom: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ThemeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    custom: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ThemeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    colors: number
    typography: number
    spacing: number
    shadows: number
    borderRadius: number
    animations: number
    custom: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ThemeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    custom?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ThemeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    custom?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ThemeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    colors?: true
    typography?: true
    spacing?: true
    shadows?: true
    borderRadius?: true
    animations?: true
    custom?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ThemeAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Theme to aggregate.
     */
    where?: ThemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Themes to fetch.
     */
    orderBy?: ThemeOrderByWithRelationInput | ThemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ThemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Themes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Themes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Themes
    **/
    _count?: true | ThemeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThemeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThemeMaxAggregateInputType
  }

  export type GetThemeAggregateType<T extends ThemeAggregateArgs> = {
        [P in keyof T & keyof AggregateTheme]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTheme[P]>
      : GetScalarType<T[P], AggregateTheme[P]>
  }




  export type ThemeGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ThemeWhereInput
    orderBy?: ThemeOrderByWithAggregationInput | ThemeOrderByWithAggregationInput[]
    by: ThemeScalarFieldEnum[] | ThemeScalarFieldEnum
    having?: ThemeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThemeCountAggregateInputType | true
    _min?: ThemeMinAggregateInputType
    _max?: ThemeMaxAggregateInputType
  }


  export type ThemeGroupByOutputType = {
    id: string
    name: string
    description: string | null
    category: string
    colors: JsonValue
    typography: JsonValue
    spacing: JsonValue
    shadows: JsonValue
    borderRadius: JsonValue
    animations: JsonValue
    custom: boolean
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: ThemeCountAggregateOutputType | null
    _min: ThemeMinAggregateOutputType | null
    _max: ThemeMaxAggregateOutputType | null
  }

  type GetThemeGroupByPayload<T extends ThemeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ThemeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThemeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThemeGroupByOutputType[P]>
            : GetScalarType<T[P], ThemeGroupByOutputType[P]>
        }
      >
    >


  export type ThemeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    colors?: boolean
    typography?: boolean
    spacing?: boolean
    shadows?: boolean
    borderRadius?: boolean
    animations?: boolean
    custom?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | Theme$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["theme"]>

  export type ThemeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    colors?: boolean
    typography?: boolean
    spacing?: boolean
    shadows?: boolean
    borderRadius?: boolean
    animations?: boolean
    custom?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ThemeInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    creator?: boolean | Theme$creatorArgs<ExtArgs>
  }


  type ThemeGetPayload<S extends boolean | null | undefined | ThemeArgs> = $Types.GetResult<ThemePayload, S>

  type ThemeCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ThemeFindManyArgs, 'select' | 'include'> & {
      select?: ThemeCountAggregateInputType | true
    }

  export interface ThemeDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Theme'], meta: { name: 'Theme' } }
    /**
     * Find zero or one Theme that matches the filter.
     * @param {ThemeFindUniqueArgs} args - Arguments to find a Theme
     * @example
     * // Get one Theme
     * const theme = await prisma.theme.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ThemeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ThemeFindUniqueArgs<ExtArgs>>
    ): Prisma__ThemeClient<$Types.GetResult<ThemePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Theme that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ThemeFindUniqueOrThrowArgs} args - Arguments to find a Theme
     * @example
     * // Get one Theme
     * const theme = await prisma.theme.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ThemeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ThemeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ThemeClient<$Types.GetResult<ThemePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Theme that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeFindFirstArgs} args - Arguments to find a Theme
     * @example
     * // Get one Theme
     * const theme = await prisma.theme.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ThemeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ThemeFindFirstArgs<ExtArgs>>
    ): Prisma__ThemeClient<$Types.GetResult<ThemePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Theme that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeFindFirstOrThrowArgs} args - Arguments to find a Theme
     * @example
     * // Get one Theme
     * const theme = await prisma.theme.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ThemeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ThemeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ThemeClient<$Types.GetResult<ThemePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Themes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Themes
     * const themes = await prisma.theme.findMany()
     * 
     * // Get first 10 Themes
     * const themes = await prisma.theme.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const themeWithIdOnly = await prisma.theme.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ThemeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ThemeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ThemePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Theme.
     * @param {ThemeCreateArgs} args - Arguments to create a Theme.
     * @example
     * // Create one Theme
     * const Theme = await prisma.theme.create({
     *   data: {
     *     // ... data to create a Theme
     *   }
     * })
     * 
    **/
    create<T extends ThemeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ThemeCreateArgs<ExtArgs>>
    ): Prisma__ThemeClient<$Types.GetResult<ThemePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Themes.
     *     @param {ThemeCreateManyArgs} args - Arguments to create many Themes.
     *     @example
     *     // Create many Themes
     *     const theme = await prisma.theme.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ThemeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ThemeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Theme.
     * @param {ThemeDeleteArgs} args - Arguments to delete one Theme.
     * @example
     * // Delete one Theme
     * const Theme = await prisma.theme.delete({
     *   where: {
     *     // ... filter to delete one Theme
     *   }
     * })
     * 
    **/
    delete<T extends ThemeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ThemeDeleteArgs<ExtArgs>>
    ): Prisma__ThemeClient<$Types.GetResult<ThemePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Theme.
     * @param {ThemeUpdateArgs} args - Arguments to update one Theme.
     * @example
     * // Update one Theme
     * const theme = await prisma.theme.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ThemeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ThemeUpdateArgs<ExtArgs>>
    ): Prisma__ThemeClient<$Types.GetResult<ThemePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Themes.
     * @param {ThemeDeleteManyArgs} args - Arguments to filter Themes to delete.
     * @example
     * // Delete a few Themes
     * const { count } = await prisma.theme.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ThemeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ThemeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Themes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Themes
     * const theme = await prisma.theme.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ThemeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ThemeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Theme.
     * @param {ThemeUpsertArgs} args - Arguments to update or create a Theme.
     * @example
     * // Update or create a Theme
     * const theme = await prisma.theme.upsert({
     *   create: {
     *     // ... data to create a Theme
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Theme we want to update
     *   }
     * })
    **/
    upsert<T extends ThemeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ThemeUpsertArgs<ExtArgs>>
    ): Prisma__ThemeClient<$Types.GetResult<ThemePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Themes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeCountArgs} args - Arguments to filter Themes to count.
     * @example
     * // Count the number of Themes
     * const count = await prisma.theme.count({
     *   where: {
     *     // ... the filter for the Themes we want to count
     *   }
     * })
    **/
    count<T extends ThemeCountArgs>(
      args?: Subset<T, ThemeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThemeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Theme.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThemeAggregateArgs>(args: Subset<T, ThemeAggregateArgs>): Prisma.PrismaPromise<GetThemeAggregateType<T>>

    /**
     * Group by Theme.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ThemeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThemeGroupByArgs['orderBy'] }
        : { orderBy?: ThemeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ThemeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThemeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Theme model
   */
  readonly fields: ThemeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Theme.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ThemeClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    creator<T extends Theme$creatorArgs<ExtArgs> = {}>(args?: Subset<T, Theme$creatorArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the Theme model
   */ 
  interface ThemeFieldRefs {
    readonly id: FieldRef<"Theme", 'String'>
    readonly name: FieldRef<"Theme", 'String'>
    readonly description: FieldRef<"Theme", 'String'>
    readonly category: FieldRef<"Theme", 'String'>
    readonly colors: FieldRef<"Theme", 'Json'>
    readonly typography: FieldRef<"Theme", 'Json'>
    readonly spacing: FieldRef<"Theme", 'Json'>
    readonly shadows: FieldRef<"Theme", 'Json'>
    readonly borderRadius: FieldRef<"Theme", 'Json'>
    readonly animations: FieldRef<"Theme", 'Json'>
    readonly custom: FieldRef<"Theme", 'Boolean'>
    readonly createdBy: FieldRef<"Theme", 'String'>
    readonly createdAt: FieldRef<"Theme", 'DateTime'>
    readonly updatedAt: FieldRef<"Theme", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Theme findUnique
   */
  export type ThemeFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * Filter, which Theme to fetch.
     */
    where: ThemeWhereUniqueInput
  }


  /**
   * Theme findUniqueOrThrow
   */
  export type ThemeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * Filter, which Theme to fetch.
     */
    where: ThemeWhereUniqueInput
  }


  /**
   * Theme findFirst
   */
  export type ThemeFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * Filter, which Theme to fetch.
     */
    where?: ThemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Themes to fetch.
     */
    orderBy?: ThemeOrderByWithRelationInput | ThemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Themes.
     */
    cursor?: ThemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Themes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Themes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Themes.
     */
    distinct?: ThemeScalarFieldEnum | ThemeScalarFieldEnum[]
  }


  /**
   * Theme findFirstOrThrow
   */
  export type ThemeFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * Filter, which Theme to fetch.
     */
    where?: ThemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Themes to fetch.
     */
    orderBy?: ThemeOrderByWithRelationInput | ThemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Themes.
     */
    cursor?: ThemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Themes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Themes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Themes.
     */
    distinct?: ThemeScalarFieldEnum | ThemeScalarFieldEnum[]
  }


  /**
   * Theme findMany
   */
  export type ThemeFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * Filter, which Themes to fetch.
     */
    where?: ThemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Themes to fetch.
     */
    orderBy?: ThemeOrderByWithRelationInput | ThemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Themes.
     */
    cursor?: ThemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Themes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Themes.
     */
    skip?: number
    distinct?: ThemeScalarFieldEnum | ThemeScalarFieldEnum[]
  }


  /**
   * Theme create
   */
  export type ThemeCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * The data needed to create a Theme.
     */
    data: XOR<ThemeCreateInput, ThemeUncheckedCreateInput>
  }


  /**
   * Theme createMany
   */
  export type ThemeCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Themes.
     */
    data: ThemeCreateManyInput | ThemeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Theme update
   */
  export type ThemeUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * The data needed to update a Theme.
     */
    data: XOR<ThemeUpdateInput, ThemeUncheckedUpdateInput>
    /**
     * Choose, which Theme to update.
     */
    where: ThemeWhereUniqueInput
  }


  /**
   * Theme updateMany
   */
  export type ThemeUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Themes.
     */
    data: XOR<ThemeUpdateManyMutationInput, ThemeUncheckedUpdateManyInput>
    /**
     * Filter which Themes to update
     */
    where?: ThemeWhereInput
  }


  /**
   * Theme upsert
   */
  export type ThemeUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * The filter to search for the Theme to update in case it exists.
     */
    where: ThemeWhereUniqueInput
    /**
     * In case the Theme found by the `where` argument doesn't exist, create a new Theme with this data.
     */
    create: XOR<ThemeCreateInput, ThemeUncheckedCreateInput>
    /**
     * In case the Theme was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThemeUpdateInput, ThemeUncheckedUpdateInput>
  }


  /**
   * Theme delete
   */
  export type ThemeDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * Filter which Theme to delete.
     */
    where: ThemeWhereUniqueInput
  }


  /**
   * Theme deleteMany
   */
  export type ThemeDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Themes to delete
     */
    where?: ThemeWhereInput
  }


  /**
   * Theme.creator
   */
  export type Theme$creatorArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Theme without action
   */
  export type ThemeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThemeInclude<ExtArgs> | null
  }



  /**
   * Model PersonalizationAnalytics
   */


  export type AggregatePersonalizationAnalytics = {
    _count: PersonalizationAnalyticsCountAggregateOutputType | null
    _min: PersonalizationAnalyticsMinAggregateOutputType | null
    _max: PersonalizationAnalyticsMaxAggregateOutputType | null
  }

  export type PersonalizationAnalyticsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    actionType: string | null
    createdAt: Date | null
  }

  export type PersonalizationAnalyticsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    actionType: string | null
    createdAt: Date | null
  }

  export type PersonalizationAnalyticsCountAggregateOutputType = {
    id: number
    userId: number
    actionType: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type PersonalizationAnalyticsMinAggregateInputType = {
    id?: true
    userId?: true
    actionType?: true
    createdAt?: true
  }

  export type PersonalizationAnalyticsMaxAggregateInputType = {
    id?: true
    userId?: true
    actionType?: true
    createdAt?: true
  }

  export type PersonalizationAnalyticsCountAggregateInputType = {
    id?: true
    userId?: true
    actionType?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type PersonalizationAnalyticsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonalizationAnalytics to aggregate.
     */
    where?: PersonalizationAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalizationAnalytics to fetch.
     */
    orderBy?: PersonalizationAnalyticsOrderByWithRelationInput | PersonalizationAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonalizationAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalizationAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalizationAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonalizationAnalytics
    **/
    _count?: true | PersonalizationAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonalizationAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonalizationAnalyticsMaxAggregateInputType
  }

  export type GetPersonalizationAnalyticsAggregateType<T extends PersonalizationAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonalizationAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonalizationAnalytics[P]>
      : GetScalarType<T[P], AggregatePersonalizationAnalytics[P]>
  }




  export type PersonalizationAnalyticsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PersonalizationAnalyticsWhereInput
    orderBy?: PersonalizationAnalyticsOrderByWithAggregationInput | PersonalizationAnalyticsOrderByWithAggregationInput[]
    by: PersonalizationAnalyticsScalarFieldEnum[] | PersonalizationAnalyticsScalarFieldEnum
    having?: PersonalizationAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonalizationAnalyticsCountAggregateInputType | true
    _min?: PersonalizationAnalyticsMinAggregateInputType
    _max?: PersonalizationAnalyticsMaxAggregateInputType
  }


  export type PersonalizationAnalyticsGroupByOutputType = {
    id: string
    userId: string
    actionType: string
    metadata: JsonValue
    createdAt: Date
    _count: PersonalizationAnalyticsCountAggregateOutputType | null
    _min: PersonalizationAnalyticsMinAggregateOutputType | null
    _max: PersonalizationAnalyticsMaxAggregateOutputType | null
  }

  type GetPersonalizationAnalyticsGroupByPayload<T extends PersonalizationAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonalizationAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonalizationAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonalizationAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], PersonalizationAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type PersonalizationAnalyticsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    actionType?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["personalizationAnalytics"]>

  export type PersonalizationAnalyticsSelectScalar = {
    id?: boolean
    userId?: boolean
    actionType?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type PersonalizationAnalyticsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type PersonalizationAnalyticsGetPayload<S extends boolean | null | undefined | PersonalizationAnalyticsArgs> = $Types.GetResult<PersonalizationAnalyticsPayload, S>

  type PersonalizationAnalyticsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PersonalizationAnalyticsFindManyArgs, 'select' | 'include'> & {
      select?: PersonalizationAnalyticsCountAggregateInputType | true
    }

  export interface PersonalizationAnalyticsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonalizationAnalytics'], meta: { name: 'PersonalizationAnalytics' } }
    /**
     * Find zero or one PersonalizationAnalytics that matches the filter.
     * @param {PersonalizationAnalyticsFindUniqueArgs} args - Arguments to find a PersonalizationAnalytics
     * @example
     * // Get one PersonalizationAnalytics
     * const personalizationAnalytics = await prisma.personalizationAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PersonalizationAnalyticsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PersonalizationAnalyticsFindUniqueArgs<ExtArgs>>
    ): Prisma__PersonalizationAnalyticsClient<$Types.GetResult<PersonalizationAnalyticsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one PersonalizationAnalytics that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PersonalizationAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a PersonalizationAnalytics
     * @example
     * // Get one PersonalizationAnalytics
     * const personalizationAnalytics = await prisma.personalizationAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PersonalizationAnalyticsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PersonalizationAnalyticsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PersonalizationAnalyticsClient<$Types.GetResult<PersonalizationAnalyticsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first PersonalizationAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalizationAnalyticsFindFirstArgs} args - Arguments to find a PersonalizationAnalytics
     * @example
     * // Get one PersonalizationAnalytics
     * const personalizationAnalytics = await prisma.personalizationAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PersonalizationAnalyticsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PersonalizationAnalyticsFindFirstArgs<ExtArgs>>
    ): Prisma__PersonalizationAnalyticsClient<$Types.GetResult<PersonalizationAnalyticsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first PersonalizationAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalizationAnalyticsFindFirstOrThrowArgs} args - Arguments to find a PersonalizationAnalytics
     * @example
     * // Get one PersonalizationAnalytics
     * const personalizationAnalytics = await prisma.personalizationAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PersonalizationAnalyticsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PersonalizationAnalyticsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PersonalizationAnalyticsClient<$Types.GetResult<PersonalizationAnalyticsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more PersonalizationAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalizationAnalyticsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonalizationAnalytics
     * const personalizationAnalytics = await prisma.personalizationAnalytics.findMany()
     * 
     * // Get first 10 PersonalizationAnalytics
     * const personalizationAnalytics = await prisma.personalizationAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personalizationAnalyticsWithIdOnly = await prisma.personalizationAnalytics.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PersonalizationAnalyticsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PersonalizationAnalyticsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PersonalizationAnalyticsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a PersonalizationAnalytics.
     * @param {PersonalizationAnalyticsCreateArgs} args - Arguments to create a PersonalizationAnalytics.
     * @example
     * // Create one PersonalizationAnalytics
     * const PersonalizationAnalytics = await prisma.personalizationAnalytics.create({
     *   data: {
     *     // ... data to create a PersonalizationAnalytics
     *   }
     * })
     * 
    **/
    create<T extends PersonalizationAnalyticsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PersonalizationAnalyticsCreateArgs<ExtArgs>>
    ): Prisma__PersonalizationAnalyticsClient<$Types.GetResult<PersonalizationAnalyticsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many PersonalizationAnalytics.
     *     @param {PersonalizationAnalyticsCreateManyArgs} args - Arguments to create many PersonalizationAnalytics.
     *     @example
     *     // Create many PersonalizationAnalytics
     *     const personalizationAnalytics = await prisma.personalizationAnalytics.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PersonalizationAnalyticsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PersonalizationAnalyticsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PersonalizationAnalytics.
     * @param {PersonalizationAnalyticsDeleteArgs} args - Arguments to delete one PersonalizationAnalytics.
     * @example
     * // Delete one PersonalizationAnalytics
     * const PersonalizationAnalytics = await prisma.personalizationAnalytics.delete({
     *   where: {
     *     // ... filter to delete one PersonalizationAnalytics
     *   }
     * })
     * 
    **/
    delete<T extends PersonalizationAnalyticsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PersonalizationAnalyticsDeleteArgs<ExtArgs>>
    ): Prisma__PersonalizationAnalyticsClient<$Types.GetResult<PersonalizationAnalyticsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one PersonalizationAnalytics.
     * @param {PersonalizationAnalyticsUpdateArgs} args - Arguments to update one PersonalizationAnalytics.
     * @example
     * // Update one PersonalizationAnalytics
     * const personalizationAnalytics = await prisma.personalizationAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PersonalizationAnalyticsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PersonalizationAnalyticsUpdateArgs<ExtArgs>>
    ): Prisma__PersonalizationAnalyticsClient<$Types.GetResult<PersonalizationAnalyticsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more PersonalizationAnalytics.
     * @param {PersonalizationAnalyticsDeleteManyArgs} args - Arguments to filter PersonalizationAnalytics to delete.
     * @example
     * // Delete a few PersonalizationAnalytics
     * const { count } = await prisma.personalizationAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PersonalizationAnalyticsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PersonalizationAnalyticsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonalizationAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalizationAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonalizationAnalytics
     * const personalizationAnalytics = await prisma.personalizationAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PersonalizationAnalyticsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PersonalizationAnalyticsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PersonalizationAnalytics.
     * @param {PersonalizationAnalyticsUpsertArgs} args - Arguments to update or create a PersonalizationAnalytics.
     * @example
     * // Update or create a PersonalizationAnalytics
     * const personalizationAnalytics = await prisma.personalizationAnalytics.upsert({
     *   create: {
     *     // ... data to create a PersonalizationAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonalizationAnalytics we want to update
     *   }
     * })
    **/
    upsert<T extends PersonalizationAnalyticsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PersonalizationAnalyticsUpsertArgs<ExtArgs>>
    ): Prisma__PersonalizationAnalyticsClient<$Types.GetResult<PersonalizationAnalyticsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of PersonalizationAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalizationAnalyticsCountArgs} args - Arguments to filter PersonalizationAnalytics to count.
     * @example
     * // Count the number of PersonalizationAnalytics
     * const count = await prisma.personalizationAnalytics.count({
     *   where: {
     *     // ... the filter for the PersonalizationAnalytics we want to count
     *   }
     * })
    **/
    count<T extends PersonalizationAnalyticsCountArgs>(
      args?: Subset<T, PersonalizationAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonalizationAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonalizationAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalizationAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonalizationAnalyticsAggregateArgs>(args: Subset<T, PersonalizationAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetPersonalizationAnalyticsAggregateType<T>>

    /**
     * Group by PersonalizationAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalizationAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonalizationAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonalizationAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: PersonalizationAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonalizationAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonalizationAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersonalizationAnalytics model
   */
  readonly fields: PersonalizationAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonalizationAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PersonalizationAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the PersonalizationAnalytics model
   */ 
  interface PersonalizationAnalyticsFieldRefs {
    readonly id: FieldRef<"PersonalizationAnalytics", 'String'>
    readonly userId: FieldRef<"PersonalizationAnalytics", 'String'>
    readonly actionType: FieldRef<"PersonalizationAnalytics", 'String'>
    readonly metadata: FieldRef<"PersonalizationAnalytics", 'Json'>
    readonly createdAt: FieldRef<"PersonalizationAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * PersonalizationAnalytics findUnique
   */
  export type PersonalizationAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalizationAnalytics
     */
    select?: PersonalizationAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalizationAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which PersonalizationAnalytics to fetch.
     */
    where: PersonalizationAnalyticsWhereUniqueInput
  }


  /**
   * PersonalizationAnalytics findUniqueOrThrow
   */
  export type PersonalizationAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalizationAnalytics
     */
    select?: PersonalizationAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalizationAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which PersonalizationAnalytics to fetch.
     */
    where: PersonalizationAnalyticsWhereUniqueInput
  }


  /**
   * PersonalizationAnalytics findFirst
   */
  export type PersonalizationAnalyticsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalizationAnalytics
     */
    select?: PersonalizationAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalizationAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which PersonalizationAnalytics to fetch.
     */
    where?: PersonalizationAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalizationAnalytics to fetch.
     */
    orderBy?: PersonalizationAnalyticsOrderByWithRelationInput | PersonalizationAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonalizationAnalytics.
     */
    cursor?: PersonalizationAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalizationAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalizationAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonalizationAnalytics.
     */
    distinct?: PersonalizationAnalyticsScalarFieldEnum | PersonalizationAnalyticsScalarFieldEnum[]
  }


  /**
   * PersonalizationAnalytics findFirstOrThrow
   */
  export type PersonalizationAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalizationAnalytics
     */
    select?: PersonalizationAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalizationAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which PersonalizationAnalytics to fetch.
     */
    where?: PersonalizationAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalizationAnalytics to fetch.
     */
    orderBy?: PersonalizationAnalyticsOrderByWithRelationInput | PersonalizationAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonalizationAnalytics.
     */
    cursor?: PersonalizationAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalizationAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalizationAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonalizationAnalytics.
     */
    distinct?: PersonalizationAnalyticsScalarFieldEnum | PersonalizationAnalyticsScalarFieldEnum[]
  }


  /**
   * PersonalizationAnalytics findMany
   */
  export type PersonalizationAnalyticsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalizationAnalytics
     */
    select?: PersonalizationAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalizationAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which PersonalizationAnalytics to fetch.
     */
    where?: PersonalizationAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalizationAnalytics to fetch.
     */
    orderBy?: PersonalizationAnalyticsOrderByWithRelationInput | PersonalizationAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonalizationAnalytics.
     */
    cursor?: PersonalizationAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalizationAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalizationAnalytics.
     */
    skip?: number
    distinct?: PersonalizationAnalyticsScalarFieldEnum | PersonalizationAnalyticsScalarFieldEnum[]
  }


  /**
   * PersonalizationAnalytics create
   */
  export type PersonalizationAnalyticsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalizationAnalytics
     */
    select?: PersonalizationAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalizationAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a PersonalizationAnalytics.
     */
    data: XOR<PersonalizationAnalyticsCreateInput, PersonalizationAnalyticsUncheckedCreateInput>
  }


  /**
   * PersonalizationAnalytics createMany
   */
  export type PersonalizationAnalyticsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonalizationAnalytics.
     */
    data: PersonalizationAnalyticsCreateManyInput | PersonalizationAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * PersonalizationAnalytics update
   */
  export type PersonalizationAnalyticsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalizationAnalytics
     */
    select?: PersonalizationAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalizationAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a PersonalizationAnalytics.
     */
    data: XOR<PersonalizationAnalyticsUpdateInput, PersonalizationAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which PersonalizationAnalytics to update.
     */
    where: PersonalizationAnalyticsWhereUniqueInput
  }


  /**
   * PersonalizationAnalytics updateMany
   */
  export type PersonalizationAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonalizationAnalytics.
     */
    data: XOR<PersonalizationAnalyticsUpdateManyMutationInput, PersonalizationAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which PersonalizationAnalytics to update
     */
    where?: PersonalizationAnalyticsWhereInput
  }


  /**
   * PersonalizationAnalytics upsert
   */
  export type PersonalizationAnalyticsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalizationAnalytics
     */
    select?: PersonalizationAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalizationAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the PersonalizationAnalytics to update in case it exists.
     */
    where: PersonalizationAnalyticsWhereUniqueInput
    /**
     * In case the PersonalizationAnalytics found by the `where` argument doesn't exist, create a new PersonalizationAnalytics with this data.
     */
    create: XOR<PersonalizationAnalyticsCreateInput, PersonalizationAnalyticsUncheckedCreateInput>
    /**
     * In case the PersonalizationAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonalizationAnalyticsUpdateInput, PersonalizationAnalyticsUncheckedUpdateInput>
  }


  /**
   * PersonalizationAnalytics delete
   */
  export type PersonalizationAnalyticsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalizationAnalytics
     */
    select?: PersonalizationAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalizationAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which PersonalizationAnalytics to delete.
     */
    where: PersonalizationAnalyticsWhereUniqueInput
  }


  /**
   * PersonalizationAnalytics deleteMany
   */
  export type PersonalizationAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonalizationAnalytics to delete
     */
    where?: PersonalizationAnalyticsWhereInput
  }


  /**
   * PersonalizationAnalytics without action
   */
  export type PersonalizationAnalyticsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalizationAnalytics
     */
    select?: PersonalizationAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalizationAnalyticsInclude<ExtArgs> | null
  }



  /**
   * Model UserProfile
   */


  export type AggregateUserProfile = {
    _count: UserProfileCountAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  export type UserProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    postalCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    postalCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProfileCountAggregateOutputType = {
    id: number
    userId: number
    firstName: number
    lastName: number
    email: number
    phone: number
    address: number
    city: number
    state: number
    country: number
    postalCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserProfileMinAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    state?: true
    country?: true
    postalCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    state?: true
    country?: true
    postalCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProfileCountAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    state?: true
    country?: true
    postalCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserProfileAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfile to aggregate.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfiles
    **/
    _count?: true | UserProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileMaxAggregateInputType
  }

  export type GetUserProfileAggregateType<T extends UserProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfile[P]>
      : GetScalarType<T[P], AggregateUserProfile[P]>
  }




  export type UserProfileGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithAggregationInput | UserProfileOrderByWithAggregationInput[]
    by: UserProfileScalarFieldEnum[] | UserProfileScalarFieldEnum
    having?: UserProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileCountAggregateInputType | true
    _min?: UserProfileMinAggregateInputType
    _max?: UserProfileMaxAggregateInputType
  }


  export type UserProfileGroupByOutputType = {
    id: string
    userId: string
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    state: string | null
    country: string | null
    postalCode: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserProfileCountAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  type GetUserProfileGroupByPayload<T extends UserProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postalCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoices?: boolean | UserProfile$invoicesArgs<ExtArgs>
    payments?: boolean | UserProfile$paymentsArgs<ExtArgs>
    subscriptions?: boolean | UserProfile$subscriptionsArgs<ExtArgs>
    credits?: boolean | UserProfile$creditsArgs<ExtArgs>
    _count?: boolean | UserProfileCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    postalCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserProfileInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    invoices?: boolean | UserProfile$invoicesArgs<ExtArgs>
    payments?: boolean | UserProfile$paymentsArgs<ExtArgs>
    subscriptions?: boolean | UserProfile$subscriptionsArgs<ExtArgs>
    credits?: boolean | UserProfile$creditsArgs<ExtArgs>
    _count?: boolean | UserProfileCountOutputTypeArgs<ExtArgs>
  }


  type UserProfileGetPayload<S extends boolean | null | undefined | UserProfileArgs> = $Types.GetResult<UserProfilePayload, S>

  type UserProfileCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserProfileFindManyArgs, 'select' | 'include'> & {
      select?: UserProfileCountAggregateInputType | true
    }

  export interface UserProfileDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProfile'], meta: { name: 'UserProfile' } }
    /**
     * Find zero or one UserProfile that matches the filter.
     * @param {UserProfileFindUniqueArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserProfileFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserProfileFindUniqueArgs<ExtArgs>>
    ): Prisma__UserProfileClient<$Types.GetResult<UserProfilePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserProfile that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserProfileFindUniqueOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserProfileFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserProfileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserProfileClient<$Types.GetResult<UserProfilePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserProfileFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserProfileFindFirstArgs<ExtArgs>>
    ): Prisma__UserProfileClient<$Types.GetResult<UserProfilePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserProfileFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserProfileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserProfileClient<$Types.GetResult<UserProfilePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfiles
     * const userProfiles = await prisma.userProfile.findMany()
     * 
     * // Get first 10 UserProfiles
     * const userProfiles = await prisma.userProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserProfileFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserProfileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserProfilePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserProfile.
     * @param {UserProfileCreateArgs} args - Arguments to create a UserProfile.
     * @example
     * // Create one UserProfile
     * const UserProfile = await prisma.userProfile.create({
     *   data: {
     *     // ... data to create a UserProfile
     *   }
     * })
     * 
    **/
    create<T extends UserProfileCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserProfileCreateArgs<ExtArgs>>
    ): Prisma__UserProfileClient<$Types.GetResult<UserProfilePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserProfiles.
     *     @param {UserProfileCreateManyArgs} args - Arguments to create many UserProfiles.
     *     @example
     *     // Create many UserProfiles
     *     const userProfile = await prisma.userProfile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserProfileCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserProfileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserProfile.
     * @param {UserProfileDeleteArgs} args - Arguments to delete one UserProfile.
     * @example
     * // Delete one UserProfile
     * const UserProfile = await prisma.userProfile.delete({
     *   where: {
     *     // ... filter to delete one UserProfile
     *   }
     * })
     * 
    **/
    delete<T extends UserProfileDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserProfileDeleteArgs<ExtArgs>>
    ): Prisma__UserProfileClient<$Types.GetResult<UserProfilePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserProfile.
     * @param {UserProfileUpdateArgs} args - Arguments to update one UserProfile.
     * @example
     * // Update one UserProfile
     * const userProfile = await prisma.userProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserProfileUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserProfileUpdateArgs<ExtArgs>>
    ): Prisma__UserProfileClient<$Types.GetResult<UserProfilePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserProfiles.
     * @param {UserProfileDeleteManyArgs} args - Arguments to filter UserProfiles to delete.
     * @example
     * // Delete a few UserProfiles
     * const { count } = await prisma.userProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserProfileDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserProfileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserProfileUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserProfileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserProfile.
     * @param {UserProfileUpsertArgs} args - Arguments to update or create a UserProfile.
     * @example
     * // Update or create a UserProfile
     * const userProfile = await prisma.userProfile.upsert({
     *   create: {
     *     // ... data to create a UserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfile we want to update
     *   }
     * })
    **/
    upsert<T extends UserProfileUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserProfileUpsertArgs<ExtArgs>>
    ): Prisma__UserProfileClient<$Types.GetResult<UserProfilePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileCountArgs} args - Arguments to filter UserProfiles to count.
     * @example
     * // Count the number of UserProfiles
     * const count = await prisma.userProfile.count({
     *   where: {
     *     // ... the filter for the UserProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserProfileCountArgs>(
      args?: Subset<T, UserProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileAggregateArgs>(args: Subset<T, UserProfileAggregateArgs>): Prisma.PrismaPromise<GetUserProfileAggregateType<T>>

    /**
     * Group by UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProfile model
   */
  readonly fields: UserProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserProfileClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    invoices<T extends UserProfile$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findMany'>| Null>;

    payments<T extends UserProfile$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findMany'>| Null>;

    subscriptions<T extends UserProfile$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<SubscriptionPayload<ExtArgs>, T, 'findMany'>| Null>;

    credits<T extends UserProfile$creditsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$creditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<CreditPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the UserProfile model
   */ 
  interface UserProfileFieldRefs {
    readonly id: FieldRef<"UserProfile", 'String'>
    readonly userId: FieldRef<"UserProfile", 'String'>
    readonly firstName: FieldRef<"UserProfile", 'String'>
    readonly lastName: FieldRef<"UserProfile", 'String'>
    readonly email: FieldRef<"UserProfile", 'String'>
    readonly phone: FieldRef<"UserProfile", 'String'>
    readonly address: FieldRef<"UserProfile", 'String'>
    readonly city: FieldRef<"UserProfile", 'String'>
    readonly state: FieldRef<"UserProfile", 'String'>
    readonly country: FieldRef<"UserProfile", 'String'>
    readonly postalCode: FieldRef<"UserProfile", 'String'>
    readonly createdAt: FieldRef<"UserProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"UserProfile", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * UserProfile findUnique
   */
  export type UserProfileFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }


  /**
   * UserProfile findUniqueOrThrow
   */
  export type UserProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }


  /**
   * UserProfile findFirst
   */
  export type UserProfileFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }


  /**
   * UserProfile findFirstOrThrow
   */
  export type UserProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }


  /**
   * UserProfile findMany
   */
  export type UserProfileFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfiles to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }


  /**
   * UserProfile create
   */
  export type UserProfileCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProfile.
     */
    data: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
  }


  /**
   * UserProfile createMany
   */
  export type UserProfileCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UserProfile update
   */
  export type UserProfileUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProfile.
     */
    data: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
    /**
     * Choose, which UserProfile to update.
     */
    where: UserProfileWhereUniqueInput
  }


  /**
   * UserProfile updateMany
   */
  export type UserProfileUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
  }


  /**
   * UserProfile upsert
   */
  export type UserProfileUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProfile to update in case it exists.
     */
    where: UserProfileWhereUniqueInput
    /**
     * In case the UserProfile found by the `where` argument doesn't exist, create a new UserProfile with this data.
     */
    create: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
    /**
     * In case the UserProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
  }


  /**
   * UserProfile delete
   */
  export type UserProfileDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter which UserProfile to delete.
     */
    where: UserProfileWhereUniqueInput
  }


  /**
   * UserProfile deleteMany
   */
  export type UserProfileDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfiles to delete
     */
    where?: UserProfileWhereInput
  }


  /**
   * UserProfile.invoices
   */
  export type UserProfile$invoicesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }


  /**
   * UserProfile.payments
   */
  export type UserProfile$paymentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }


  /**
   * UserProfile.subscriptions
   */
  export type UserProfile$subscriptionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }


  /**
   * UserProfile.credits
   */
  export type UserProfile$creditsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit
     */
    select?: CreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CreditInclude<ExtArgs> | null
    where?: CreditWhereInput
    orderBy?: CreditOrderByWithRelationInput | CreditOrderByWithRelationInput[]
    cursor?: CreditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditScalarFieldEnum | CreditScalarFieldEnum[]
  }


  /**
   * UserProfile without action
   */
  export type UserProfileArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserProfileInclude<ExtArgs> | null
  }



  /**
   * Model Invoice
   */


  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    subtotal: Decimal | null
    tax: Decimal | null
    total: Decimal | null
  }

  export type InvoiceSumAggregateOutputType = {
    subtotal: Decimal | null
    tax: Decimal | null
    total: Decimal | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    number: string | null
    userId: string | null
    status: InvoiceStatus | null
    issueDate: Date | null
    dueDate: Date | null
    paidDate: Date | null
    subtotal: Decimal | null
    tax: Decimal | null
    total: Decimal | null
    currency: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    number: string | null
    userId: string | null
    status: InvoiceStatus | null
    issueDate: Date | null
    dueDate: Date | null
    paidDate: Date | null
    subtotal: Decimal | null
    tax: Decimal | null
    total: Decimal | null
    currency: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    number: number
    userId: number
    status: number
    period: number
    issueDate: number
    dueDate: number
    paidDate: number
    subtotal: number
    tax: number
    total: number
    currency: number
    items: number
    billingAddress: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    subtotal?: true
    tax?: true
    total?: true
  }

  export type InvoiceSumAggregateInputType = {
    subtotal?: true
    tax?: true
    total?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    number?: true
    userId?: true
    status?: true
    issueDate?: true
    dueDate?: true
    paidDate?: true
    subtotal?: true
    tax?: true
    total?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    number?: true
    userId?: true
    status?: true
    issueDate?: true
    dueDate?: true
    paidDate?: true
    subtotal?: true
    tax?: true
    total?: true
    currency?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    number?: true
    userId?: true
    status?: true
    period?: true
    issueDate?: true
    dueDate?: true
    paidDate?: true
    subtotal?: true
    tax?: true
    total?: true
    currency?: true
    items?: true
    billingAddress?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }


  export type InvoiceGroupByOutputType = {
    id: string
    number: string
    userId: string
    status: InvoiceStatus
    period: JsonValue
    issueDate: Date
    dueDate: Date
    paidDate: Date | null
    subtotal: Decimal
    tax: Decimal
    total: Decimal
    currency: string
    items: JsonValue
    billingAddress: JsonValue
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    userId?: boolean
    status?: boolean
    period?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidDate?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    currency?: boolean
    items?: boolean
    billingAddress?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userProfile?: boolean | UserProfileArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    number?: boolean
    userId?: boolean
    status?: boolean
    period?: boolean
    issueDate?: boolean
    dueDate?: boolean
    paidDate?: boolean
    subtotal?: boolean
    tax?: boolean
    total?: boolean
    currency?: boolean
    items?: boolean
    billingAddress?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    userProfile?: boolean | UserProfileArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeArgs<ExtArgs>
  }


  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceArgs> = $Types.GetResult<InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InvoiceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InvoiceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InvoiceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
    **/
    create<T extends InvoiceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Invoices.
     *     @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     *     @example
     *     // Create many Invoices
     *     const invoice = await prisma.invoice.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InvoiceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
    **/
    delete<T extends InvoiceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InvoiceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InvoiceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InvoiceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
    **/
    upsert<T extends InvoiceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    userProfile<T extends UserProfileArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileArgs<ExtArgs>>): Prisma__UserProfileClient<$Types.GetResult<UserProfilePayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly number: FieldRef<"Invoice", 'String'>
    readonly userId: FieldRef<"Invoice", 'String'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly period: FieldRef<"Invoice", 'Json'>
    readonly issueDate: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly paidDate: FieldRef<"Invoice", 'DateTime'>
    readonly subtotal: FieldRef<"Invoice", 'Decimal'>
    readonly tax: FieldRef<"Invoice", 'Decimal'>
    readonly total: FieldRef<"Invoice", 'Decimal'>
    readonly currency: FieldRef<"Invoice", 'String'>
    readonly items: FieldRef<"Invoice", 'Json'>
    readonly billingAddress: FieldRef<"Invoice", 'Json'>
    readonly metadata: FieldRef<"Invoice", 'Json'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }


  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }


  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }


  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }


  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }


  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }


  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }


  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }


  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }


  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }


  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }


  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }


  /**
   * Invoice without action
   */
  export type InvoiceArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
  }



  /**
   * Model Payment
   */


  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
    refundedAmount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
    refundedAmount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    userId: string | null
    amount: Decimal | null
    currency: string | null
    status: PaymentStatus | null
    providerTransactionId: string | null
    failureReason: string | null
    refundedAmount: Decimal | null
    createdAt: Date | null
    processedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    userId: string | null
    amount: Decimal | null
    currency: string | null
    status: PaymentStatus | null
    providerTransactionId: string | null
    failureReason: string | null
    refundedAmount: Decimal | null
    createdAt: Date | null
    processedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    invoiceId: number
    userId: number
    amount: number
    currency: number
    status: number
    providerTransactionId: number
    failureReason: number
    refundedAmount: number
    createdAt: number
    processedAt: number
    metadata: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
    refundedAmount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
    refundedAmount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    invoiceId?: true
    userId?: true
    amount?: true
    currency?: true
    status?: true
    providerTransactionId?: true
    failureReason?: true
    refundedAmount?: true
    createdAt?: true
    processedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    userId?: true
    amount?: true
    currency?: true
    status?: true
    providerTransactionId?: true
    failureReason?: true
    refundedAmount?: true
    createdAt?: true
    processedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    invoiceId?: true
    userId?: true
    amount?: true
    currency?: true
    status?: true
    providerTransactionId?: true
    failureReason?: true
    refundedAmount?: true
    createdAt?: true
    processedAt?: true
    metadata?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }


  export type PaymentGroupByOutputType = {
    id: string
    invoiceId: string
    userId: string
    amount: Decimal
    currency: string
    status: PaymentStatus
    providerTransactionId: string | null
    failureReason: string | null
    refundedAmount: Decimal | null
    createdAt: Date
    processedAt: Date | null
    metadata: JsonValue
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    providerTransactionId?: boolean
    failureReason?: boolean
    refundedAmount?: boolean
    createdAt?: boolean
    processedAt?: boolean
    metadata?: boolean
    invoice?: boolean | InvoiceArgs<ExtArgs>
    userProfile?: boolean | UserProfileArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    providerTransactionId?: boolean
    failureReason?: boolean
    refundedAmount?: boolean
    createdAt?: boolean
    processedAt?: boolean
    metadata?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceArgs<ExtArgs>
    userProfile?: boolean | UserProfileArgs<ExtArgs>
  }


  type PaymentGetPayload<S extends boolean | null | undefined | PaymentArgs> = $Types.GetResult<PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PaymentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PaymentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PaymentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
    **/
    create<T extends PaymentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Payments.
     *     @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     *     @example
     *     // Create many Payments
     *     const payment = await prisma.payment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PaymentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
    **/
    delete<T extends PaymentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PaymentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PaymentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PaymentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
    **/
    upsert<T extends PaymentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>
    ): Prisma__PaymentClient<$Types.GetResult<PaymentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    invoice<T extends InvoiceArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Types.GetResult<InvoicePayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    userProfile<T extends UserProfileArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileArgs<ExtArgs>>): Prisma__UserProfileClient<$Types.GetResult<UserProfilePayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly invoiceId: FieldRef<"Payment", 'String'>
    readonly userId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly providerTransactionId: FieldRef<"Payment", 'String'>
    readonly failureReason: FieldRef<"Payment", 'String'>
    readonly refundedAmount: FieldRef<"Payment", 'Decimal'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly processedAt: FieldRef<"Payment", 'DateTime'>
    readonly metadata: FieldRef<"Payment", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }


  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }


  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }


  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }


  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }


  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }


  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }


  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }


  /**
   * Payment without action
   */
  export type PaymentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PaymentInclude<ExtArgs> | null
  }



  /**
   * Model Subscription
   */


  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    amount: Decimal | null
    intervalCount: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    amount: Decimal | null
    intervalCount: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    plan: string | null
    status: SubscriptionStatus | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    amount: Decimal | null
    currency: string | null
    interval: SubscriptionInterval | null
    intervalCount: number | null
    trialStart: Date | null
    trialEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    plan: string | null
    status: SubscriptionStatus | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    amount: Decimal | null
    currency: string | null
    interval: SubscriptionInterval | null
    intervalCount: number | null
    trialStart: Date | null
    trialEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    plan: number
    status: number
    currentPeriodStart: number
    currentPeriodEnd: number
    cancelAtPeriodEnd: number
    amount: number
    currency: number
    interval: number
    intervalCount: number
    trialStart: number
    trialEnd: number
    createdAt: number
    updatedAt: number
    metadata: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    amount?: true
    intervalCount?: true
  }

  export type SubscriptionSumAggregateInputType = {
    amount?: true
    intervalCount?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    plan?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    amount?: true
    currency?: true
    interval?: true
    intervalCount?: true
    trialStart?: true
    trialEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    plan?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    amount?: true
    currency?: true
    interval?: true
    intervalCount?: true
    trialStart?: true
    trialEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    plan?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    amount?: true
    currency?: true
    interval?: true
    intervalCount?: true
    trialStart?: true
    trialEnd?: true
    createdAt?: true
    updatedAt?: true
    metadata?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }


  export type SubscriptionGroupByOutputType = {
    id: string
    userId: string
    plan: string
    status: SubscriptionStatus
    currentPeriodStart: Date
    currentPeriodEnd: Date
    cancelAtPeriodEnd: boolean
    amount: Decimal
    currency: string
    interval: SubscriptionInterval
    intervalCount: number
    trialStart: Date | null
    trialEnd: Date | null
    createdAt: Date
    updatedAt: Date
    metadata: JsonValue
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    plan?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    amount?: boolean
    currency?: boolean
    interval?: boolean
    intervalCount?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
    userProfile?: boolean | UserProfileArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    plan?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    amount?: boolean
    currency?: boolean
    interval?: boolean
    intervalCount?: boolean
    trialStart?: boolean
    trialEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
  }

  export type SubscriptionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    userProfile?: boolean | UserProfileArgs<ExtArgs>
  }


  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionArgs> = $Types.GetResult<SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<SubscriptionFindManyArgs, 'select' | 'include'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubscriptionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Types.GetResult<SubscriptionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Subscription that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Types.GetResult<SubscriptionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubscriptionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Types.GetResult<SubscriptionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Types.GetResult<SubscriptionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubscriptionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<SubscriptionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
    **/
    create<T extends SubscriptionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Types.GetResult<SubscriptionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Subscriptions.
     *     @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     *     @example
     *     // Create many Subscriptions
     *     const subscription = await prisma.subscription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubscriptionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
    **/
    delete<T extends SubscriptionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Types.GetResult<SubscriptionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubscriptionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Types.GetResult<SubscriptionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubscriptionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubscriptionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
    **/
    upsert<T extends SubscriptionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Types.GetResult<SubscriptionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    userProfile<T extends UserProfileArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileArgs<ExtArgs>>): Prisma__UserProfileClient<$Types.GetResult<UserProfilePayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the Subscription model
   */ 
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly userId: FieldRef<"Subscription", 'String'>
    readonly plan: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'SubscriptionStatus'>
    readonly currentPeriodStart: FieldRef<"Subscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"Subscription", 'DateTime'>
    readonly cancelAtPeriodEnd: FieldRef<"Subscription", 'Boolean'>
    readonly amount: FieldRef<"Subscription", 'Decimal'>
    readonly currency: FieldRef<"Subscription", 'String'>
    readonly interval: FieldRef<"Subscription", 'SubscriptionInterval'>
    readonly intervalCount: FieldRef<"Subscription", 'Int'>
    readonly trialStart: FieldRef<"Subscription", 'DateTime'>
    readonly trialEnd: FieldRef<"Subscription", 'DateTime'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
    readonly metadata: FieldRef<"Subscription", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }


  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }


  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }


  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }


  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
  }


  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }


  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
  }


  /**
   * Subscription without action
   */
  export type SubscriptionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }



  /**
   * Model Credit
   */


  export type AggregateCredit = {
    _count: CreditCountAggregateOutputType | null
    _avg: CreditAvgAggregateOutputType | null
    _sum: CreditSumAggregateOutputType | null
    _min: CreditMinAggregateOutputType | null
    _max: CreditMaxAggregateOutputType | null
  }

  export type CreditAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type CreditSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type CreditMinAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: Decimal | null
    currency: string | null
    reason: string | null
    type: CreditType | null
    expiresAt: Date | null
    usedAt: Date | null
    invoiceId: string | null
    createdAt: Date | null
  }

  export type CreditMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: Decimal | null
    currency: string | null
    reason: string | null
    type: CreditType | null
    expiresAt: Date | null
    usedAt: Date | null
    invoiceId: string | null
    createdAt: Date | null
  }

  export type CreditCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    currency: number
    reason: number
    type: number
    expiresAt: number
    usedAt: number
    invoiceId: number
    createdAt: number
    metadata: number
    _all: number
  }


  export type CreditAvgAggregateInputType = {
    amount?: true
  }

  export type CreditSumAggregateInputType = {
    amount?: true
  }

  export type CreditMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    reason?: true
    type?: true
    expiresAt?: true
    usedAt?: true
    invoiceId?: true
    createdAt?: true
  }

  export type CreditMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    reason?: true
    type?: true
    expiresAt?: true
    usedAt?: true
    invoiceId?: true
    createdAt?: true
  }

  export type CreditCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    reason?: true
    type?: true
    expiresAt?: true
    usedAt?: true
    invoiceId?: true
    createdAt?: true
    metadata?: true
    _all?: true
  }

  export type CreditAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Credit to aggregate.
     */
    where?: CreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credits to fetch.
     */
    orderBy?: CreditOrderByWithRelationInput | CreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Credits
    **/
    _count?: true | CreditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditMaxAggregateInputType
  }

  export type GetCreditAggregateType<T extends CreditAggregateArgs> = {
        [P in keyof T & keyof AggregateCredit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCredit[P]>
      : GetScalarType<T[P], AggregateCredit[P]>
  }




  export type CreditGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CreditWhereInput
    orderBy?: CreditOrderByWithAggregationInput | CreditOrderByWithAggregationInput[]
    by: CreditScalarFieldEnum[] | CreditScalarFieldEnum
    having?: CreditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditCountAggregateInputType | true
    _avg?: CreditAvgAggregateInputType
    _sum?: CreditSumAggregateInputType
    _min?: CreditMinAggregateInputType
    _max?: CreditMaxAggregateInputType
  }


  export type CreditGroupByOutputType = {
    id: string
    userId: string
    amount: Decimal
    currency: string
    reason: string
    type: CreditType
    expiresAt: Date | null
    usedAt: Date | null
    invoiceId: string | null
    createdAt: Date
    metadata: JsonValue
    _count: CreditCountAggregateOutputType | null
    _avg: CreditAvgAggregateOutputType | null
    _sum: CreditSumAggregateOutputType | null
    _min: CreditMinAggregateOutputType | null
    _max: CreditMaxAggregateOutputType | null
  }

  type GetCreditGroupByPayload<T extends CreditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditGroupByOutputType[P]>
            : GetScalarType<T[P], CreditGroupByOutputType[P]>
        }
      >
    >


  export type CreditSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    reason?: boolean
    type?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    invoiceId?: boolean
    createdAt?: boolean
    metadata?: boolean
    userProfile?: boolean | UserProfileArgs<ExtArgs>
  }, ExtArgs["result"]["credit"]>

  export type CreditSelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    reason?: boolean
    type?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    invoiceId?: boolean
    createdAt?: boolean
    metadata?: boolean
  }

  export type CreditInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    userProfile?: boolean | UserProfileArgs<ExtArgs>
  }


  type CreditGetPayload<S extends boolean | null | undefined | CreditArgs> = $Types.GetResult<CreditPayload, S>

  type CreditCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CreditFindManyArgs, 'select' | 'include'> & {
      select?: CreditCountAggregateInputType | true
    }

  export interface CreditDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Credit'], meta: { name: 'Credit' } }
    /**
     * Find zero or one Credit that matches the filter.
     * @param {CreditFindUniqueArgs} args - Arguments to find a Credit
     * @example
     * // Get one Credit
     * const credit = await prisma.credit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CreditFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CreditFindUniqueArgs<ExtArgs>>
    ): Prisma__CreditClient<$Types.GetResult<CreditPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Credit that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CreditFindUniqueOrThrowArgs} args - Arguments to find a Credit
     * @example
     * // Get one Credit
     * const credit = await prisma.credit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CreditFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CreditFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CreditClient<$Types.GetResult<CreditPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Credit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditFindFirstArgs} args - Arguments to find a Credit
     * @example
     * // Get one Credit
     * const credit = await prisma.credit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CreditFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CreditFindFirstArgs<ExtArgs>>
    ): Prisma__CreditClient<$Types.GetResult<CreditPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Credit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditFindFirstOrThrowArgs} args - Arguments to find a Credit
     * @example
     * // Get one Credit
     * const credit = await prisma.credit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CreditFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CreditFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CreditClient<$Types.GetResult<CreditPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Credits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Credits
     * const credits = await prisma.credit.findMany()
     * 
     * // Get first 10 Credits
     * const credits = await prisma.credit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditWithIdOnly = await prisma.credit.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CreditFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CreditFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<CreditPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Credit.
     * @param {CreditCreateArgs} args - Arguments to create a Credit.
     * @example
     * // Create one Credit
     * const Credit = await prisma.credit.create({
     *   data: {
     *     // ... data to create a Credit
     *   }
     * })
     * 
    **/
    create<T extends CreditCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CreditCreateArgs<ExtArgs>>
    ): Prisma__CreditClient<$Types.GetResult<CreditPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Credits.
     *     @param {CreditCreateManyArgs} args - Arguments to create many Credits.
     *     @example
     *     // Create many Credits
     *     const credit = await prisma.credit.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CreditCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CreditCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Credit.
     * @param {CreditDeleteArgs} args - Arguments to delete one Credit.
     * @example
     * // Delete one Credit
     * const Credit = await prisma.credit.delete({
     *   where: {
     *     // ... filter to delete one Credit
     *   }
     * })
     * 
    **/
    delete<T extends CreditDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CreditDeleteArgs<ExtArgs>>
    ): Prisma__CreditClient<$Types.GetResult<CreditPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Credit.
     * @param {CreditUpdateArgs} args - Arguments to update one Credit.
     * @example
     * // Update one Credit
     * const credit = await prisma.credit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CreditUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CreditUpdateArgs<ExtArgs>>
    ): Prisma__CreditClient<$Types.GetResult<CreditPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Credits.
     * @param {CreditDeleteManyArgs} args - Arguments to filter Credits to delete.
     * @example
     * // Delete a few Credits
     * const { count } = await prisma.credit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CreditDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CreditDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Credits
     * const credit = await prisma.credit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CreditUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CreditUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Credit.
     * @param {CreditUpsertArgs} args - Arguments to update or create a Credit.
     * @example
     * // Update or create a Credit
     * const credit = await prisma.credit.upsert({
     *   create: {
     *     // ... data to create a Credit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Credit we want to update
     *   }
     * })
    **/
    upsert<T extends CreditUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CreditUpsertArgs<ExtArgs>>
    ): Prisma__CreditClient<$Types.GetResult<CreditPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Credits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditCountArgs} args - Arguments to filter Credits to count.
     * @example
     * // Count the number of Credits
     * const count = await prisma.credit.count({
     *   where: {
     *     // ... the filter for the Credits we want to count
     *   }
     * })
    **/
    count<T extends CreditCountArgs>(
      args?: Subset<T, CreditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Credit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditAggregateArgs>(args: Subset<T, CreditAggregateArgs>): Prisma.PrismaPromise<GetCreditAggregateType<T>>

    /**
     * Group by Credit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditGroupByArgs['orderBy'] }
        : { orderBy?: CreditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Credit model
   */
  readonly fields: CreditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Credit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CreditClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    userProfile<T extends UserProfileArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileArgs<ExtArgs>>): Prisma__UserProfileClient<$Types.GetResult<UserProfilePayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the Credit model
   */ 
  interface CreditFieldRefs {
    readonly id: FieldRef<"Credit", 'String'>
    readonly userId: FieldRef<"Credit", 'String'>
    readonly amount: FieldRef<"Credit", 'Decimal'>
    readonly currency: FieldRef<"Credit", 'String'>
    readonly reason: FieldRef<"Credit", 'String'>
    readonly type: FieldRef<"Credit", 'CreditType'>
    readonly expiresAt: FieldRef<"Credit", 'DateTime'>
    readonly usedAt: FieldRef<"Credit", 'DateTime'>
    readonly invoiceId: FieldRef<"Credit", 'String'>
    readonly createdAt: FieldRef<"Credit", 'DateTime'>
    readonly metadata: FieldRef<"Credit", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * Credit findUnique
   */
  export type CreditFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit
     */
    select?: CreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CreditInclude<ExtArgs> | null
    /**
     * Filter, which Credit to fetch.
     */
    where: CreditWhereUniqueInput
  }


  /**
   * Credit findUniqueOrThrow
   */
  export type CreditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit
     */
    select?: CreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CreditInclude<ExtArgs> | null
    /**
     * Filter, which Credit to fetch.
     */
    where: CreditWhereUniqueInput
  }


  /**
   * Credit findFirst
   */
  export type CreditFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit
     */
    select?: CreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CreditInclude<ExtArgs> | null
    /**
     * Filter, which Credit to fetch.
     */
    where?: CreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credits to fetch.
     */
    orderBy?: CreditOrderByWithRelationInput | CreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Credits.
     */
    cursor?: CreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Credits.
     */
    distinct?: CreditScalarFieldEnum | CreditScalarFieldEnum[]
  }


  /**
   * Credit findFirstOrThrow
   */
  export type CreditFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit
     */
    select?: CreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CreditInclude<ExtArgs> | null
    /**
     * Filter, which Credit to fetch.
     */
    where?: CreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credits to fetch.
     */
    orderBy?: CreditOrderByWithRelationInput | CreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Credits.
     */
    cursor?: CreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Credits.
     */
    distinct?: CreditScalarFieldEnum | CreditScalarFieldEnum[]
  }


  /**
   * Credit findMany
   */
  export type CreditFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit
     */
    select?: CreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CreditInclude<ExtArgs> | null
    /**
     * Filter, which Credits to fetch.
     */
    where?: CreditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credits to fetch.
     */
    orderBy?: CreditOrderByWithRelationInput | CreditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Credits.
     */
    cursor?: CreditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credits.
     */
    skip?: number
    distinct?: CreditScalarFieldEnum | CreditScalarFieldEnum[]
  }


  /**
   * Credit create
   */
  export type CreditCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit
     */
    select?: CreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CreditInclude<ExtArgs> | null
    /**
     * The data needed to create a Credit.
     */
    data: XOR<CreditCreateInput, CreditUncheckedCreateInput>
  }


  /**
   * Credit createMany
   */
  export type CreditCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Credits.
     */
    data: CreditCreateManyInput | CreditCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Credit update
   */
  export type CreditUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit
     */
    select?: CreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CreditInclude<ExtArgs> | null
    /**
     * The data needed to update a Credit.
     */
    data: XOR<CreditUpdateInput, CreditUncheckedUpdateInput>
    /**
     * Choose, which Credit to update.
     */
    where: CreditWhereUniqueInput
  }


  /**
   * Credit updateMany
   */
  export type CreditUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Credits.
     */
    data: XOR<CreditUpdateManyMutationInput, CreditUncheckedUpdateManyInput>
    /**
     * Filter which Credits to update
     */
    where?: CreditWhereInput
  }


  /**
   * Credit upsert
   */
  export type CreditUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit
     */
    select?: CreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CreditInclude<ExtArgs> | null
    /**
     * The filter to search for the Credit to update in case it exists.
     */
    where: CreditWhereUniqueInput
    /**
     * In case the Credit found by the `where` argument doesn't exist, create a new Credit with this data.
     */
    create: XOR<CreditCreateInput, CreditUncheckedCreateInput>
    /**
     * In case the Credit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditUpdateInput, CreditUncheckedUpdateInput>
  }


  /**
   * Credit delete
   */
  export type CreditDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit
     */
    select?: CreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CreditInclude<ExtArgs> | null
    /**
     * Filter which Credit to delete.
     */
    where: CreditWhereUniqueInput
  }


  /**
   * Credit deleteMany
   */
  export type CreditDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Credits to delete
     */
    where?: CreditWhereInput
  }


  /**
   * Credit without action
   */
  export type CreditArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credit
     */
    select?: CreditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CreditInclude<ExtArgs> | null
  }



  /**
   * Model BillingAlert
   */


  export type AggregateBillingAlert = {
    _count: BillingAlertCountAggregateOutputType | null
    _avg: BillingAlertAvgAggregateOutputType | null
    _sum: BillingAlertSumAggregateOutputType | null
    _min: BillingAlertMinAggregateOutputType | null
    _max: BillingAlertMaxAggregateOutputType | null
  }

  export type BillingAlertAvgAggregateOutputType = {
    threshold: Decimal | null
    currentValue: Decimal | null
  }

  export type BillingAlertSumAggregateOutputType = {
    threshold: Decimal | null
    currentValue: Decimal | null
  }

  export type BillingAlertMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: BillingAlertType | null
    threshold: Decimal | null
    currentValue: Decimal | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
    readAt: Date | null
  }

  export type BillingAlertMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: BillingAlertType | null
    threshold: Decimal | null
    currentValue: Decimal | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
    readAt: Date | null
  }

  export type BillingAlertCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    threshold: number
    currentValue: number
    message: number
    isRead: number
    createdAt: number
    readAt: number
    metadata: number
    _all: number
  }


  export type BillingAlertAvgAggregateInputType = {
    threshold?: true
    currentValue?: true
  }

  export type BillingAlertSumAggregateInputType = {
    threshold?: true
    currentValue?: true
  }

  export type BillingAlertMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    threshold?: true
    currentValue?: true
    message?: true
    isRead?: true
    createdAt?: true
    readAt?: true
  }

  export type BillingAlertMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    threshold?: true
    currentValue?: true
    message?: true
    isRead?: true
    createdAt?: true
    readAt?: true
  }

  export type BillingAlertCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    threshold?: true
    currentValue?: true
    message?: true
    isRead?: true
    createdAt?: true
    readAt?: true
    metadata?: true
    _all?: true
  }

  export type BillingAlertAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingAlert to aggregate.
     */
    where?: BillingAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingAlerts to fetch.
     */
    orderBy?: BillingAlertOrderByWithRelationInput | BillingAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillingAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BillingAlerts
    **/
    _count?: true | BillingAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillingAlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillingAlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillingAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillingAlertMaxAggregateInputType
  }

  export type GetBillingAlertAggregateType<T extends BillingAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateBillingAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBillingAlert[P]>
      : GetScalarType<T[P], AggregateBillingAlert[P]>
  }




  export type BillingAlertGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BillingAlertWhereInput
    orderBy?: BillingAlertOrderByWithAggregationInput | BillingAlertOrderByWithAggregationInput[]
    by: BillingAlertScalarFieldEnum[] | BillingAlertScalarFieldEnum
    having?: BillingAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillingAlertCountAggregateInputType | true
    _avg?: BillingAlertAvgAggregateInputType
    _sum?: BillingAlertSumAggregateInputType
    _min?: BillingAlertMinAggregateInputType
    _max?: BillingAlertMaxAggregateInputType
  }


  export type BillingAlertGroupByOutputType = {
    id: string
    userId: string
    type: BillingAlertType
    threshold: Decimal | null
    currentValue: Decimal | null
    message: string
    isRead: boolean
    createdAt: Date
    readAt: Date | null
    metadata: JsonValue
    _count: BillingAlertCountAggregateOutputType | null
    _avg: BillingAlertAvgAggregateOutputType | null
    _sum: BillingAlertSumAggregateOutputType | null
    _min: BillingAlertMinAggregateOutputType | null
    _max: BillingAlertMaxAggregateOutputType | null
  }

  type GetBillingAlertGroupByPayload<T extends BillingAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillingAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillingAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillingAlertGroupByOutputType[P]>
            : GetScalarType<T[P], BillingAlertGroupByOutputType[P]>
        }
      >
    >


  export type BillingAlertSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    threshold?: boolean
    currentValue?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    readAt?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["billingAlert"]>

  export type BillingAlertSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    threshold?: boolean
    currentValue?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
    readAt?: boolean
    metadata?: boolean
  }


  type BillingAlertGetPayload<S extends boolean | null | undefined | BillingAlertArgs> = $Types.GetResult<BillingAlertPayload, S>

  type BillingAlertCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BillingAlertFindManyArgs, 'select' | 'include'> & {
      select?: BillingAlertCountAggregateInputType | true
    }

  export interface BillingAlertDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BillingAlert'], meta: { name: 'BillingAlert' } }
    /**
     * Find zero or one BillingAlert that matches the filter.
     * @param {BillingAlertFindUniqueArgs} args - Arguments to find a BillingAlert
     * @example
     * // Get one BillingAlert
     * const billingAlert = await prisma.billingAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BillingAlertFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BillingAlertFindUniqueArgs<ExtArgs>>
    ): Prisma__BillingAlertClient<$Types.GetResult<BillingAlertPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BillingAlert that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BillingAlertFindUniqueOrThrowArgs} args - Arguments to find a BillingAlert
     * @example
     * // Get one BillingAlert
     * const billingAlert = await prisma.billingAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BillingAlertFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BillingAlertFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BillingAlertClient<$Types.GetResult<BillingAlertPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BillingAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingAlertFindFirstArgs} args - Arguments to find a BillingAlert
     * @example
     * // Get one BillingAlert
     * const billingAlert = await prisma.billingAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BillingAlertFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BillingAlertFindFirstArgs<ExtArgs>>
    ): Prisma__BillingAlertClient<$Types.GetResult<BillingAlertPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BillingAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingAlertFindFirstOrThrowArgs} args - Arguments to find a BillingAlert
     * @example
     * // Get one BillingAlert
     * const billingAlert = await prisma.billingAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BillingAlertFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BillingAlertFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BillingAlertClient<$Types.GetResult<BillingAlertPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BillingAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingAlertFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BillingAlerts
     * const billingAlerts = await prisma.billingAlert.findMany()
     * 
     * // Get first 10 BillingAlerts
     * const billingAlerts = await prisma.billingAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const billingAlertWithIdOnly = await prisma.billingAlert.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BillingAlertFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BillingAlertFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<BillingAlertPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BillingAlert.
     * @param {BillingAlertCreateArgs} args - Arguments to create a BillingAlert.
     * @example
     * // Create one BillingAlert
     * const BillingAlert = await prisma.billingAlert.create({
     *   data: {
     *     // ... data to create a BillingAlert
     *   }
     * })
     * 
    **/
    create<T extends BillingAlertCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BillingAlertCreateArgs<ExtArgs>>
    ): Prisma__BillingAlertClient<$Types.GetResult<BillingAlertPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BillingAlerts.
     *     @param {BillingAlertCreateManyArgs} args - Arguments to create many BillingAlerts.
     *     @example
     *     // Create many BillingAlerts
     *     const billingAlert = await prisma.billingAlert.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BillingAlertCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BillingAlertCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BillingAlert.
     * @param {BillingAlertDeleteArgs} args - Arguments to delete one BillingAlert.
     * @example
     * // Delete one BillingAlert
     * const BillingAlert = await prisma.billingAlert.delete({
     *   where: {
     *     // ... filter to delete one BillingAlert
     *   }
     * })
     * 
    **/
    delete<T extends BillingAlertDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BillingAlertDeleteArgs<ExtArgs>>
    ): Prisma__BillingAlertClient<$Types.GetResult<BillingAlertPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BillingAlert.
     * @param {BillingAlertUpdateArgs} args - Arguments to update one BillingAlert.
     * @example
     * // Update one BillingAlert
     * const billingAlert = await prisma.billingAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BillingAlertUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BillingAlertUpdateArgs<ExtArgs>>
    ): Prisma__BillingAlertClient<$Types.GetResult<BillingAlertPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BillingAlerts.
     * @param {BillingAlertDeleteManyArgs} args - Arguments to filter BillingAlerts to delete.
     * @example
     * // Delete a few BillingAlerts
     * const { count } = await prisma.billingAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BillingAlertDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BillingAlertDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BillingAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BillingAlerts
     * const billingAlert = await prisma.billingAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BillingAlertUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BillingAlertUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BillingAlert.
     * @param {BillingAlertUpsertArgs} args - Arguments to update or create a BillingAlert.
     * @example
     * // Update or create a BillingAlert
     * const billingAlert = await prisma.billingAlert.upsert({
     *   create: {
     *     // ... data to create a BillingAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BillingAlert we want to update
     *   }
     * })
    **/
    upsert<T extends BillingAlertUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BillingAlertUpsertArgs<ExtArgs>>
    ): Prisma__BillingAlertClient<$Types.GetResult<BillingAlertPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BillingAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingAlertCountArgs} args - Arguments to filter BillingAlerts to count.
     * @example
     * // Count the number of BillingAlerts
     * const count = await prisma.billingAlert.count({
     *   where: {
     *     // ... the filter for the BillingAlerts we want to count
     *   }
     * })
    **/
    count<T extends BillingAlertCountArgs>(
      args?: Subset<T, BillingAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillingAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BillingAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillingAlertAggregateArgs>(args: Subset<T, BillingAlertAggregateArgs>): Prisma.PrismaPromise<GetBillingAlertAggregateType<T>>

    /**
     * Group by BillingAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillingAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillingAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillingAlertGroupByArgs['orderBy'] }
        : { orderBy?: BillingAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillingAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillingAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BillingAlert model
   */
  readonly fields: BillingAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BillingAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BillingAlertClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the BillingAlert model
   */ 
  interface BillingAlertFieldRefs {
    readonly id: FieldRef<"BillingAlert", 'String'>
    readonly userId: FieldRef<"BillingAlert", 'String'>
    readonly type: FieldRef<"BillingAlert", 'BillingAlertType'>
    readonly threshold: FieldRef<"BillingAlert", 'Decimal'>
    readonly currentValue: FieldRef<"BillingAlert", 'Decimal'>
    readonly message: FieldRef<"BillingAlert", 'String'>
    readonly isRead: FieldRef<"BillingAlert", 'Boolean'>
    readonly createdAt: FieldRef<"BillingAlert", 'DateTime'>
    readonly readAt: FieldRef<"BillingAlert", 'DateTime'>
    readonly metadata: FieldRef<"BillingAlert", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * BillingAlert findUnique
   */
  export type BillingAlertFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingAlert
     */
    select?: BillingAlertSelect<ExtArgs> | null
    /**
     * Filter, which BillingAlert to fetch.
     */
    where: BillingAlertWhereUniqueInput
  }


  /**
   * BillingAlert findUniqueOrThrow
   */
  export type BillingAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingAlert
     */
    select?: BillingAlertSelect<ExtArgs> | null
    /**
     * Filter, which BillingAlert to fetch.
     */
    where: BillingAlertWhereUniqueInput
  }


  /**
   * BillingAlert findFirst
   */
  export type BillingAlertFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingAlert
     */
    select?: BillingAlertSelect<ExtArgs> | null
    /**
     * Filter, which BillingAlert to fetch.
     */
    where?: BillingAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingAlerts to fetch.
     */
    orderBy?: BillingAlertOrderByWithRelationInput | BillingAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingAlerts.
     */
    cursor?: BillingAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingAlerts.
     */
    distinct?: BillingAlertScalarFieldEnum | BillingAlertScalarFieldEnum[]
  }


  /**
   * BillingAlert findFirstOrThrow
   */
  export type BillingAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingAlert
     */
    select?: BillingAlertSelect<ExtArgs> | null
    /**
     * Filter, which BillingAlert to fetch.
     */
    where?: BillingAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingAlerts to fetch.
     */
    orderBy?: BillingAlertOrderByWithRelationInput | BillingAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BillingAlerts.
     */
    cursor?: BillingAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BillingAlerts.
     */
    distinct?: BillingAlertScalarFieldEnum | BillingAlertScalarFieldEnum[]
  }


  /**
   * BillingAlert findMany
   */
  export type BillingAlertFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingAlert
     */
    select?: BillingAlertSelect<ExtArgs> | null
    /**
     * Filter, which BillingAlerts to fetch.
     */
    where?: BillingAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BillingAlerts to fetch.
     */
    orderBy?: BillingAlertOrderByWithRelationInput | BillingAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BillingAlerts.
     */
    cursor?: BillingAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BillingAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BillingAlerts.
     */
    skip?: number
    distinct?: BillingAlertScalarFieldEnum | BillingAlertScalarFieldEnum[]
  }


  /**
   * BillingAlert create
   */
  export type BillingAlertCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingAlert
     */
    select?: BillingAlertSelect<ExtArgs> | null
    /**
     * The data needed to create a BillingAlert.
     */
    data: XOR<BillingAlertCreateInput, BillingAlertUncheckedCreateInput>
  }


  /**
   * BillingAlert createMany
   */
  export type BillingAlertCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BillingAlerts.
     */
    data: BillingAlertCreateManyInput | BillingAlertCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * BillingAlert update
   */
  export type BillingAlertUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingAlert
     */
    select?: BillingAlertSelect<ExtArgs> | null
    /**
     * The data needed to update a BillingAlert.
     */
    data: XOR<BillingAlertUpdateInput, BillingAlertUncheckedUpdateInput>
    /**
     * Choose, which BillingAlert to update.
     */
    where: BillingAlertWhereUniqueInput
  }


  /**
   * BillingAlert updateMany
   */
  export type BillingAlertUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BillingAlerts.
     */
    data: XOR<BillingAlertUpdateManyMutationInput, BillingAlertUncheckedUpdateManyInput>
    /**
     * Filter which BillingAlerts to update
     */
    where?: BillingAlertWhereInput
  }


  /**
   * BillingAlert upsert
   */
  export type BillingAlertUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingAlert
     */
    select?: BillingAlertSelect<ExtArgs> | null
    /**
     * The filter to search for the BillingAlert to update in case it exists.
     */
    where: BillingAlertWhereUniqueInput
    /**
     * In case the BillingAlert found by the `where` argument doesn't exist, create a new BillingAlert with this data.
     */
    create: XOR<BillingAlertCreateInput, BillingAlertUncheckedCreateInput>
    /**
     * In case the BillingAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillingAlertUpdateInput, BillingAlertUncheckedUpdateInput>
  }


  /**
   * BillingAlert delete
   */
  export type BillingAlertDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingAlert
     */
    select?: BillingAlertSelect<ExtArgs> | null
    /**
     * Filter which BillingAlert to delete.
     */
    where: BillingAlertWhereUniqueInput
  }


  /**
   * BillingAlert deleteMany
   */
  export type BillingAlertDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BillingAlerts to delete
     */
    where?: BillingAlertWhereInput
  }


  /**
   * BillingAlert without action
   */
  export type BillingAlertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BillingAlert
     */
    select?: BillingAlertSelect<ExtArgs> | null
  }



  /**
   * Model Plan
   */


  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  export type PlanAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PlanSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    amount: Decimal | null
    currency: string | null
    interval: PlanInterval | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    amount: Decimal | null
    currency: string | null
    interval: PlanInterval | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanCountAggregateOutputType = {
    id: number
    name: number
    description: number
    amount: number
    currency: number
    interval: number
    features: number
    limits: number
    createdAt: number
    updatedAt: number
    metadata: number
    _all: number
  }


  export type PlanAvgAggregateInputType = {
    amount?: true
  }

  export type PlanSumAggregateInputType = {
    amount?: true
  }

  export type PlanMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    amount?: true
    currency?: true
    interval?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    amount?: true
    currency?: true
    interval?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    amount?: true
    currency?: true
    interval?: true
    features?: true
    limits?: true
    createdAt?: true
    updatedAt?: true
    metadata?: true
    _all?: true
  }

  export type PlanAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plan to aggregate.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plans
    **/
    _count?: true | PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaxAggregateInputType
  }

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>
  }




  export type PlanGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithAggregationInput | PlanOrderByWithAggregationInput[]
    by: PlanScalarFieldEnum[] | PlanScalarFieldEnum
    having?: PlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCountAggregateInputType | true
    _avg?: PlanAvgAggregateInputType
    _sum?: PlanSumAggregateInputType
    _min?: PlanMinAggregateInputType
    _max?: PlanMaxAggregateInputType
  }


  export type PlanGroupByOutputType = {
    id: string
    name: string
    description: string | null
    amount: Decimal
    currency: string
    interval: PlanInterval
    features: string[]
    limits: JsonValue
    createdAt: Date
    updatedAt: Date
    metadata: JsonValue
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  type GetPlanGroupByPayload<T extends PlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
        }
      >
    >


  export type PlanSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    amount?: boolean
    currency?: boolean
    interval?: boolean
    features?: boolean
    limits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    amount?: boolean
    currency?: boolean
    interval?: boolean
    features?: boolean
    limits?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
  }


  type PlanGetPayload<S extends boolean | null | undefined | PlanArgs> = $Types.GetResult<PlanPayload, S>

  type PlanCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PlanFindManyArgs, 'select' | 'include'> & {
      select?: PlanCountAggregateInputType | true
    }

  export interface PlanDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plan'], meta: { name: 'Plan' } }
    /**
     * Find zero or one Plan that matches the filter.
     * @param {PlanFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PlanFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PlanFindUniqueArgs<ExtArgs>>
    ): Prisma__PlanClient<$Types.GetResult<PlanPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Plan that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PlanFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PlanFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PlanFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PlanClient<$Types.GetResult<PlanPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PlanFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PlanFindFirstArgs<ExtArgs>>
    ): Prisma__PlanClient<$Types.GetResult<PlanPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PlanFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PlanFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PlanClient<$Types.GetResult<PlanPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planWithIdOnly = await prisma.plan.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PlanFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlanFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PlanPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Plan.
     * @param {PlanCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     * 
    **/
    create<T extends PlanCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PlanCreateArgs<ExtArgs>>
    ): Prisma__PlanClient<$Types.GetResult<PlanPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Plans.
     *     @param {PlanCreateManyArgs} args - Arguments to create many Plans.
     *     @example
     *     // Create many Plans
     *     const plan = await prisma.plan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PlanCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlanCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Plan.
     * @param {PlanDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     * 
    **/
    delete<T extends PlanDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PlanDeleteArgs<ExtArgs>>
    ): Prisma__PlanClient<$Types.GetResult<PlanPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Plan.
     * @param {PlanUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PlanUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PlanUpdateArgs<ExtArgs>>
    ): Prisma__PlanClient<$Types.GetResult<PlanPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Plans.
     * @param {PlanDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PlanDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PlanDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PlanUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PlanUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Plan.
     * @param {PlanUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
    **/
    upsert<T extends PlanUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PlanUpsertArgs<ExtArgs>>
    ): Prisma__PlanClient<$Types.GetResult<PlanPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends PlanCountArgs>(
      args?: Subset<T, PlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanAggregateArgs>(args: Subset<T, PlanAggregateArgs>): Prisma.PrismaPromise<GetPlanAggregateType<T>>

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanGroupByArgs['orderBy'] }
        : { orderBy?: PlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plan model
   */
  readonly fields: PlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PlanClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the Plan model
   */ 
  interface PlanFieldRefs {
    readonly id: FieldRef<"Plan", 'String'>
    readonly name: FieldRef<"Plan", 'String'>
    readonly description: FieldRef<"Plan", 'String'>
    readonly amount: FieldRef<"Plan", 'Decimal'>
    readonly currency: FieldRef<"Plan", 'String'>
    readonly interval: FieldRef<"Plan", 'PlanInterval'>
    readonly features: FieldRef<"Plan", 'String[]'>
    readonly limits: FieldRef<"Plan", 'Json'>
    readonly createdAt: FieldRef<"Plan", 'DateTime'>
    readonly updatedAt: FieldRef<"Plan", 'DateTime'>
    readonly metadata: FieldRef<"Plan", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * Plan findUnique
   */
  export type PlanFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }


  /**
   * Plan findUniqueOrThrow
   */
  export type PlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }


  /**
   * Plan findFirst
   */
  export type PlanFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }


  /**
   * Plan findFirstOrThrow
   */
  export type PlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }


  /**
   * Plan findMany
   */
  export type PlanFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Filter, which Plans to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }


  /**
   * Plan create
   */
  export type PlanCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * The data needed to create a Plan.
     */
    data: XOR<PlanCreateInput, PlanUncheckedCreateInput>
  }


  /**
   * Plan createMany
   */
  export type PlanCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Plan update
   */
  export type PlanUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * The data needed to update a Plan.
     */
    data: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
    /**
     * Choose, which Plan to update.
     */
    where: PlanWhereUniqueInput
  }


  /**
   * Plan updateMany
   */
  export type PlanUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
  }


  /**
   * Plan upsert
   */
  export type PlanUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * The filter to search for the Plan to update in case it exists.
     */
    where: PlanWhereUniqueInput
    /**
     * In case the Plan found by the `where` argument doesn't exist, create a new Plan with this data.
     */
    create: XOR<PlanCreateInput, PlanUncheckedCreateInput>
    /**
     * In case the Plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
  }


  /**
   * Plan delete
   */
  export type PlanDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Filter which Plan to delete.
     */
    where: PlanWhereUniqueInput
  }


  /**
   * Plan deleteMany
   */
  export type PlanDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plans to delete
     */
    where?: PlanWhereInput
  }


  /**
   * Plan without action
   */
  export type PlanArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ClientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    domain: 'domain',
    apiKeys: 'apiKeys',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const ModuleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    version: 'version'
  };

  export type ModuleScalarFieldEnum = (typeof ModuleScalarFieldEnum)[keyof typeof ModuleScalarFieldEnum]


  export const ModuleOnClientScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    moduleId: 'moduleId',
    enabled: 'enabled'
  };

  export type ModuleOnClientScalarFieldEnum = (typeof ModuleOnClientScalarFieldEnum)[keyof typeof ModuleOnClientScalarFieldEnum]


  export const EnvironmentVariableScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    environment: 'environment',
    clientId: 'clientId'
  };

  export type EnvironmentVariableScalarFieldEnum = (typeof EnvironmentVariableScalarFieldEnum)[keyof typeof EnvironmentVariableScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    avatar: 'avatar',
    hashedPassword: 'hashedPassword',
    oauthProvider: 'oauthProvider',
    oauthId: 'oauthId',
    role: 'role',
    clientId: 'clientId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const LibraryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    displayName: 'displayName',
    description: 'description',
    vendor: 'vendor',
    repoUrl: 'repoUrl',
    docsUrl: 'docsUrl',
    defaultVersion: 'defaultVersion',
    popularityScore: 'popularityScore',
    totalSnippets: 'totalSnippets',
    totalTokens: 'totalTokens',
    language: 'language',
    ecosystem: 'ecosystem',
    tags: 'tags',
    metadata: 'metadata',
    clientId: 'clientId',
    lastCrawledAt: 'lastCrawledAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LibraryScalarFieldEnum = (typeof LibraryScalarFieldEnum)[keyof typeof LibraryScalarFieldEnum]


  export const LibraryVersionScalarFieldEnum: {
    id: 'id',
    libraryId: 'libraryId',
    version: 'version',
    releaseDate: 'releaseDate',
    isLatest: 'isLatest',
    docsSnapshotUrl: 'docsSnapshotUrl'
  };

  export type LibraryVersionScalarFieldEnum = (typeof LibraryVersionScalarFieldEnum)[keyof typeof LibraryVersionScalarFieldEnum]


  export const LibraryAliasScalarFieldEnum: {
    id: 'id',
    libraryId: 'libraryId',
    alias: 'alias'
  };

  export type LibraryAliasScalarFieldEnum = (typeof LibraryAliasScalarFieldEnum)[keyof typeof LibraryAliasScalarFieldEnum]


  export const DocumentationChunkScalarFieldEnum: {
    id: 'id',
    libraryVersionId: 'libraryVersionId',
    chunkIndex: 'chunkIndex',
    content: 'content',
    contentType: 'contentType',
    sourceUrl: 'sourceUrl',
    tokenCount: 'tokenCount',
    embeddingId: 'embeddingId',
    metadata: 'metadata',
    createdAt: 'createdAt',
    libraryId: 'libraryId'
  };

  export type DocumentationChunkScalarFieldEnum = (typeof DocumentationChunkScalarFieldEnum)[keyof typeof DocumentationChunkScalarFieldEnum]


  export const ApiKeyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    keyHash: 'keyHash',
    keyPrefix: 'keyPrefix',
    name: 'name',
    tier: 'tier',
    quotaDaily: 'quotaDaily',
    quotaMonthly: 'quotaMonthly',
    usedDaily: 'usedDaily',
    usedMonthly: 'usedMonthly',
    lastUsedAt: 'lastUsedAt',
    expiresAt: 'expiresAt',
    isActive: 'isActive',
    permissions: 'permissions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    revokedAt: 'revokedAt'
  };

  export type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]


  export const UsageLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    apiKeyId: 'apiKeyId',
    libraryId: 'libraryId',
    toolName: 'toolName',
    query: 'query',
    tokensReturned: 'tokensReturned',
    responseTimeMs: 'responseTimeMs',
    createdAt: 'createdAt'
  };

  export type UsageLogScalarFieldEnum = (typeof UsageLogScalarFieldEnum)[keyof typeof UsageLogScalarFieldEnum]


  export const MCPConfigurationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    configData: 'configData',
    status: 'status',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MCPConfigurationScalarFieldEnum = (typeof MCPConfigurationScalarFieldEnum)[keyof typeof MCPConfigurationScalarFieldEnum]


  export const OAuthTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    provider: 'provider',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type OAuthTokenScalarFieldEnum = (typeof OAuthTokenScalarFieldEnum)[keyof typeof OAuthTokenScalarFieldEnum]


  export const OAuthClientScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    clientSecretHash: 'clientSecretHash',
    name: 'name',
    redirectUris: 'redirectUris',
    allowedScopes: 'allowedScopes',
    grantTypes: 'grantTypes',
    requirePkce: 'requirePkce',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OAuthClientScalarFieldEnum = (typeof OAuthClientScalarFieldEnum)[keyof typeof OAuthClientScalarFieldEnum]


  export const OAuthAuthorizationCodeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    clientId: 'clientId',
    userId: 'userId',
    redirectUri: 'redirectUri',
    scopes: 'scopes',
    codeChallenge: 'codeChallenge',
    codeChallengeMethod: 'codeChallengeMethod',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type OAuthAuthorizationCodeScalarFieldEnum = (typeof OAuthAuthorizationCodeScalarFieldEnum)[keyof typeof OAuthAuthorizationCodeScalarFieldEnum]


  export const OAuthAccessTokenScalarFieldEnum: {
    id: 'id',
    tokenHash: 'tokenHash',
    clientId: 'clientId',
    userId: 'userId',
    scopes: 'scopes',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type OAuthAccessTokenScalarFieldEnum = (typeof OAuthAccessTokenScalarFieldEnum)[keyof typeof OAuthAccessTokenScalarFieldEnum]


  export const OAuthRefreshTokenScalarFieldEnum: {
    id: 'id',
    tokenHash: 'tokenHash',
    accessTokenId: 'accessTokenId',
    clientId: 'clientId',
    userId: 'userId',
    scopes: 'scopes',
    expiresAt: 'expiresAt',
    isRevoked: 'isRevoked',
    createdAt: 'createdAt'
  };

  export type OAuthRefreshTokenScalarFieldEnum = (typeof OAuthRefreshTokenScalarFieldEnum)[keyof typeof OAuthRefreshTokenScalarFieldEnum]


  export const DownloadTaskScalarFieldEnum: {
    id: 'id',
    type: 'type',
    source: 'source',
    options: 'options',
    priority: 'priority',
    status: 'status',
    progress: 'progress',
    metadata: 'metadata',
    created_at: 'created_at',
    started_at: 'started_at',
    completed_at: 'completed_at',
    error: 'error',
    retry_count: 'retry_count'
  };

  export type DownloadTaskScalarFieldEnum = (typeof DownloadTaskScalarFieldEnum)[keyof typeof DownloadTaskScalarFieldEnum]


  export const DownloadResultScalarFieldEnum: {
    id: 'id',
    task_id: 'task_id',
    success: 'success',
    local_path: 'local_path',
    metadata: 'metadata',
    files: 'files',
    errors: 'errors',
    created_at: 'created_at'
  };

  export type DownloadResultScalarFieldEnum = (typeof DownloadResultScalarFieldEnum)[keyof typeof DownloadResultScalarFieldEnum]


  export const PromptCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    parentCategory: 'parentCategory',
    icon: 'icon',
    color: 'color',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PromptCategoryScalarFieldEnum = (typeof PromptCategoryScalarFieldEnum)[keyof typeof PromptCategoryScalarFieldEnum]


  export const PromptTemplateScalarFieldEnum: {
    id: 'id',
    version: 'version',
    name: 'name',
    description: 'description',
    category: 'category',
    status: 'status',
    template: 'template',
    variables: 'variables',
    examples: 'examples',
    metadata: 'metadata',
    constraints: 'constraints',
    optimization: 'optimization',
    testing: 'testing',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PromptTemplateScalarFieldEnum = (typeof PromptTemplateScalarFieldEnum)[keyof typeof PromptTemplateScalarFieldEnum]


  export const TemplateChangeScalarFieldEnum: {
    id: 'id',
    templateId: 'templateId',
    fromVersion: 'fromVersion',
    toVersion: 'toVersion',
    changes: 'changes',
    createdAt: 'createdAt'
  };

  export type TemplateChangeScalarFieldEnum = (typeof TemplateChangeScalarFieldEnum)[keyof typeof TemplateChangeScalarFieldEnum]


  export const PromptExecutionScalarFieldEnum: {
    id: 'id',
    templateId: 'templateId',
    templateVersion: 'templateVersion',
    variables: 'variables',
    renderedPrompt: 'renderedPrompt',
    context: 'context',
    model: 'model',
    provider: 'provider',
    response: 'response',
    metrics: 'metrics',
    quality: 'quality',
    feedback: 'feedback',
    abTestVariant: 'abTestVariant',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type PromptExecutionScalarFieldEnum = (typeof PromptExecutionScalarFieldEnum)[keyof typeof PromptExecutionScalarFieldEnum]


  export const PromptExecutionErrorScalarFieldEnum: {
    id: 'id',
    templateId: 'templateId',
    variables: 'variables',
    errorMessage: 'errorMessage',
    context: 'context',
    createdAt: 'createdAt'
  };

  export type PromptExecutionErrorScalarFieldEnum = (typeof PromptExecutionErrorScalarFieldEnum)[keyof typeof PromptExecutionErrorScalarFieldEnum]


  export const ABTestScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    variants: 'variants',
    trafficSplit: 'trafficSplit',
    startDate: 'startDate',
    endDate: 'endDate',
    sampleSize: 'sampleSize',
    confidence: 'confidence',
    results: 'results',
    createdAt: 'createdAt'
  };

  export type ABTestScalarFieldEnum = (typeof ABTestScalarFieldEnum)[keyof typeof ABTestScalarFieldEnum]


  export const OptimizationRecordScalarFieldEnum: {
    id: 'id',
    templateId: 'templateId',
    timestamp: 'timestamp',
    type: 'type',
    reason: 'reason',
    changes: 'changes',
    metricsBefore: 'metricsBefore',
    metricsAfter: 'metricsAfter',
    improvement: 'improvement',
    createdAt: 'createdAt'
  };

  export type OptimizationRecordScalarFieldEnum = (typeof OptimizationRecordScalarFieldEnum)[keyof typeof OptimizationRecordScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    metadata: 'metadata',
    settings: 'settings',
    analytics: 'analytics',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    role: 'role',
    content: 'content',
    timestamp: 'timestamp',
    metadata: 'metadata'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const MessageReactionScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    userId: 'userId',
    emoji: 'emoji',
    timestamp: 'timestamp'
  };

  export type MessageReactionScalarFieldEnum = (typeof MessageReactionScalarFieldEnum)[keyof typeof MessageReactionScalarFieldEnum]


  export const MessageAttachmentScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    type: 'type',
    name: 'name',
    url: 'url',
    size: 'size',
    mimeType: 'mimeType',
    metadata: 'metadata',
    thumbnail: 'thumbnail'
  };

  export type MessageAttachmentScalarFieldEnum = (typeof MessageAttachmentScalarFieldEnum)[keyof typeof MessageAttachmentScalarFieldEnum]


  export const ConversationShareScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    shareId: 'shareId',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    permissions: 'permissions',
    settings: 'settings',
    analytics: 'analytics'
  };

  export type ConversationShareScalarFieldEnum = (typeof ConversationShareScalarFieldEnum)[keyof typeof ConversationShareScalarFieldEnum]


  export const ConversationExportScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    format: 'format',
    options: 'options',
    status: 'status',
    downloadUrl: 'downloadUrl',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    completedAt: 'completedAt',
    error: 'error'
  };

  export type ConversationExportScalarFieldEnum = (typeof ConversationExportScalarFieldEnum)[keyof typeof ConversationExportScalarFieldEnum]


  export const ContextSourceScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    content: 'content',
    url: 'url',
    libraryId: 'libraryId',
    version: 'version',
    language: 'language',
    tags: 'tags',
    relevanceScore: 'relevanceScore',
    freshness: 'freshness',
    popularity: 'popularity',
    lastUpdated: 'lastUpdated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContextSourceScalarFieldEnum = (typeof ContextSourceScalarFieldEnum)[keyof typeof ContextSourceScalarFieldEnum]


  export const ContextChunkScalarFieldEnum: {
    id: 'id',
    sourceId: 'sourceId',
    content: 'content',
    positionStart: 'positionStart',
    positionEnd: 'positionEnd',
    positionIndex: 'positionIndex',
    positionTotal: 'positionTotal',
    sectionTitle: 'sectionTitle',
    codeBlocks: 'codeBlocks',
    links: 'links',
    images: 'images',
    complexity: 'complexity',
    embedding: 'embedding',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContextChunkScalarFieldEnum = (typeof ContextChunkScalarFieldEnum)[keyof typeof ContextChunkScalarFieldEnum]


  export const ContextQueryScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    messageId: 'messageId',
    queryText: 'queryText',
    intentType: 'intentType',
    intentConfidence: 'intentConfidence',
    intentKeywords: 'intentKeywords',
    intentCategory: 'intentCategory',
    intentSubcategory: 'intentSubcategory',
    entities: 'entities',
    filters: 'filters',
    options: 'options',
    createdAt: 'createdAt'
  };

  export type ContextQueryScalarFieldEnum = (typeof ContextQueryScalarFieldEnum)[keyof typeof ContextQueryScalarFieldEnum]


  export const ContextResultScalarFieldEnum: {
    id: 'id',
    queryId: 'queryId',
    sources: 'sources',
    chunks: 'chunks',
    summary: 'summary',
    totalSources: 'totalSources',
    totalChunks: 'totalChunks',
    queryTime: 'queryTime',
    relevanceScore: 'relevanceScore',
    coverage: 'coverage',
    freshness: 'freshness',
    suggestions: 'suggestions',
    createdAt: 'createdAt'
  };

  export type ContextResultScalarFieldEnum = (typeof ContextResultScalarFieldEnum)[keyof typeof ContextResultScalarFieldEnum]


  export const ContextInjectionScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    messageId: 'messageId',
    context: 'context',
    templateId: 'templateId',
    injectedPrompt: 'injectedPrompt',
    originalLength: 'originalLength',
    injectedLength: 'injectedLength',
    compressionRatio: 'compressionRatio',
    relevanceScore: 'relevanceScore',
    createdAt: 'createdAt'
  };

  export type ContextInjectionScalarFieldEnum = (typeof ContextInjectionScalarFieldEnum)[keyof typeof ContextInjectionScalarFieldEnum]


  export const ContextTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    template: 'template',
    variables: 'variables',
    description: 'description',
    version: 'version',
    usageCount: 'usageCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContextTemplateScalarFieldEnum = (typeof ContextTemplateScalarFieldEnum)[keyof typeof ContextTemplateScalarFieldEnum]


  export const ContextQueryAnalyticsScalarFieldEnum: {
    id: 'id',
    queryId: 'queryId',
    conversationId: 'conversationId',
    queryText: 'queryText',
    intent: 'intent',
    entities: 'entities',
    filters: 'filters',
    options: 'options',
    resultMetadata: 'resultMetadata',
    createdAt: 'createdAt'
  };

  export type ContextQueryAnalyticsScalarFieldEnum = (typeof ContextQueryAnalyticsScalarFieldEnum)[keyof typeof ContextQueryAnalyticsScalarFieldEnum]


  export const ContextCacheScalarFieldEnum: {
    id: 'id',
    cacheKey: 'cacheKey',
    queryText: 'queryText',
    result: 'result',
    expiresAt: 'expiresAt',
    hitCount: 'hitCount',
    lastAccessed: 'lastAccessed',
    createdAt: 'createdAt'
  };

  export type ContextCacheScalarFieldEnum = (typeof ContextCacheScalarFieldEnum)[keyof typeof ContextCacheScalarFieldEnum]


  export const UserPreferencesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    preferences: 'preferences',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserPreferencesScalarFieldEnum = (typeof UserPreferencesScalarFieldEnum)[keyof typeof UserPreferencesScalarFieldEnum]


  export const ThemeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    colors: 'colors',
    typography: 'typography',
    spacing: 'spacing',
    shadows: 'shadows',
    borderRadius: 'borderRadius',
    animations: 'animations',
    custom: 'custom',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ThemeScalarFieldEnum = (typeof ThemeScalarFieldEnum)[keyof typeof ThemeScalarFieldEnum]


  export const PersonalizationAnalyticsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    actionType: 'actionType',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type PersonalizationAnalyticsScalarFieldEnum = (typeof PersonalizationAnalyticsScalarFieldEnum)[keyof typeof PersonalizationAnalyticsScalarFieldEnum]


  export const UserProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    address: 'address',
    city: 'city',
    state: 'state',
    country: 'country',
    postalCode: 'postalCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    number: 'number',
    userId: 'userId',
    status: 'status',
    period: 'period',
    issueDate: 'issueDate',
    dueDate: 'dueDate',
    paidDate: 'paidDate',
    subtotal: 'subtotal',
    tax: 'tax',
    total: 'total',
    currency: 'currency',
    items: 'items',
    billingAddress: 'billingAddress',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    userId: 'userId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    providerTransactionId: 'providerTransactionId',
    failureReason: 'failureReason',
    refundedAmount: 'refundedAmount',
    createdAt: 'createdAt',
    processedAt: 'processedAt',
    metadata: 'metadata'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    plan: 'plan',
    status: 'status',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    cancelAtPeriodEnd: 'cancelAtPeriodEnd',
    amount: 'amount',
    currency: 'currency',
    interval: 'interval',
    intervalCount: 'intervalCount',
    trialStart: 'trialStart',
    trialEnd: 'trialEnd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    metadata: 'metadata'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const CreditScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    currency: 'currency',
    reason: 'reason',
    type: 'type',
    expiresAt: 'expiresAt',
    usedAt: 'usedAt',
    invoiceId: 'invoiceId',
    createdAt: 'createdAt',
    metadata: 'metadata'
  };

  export type CreditScalarFieldEnum = (typeof CreditScalarFieldEnum)[keyof typeof CreditScalarFieldEnum]


  export const BillingAlertScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    threshold: 'threshold',
    currentValue: 'currentValue',
    message: 'message',
    isRead: 'isRead',
    createdAt: 'createdAt',
    readAt: 'readAt',
    metadata: 'metadata'
  };

  export type BillingAlertScalarFieldEnum = (typeof BillingAlertScalarFieldEnum)[keyof typeof BillingAlertScalarFieldEnum]


  export const PlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    amount: 'amount',
    currency: 'currency',
    interval: 'interval',
    features: 'features',
    limits: 'limits',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    metadata: 'metadata'
  };

  export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Environment'
   */
  export type EnumEnvironmentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Environment'>
    


  /**
   * Reference to a field of type 'Environment[]'
   */
  export type ListEnumEnvironmentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Environment[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ConfigStatus'
   */
  export type EnumConfigStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConfigStatus'>
    


  /**
   * Reference to a field of type 'ConfigStatus[]'
   */
  export type ListEnumConfigStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConfigStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'SubscriptionInterval'
   */
  export type EnumSubscriptionIntervalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionInterval'>
    


  /**
   * Reference to a field of type 'SubscriptionInterval[]'
   */
  export type ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionInterval[]'>
    


  /**
   * Reference to a field of type 'CreditType'
   */
  export type EnumCreditTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreditType'>
    


  /**
   * Reference to a field of type 'CreditType[]'
   */
  export type ListEnumCreditTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreditType[]'>
    


  /**
   * Reference to a field of type 'BillingAlertType'
   */
  export type EnumBillingAlertTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingAlertType'>
    


  /**
   * Reference to a field of type 'BillingAlertType[]'
   */
  export type ListEnumBillingAlertTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingAlertType[]'>
    


  /**
   * Reference to a field of type 'PlanInterval'
   */
  export type EnumPlanIntervalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanInterval'>
    


  /**
   * Reference to a field of type 'PlanInterval[]'
   */
  export type ListEnumPlanIntervalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanInterval[]'>
    
  /**
   * Deep Input Types
   */


  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    domain?: StringNullableFilter<"Client"> | string | null
    apiKeys?: JsonFilter<"Client">
    settings?: JsonNullableFilter<"Client">
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    modules?: ModuleOnClientListRelationFilter
    environmentVariables?: EnvironmentVariableListRelationFilter
    users?: UserListRelationFilter
    libraries?: LibraryListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrderInput | SortOrder
    apiKeys?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    modules?: ModuleOnClientOrderByRelationAggregateInput
    environmentVariables?: EnvironmentVariableOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    libraries?: LibraryOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    domain?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    apiKeys?: JsonFilter<"Client">
    settings?: JsonNullableFilter<"Client">
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    modules?: ModuleOnClientListRelationFilter
    environmentVariables?: EnvironmentVariableListRelationFilter
    users?: UserListRelationFilter
    libraries?: LibraryListRelationFilter
  }, "id" | "name" | "domain">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrderInput | SortOrder
    apiKeys?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    name?: StringWithAggregatesFilter<"Client"> | string
    domain?: StringNullableWithAggregatesFilter<"Client"> | string | null
    apiKeys?: JsonWithAggregatesFilter<"Client">
    settings?: JsonNullableWithAggregatesFilter<"Client">
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
  }

  export type ModuleWhereInput = {
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    id?: StringFilter<"Module"> | string
    name?: StringFilter<"Module"> | string
    description?: StringNullableFilter<"Module"> | string | null
    version?: StringNullableFilter<"Module"> | string | null
    clients?: ModuleOnClientListRelationFilter
  }

  export type ModuleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    clients?: ModuleOnClientOrderByRelationAggregateInput
  }

  export type ModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    description?: StringNullableFilter<"Module"> | string | null
    version?: StringNullableFilter<"Module"> | string | null
    clients?: ModuleOnClientListRelationFilter
  }, "id" | "name">

  export type ModuleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    _count?: ModuleCountOrderByAggregateInput
    _max?: ModuleMaxOrderByAggregateInput
    _min?: ModuleMinOrderByAggregateInput
  }

  export type ModuleScalarWhereWithAggregatesInput = {
    AND?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    OR?: ModuleScalarWhereWithAggregatesInput[]
    NOT?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Module"> | string
    name?: StringWithAggregatesFilter<"Module"> | string
    description?: StringNullableWithAggregatesFilter<"Module"> | string | null
    version?: StringNullableWithAggregatesFilter<"Module"> | string | null
  }

  export type ModuleOnClientWhereInput = {
    AND?: ModuleOnClientWhereInput | ModuleOnClientWhereInput[]
    OR?: ModuleOnClientWhereInput[]
    NOT?: ModuleOnClientWhereInput | ModuleOnClientWhereInput[]
    id?: StringFilter<"ModuleOnClient"> | string
    clientId?: StringFilter<"ModuleOnClient"> | string
    moduleId?: StringFilter<"ModuleOnClient"> | string
    enabled?: BoolFilter<"ModuleOnClient"> | boolean
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    module?: XOR<ModuleRelationFilter, ModuleWhereInput>
  }

  export type ModuleOnClientOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    moduleId?: SortOrder
    enabled?: SortOrder
    client?: ClientOrderByWithRelationInput
    module?: ModuleOrderByWithRelationInput
  }

  export type ModuleOnClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId_moduleId?: ModuleOnClientClientIdModuleIdCompoundUniqueInput
    AND?: ModuleOnClientWhereInput | ModuleOnClientWhereInput[]
    OR?: ModuleOnClientWhereInput[]
    NOT?: ModuleOnClientWhereInput | ModuleOnClientWhereInput[]
    clientId?: StringFilter<"ModuleOnClient"> | string
    moduleId?: StringFilter<"ModuleOnClient"> | string
    enabled?: BoolFilter<"ModuleOnClient"> | boolean
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    module?: XOR<ModuleRelationFilter, ModuleWhereInput>
  }, "id" | "clientId_moduleId">

  export type ModuleOnClientOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    moduleId?: SortOrder
    enabled?: SortOrder
    _count?: ModuleOnClientCountOrderByAggregateInput
    _max?: ModuleOnClientMaxOrderByAggregateInput
    _min?: ModuleOnClientMinOrderByAggregateInput
  }

  export type ModuleOnClientScalarWhereWithAggregatesInput = {
    AND?: ModuleOnClientScalarWhereWithAggregatesInput | ModuleOnClientScalarWhereWithAggregatesInput[]
    OR?: ModuleOnClientScalarWhereWithAggregatesInput[]
    NOT?: ModuleOnClientScalarWhereWithAggregatesInput | ModuleOnClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ModuleOnClient"> | string
    clientId?: StringWithAggregatesFilter<"ModuleOnClient"> | string
    moduleId?: StringWithAggregatesFilter<"ModuleOnClient"> | string
    enabled?: BoolWithAggregatesFilter<"ModuleOnClient"> | boolean
  }

  export type EnvironmentVariableWhereInput = {
    AND?: EnvironmentVariableWhereInput | EnvironmentVariableWhereInput[]
    OR?: EnvironmentVariableWhereInput[]
    NOT?: EnvironmentVariableWhereInput | EnvironmentVariableWhereInput[]
    id?: StringFilter<"EnvironmentVariable"> | string
    key?: StringFilter<"EnvironmentVariable"> | string
    value?: StringFilter<"EnvironmentVariable"> | string
    environment?: EnumEnvironmentFilter<"EnvironmentVariable"> | Environment
    clientId?: StringFilter<"EnvironmentVariable"> | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
  }

  export type EnvironmentVariableOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    environment?: SortOrder
    clientId?: SortOrder
    client?: ClientOrderByWithRelationInput
  }

  export type EnvironmentVariableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key_environment_clientId?: EnvironmentVariableKeyEnvironmentClientIdCompoundUniqueInput
    AND?: EnvironmentVariableWhereInput | EnvironmentVariableWhereInput[]
    OR?: EnvironmentVariableWhereInput[]
    NOT?: EnvironmentVariableWhereInput | EnvironmentVariableWhereInput[]
    key?: StringFilter<"EnvironmentVariable"> | string
    value?: StringFilter<"EnvironmentVariable"> | string
    environment?: EnumEnvironmentFilter<"EnvironmentVariable"> | Environment
    clientId?: StringFilter<"EnvironmentVariable"> | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
  }, "id" | "key_environment_clientId">

  export type EnvironmentVariableOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    environment?: SortOrder
    clientId?: SortOrder
    _count?: EnvironmentVariableCountOrderByAggregateInput
    _max?: EnvironmentVariableMaxOrderByAggregateInput
    _min?: EnvironmentVariableMinOrderByAggregateInput
  }

  export type EnvironmentVariableScalarWhereWithAggregatesInput = {
    AND?: EnvironmentVariableScalarWhereWithAggregatesInput | EnvironmentVariableScalarWhereWithAggregatesInput[]
    OR?: EnvironmentVariableScalarWhereWithAggregatesInput[]
    NOT?: EnvironmentVariableScalarWhereWithAggregatesInput | EnvironmentVariableScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EnvironmentVariable"> | string
    key?: StringWithAggregatesFilter<"EnvironmentVariable"> | string
    value?: StringWithAggregatesFilter<"EnvironmentVariable"> | string
    environment?: EnumEnvironmentWithAggregatesFilter<"EnvironmentVariable"> | Environment
    clientId?: StringWithAggregatesFilter<"EnvironmentVariable"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    hashedPassword?: StringNullableFilter<"User"> | string | null
    oauthProvider?: StringNullableFilter<"User"> | string | null
    oauthId?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | Role
    clientId?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    apiKeys?: ApiKeyListRelationFilter
    mcpConfigurations?: MCPConfigurationListRelationFilter
    usageLogs?: UsageLogListRelationFilter
    oauthTokens?: OAuthTokenListRelationFilter
    conversations?: ConversationListRelationFilter
    messageReactions?: MessageReactionListRelationFilter
    userPreferences?: XOR<UserPreferencesNullableRelationFilter, UserPreferencesWhereInput> | null
    themes?: ThemeListRelationFilter
    personalizationAnalytics?: PersonalizationAnalyticsListRelationFilter
    conversationShares?: ConversationShareListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    hashedPassword?: SortOrderInput | SortOrder
    oauthProvider?: SortOrderInput | SortOrder
    oauthId?: SortOrderInput | SortOrder
    role?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    apiKeys?: ApiKeyOrderByRelationAggregateInput
    mcpConfigurations?: MCPConfigurationOrderByRelationAggregateInput
    usageLogs?: UsageLogOrderByRelationAggregateInput
    oauthTokens?: OAuthTokenOrderByRelationAggregateInput
    conversations?: ConversationOrderByRelationAggregateInput
    messageReactions?: MessageReactionOrderByRelationAggregateInput
    userPreferences?: UserPreferencesOrderByWithRelationInput
    themes?: ThemeOrderByRelationAggregateInput
    personalizationAnalytics?: PersonalizationAnalyticsOrderByRelationAggregateInput
    conversationShares?: ConversationShareOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    hashedPassword?: StringNullableFilter<"User"> | string | null
    oauthProvider?: StringNullableFilter<"User"> | string | null
    oauthId?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | Role
    clientId?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    apiKeys?: ApiKeyListRelationFilter
    mcpConfigurations?: MCPConfigurationListRelationFilter
    usageLogs?: UsageLogListRelationFilter
    oauthTokens?: OAuthTokenListRelationFilter
    conversations?: ConversationListRelationFilter
    messageReactions?: MessageReactionListRelationFilter
    userPreferences?: XOR<UserPreferencesNullableRelationFilter, UserPreferencesWhereInput> | null
    themes?: ThemeListRelationFilter
    personalizationAnalytics?: PersonalizationAnalyticsListRelationFilter
    conversationShares?: ConversationShareListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    hashedPassword?: SortOrderInput | SortOrder
    oauthProvider?: SortOrderInput | SortOrder
    oauthId?: SortOrderInput | SortOrder
    role?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    hashedPassword?: StringNullableWithAggregatesFilter<"User"> | string | null
    oauthProvider?: StringNullableWithAggregatesFilter<"User"> | string | null
    oauthId?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | Role
    clientId?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type LibraryWhereInput = {
    AND?: LibraryWhereInput | LibraryWhereInput[]
    OR?: LibraryWhereInput[]
    NOT?: LibraryWhereInput | LibraryWhereInput[]
    id?: StringFilter<"Library"> | string
    name?: StringFilter<"Library"> | string
    displayName?: StringFilter<"Library"> | string
    description?: StringNullableFilter<"Library"> | string | null
    vendor?: StringNullableFilter<"Library"> | string | null
    repoUrl?: StringNullableFilter<"Library"> | string | null
    docsUrl?: StringNullableFilter<"Library"> | string | null
    defaultVersion?: StringNullableFilter<"Library"> | string | null
    popularityScore?: FloatFilter<"Library"> | number
    totalSnippets?: IntFilter<"Library"> | number
    totalTokens?: IntFilter<"Library"> | number
    language?: StringFilter<"Library"> | string
    ecosystem?: StringFilter<"Library"> | string
    tags?: StringNullableListFilter<"Library">
    metadata?: JsonNullableFilter<"Library">
    clientId?: StringFilter<"Library"> | string
    lastCrawledAt?: DateTimeNullableFilter<"Library"> | Date | string | null
    createdAt?: DateTimeFilter<"Library"> | Date | string
    updatedAt?: DateTimeFilter<"Library"> | Date | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    versions?: LibraryVersionListRelationFilter
    aliases?: LibraryAliasListRelationFilter
    documentationChunks?: DocumentationChunkListRelationFilter
    usageLogs?: UsageLogListRelationFilter
  }

  export type LibraryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    vendor?: SortOrderInput | SortOrder
    repoUrl?: SortOrderInput | SortOrder
    docsUrl?: SortOrderInput | SortOrder
    defaultVersion?: SortOrderInput | SortOrder
    popularityScore?: SortOrder
    totalSnippets?: SortOrder
    totalTokens?: SortOrder
    language?: SortOrder
    ecosystem?: SortOrder
    tags?: SortOrder
    metadata?: SortOrderInput | SortOrder
    clientId?: SortOrder
    lastCrawledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    versions?: LibraryVersionOrderByRelationAggregateInput
    aliases?: LibraryAliasOrderByRelationAggregateInput
    documentationChunks?: DocumentationChunkOrderByRelationAggregateInput
    usageLogs?: UsageLogOrderByRelationAggregateInput
  }

  export type LibraryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: LibraryWhereInput | LibraryWhereInput[]
    OR?: LibraryWhereInput[]
    NOT?: LibraryWhereInput | LibraryWhereInput[]
    displayName?: StringFilter<"Library"> | string
    description?: StringNullableFilter<"Library"> | string | null
    vendor?: StringNullableFilter<"Library"> | string | null
    repoUrl?: StringNullableFilter<"Library"> | string | null
    docsUrl?: StringNullableFilter<"Library"> | string | null
    defaultVersion?: StringNullableFilter<"Library"> | string | null
    popularityScore?: FloatFilter<"Library"> | number
    totalSnippets?: IntFilter<"Library"> | number
    totalTokens?: IntFilter<"Library"> | number
    language?: StringFilter<"Library"> | string
    ecosystem?: StringFilter<"Library"> | string
    tags?: StringNullableListFilter<"Library">
    metadata?: JsonNullableFilter<"Library">
    clientId?: StringFilter<"Library"> | string
    lastCrawledAt?: DateTimeNullableFilter<"Library"> | Date | string | null
    createdAt?: DateTimeFilter<"Library"> | Date | string
    updatedAt?: DateTimeFilter<"Library"> | Date | string
    client?: XOR<ClientRelationFilter, ClientWhereInput>
    versions?: LibraryVersionListRelationFilter
    aliases?: LibraryAliasListRelationFilter
    documentationChunks?: DocumentationChunkListRelationFilter
    usageLogs?: UsageLogListRelationFilter
  }, "id" | "name">

  export type LibraryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    vendor?: SortOrderInput | SortOrder
    repoUrl?: SortOrderInput | SortOrder
    docsUrl?: SortOrderInput | SortOrder
    defaultVersion?: SortOrderInput | SortOrder
    popularityScore?: SortOrder
    totalSnippets?: SortOrder
    totalTokens?: SortOrder
    language?: SortOrder
    ecosystem?: SortOrder
    tags?: SortOrder
    metadata?: SortOrderInput | SortOrder
    clientId?: SortOrder
    lastCrawledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LibraryCountOrderByAggregateInput
    _avg?: LibraryAvgOrderByAggregateInput
    _max?: LibraryMaxOrderByAggregateInput
    _min?: LibraryMinOrderByAggregateInput
    _sum?: LibrarySumOrderByAggregateInput
  }

  export type LibraryScalarWhereWithAggregatesInput = {
    AND?: LibraryScalarWhereWithAggregatesInput | LibraryScalarWhereWithAggregatesInput[]
    OR?: LibraryScalarWhereWithAggregatesInput[]
    NOT?: LibraryScalarWhereWithAggregatesInput | LibraryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Library"> | string
    name?: StringWithAggregatesFilter<"Library"> | string
    displayName?: StringWithAggregatesFilter<"Library"> | string
    description?: StringNullableWithAggregatesFilter<"Library"> | string | null
    vendor?: StringNullableWithAggregatesFilter<"Library"> | string | null
    repoUrl?: StringNullableWithAggregatesFilter<"Library"> | string | null
    docsUrl?: StringNullableWithAggregatesFilter<"Library"> | string | null
    defaultVersion?: StringNullableWithAggregatesFilter<"Library"> | string | null
    popularityScore?: FloatWithAggregatesFilter<"Library"> | number
    totalSnippets?: IntWithAggregatesFilter<"Library"> | number
    totalTokens?: IntWithAggregatesFilter<"Library"> | number
    language?: StringWithAggregatesFilter<"Library"> | string
    ecosystem?: StringWithAggregatesFilter<"Library"> | string
    tags?: StringNullableListFilter<"Library">
    metadata?: JsonNullableWithAggregatesFilter<"Library">
    clientId?: StringWithAggregatesFilter<"Library"> | string
    lastCrawledAt?: DateTimeNullableWithAggregatesFilter<"Library"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Library"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Library"> | Date | string
  }

  export type LibraryVersionWhereInput = {
    AND?: LibraryVersionWhereInput | LibraryVersionWhereInput[]
    OR?: LibraryVersionWhereInput[]
    NOT?: LibraryVersionWhereInput | LibraryVersionWhereInput[]
    id?: StringFilter<"LibraryVersion"> | string
    libraryId?: StringFilter<"LibraryVersion"> | string
    version?: StringFilter<"LibraryVersion"> | string
    releaseDate?: DateTimeNullableFilter<"LibraryVersion"> | Date | string | null
    isLatest?: BoolFilter<"LibraryVersion"> | boolean
    docsSnapshotUrl?: StringNullableFilter<"LibraryVersion"> | string | null
    library?: XOR<LibraryRelationFilter, LibraryWhereInput>
    documentationChunks?: DocumentationChunkListRelationFilter
  }

  export type LibraryVersionOrderByWithRelationInput = {
    id?: SortOrder
    libraryId?: SortOrder
    version?: SortOrder
    releaseDate?: SortOrderInput | SortOrder
    isLatest?: SortOrder
    docsSnapshotUrl?: SortOrderInput | SortOrder
    library?: LibraryOrderByWithRelationInput
    documentationChunks?: DocumentationChunkOrderByRelationAggregateInput
  }

  export type LibraryVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    libraryId_version?: LibraryVersionLibraryIdVersionCompoundUniqueInput
    AND?: LibraryVersionWhereInput | LibraryVersionWhereInput[]
    OR?: LibraryVersionWhereInput[]
    NOT?: LibraryVersionWhereInput | LibraryVersionWhereInput[]
    libraryId?: StringFilter<"LibraryVersion"> | string
    version?: StringFilter<"LibraryVersion"> | string
    releaseDate?: DateTimeNullableFilter<"LibraryVersion"> | Date | string | null
    isLatest?: BoolFilter<"LibraryVersion"> | boolean
    docsSnapshotUrl?: StringNullableFilter<"LibraryVersion"> | string | null
    library?: XOR<LibraryRelationFilter, LibraryWhereInput>
    documentationChunks?: DocumentationChunkListRelationFilter
  }, "id" | "libraryId_version">

  export type LibraryVersionOrderByWithAggregationInput = {
    id?: SortOrder
    libraryId?: SortOrder
    version?: SortOrder
    releaseDate?: SortOrderInput | SortOrder
    isLatest?: SortOrder
    docsSnapshotUrl?: SortOrderInput | SortOrder
    _count?: LibraryVersionCountOrderByAggregateInput
    _max?: LibraryVersionMaxOrderByAggregateInput
    _min?: LibraryVersionMinOrderByAggregateInput
  }

  export type LibraryVersionScalarWhereWithAggregatesInput = {
    AND?: LibraryVersionScalarWhereWithAggregatesInput | LibraryVersionScalarWhereWithAggregatesInput[]
    OR?: LibraryVersionScalarWhereWithAggregatesInput[]
    NOT?: LibraryVersionScalarWhereWithAggregatesInput | LibraryVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LibraryVersion"> | string
    libraryId?: StringWithAggregatesFilter<"LibraryVersion"> | string
    version?: StringWithAggregatesFilter<"LibraryVersion"> | string
    releaseDate?: DateTimeNullableWithAggregatesFilter<"LibraryVersion"> | Date | string | null
    isLatest?: BoolWithAggregatesFilter<"LibraryVersion"> | boolean
    docsSnapshotUrl?: StringNullableWithAggregatesFilter<"LibraryVersion"> | string | null
  }

  export type LibraryAliasWhereInput = {
    AND?: LibraryAliasWhereInput | LibraryAliasWhereInput[]
    OR?: LibraryAliasWhereInput[]
    NOT?: LibraryAliasWhereInput | LibraryAliasWhereInput[]
    id?: StringFilter<"LibraryAlias"> | string
    libraryId?: StringFilter<"LibraryAlias"> | string
    alias?: StringFilter<"LibraryAlias"> | string
    library?: XOR<LibraryRelationFilter, LibraryWhereInput>
  }

  export type LibraryAliasOrderByWithRelationInput = {
    id?: SortOrder
    libraryId?: SortOrder
    alias?: SortOrder
    library?: LibraryOrderByWithRelationInput
  }

  export type LibraryAliasWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    libraryId_alias?: LibraryAliasLibraryIdAliasCompoundUniqueInput
    AND?: LibraryAliasWhereInput | LibraryAliasWhereInput[]
    OR?: LibraryAliasWhereInput[]
    NOT?: LibraryAliasWhereInput | LibraryAliasWhereInput[]
    libraryId?: StringFilter<"LibraryAlias"> | string
    alias?: StringFilter<"LibraryAlias"> | string
    library?: XOR<LibraryRelationFilter, LibraryWhereInput>
  }, "id" | "libraryId_alias">

  export type LibraryAliasOrderByWithAggregationInput = {
    id?: SortOrder
    libraryId?: SortOrder
    alias?: SortOrder
    _count?: LibraryAliasCountOrderByAggregateInput
    _max?: LibraryAliasMaxOrderByAggregateInput
    _min?: LibraryAliasMinOrderByAggregateInput
  }

  export type LibraryAliasScalarWhereWithAggregatesInput = {
    AND?: LibraryAliasScalarWhereWithAggregatesInput | LibraryAliasScalarWhereWithAggregatesInput[]
    OR?: LibraryAliasScalarWhereWithAggregatesInput[]
    NOT?: LibraryAliasScalarWhereWithAggregatesInput | LibraryAliasScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LibraryAlias"> | string
    libraryId?: StringWithAggregatesFilter<"LibraryAlias"> | string
    alias?: StringWithAggregatesFilter<"LibraryAlias"> | string
  }

  export type DocumentationChunkWhereInput = {
    AND?: DocumentationChunkWhereInput | DocumentationChunkWhereInput[]
    OR?: DocumentationChunkWhereInput[]
    NOT?: DocumentationChunkWhereInput | DocumentationChunkWhereInput[]
    id?: StringFilter<"DocumentationChunk"> | string
    libraryVersionId?: StringFilter<"DocumentationChunk"> | string
    chunkIndex?: IntFilter<"DocumentationChunk"> | number
    content?: StringFilter<"DocumentationChunk"> | string
    contentType?: StringFilter<"DocumentationChunk"> | string
    sourceUrl?: StringNullableFilter<"DocumentationChunk"> | string | null
    tokenCount?: IntFilter<"DocumentationChunk"> | number
    embeddingId?: StringNullableFilter<"DocumentationChunk"> | string | null
    metadata?: JsonNullableFilter<"DocumentationChunk">
    createdAt?: DateTimeFilter<"DocumentationChunk"> | Date | string
    libraryId?: StringNullableFilter<"DocumentationChunk"> | string | null
    libraryVersion?: XOR<LibraryVersionRelationFilter, LibraryVersionWhereInput>
    Library?: XOR<LibraryNullableRelationFilter, LibraryWhereInput> | null
  }

  export type DocumentationChunkOrderByWithRelationInput = {
    id?: SortOrder
    libraryVersionId?: SortOrder
    chunkIndex?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    tokenCount?: SortOrder
    embeddingId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    libraryId?: SortOrderInput | SortOrder
    libraryVersion?: LibraryVersionOrderByWithRelationInput
    Library?: LibraryOrderByWithRelationInput
  }

  export type DocumentationChunkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentationChunkWhereInput | DocumentationChunkWhereInput[]
    OR?: DocumentationChunkWhereInput[]
    NOT?: DocumentationChunkWhereInput | DocumentationChunkWhereInput[]
    libraryVersionId?: StringFilter<"DocumentationChunk"> | string
    chunkIndex?: IntFilter<"DocumentationChunk"> | number
    content?: StringFilter<"DocumentationChunk"> | string
    contentType?: StringFilter<"DocumentationChunk"> | string
    sourceUrl?: StringNullableFilter<"DocumentationChunk"> | string | null
    tokenCount?: IntFilter<"DocumentationChunk"> | number
    embeddingId?: StringNullableFilter<"DocumentationChunk"> | string | null
    metadata?: JsonNullableFilter<"DocumentationChunk">
    createdAt?: DateTimeFilter<"DocumentationChunk"> | Date | string
    libraryId?: StringNullableFilter<"DocumentationChunk"> | string | null
    libraryVersion?: XOR<LibraryVersionRelationFilter, LibraryVersionWhereInput>
    Library?: XOR<LibraryNullableRelationFilter, LibraryWhereInput> | null
  }, "id">

  export type DocumentationChunkOrderByWithAggregationInput = {
    id?: SortOrder
    libraryVersionId?: SortOrder
    chunkIndex?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    tokenCount?: SortOrder
    embeddingId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    libraryId?: SortOrderInput | SortOrder
    _count?: DocumentationChunkCountOrderByAggregateInput
    _avg?: DocumentationChunkAvgOrderByAggregateInput
    _max?: DocumentationChunkMaxOrderByAggregateInput
    _min?: DocumentationChunkMinOrderByAggregateInput
    _sum?: DocumentationChunkSumOrderByAggregateInput
  }

  export type DocumentationChunkScalarWhereWithAggregatesInput = {
    AND?: DocumentationChunkScalarWhereWithAggregatesInput | DocumentationChunkScalarWhereWithAggregatesInput[]
    OR?: DocumentationChunkScalarWhereWithAggregatesInput[]
    NOT?: DocumentationChunkScalarWhereWithAggregatesInput | DocumentationChunkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentationChunk"> | string
    libraryVersionId?: StringWithAggregatesFilter<"DocumentationChunk"> | string
    chunkIndex?: IntWithAggregatesFilter<"DocumentationChunk"> | number
    content?: StringWithAggregatesFilter<"DocumentationChunk"> | string
    contentType?: StringWithAggregatesFilter<"DocumentationChunk"> | string
    sourceUrl?: StringNullableWithAggregatesFilter<"DocumentationChunk"> | string | null
    tokenCount?: IntWithAggregatesFilter<"DocumentationChunk"> | number
    embeddingId?: StringNullableWithAggregatesFilter<"DocumentationChunk"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"DocumentationChunk">
    createdAt?: DateTimeWithAggregatesFilter<"DocumentationChunk"> | Date | string
    libraryId?: StringNullableWithAggregatesFilter<"DocumentationChunk"> | string | null
  }

  export type ApiKeyWhereInput = {
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    userId?: StringFilter<"ApiKey"> | string
    keyHash?: StringFilter<"ApiKey"> | string
    keyPrefix?: StringFilter<"ApiKey"> | string
    name?: StringNullableFilter<"ApiKey"> | string | null
    tier?: StringFilter<"ApiKey"> | string
    quotaDaily?: IntFilter<"ApiKey"> | number
    quotaMonthly?: IntFilter<"ApiKey"> | number
    usedDaily?: IntFilter<"ApiKey"> | number
    usedMonthly?: IntFilter<"ApiKey"> | number
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    isActive?: BoolFilter<"ApiKey"> | boolean
    permissions?: JsonFilter<"ApiKey">
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
    revokedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    usageLogs?: UsageLogListRelationFilter
  }

  export type ApiKeyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    keyHash?: SortOrder
    keyPrefix?: SortOrder
    name?: SortOrderInput | SortOrder
    tier?: SortOrder
    quotaDaily?: SortOrder
    quotaMonthly?: SortOrder
    usedDaily?: SortOrder
    usedMonthly?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    usageLogs?: UsageLogOrderByRelationAggregateInput
  }

  export type ApiKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    keyHash?: string
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    userId?: StringFilter<"ApiKey"> | string
    keyPrefix?: StringFilter<"ApiKey"> | string
    name?: StringNullableFilter<"ApiKey"> | string | null
    tier?: StringFilter<"ApiKey"> | string
    quotaDaily?: IntFilter<"ApiKey"> | number
    quotaMonthly?: IntFilter<"ApiKey"> | number
    usedDaily?: IntFilter<"ApiKey"> | number
    usedMonthly?: IntFilter<"ApiKey"> | number
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    isActive?: BoolFilter<"ApiKey"> | boolean
    permissions?: JsonFilter<"ApiKey">
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
    revokedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    usageLogs?: UsageLogListRelationFilter
  }, "id" | "keyHash">

  export type ApiKeyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    keyHash?: SortOrder
    keyPrefix?: SortOrder
    name?: SortOrderInput | SortOrder
    tier?: SortOrder
    quotaDaily?: SortOrder
    quotaMonthly?: SortOrder
    usedDaily?: SortOrder
    usedMonthly?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    _count?: ApiKeyCountOrderByAggregateInput
    _avg?: ApiKeyAvgOrderByAggregateInput
    _max?: ApiKeyMaxOrderByAggregateInput
    _min?: ApiKeyMinOrderByAggregateInput
    _sum?: ApiKeySumOrderByAggregateInput
  }

  export type ApiKeyScalarWhereWithAggregatesInput = {
    AND?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    OR?: ApiKeyScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiKey"> | string
    userId?: StringWithAggregatesFilter<"ApiKey"> | string
    keyHash?: StringWithAggregatesFilter<"ApiKey"> | string
    keyPrefix?: StringWithAggregatesFilter<"ApiKey"> | string
    name?: StringNullableWithAggregatesFilter<"ApiKey"> | string | null
    tier?: StringWithAggregatesFilter<"ApiKey"> | string
    quotaDaily?: IntWithAggregatesFilter<"ApiKey"> | number
    quotaMonthly?: IntWithAggregatesFilter<"ApiKey"> | number
    usedDaily?: IntWithAggregatesFilter<"ApiKey"> | number
    usedMonthly?: IntWithAggregatesFilter<"ApiKey"> | number
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"ApiKey"> | boolean
    permissions?: JsonWithAggregatesFilter<"ApiKey">
    createdAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
    revokedAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
  }

  export type UsageLogWhereInput = {
    AND?: UsageLogWhereInput | UsageLogWhereInput[]
    OR?: UsageLogWhereInput[]
    NOT?: UsageLogWhereInput | UsageLogWhereInput[]
    id?: StringFilter<"UsageLog"> | string
    userId?: StringNullableFilter<"UsageLog"> | string | null
    apiKeyId?: StringNullableFilter<"UsageLog"> | string | null
    libraryId?: StringNullableFilter<"UsageLog"> | string | null
    toolName?: StringFilter<"UsageLog"> | string
    query?: StringNullableFilter<"UsageLog"> | string | null
    tokensReturned?: IntNullableFilter<"UsageLog"> | number | null
    responseTimeMs?: IntNullableFilter<"UsageLog"> | number | null
    createdAt?: DateTimeFilter<"UsageLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    apiKey?: XOR<ApiKeyNullableRelationFilter, ApiKeyWhereInput> | null
    library?: XOR<LibraryNullableRelationFilter, LibraryWhereInput> | null
  }

  export type UsageLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    apiKeyId?: SortOrderInput | SortOrder
    libraryId?: SortOrderInput | SortOrder
    toolName?: SortOrder
    query?: SortOrderInput | SortOrder
    tokensReturned?: SortOrderInput | SortOrder
    responseTimeMs?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    apiKey?: ApiKeyOrderByWithRelationInput
    library?: LibraryOrderByWithRelationInput
  }

  export type UsageLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UsageLogWhereInput | UsageLogWhereInput[]
    OR?: UsageLogWhereInput[]
    NOT?: UsageLogWhereInput | UsageLogWhereInput[]
    userId?: StringNullableFilter<"UsageLog"> | string | null
    apiKeyId?: StringNullableFilter<"UsageLog"> | string | null
    libraryId?: StringNullableFilter<"UsageLog"> | string | null
    toolName?: StringFilter<"UsageLog"> | string
    query?: StringNullableFilter<"UsageLog"> | string | null
    tokensReturned?: IntNullableFilter<"UsageLog"> | number | null
    responseTimeMs?: IntNullableFilter<"UsageLog"> | number | null
    createdAt?: DateTimeFilter<"UsageLog"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    apiKey?: XOR<ApiKeyNullableRelationFilter, ApiKeyWhereInput> | null
    library?: XOR<LibraryNullableRelationFilter, LibraryWhereInput> | null
  }, "id">

  export type UsageLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    apiKeyId?: SortOrderInput | SortOrder
    libraryId?: SortOrderInput | SortOrder
    toolName?: SortOrder
    query?: SortOrderInput | SortOrder
    tokensReturned?: SortOrderInput | SortOrder
    responseTimeMs?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UsageLogCountOrderByAggregateInput
    _avg?: UsageLogAvgOrderByAggregateInput
    _max?: UsageLogMaxOrderByAggregateInput
    _min?: UsageLogMinOrderByAggregateInput
    _sum?: UsageLogSumOrderByAggregateInput
  }

  export type UsageLogScalarWhereWithAggregatesInput = {
    AND?: UsageLogScalarWhereWithAggregatesInput | UsageLogScalarWhereWithAggregatesInput[]
    OR?: UsageLogScalarWhereWithAggregatesInput[]
    NOT?: UsageLogScalarWhereWithAggregatesInput | UsageLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UsageLog"> | string
    userId?: StringNullableWithAggregatesFilter<"UsageLog"> | string | null
    apiKeyId?: StringNullableWithAggregatesFilter<"UsageLog"> | string | null
    libraryId?: StringNullableWithAggregatesFilter<"UsageLog"> | string | null
    toolName?: StringWithAggregatesFilter<"UsageLog"> | string
    query?: StringNullableWithAggregatesFilter<"UsageLog"> | string | null
    tokensReturned?: IntNullableWithAggregatesFilter<"UsageLog"> | number | null
    responseTimeMs?: IntNullableWithAggregatesFilter<"UsageLog"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"UsageLog"> | Date | string
  }

  export type MCPConfigurationWhereInput = {
    AND?: MCPConfigurationWhereInput | MCPConfigurationWhereInput[]
    OR?: MCPConfigurationWhereInput[]
    NOT?: MCPConfigurationWhereInput | MCPConfigurationWhereInput[]
    id?: StringFilter<"MCPConfiguration"> | string
    name?: StringFilter<"MCPConfiguration"> | string
    description?: StringNullableFilter<"MCPConfiguration"> | string | null
    configData?: JsonFilter<"MCPConfiguration">
    status?: EnumConfigStatusFilter<"MCPConfiguration"> | ConfigStatus
    userId?: StringFilter<"MCPConfiguration"> | string
    createdAt?: DateTimeFilter<"MCPConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"MCPConfiguration"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MCPConfigurationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    configData?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MCPConfigurationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MCPConfigurationWhereInput | MCPConfigurationWhereInput[]
    OR?: MCPConfigurationWhereInput[]
    NOT?: MCPConfigurationWhereInput | MCPConfigurationWhereInput[]
    name?: StringFilter<"MCPConfiguration"> | string
    description?: StringNullableFilter<"MCPConfiguration"> | string | null
    configData?: JsonFilter<"MCPConfiguration">
    status?: EnumConfigStatusFilter<"MCPConfiguration"> | ConfigStatus
    userId?: StringFilter<"MCPConfiguration"> | string
    createdAt?: DateTimeFilter<"MCPConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"MCPConfiguration"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MCPConfigurationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    configData?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MCPConfigurationCountOrderByAggregateInput
    _max?: MCPConfigurationMaxOrderByAggregateInput
    _min?: MCPConfigurationMinOrderByAggregateInput
  }

  export type MCPConfigurationScalarWhereWithAggregatesInput = {
    AND?: MCPConfigurationScalarWhereWithAggregatesInput | MCPConfigurationScalarWhereWithAggregatesInput[]
    OR?: MCPConfigurationScalarWhereWithAggregatesInput[]
    NOT?: MCPConfigurationScalarWhereWithAggregatesInput | MCPConfigurationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MCPConfiguration"> | string
    name?: StringWithAggregatesFilter<"MCPConfiguration"> | string
    description?: StringNullableWithAggregatesFilter<"MCPConfiguration"> | string | null
    configData?: JsonWithAggregatesFilter<"MCPConfiguration">
    status?: EnumConfigStatusWithAggregatesFilter<"MCPConfiguration"> | ConfigStatus
    userId?: StringWithAggregatesFilter<"MCPConfiguration"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MCPConfiguration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MCPConfiguration"> | Date | string
  }

  export type OAuthTokenWhereInput = {
    AND?: OAuthTokenWhereInput | OAuthTokenWhereInput[]
    OR?: OAuthTokenWhereInput[]
    NOT?: OAuthTokenWhereInput | OAuthTokenWhereInput[]
    id?: StringFilter<"OAuthToken"> | string
    userId?: StringFilter<"OAuthToken"> | string
    provider?: StringFilter<"OAuthToken"> | string
    accessToken?: StringFilter<"OAuthToken"> | string
    refreshToken?: StringNullableFilter<"OAuthToken"> | string | null
    expiresAt?: DateTimeFilter<"OAuthToken"> | Date | string
    createdAt?: DateTimeFilter<"OAuthToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type OAuthTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type OAuthTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_provider?: OAuthTokenUserIdProviderCompoundUniqueInput
    AND?: OAuthTokenWhereInput | OAuthTokenWhereInput[]
    OR?: OAuthTokenWhereInput[]
    NOT?: OAuthTokenWhereInput | OAuthTokenWhereInput[]
    userId?: StringFilter<"OAuthToken"> | string
    provider?: StringFilter<"OAuthToken"> | string
    accessToken?: StringFilter<"OAuthToken"> | string
    refreshToken?: StringNullableFilter<"OAuthToken"> | string | null
    expiresAt?: DateTimeFilter<"OAuthToken"> | Date | string
    createdAt?: DateTimeFilter<"OAuthToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_provider">

  export type OAuthTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: OAuthTokenCountOrderByAggregateInput
    _max?: OAuthTokenMaxOrderByAggregateInput
    _min?: OAuthTokenMinOrderByAggregateInput
  }

  export type OAuthTokenScalarWhereWithAggregatesInput = {
    AND?: OAuthTokenScalarWhereWithAggregatesInput | OAuthTokenScalarWhereWithAggregatesInput[]
    OR?: OAuthTokenScalarWhereWithAggregatesInput[]
    NOT?: OAuthTokenScalarWhereWithAggregatesInput | OAuthTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OAuthToken"> | string
    userId?: StringWithAggregatesFilter<"OAuthToken"> | string
    provider?: StringWithAggregatesFilter<"OAuthToken"> | string
    accessToken?: StringWithAggregatesFilter<"OAuthToken"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"OAuthToken"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"OAuthToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"OAuthToken"> | Date | string
  }

  export type OAuthClientWhereInput = {
    AND?: OAuthClientWhereInput | OAuthClientWhereInput[]
    OR?: OAuthClientWhereInput[]
    NOT?: OAuthClientWhereInput | OAuthClientWhereInput[]
    id?: StringFilter<"OAuthClient"> | string
    clientId?: StringFilter<"OAuthClient"> | string
    clientSecretHash?: StringFilter<"OAuthClient"> | string
    name?: StringFilter<"OAuthClient"> | string
    redirectUris?: StringNullableListFilter<"OAuthClient">
    allowedScopes?: StringNullableListFilter<"OAuthClient">
    grantTypes?: StringNullableListFilter<"OAuthClient">
    requirePkce?: BoolFilter<"OAuthClient"> | boolean
    isActive?: BoolFilter<"OAuthClient"> | boolean
    createdAt?: DateTimeFilter<"OAuthClient"> | Date | string
    updatedAt?: DateTimeFilter<"OAuthClient"> | Date | string
    authorizationCodes?: OAuthAuthorizationCodeListRelationFilter
    accessTokens?: OAuthAccessTokenListRelationFilter
    refreshTokens?: OAuthRefreshTokenListRelationFilter
  }

  export type OAuthClientOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    clientSecretHash?: SortOrder
    name?: SortOrder
    redirectUris?: SortOrder
    allowedScopes?: SortOrder
    grantTypes?: SortOrder
    requirePkce?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    authorizationCodes?: OAuthAuthorizationCodeOrderByRelationAggregateInput
    accessTokens?: OAuthAccessTokenOrderByRelationAggregateInput
    refreshTokens?: OAuthRefreshTokenOrderByRelationAggregateInput
  }

  export type OAuthClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId?: string
    AND?: OAuthClientWhereInput | OAuthClientWhereInput[]
    OR?: OAuthClientWhereInput[]
    NOT?: OAuthClientWhereInput | OAuthClientWhereInput[]
    clientSecretHash?: StringFilter<"OAuthClient"> | string
    name?: StringFilter<"OAuthClient"> | string
    redirectUris?: StringNullableListFilter<"OAuthClient">
    allowedScopes?: StringNullableListFilter<"OAuthClient">
    grantTypes?: StringNullableListFilter<"OAuthClient">
    requirePkce?: BoolFilter<"OAuthClient"> | boolean
    isActive?: BoolFilter<"OAuthClient"> | boolean
    createdAt?: DateTimeFilter<"OAuthClient"> | Date | string
    updatedAt?: DateTimeFilter<"OAuthClient"> | Date | string
    authorizationCodes?: OAuthAuthorizationCodeListRelationFilter
    accessTokens?: OAuthAccessTokenListRelationFilter
    refreshTokens?: OAuthRefreshTokenListRelationFilter
  }, "id" | "clientId">

  export type OAuthClientOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    clientSecretHash?: SortOrder
    name?: SortOrder
    redirectUris?: SortOrder
    allowedScopes?: SortOrder
    grantTypes?: SortOrder
    requirePkce?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OAuthClientCountOrderByAggregateInput
    _max?: OAuthClientMaxOrderByAggregateInput
    _min?: OAuthClientMinOrderByAggregateInput
  }

  export type OAuthClientScalarWhereWithAggregatesInput = {
    AND?: OAuthClientScalarWhereWithAggregatesInput | OAuthClientScalarWhereWithAggregatesInput[]
    OR?: OAuthClientScalarWhereWithAggregatesInput[]
    NOT?: OAuthClientScalarWhereWithAggregatesInput | OAuthClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OAuthClient"> | string
    clientId?: StringWithAggregatesFilter<"OAuthClient"> | string
    clientSecretHash?: StringWithAggregatesFilter<"OAuthClient"> | string
    name?: StringWithAggregatesFilter<"OAuthClient"> | string
    redirectUris?: StringNullableListFilter<"OAuthClient">
    allowedScopes?: StringNullableListFilter<"OAuthClient">
    grantTypes?: StringNullableListFilter<"OAuthClient">
    requirePkce?: BoolWithAggregatesFilter<"OAuthClient"> | boolean
    isActive?: BoolWithAggregatesFilter<"OAuthClient"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"OAuthClient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OAuthClient"> | Date | string
  }

  export type OAuthAuthorizationCodeWhereInput = {
    AND?: OAuthAuthorizationCodeWhereInput | OAuthAuthorizationCodeWhereInput[]
    OR?: OAuthAuthorizationCodeWhereInput[]
    NOT?: OAuthAuthorizationCodeWhereInput | OAuthAuthorizationCodeWhereInput[]
    id?: StringFilter<"OAuthAuthorizationCode"> | string
    code?: StringFilter<"OAuthAuthorizationCode"> | string
    clientId?: StringFilter<"OAuthAuthorizationCode"> | string
    userId?: StringFilter<"OAuthAuthorizationCode"> | string
    redirectUri?: StringFilter<"OAuthAuthorizationCode"> | string
    scopes?: StringNullableListFilter<"OAuthAuthorizationCode">
    codeChallenge?: StringNullableFilter<"OAuthAuthorizationCode"> | string | null
    codeChallengeMethod?: StringNullableFilter<"OAuthAuthorizationCode"> | string | null
    expiresAt?: DateTimeFilter<"OAuthAuthorizationCode"> | Date | string
    createdAt?: DateTimeFilter<"OAuthAuthorizationCode"> | Date | string
    client?: XOR<OAuthClientRelationFilter, OAuthClientWhereInput>
  }

  export type OAuthAuthorizationCodeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    clientId?: SortOrder
    userId?: SortOrder
    redirectUri?: SortOrder
    scopes?: SortOrder
    codeChallenge?: SortOrderInput | SortOrder
    codeChallengeMethod?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    client?: OAuthClientOrderByWithRelationInput
  }

  export type OAuthAuthorizationCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: OAuthAuthorizationCodeWhereInput | OAuthAuthorizationCodeWhereInput[]
    OR?: OAuthAuthorizationCodeWhereInput[]
    NOT?: OAuthAuthorizationCodeWhereInput | OAuthAuthorizationCodeWhereInput[]
    clientId?: StringFilter<"OAuthAuthorizationCode"> | string
    userId?: StringFilter<"OAuthAuthorizationCode"> | string
    redirectUri?: StringFilter<"OAuthAuthorizationCode"> | string
    scopes?: StringNullableListFilter<"OAuthAuthorizationCode">
    codeChallenge?: StringNullableFilter<"OAuthAuthorizationCode"> | string | null
    codeChallengeMethod?: StringNullableFilter<"OAuthAuthorizationCode"> | string | null
    expiresAt?: DateTimeFilter<"OAuthAuthorizationCode"> | Date | string
    createdAt?: DateTimeFilter<"OAuthAuthorizationCode"> | Date | string
    client?: XOR<OAuthClientRelationFilter, OAuthClientWhereInput>
  }, "id" | "code">

  export type OAuthAuthorizationCodeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    clientId?: SortOrder
    userId?: SortOrder
    redirectUri?: SortOrder
    scopes?: SortOrder
    codeChallenge?: SortOrderInput | SortOrder
    codeChallengeMethod?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: OAuthAuthorizationCodeCountOrderByAggregateInput
    _max?: OAuthAuthorizationCodeMaxOrderByAggregateInput
    _min?: OAuthAuthorizationCodeMinOrderByAggregateInput
  }

  export type OAuthAuthorizationCodeScalarWhereWithAggregatesInput = {
    AND?: OAuthAuthorizationCodeScalarWhereWithAggregatesInput | OAuthAuthorizationCodeScalarWhereWithAggregatesInput[]
    OR?: OAuthAuthorizationCodeScalarWhereWithAggregatesInput[]
    NOT?: OAuthAuthorizationCodeScalarWhereWithAggregatesInput | OAuthAuthorizationCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OAuthAuthorizationCode"> | string
    code?: StringWithAggregatesFilter<"OAuthAuthorizationCode"> | string
    clientId?: StringWithAggregatesFilter<"OAuthAuthorizationCode"> | string
    userId?: StringWithAggregatesFilter<"OAuthAuthorizationCode"> | string
    redirectUri?: StringWithAggregatesFilter<"OAuthAuthorizationCode"> | string
    scopes?: StringNullableListFilter<"OAuthAuthorizationCode">
    codeChallenge?: StringNullableWithAggregatesFilter<"OAuthAuthorizationCode"> | string | null
    codeChallengeMethod?: StringNullableWithAggregatesFilter<"OAuthAuthorizationCode"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"OAuthAuthorizationCode"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"OAuthAuthorizationCode"> | Date | string
  }

  export type OAuthAccessTokenWhereInput = {
    AND?: OAuthAccessTokenWhereInput | OAuthAccessTokenWhereInput[]
    OR?: OAuthAccessTokenWhereInput[]
    NOT?: OAuthAccessTokenWhereInput | OAuthAccessTokenWhereInput[]
    id?: StringFilter<"OAuthAccessToken"> | string
    tokenHash?: StringFilter<"OAuthAccessToken"> | string
    clientId?: StringFilter<"OAuthAccessToken"> | string
    userId?: StringFilter<"OAuthAccessToken"> | string
    scopes?: StringNullableListFilter<"OAuthAccessToken">
    expiresAt?: DateTimeFilter<"OAuthAccessToken"> | Date | string
    createdAt?: DateTimeFilter<"OAuthAccessToken"> | Date | string
    client?: XOR<OAuthClientRelationFilter, OAuthClientWhereInput>
    refreshToken?: OAuthRefreshTokenListRelationFilter
  }

  export type OAuthAccessTokenOrderByWithRelationInput = {
    id?: SortOrder
    tokenHash?: SortOrder
    clientId?: SortOrder
    userId?: SortOrder
    scopes?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    client?: OAuthClientOrderByWithRelationInput
    refreshToken?: OAuthRefreshTokenOrderByRelationAggregateInput
  }

  export type OAuthAccessTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tokenHash?: string
    AND?: OAuthAccessTokenWhereInput | OAuthAccessTokenWhereInput[]
    OR?: OAuthAccessTokenWhereInput[]
    NOT?: OAuthAccessTokenWhereInput | OAuthAccessTokenWhereInput[]
    clientId?: StringFilter<"OAuthAccessToken"> | string
    userId?: StringFilter<"OAuthAccessToken"> | string
    scopes?: StringNullableListFilter<"OAuthAccessToken">
    expiresAt?: DateTimeFilter<"OAuthAccessToken"> | Date | string
    createdAt?: DateTimeFilter<"OAuthAccessToken"> | Date | string
    client?: XOR<OAuthClientRelationFilter, OAuthClientWhereInput>
    refreshToken?: OAuthRefreshTokenListRelationFilter
  }, "id" | "tokenHash">

  export type OAuthAccessTokenOrderByWithAggregationInput = {
    id?: SortOrder
    tokenHash?: SortOrder
    clientId?: SortOrder
    userId?: SortOrder
    scopes?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: OAuthAccessTokenCountOrderByAggregateInput
    _max?: OAuthAccessTokenMaxOrderByAggregateInput
    _min?: OAuthAccessTokenMinOrderByAggregateInput
  }

  export type OAuthAccessTokenScalarWhereWithAggregatesInput = {
    AND?: OAuthAccessTokenScalarWhereWithAggregatesInput | OAuthAccessTokenScalarWhereWithAggregatesInput[]
    OR?: OAuthAccessTokenScalarWhereWithAggregatesInput[]
    NOT?: OAuthAccessTokenScalarWhereWithAggregatesInput | OAuthAccessTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OAuthAccessToken"> | string
    tokenHash?: StringWithAggregatesFilter<"OAuthAccessToken"> | string
    clientId?: StringWithAggregatesFilter<"OAuthAccessToken"> | string
    userId?: StringWithAggregatesFilter<"OAuthAccessToken"> | string
    scopes?: StringNullableListFilter<"OAuthAccessToken">
    expiresAt?: DateTimeWithAggregatesFilter<"OAuthAccessToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"OAuthAccessToken"> | Date | string
  }

  export type OAuthRefreshTokenWhereInput = {
    AND?: OAuthRefreshTokenWhereInput | OAuthRefreshTokenWhereInput[]
    OR?: OAuthRefreshTokenWhereInput[]
    NOT?: OAuthRefreshTokenWhereInput | OAuthRefreshTokenWhereInput[]
    id?: StringFilter<"OAuthRefreshToken"> | string
    tokenHash?: StringFilter<"OAuthRefreshToken"> | string
    accessTokenId?: StringFilter<"OAuthRefreshToken"> | string
    clientId?: StringFilter<"OAuthRefreshToken"> | string
    userId?: StringFilter<"OAuthRefreshToken"> | string
    scopes?: StringNullableListFilter<"OAuthRefreshToken">
    expiresAt?: DateTimeFilter<"OAuthRefreshToken"> | Date | string
    isRevoked?: BoolFilter<"OAuthRefreshToken"> | boolean
    createdAt?: DateTimeFilter<"OAuthRefreshToken"> | Date | string
    accessToken?: XOR<OAuthAccessTokenRelationFilter, OAuthAccessTokenWhereInput>
    client?: XOR<OAuthClientRelationFilter, OAuthClientWhereInput>
  }

  export type OAuthRefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    tokenHash?: SortOrder
    accessTokenId?: SortOrder
    clientId?: SortOrder
    userId?: SortOrder
    scopes?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    createdAt?: SortOrder
    accessToken?: OAuthAccessTokenOrderByWithRelationInput
    client?: OAuthClientOrderByWithRelationInput
  }

  export type OAuthRefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tokenHash?: string
    AND?: OAuthRefreshTokenWhereInput | OAuthRefreshTokenWhereInput[]
    OR?: OAuthRefreshTokenWhereInput[]
    NOT?: OAuthRefreshTokenWhereInput | OAuthRefreshTokenWhereInput[]
    accessTokenId?: StringFilter<"OAuthRefreshToken"> | string
    clientId?: StringFilter<"OAuthRefreshToken"> | string
    userId?: StringFilter<"OAuthRefreshToken"> | string
    scopes?: StringNullableListFilter<"OAuthRefreshToken">
    expiresAt?: DateTimeFilter<"OAuthRefreshToken"> | Date | string
    isRevoked?: BoolFilter<"OAuthRefreshToken"> | boolean
    createdAt?: DateTimeFilter<"OAuthRefreshToken"> | Date | string
    accessToken?: XOR<OAuthAccessTokenRelationFilter, OAuthAccessTokenWhereInput>
    client?: XOR<OAuthClientRelationFilter, OAuthClientWhereInput>
  }, "id" | "tokenHash">

  export type OAuthRefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    tokenHash?: SortOrder
    accessTokenId?: SortOrder
    clientId?: SortOrder
    userId?: SortOrder
    scopes?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    createdAt?: SortOrder
    _count?: OAuthRefreshTokenCountOrderByAggregateInput
    _max?: OAuthRefreshTokenMaxOrderByAggregateInput
    _min?: OAuthRefreshTokenMinOrderByAggregateInput
  }

  export type OAuthRefreshTokenScalarWhereWithAggregatesInput = {
    AND?: OAuthRefreshTokenScalarWhereWithAggregatesInput | OAuthRefreshTokenScalarWhereWithAggregatesInput[]
    OR?: OAuthRefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: OAuthRefreshTokenScalarWhereWithAggregatesInput | OAuthRefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OAuthRefreshToken"> | string
    tokenHash?: StringWithAggregatesFilter<"OAuthRefreshToken"> | string
    accessTokenId?: StringWithAggregatesFilter<"OAuthRefreshToken"> | string
    clientId?: StringWithAggregatesFilter<"OAuthRefreshToken"> | string
    userId?: StringWithAggregatesFilter<"OAuthRefreshToken"> | string
    scopes?: StringNullableListFilter<"OAuthRefreshToken">
    expiresAt?: DateTimeWithAggregatesFilter<"OAuthRefreshToken"> | Date | string
    isRevoked?: BoolWithAggregatesFilter<"OAuthRefreshToken"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"OAuthRefreshToken"> | Date | string
  }

  export type DownloadTaskWhereInput = {
    AND?: DownloadTaskWhereInput | DownloadTaskWhereInput[]
    OR?: DownloadTaskWhereInput[]
    NOT?: DownloadTaskWhereInput | DownloadTaskWhereInput[]
    id?: StringFilter<"DownloadTask"> | string
    type?: StringFilter<"DownloadTask"> | string
    source?: JsonFilter<"DownloadTask">
    options?: JsonFilter<"DownloadTask">
    priority?: StringFilter<"DownloadTask"> | string
    status?: StringFilter<"DownloadTask"> | string
    progress?: JsonFilter<"DownloadTask">
    metadata?: JsonNullableFilter<"DownloadTask">
    created_at?: DateTimeFilter<"DownloadTask"> | Date | string
    started_at?: DateTimeNullableFilter<"DownloadTask"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"DownloadTask"> | Date | string | null
    error?: StringNullableFilter<"DownloadTask"> | string | null
    retry_count?: IntFilter<"DownloadTask"> | number
    downloadResults?: DownloadResultListRelationFilter
  }

  export type DownloadTaskOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    source?: SortOrder
    options?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    started_at?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    retry_count?: SortOrder
    downloadResults?: DownloadResultOrderByRelationAggregateInput
  }

  export type DownloadTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DownloadTaskWhereInput | DownloadTaskWhereInput[]
    OR?: DownloadTaskWhereInput[]
    NOT?: DownloadTaskWhereInput | DownloadTaskWhereInput[]
    type?: StringFilter<"DownloadTask"> | string
    source?: JsonFilter<"DownloadTask">
    options?: JsonFilter<"DownloadTask">
    priority?: StringFilter<"DownloadTask"> | string
    status?: StringFilter<"DownloadTask"> | string
    progress?: JsonFilter<"DownloadTask">
    metadata?: JsonNullableFilter<"DownloadTask">
    created_at?: DateTimeFilter<"DownloadTask"> | Date | string
    started_at?: DateTimeNullableFilter<"DownloadTask"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"DownloadTask"> | Date | string | null
    error?: StringNullableFilter<"DownloadTask"> | string | null
    retry_count?: IntFilter<"DownloadTask"> | number
    downloadResults?: DownloadResultListRelationFilter
  }, "id">

  export type DownloadTaskOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    source?: SortOrder
    options?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    metadata?: SortOrderInput | SortOrder
    created_at?: SortOrder
    started_at?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    retry_count?: SortOrder
    _count?: DownloadTaskCountOrderByAggregateInput
    _avg?: DownloadTaskAvgOrderByAggregateInput
    _max?: DownloadTaskMaxOrderByAggregateInput
    _min?: DownloadTaskMinOrderByAggregateInput
    _sum?: DownloadTaskSumOrderByAggregateInput
  }

  export type DownloadTaskScalarWhereWithAggregatesInput = {
    AND?: DownloadTaskScalarWhereWithAggregatesInput | DownloadTaskScalarWhereWithAggregatesInput[]
    OR?: DownloadTaskScalarWhereWithAggregatesInput[]
    NOT?: DownloadTaskScalarWhereWithAggregatesInput | DownloadTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DownloadTask"> | string
    type?: StringWithAggregatesFilter<"DownloadTask"> | string
    source?: JsonWithAggregatesFilter<"DownloadTask">
    options?: JsonWithAggregatesFilter<"DownloadTask">
    priority?: StringWithAggregatesFilter<"DownloadTask"> | string
    status?: StringWithAggregatesFilter<"DownloadTask"> | string
    progress?: JsonWithAggregatesFilter<"DownloadTask">
    metadata?: JsonNullableWithAggregatesFilter<"DownloadTask">
    created_at?: DateTimeWithAggregatesFilter<"DownloadTask"> | Date | string
    started_at?: DateTimeNullableWithAggregatesFilter<"DownloadTask"> | Date | string | null
    completed_at?: DateTimeNullableWithAggregatesFilter<"DownloadTask"> | Date | string | null
    error?: StringNullableWithAggregatesFilter<"DownloadTask"> | string | null
    retry_count?: IntWithAggregatesFilter<"DownloadTask"> | number
  }

  export type DownloadResultWhereInput = {
    AND?: DownloadResultWhereInput | DownloadResultWhereInput[]
    OR?: DownloadResultWhereInput[]
    NOT?: DownloadResultWhereInput | DownloadResultWhereInput[]
    id?: StringFilter<"DownloadResult"> | string
    task_id?: StringFilter<"DownloadResult"> | string
    success?: BoolFilter<"DownloadResult"> | boolean
    local_path?: StringFilter<"DownloadResult"> | string
    metadata?: JsonFilter<"DownloadResult">
    files?: JsonFilter<"DownloadResult">
    errors?: StringNullableListFilter<"DownloadResult">
    created_at?: DateTimeFilter<"DownloadResult"> | Date | string
    downloadTask?: XOR<DownloadTaskRelationFilter, DownloadTaskWhereInput>
  }

  export type DownloadResultOrderByWithRelationInput = {
    id?: SortOrder
    task_id?: SortOrder
    success?: SortOrder
    local_path?: SortOrder
    metadata?: SortOrder
    files?: SortOrder
    errors?: SortOrder
    created_at?: SortOrder
    downloadTask?: DownloadTaskOrderByWithRelationInput
  }

  export type DownloadResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    task_id?: string
    AND?: DownloadResultWhereInput | DownloadResultWhereInput[]
    OR?: DownloadResultWhereInput[]
    NOT?: DownloadResultWhereInput | DownloadResultWhereInput[]
    success?: BoolFilter<"DownloadResult"> | boolean
    local_path?: StringFilter<"DownloadResult"> | string
    metadata?: JsonFilter<"DownloadResult">
    files?: JsonFilter<"DownloadResult">
    errors?: StringNullableListFilter<"DownloadResult">
    created_at?: DateTimeFilter<"DownloadResult"> | Date | string
    downloadTask?: XOR<DownloadTaskRelationFilter, DownloadTaskWhereInput>
  }, "id" | "task_id">

  export type DownloadResultOrderByWithAggregationInput = {
    id?: SortOrder
    task_id?: SortOrder
    success?: SortOrder
    local_path?: SortOrder
    metadata?: SortOrder
    files?: SortOrder
    errors?: SortOrder
    created_at?: SortOrder
    _count?: DownloadResultCountOrderByAggregateInput
    _max?: DownloadResultMaxOrderByAggregateInput
    _min?: DownloadResultMinOrderByAggregateInput
  }

  export type DownloadResultScalarWhereWithAggregatesInput = {
    AND?: DownloadResultScalarWhereWithAggregatesInput | DownloadResultScalarWhereWithAggregatesInput[]
    OR?: DownloadResultScalarWhereWithAggregatesInput[]
    NOT?: DownloadResultScalarWhereWithAggregatesInput | DownloadResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DownloadResult"> | string
    task_id?: StringWithAggregatesFilter<"DownloadResult"> | string
    success?: BoolWithAggregatesFilter<"DownloadResult"> | boolean
    local_path?: StringWithAggregatesFilter<"DownloadResult"> | string
    metadata?: JsonWithAggregatesFilter<"DownloadResult">
    files?: JsonWithAggregatesFilter<"DownloadResult">
    errors?: StringNullableListFilter<"DownloadResult">
    created_at?: DateTimeWithAggregatesFilter<"DownloadResult"> | Date | string
  }

  export type PromptCategoryWhereInput = {
    AND?: PromptCategoryWhereInput | PromptCategoryWhereInput[]
    OR?: PromptCategoryWhereInput[]
    NOT?: PromptCategoryWhereInput | PromptCategoryWhereInput[]
    id?: StringFilter<"PromptCategory"> | string
    name?: StringFilter<"PromptCategory"> | string
    description?: StringNullableFilter<"PromptCategory"> | string | null
    parentCategory?: StringNullableFilter<"PromptCategory"> | string | null
    icon?: StringNullableFilter<"PromptCategory"> | string | null
    color?: StringNullableFilter<"PromptCategory"> | string | null
    order?: IntFilter<"PromptCategory"> | number
    createdAt?: DateTimeFilter<"PromptCategory"> | Date | string
    updatedAt?: DateTimeFilter<"PromptCategory"> | Date | string
    templates?: PromptTemplateListRelationFilter
    parent?: XOR<PromptCategoryNullableRelationFilter, PromptCategoryWhereInput> | null
    children?: PromptCategoryListRelationFilter
  }

  export type PromptCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    parentCategory?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    templates?: PromptTemplateOrderByRelationAggregateInput
    parent?: PromptCategoryOrderByWithRelationInput
    children?: PromptCategoryOrderByRelationAggregateInput
  }

  export type PromptCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PromptCategoryWhereInput | PromptCategoryWhereInput[]
    OR?: PromptCategoryWhereInput[]
    NOT?: PromptCategoryWhereInput | PromptCategoryWhereInput[]
    name?: StringFilter<"PromptCategory"> | string
    description?: StringNullableFilter<"PromptCategory"> | string | null
    parentCategory?: StringNullableFilter<"PromptCategory"> | string | null
    icon?: StringNullableFilter<"PromptCategory"> | string | null
    color?: StringNullableFilter<"PromptCategory"> | string | null
    order?: IntFilter<"PromptCategory"> | number
    createdAt?: DateTimeFilter<"PromptCategory"> | Date | string
    updatedAt?: DateTimeFilter<"PromptCategory"> | Date | string
    templates?: PromptTemplateListRelationFilter
    parent?: XOR<PromptCategoryNullableRelationFilter, PromptCategoryWhereInput> | null
    children?: PromptCategoryListRelationFilter
  }, "id">

  export type PromptCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    parentCategory?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PromptCategoryCountOrderByAggregateInput
    _avg?: PromptCategoryAvgOrderByAggregateInput
    _max?: PromptCategoryMaxOrderByAggregateInput
    _min?: PromptCategoryMinOrderByAggregateInput
    _sum?: PromptCategorySumOrderByAggregateInput
  }

  export type PromptCategoryScalarWhereWithAggregatesInput = {
    AND?: PromptCategoryScalarWhereWithAggregatesInput | PromptCategoryScalarWhereWithAggregatesInput[]
    OR?: PromptCategoryScalarWhereWithAggregatesInput[]
    NOT?: PromptCategoryScalarWhereWithAggregatesInput | PromptCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PromptCategory"> | string
    name?: StringWithAggregatesFilter<"PromptCategory"> | string
    description?: StringNullableWithAggregatesFilter<"PromptCategory"> | string | null
    parentCategory?: StringNullableWithAggregatesFilter<"PromptCategory"> | string | null
    icon?: StringNullableWithAggregatesFilter<"PromptCategory"> | string | null
    color?: StringNullableWithAggregatesFilter<"PromptCategory"> | string | null
    order?: IntWithAggregatesFilter<"PromptCategory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PromptCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PromptCategory"> | Date | string
  }

  export type PromptTemplateWhereInput = {
    AND?: PromptTemplateWhereInput | PromptTemplateWhereInput[]
    OR?: PromptTemplateWhereInput[]
    NOT?: PromptTemplateWhereInput | PromptTemplateWhereInput[]
    id?: StringFilter<"PromptTemplate"> | string
    version?: StringFilter<"PromptTemplate"> | string
    name?: StringFilter<"PromptTemplate"> | string
    description?: StringNullableFilter<"PromptTemplate"> | string | null
    category?: StringFilter<"PromptTemplate"> | string
    status?: StringFilter<"PromptTemplate"> | string
    template?: StringFilter<"PromptTemplate"> | string
    variables?: JsonFilter<"PromptTemplate">
    examples?: JsonFilter<"PromptTemplate">
    metadata?: JsonFilter<"PromptTemplate">
    constraints?: JsonFilter<"PromptTemplate">
    optimization?: JsonFilter<"PromptTemplate">
    testing?: JsonFilter<"PromptTemplate">
    createdAt?: DateTimeFilter<"PromptTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"PromptTemplate"> | Date | string
    categoryRel?: XOR<PromptCategoryRelationFilter, PromptCategoryWhereInput>
    executions?: PromptExecutionListRelationFilter
    changes?: TemplateChangeListRelationFilter
    optimizations?: OptimizationRecordListRelationFilter
  }

  export type PromptTemplateOrderByWithRelationInput = {
    id?: SortOrder
    version?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    status?: SortOrder
    template?: SortOrder
    variables?: SortOrder
    examples?: SortOrder
    metadata?: SortOrder
    constraints?: SortOrder
    optimization?: SortOrder
    testing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryRel?: PromptCategoryOrderByWithRelationInput
    executions?: PromptExecutionOrderByRelationAggregateInput
    changes?: TemplateChangeOrderByRelationAggregateInput
    optimizations?: OptimizationRecordOrderByRelationAggregateInput
  }

  export type PromptTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    id_version?: PromptTemplateIdVersionCompoundUniqueInput
    AND?: PromptTemplateWhereInput | PromptTemplateWhereInput[]
    OR?: PromptTemplateWhereInput[]
    NOT?: PromptTemplateWhereInput | PromptTemplateWhereInput[]
    version?: StringFilter<"PromptTemplate"> | string
    name?: StringFilter<"PromptTemplate"> | string
    description?: StringNullableFilter<"PromptTemplate"> | string | null
    category?: StringFilter<"PromptTemplate"> | string
    status?: StringFilter<"PromptTemplate"> | string
    template?: StringFilter<"PromptTemplate"> | string
    variables?: JsonFilter<"PromptTemplate">
    examples?: JsonFilter<"PromptTemplate">
    metadata?: JsonFilter<"PromptTemplate">
    constraints?: JsonFilter<"PromptTemplate">
    optimization?: JsonFilter<"PromptTemplate">
    testing?: JsonFilter<"PromptTemplate">
    createdAt?: DateTimeFilter<"PromptTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"PromptTemplate"> | Date | string
    categoryRel?: XOR<PromptCategoryRelationFilter, PromptCategoryWhereInput>
    executions?: PromptExecutionListRelationFilter
    changes?: TemplateChangeListRelationFilter
    optimizations?: OptimizationRecordListRelationFilter
  }, "id" | "id_version">

  export type PromptTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    version?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    status?: SortOrder
    template?: SortOrder
    variables?: SortOrder
    examples?: SortOrder
    metadata?: SortOrder
    constraints?: SortOrder
    optimization?: SortOrder
    testing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PromptTemplateCountOrderByAggregateInput
    _max?: PromptTemplateMaxOrderByAggregateInput
    _min?: PromptTemplateMinOrderByAggregateInput
  }

  export type PromptTemplateScalarWhereWithAggregatesInput = {
    AND?: PromptTemplateScalarWhereWithAggregatesInput | PromptTemplateScalarWhereWithAggregatesInput[]
    OR?: PromptTemplateScalarWhereWithAggregatesInput[]
    NOT?: PromptTemplateScalarWhereWithAggregatesInput | PromptTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PromptTemplate"> | string
    version?: StringWithAggregatesFilter<"PromptTemplate"> | string
    name?: StringWithAggregatesFilter<"PromptTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"PromptTemplate"> | string | null
    category?: StringWithAggregatesFilter<"PromptTemplate"> | string
    status?: StringWithAggregatesFilter<"PromptTemplate"> | string
    template?: StringWithAggregatesFilter<"PromptTemplate"> | string
    variables?: JsonWithAggregatesFilter<"PromptTemplate">
    examples?: JsonWithAggregatesFilter<"PromptTemplate">
    metadata?: JsonWithAggregatesFilter<"PromptTemplate">
    constraints?: JsonWithAggregatesFilter<"PromptTemplate">
    optimization?: JsonWithAggregatesFilter<"PromptTemplate">
    testing?: JsonWithAggregatesFilter<"PromptTemplate">
    createdAt?: DateTimeWithAggregatesFilter<"PromptTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PromptTemplate"> | Date | string
  }

  export type TemplateChangeWhereInput = {
    AND?: TemplateChangeWhereInput | TemplateChangeWhereInput[]
    OR?: TemplateChangeWhereInput[]
    NOT?: TemplateChangeWhereInput | TemplateChangeWhereInput[]
    id?: StringFilter<"TemplateChange"> | string
    templateId?: StringFilter<"TemplateChange"> | string
    fromVersion?: StringFilter<"TemplateChange"> | string
    toVersion?: StringFilter<"TemplateChange"> | string
    changes?: JsonFilter<"TemplateChange">
    createdAt?: DateTimeFilter<"TemplateChange"> | Date | string
    template?: XOR<PromptTemplateRelationFilter, PromptTemplateWhereInput>
  }

  export type TemplateChangeOrderByWithRelationInput = {
    id?: SortOrder
    templateId?: SortOrder
    fromVersion?: SortOrder
    toVersion?: SortOrder
    changes?: SortOrder
    createdAt?: SortOrder
    template?: PromptTemplateOrderByWithRelationInput
  }

  export type TemplateChangeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TemplateChangeWhereInput | TemplateChangeWhereInput[]
    OR?: TemplateChangeWhereInput[]
    NOT?: TemplateChangeWhereInput | TemplateChangeWhereInput[]
    templateId?: StringFilter<"TemplateChange"> | string
    fromVersion?: StringFilter<"TemplateChange"> | string
    toVersion?: StringFilter<"TemplateChange"> | string
    changes?: JsonFilter<"TemplateChange">
    createdAt?: DateTimeFilter<"TemplateChange"> | Date | string
    template?: XOR<PromptTemplateRelationFilter, PromptTemplateWhereInput>
  }, "id">

  export type TemplateChangeOrderByWithAggregationInput = {
    id?: SortOrder
    templateId?: SortOrder
    fromVersion?: SortOrder
    toVersion?: SortOrder
    changes?: SortOrder
    createdAt?: SortOrder
    _count?: TemplateChangeCountOrderByAggregateInput
    _max?: TemplateChangeMaxOrderByAggregateInput
    _min?: TemplateChangeMinOrderByAggregateInput
  }

  export type TemplateChangeScalarWhereWithAggregatesInput = {
    AND?: TemplateChangeScalarWhereWithAggregatesInput | TemplateChangeScalarWhereWithAggregatesInput[]
    OR?: TemplateChangeScalarWhereWithAggregatesInput[]
    NOT?: TemplateChangeScalarWhereWithAggregatesInput | TemplateChangeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TemplateChange"> | string
    templateId?: StringWithAggregatesFilter<"TemplateChange"> | string
    fromVersion?: StringWithAggregatesFilter<"TemplateChange"> | string
    toVersion?: StringWithAggregatesFilter<"TemplateChange"> | string
    changes?: JsonWithAggregatesFilter<"TemplateChange">
    createdAt?: DateTimeWithAggregatesFilter<"TemplateChange"> | Date | string
  }

  export type PromptExecutionWhereInput = {
    AND?: PromptExecutionWhereInput | PromptExecutionWhereInput[]
    OR?: PromptExecutionWhereInput[]
    NOT?: PromptExecutionWhereInput | PromptExecutionWhereInput[]
    id?: StringFilter<"PromptExecution"> | string
    templateId?: StringFilter<"PromptExecution"> | string
    templateVersion?: StringFilter<"PromptExecution"> | string
    variables?: JsonFilter<"PromptExecution">
    renderedPrompt?: StringFilter<"PromptExecution"> | string
    context?: JsonNullableFilter<"PromptExecution">
    model?: StringFilter<"PromptExecution"> | string
    provider?: StringFilter<"PromptExecution"> | string
    response?: StringNullableFilter<"PromptExecution"> | string | null
    metrics?: JsonFilter<"PromptExecution">
    quality?: JsonFilter<"PromptExecution">
    feedback?: JsonNullableFilter<"PromptExecution">
    abTestVariant?: StringNullableFilter<"PromptExecution"> | string | null
    userId?: StringNullableFilter<"PromptExecution"> | string | null
    createdAt?: DateTimeFilter<"PromptExecution"> | Date | string
    template?: XOR<PromptTemplateRelationFilter, PromptTemplateWhereInput>
  }

  export type PromptExecutionOrderByWithRelationInput = {
    id?: SortOrder
    templateId?: SortOrder
    templateVersion?: SortOrder
    variables?: SortOrder
    renderedPrompt?: SortOrder
    context?: SortOrderInput | SortOrder
    model?: SortOrder
    provider?: SortOrder
    response?: SortOrderInput | SortOrder
    metrics?: SortOrder
    quality?: SortOrder
    feedback?: SortOrderInput | SortOrder
    abTestVariant?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    template?: PromptTemplateOrderByWithRelationInput
  }

  export type PromptExecutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PromptExecutionWhereInput | PromptExecutionWhereInput[]
    OR?: PromptExecutionWhereInput[]
    NOT?: PromptExecutionWhereInput | PromptExecutionWhereInput[]
    templateId?: StringFilter<"PromptExecution"> | string
    templateVersion?: StringFilter<"PromptExecution"> | string
    variables?: JsonFilter<"PromptExecution">
    renderedPrompt?: StringFilter<"PromptExecution"> | string
    context?: JsonNullableFilter<"PromptExecution">
    model?: StringFilter<"PromptExecution"> | string
    provider?: StringFilter<"PromptExecution"> | string
    response?: StringNullableFilter<"PromptExecution"> | string | null
    metrics?: JsonFilter<"PromptExecution">
    quality?: JsonFilter<"PromptExecution">
    feedback?: JsonNullableFilter<"PromptExecution">
    abTestVariant?: StringNullableFilter<"PromptExecution"> | string | null
    userId?: StringNullableFilter<"PromptExecution"> | string | null
    createdAt?: DateTimeFilter<"PromptExecution"> | Date | string
    template?: XOR<PromptTemplateRelationFilter, PromptTemplateWhereInput>
  }, "id">

  export type PromptExecutionOrderByWithAggregationInput = {
    id?: SortOrder
    templateId?: SortOrder
    templateVersion?: SortOrder
    variables?: SortOrder
    renderedPrompt?: SortOrder
    context?: SortOrderInput | SortOrder
    model?: SortOrder
    provider?: SortOrder
    response?: SortOrderInput | SortOrder
    metrics?: SortOrder
    quality?: SortOrder
    feedback?: SortOrderInput | SortOrder
    abTestVariant?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PromptExecutionCountOrderByAggregateInput
    _max?: PromptExecutionMaxOrderByAggregateInput
    _min?: PromptExecutionMinOrderByAggregateInput
  }

  export type PromptExecutionScalarWhereWithAggregatesInput = {
    AND?: PromptExecutionScalarWhereWithAggregatesInput | PromptExecutionScalarWhereWithAggregatesInput[]
    OR?: PromptExecutionScalarWhereWithAggregatesInput[]
    NOT?: PromptExecutionScalarWhereWithAggregatesInput | PromptExecutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PromptExecution"> | string
    templateId?: StringWithAggregatesFilter<"PromptExecution"> | string
    templateVersion?: StringWithAggregatesFilter<"PromptExecution"> | string
    variables?: JsonWithAggregatesFilter<"PromptExecution">
    renderedPrompt?: StringWithAggregatesFilter<"PromptExecution"> | string
    context?: JsonNullableWithAggregatesFilter<"PromptExecution">
    model?: StringWithAggregatesFilter<"PromptExecution"> | string
    provider?: StringWithAggregatesFilter<"PromptExecution"> | string
    response?: StringNullableWithAggregatesFilter<"PromptExecution"> | string | null
    metrics?: JsonWithAggregatesFilter<"PromptExecution">
    quality?: JsonWithAggregatesFilter<"PromptExecution">
    feedback?: JsonNullableWithAggregatesFilter<"PromptExecution">
    abTestVariant?: StringNullableWithAggregatesFilter<"PromptExecution"> | string | null
    userId?: StringNullableWithAggregatesFilter<"PromptExecution"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PromptExecution"> | Date | string
  }

  export type PromptExecutionErrorWhereInput = {
    AND?: PromptExecutionErrorWhereInput | PromptExecutionErrorWhereInput[]
    OR?: PromptExecutionErrorWhereInput[]
    NOT?: PromptExecutionErrorWhereInput | PromptExecutionErrorWhereInput[]
    id?: StringFilter<"PromptExecutionError"> | string
    templateId?: StringFilter<"PromptExecutionError"> | string
    variables?: JsonFilter<"PromptExecutionError">
    errorMessage?: StringFilter<"PromptExecutionError"> | string
    context?: JsonNullableFilter<"PromptExecutionError">
    createdAt?: DateTimeFilter<"PromptExecutionError"> | Date | string
  }

  export type PromptExecutionErrorOrderByWithRelationInput = {
    id?: SortOrder
    templateId?: SortOrder
    variables?: SortOrder
    errorMessage?: SortOrder
    context?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type PromptExecutionErrorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PromptExecutionErrorWhereInput | PromptExecutionErrorWhereInput[]
    OR?: PromptExecutionErrorWhereInput[]
    NOT?: PromptExecutionErrorWhereInput | PromptExecutionErrorWhereInput[]
    templateId?: StringFilter<"PromptExecutionError"> | string
    variables?: JsonFilter<"PromptExecutionError">
    errorMessage?: StringFilter<"PromptExecutionError"> | string
    context?: JsonNullableFilter<"PromptExecutionError">
    createdAt?: DateTimeFilter<"PromptExecutionError"> | Date | string
  }, "id">

  export type PromptExecutionErrorOrderByWithAggregationInput = {
    id?: SortOrder
    templateId?: SortOrder
    variables?: SortOrder
    errorMessage?: SortOrder
    context?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PromptExecutionErrorCountOrderByAggregateInput
    _max?: PromptExecutionErrorMaxOrderByAggregateInput
    _min?: PromptExecutionErrorMinOrderByAggregateInput
  }

  export type PromptExecutionErrorScalarWhereWithAggregatesInput = {
    AND?: PromptExecutionErrorScalarWhereWithAggregatesInput | PromptExecutionErrorScalarWhereWithAggregatesInput[]
    OR?: PromptExecutionErrorScalarWhereWithAggregatesInput[]
    NOT?: PromptExecutionErrorScalarWhereWithAggregatesInput | PromptExecutionErrorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PromptExecutionError"> | string
    templateId?: StringWithAggregatesFilter<"PromptExecutionError"> | string
    variables?: JsonWithAggregatesFilter<"PromptExecutionError">
    errorMessage?: StringWithAggregatesFilter<"PromptExecutionError"> | string
    context?: JsonNullableWithAggregatesFilter<"PromptExecutionError">
    createdAt?: DateTimeWithAggregatesFilter<"PromptExecutionError"> | Date | string
  }

  export type ABTestWhereInput = {
    AND?: ABTestWhereInput | ABTestWhereInput[]
    OR?: ABTestWhereInput[]
    NOT?: ABTestWhereInput | ABTestWhereInput[]
    id?: StringFilter<"ABTest"> | string
    name?: StringFilter<"ABTest"> | string
    description?: StringNullableFilter<"ABTest"> | string | null
    status?: StringFilter<"ABTest"> | string
    variants?: JsonFilter<"ABTest">
    trafficSplit?: JsonFilter<"ABTest">
    startDate?: DateTimeNullableFilter<"ABTest"> | Date | string | null
    endDate?: DateTimeNullableFilter<"ABTest"> | Date | string | null
    sampleSize?: IntFilter<"ABTest"> | number
    confidence?: DecimalFilter<"ABTest"> | Decimal | DecimalJsLike | number | string
    results?: JsonNullableFilter<"ABTest">
    createdAt?: DateTimeFilter<"ABTest"> | Date | string
  }

  export type ABTestOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    variants?: SortOrder
    trafficSplit?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    sampleSize?: SortOrder
    confidence?: SortOrder
    results?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type ABTestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ABTestWhereInput | ABTestWhereInput[]
    OR?: ABTestWhereInput[]
    NOT?: ABTestWhereInput | ABTestWhereInput[]
    name?: StringFilter<"ABTest"> | string
    description?: StringNullableFilter<"ABTest"> | string | null
    status?: StringFilter<"ABTest"> | string
    variants?: JsonFilter<"ABTest">
    trafficSplit?: JsonFilter<"ABTest">
    startDate?: DateTimeNullableFilter<"ABTest"> | Date | string | null
    endDate?: DateTimeNullableFilter<"ABTest"> | Date | string | null
    sampleSize?: IntFilter<"ABTest"> | number
    confidence?: DecimalFilter<"ABTest"> | Decimal | DecimalJsLike | number | string
    results?: JsonNullableFilter<"ABTest">
    createdAt?: DateTimeFilter<"ABTest"> | Date | string
  }, "id">

  export type ABTestOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    variants?: SortOrder
    trafficSplit?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    sampleSize?: SortOrder
    confidence?: SortOrder
    results?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ABTestCountOrderByAggregateInput
    _avg?: ABTestAvgOrderByAggregateInput
    _max?: ABTestMaxOrderByAggregateInput
    _min?: ABTestMinOrderByAggregateInput
    _sum?: ABTestSumOrderByAggregateInput
  }

  export type ABTestScalarWhereWithAggregatesInput = {
    AND?: ABTestScalarWhereWithAggregatesInput | ABTestScalarWhereWithAggregatesInput[]
    OR?: ABTestScalarWhereWithAggregatesInput[]
    NOT?: ABTestScalarWhereWithAggregatesInput | ABTestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ABTest"> | string
    name?: StringWithAggregatesFilter<"ABTest"> | string
    description?: StringNullableWithAggregatesFilter<"ABTest"> | string | null
    status?: StringWithAggregatesFilter<"ABTest"> | string
    variants?: JsonWithAggregatesFilter<"ABTest">
    trafficSplit?: JsonWithAggregatesFilter<"ABTest">
    startDate?: DateTimeNullableWithAggregatesFilter<"ABTest"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"ABTest"> | Date | string | null
    sampleSize?: IntWithAggregatesFilter<"ABTest"> | number
    confidence?: DecimalWithAggregatesFilter<"ABTest"> | Decimal | DecimalJsLike | number | string
    results?: JsonNullableWithAggregatesFilter<"ABTest">
    createdAt?: DateTimeWithAggregatesFilter<"ABTest"> | Date | string
  }

  export type OptimizationRecordWhereInput = {
    AND?: OptimizationRecordWhereInput | OptimizationRecordWhereInput[]
    OR?: OptimizationRecordWhereInput[]
    NOT?: OptimizationRecordWhereInput | OptimizationRecordWhereInput[]
    id?: StringFilter<"OptimizationRecord"> | string
    templateId?: StringFilter<"OptimizationRecord"> | string
    timestamp?: DateTimeFilter<"OptimizationRecord"> | Date | string
    type?: StringFilter<"OptimizationRecord"> | string
    reason?: StringNullableFilter<"OptimizationRecord"> | string | null
    changes?: JsonFilter<"OptimizationRecord">
    metricsBefore?: JsonFilter<"OptimizationRecord">
    metricsAfter?: JsonFilter<"OptimizationRecord">
    improvement?: DecimalNullableFilter<"OptimizationRecord"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"OptimizationRecord"> | Date | string
    template?: XOR<PromptTemplateRelationFilter, PromptTemplateWhereInput>
  }

  export type OptimizationRecordOrderByWithRelationInput = {
    id?: SortOrder
    templateId?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    reason?: SortOrderInput | SortOrder
    changes?: SortOrder
    metricsBefore?: SortOrder
    metricsAfter?: SortOrder
    improvement?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    template?: PromptTemplateOrderByWithRelationInput
  }

  export type OptimizationRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OptimizationRecordWhereInput | OptimizationRecordWhereInput[]
    OR?: OptimizationRecordWhereInput[]
    NOT?: OptimizationRecordWhereInput | OptimizationRecordWhereInput[]
    templateId?: StringFilter<"OptimizationRecord"> | string
    timestamp?: DateTimeFilter<"OptimizationRecord"> | Date | string
    type?: StringFilter<"OptimizationRecord"> | string
    reason?: StringNullableFilter<"OptimizationRecord"> | string | null
    changes?: JsonFilter<"OptimizationRecord">
    metricsBefore?: JsonFilter<"OptimizationRecord">
    metricsAfter?: JsonFilter<"OptimizationRecord">
    improvement?: DecimalNullableFilter<"OptimizationRecord"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"OptimizationRecord"> | Date | string
    template?: XOR<PromptTemplateRelationFilter, PromptTemplateWhereInput>
  }, "id">

  export type OptimizationRecordOrderByWithAggregationInput = {
    id?: SortOrder
    templateId?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    reason?: SortOrderInput | SortOrder
    changes?: SortOrder
    metricsBefore?: SortOrder
    metricsAfter?: SortOrder
    improvement?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: OptimizationRecordCountOrderByAggregateInput
    _avg?: OptimizationRecordAvgOrderByAggregateInput
    _max?: OptimizationRecordMaxOrderByAggregateInput
    _min?: OptimizationRecordMinOrderByAggregateInput
    _sum?: OptimizationRecordSumOrderByAggregateInput
  }

  export type OptimizationRecordScalarWhereWithAggregatesInput = {
    AND?: OptimizationRecordScalarWhereWithAggregatesInput | OptimizationRecordScalarWhereWithAggregatesInput[]
    OR?: OptimizationRecordScalarWhereWithAggregatesInput[]
    NOT?: OptimizationRecordScalarWhereWithAggregatesInput | OptimizationRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OptimizationRecord"> | string
    templateId?: StringWithAggregatesFilter<"OptimizationRecord"> | string
    timestamp?: DateTimeWithAggregatesFilter<"OptimizationRecord"> | Date | string
    type?: StringWithAggregatesFilter<"OptimizationRecord"> | string
    reason?: StringNullableWithAggregatesFilter<"OptimizationRecord"> | string | null
    changes?: JsonWithAggregatesFilter<"OptimizationRecord">
    metricsBefore?: JsonWithAggregatesFilter<"OptimizationRecord">
    metricsAfter?: JsonWithAggregatesFilter<"OptimizationRecord">
    improvement?: DecimalNullableWithAggregatesFilter<"OptimizationRecord"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OptimizationRecord"> | Date | string
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: StringFilter<"Conversation"> | string
    userId?: StringFilter<"Conversation"> | string
    title?: StringFilter<"Conversation"> | string
    metadata?: JsonFilter<"Conversation">
    settings?: JsonFilter<"Conversation">
    analytics?: JsonFilter<"Conversation">
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    messages?: MessageListRelationFilter
    shares?: ConversationShareListRelationFilter
    exports?: ConversationExportListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    metadata?: SortOrder
    settings?: SortOrder
    analytics?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
    shares?: ConversationShareOrderByRelationAggregateInput
    exports?: ConversationExportOrderByRelationAggregateInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    userId?: StringFilter<"Conversation"> | string
    title?: StringFilter<"Conversation"> | string
    metadata?: JsonFilter<"Conversation">
    settings?: JsonFilter<"Conversation">
    analytics?: JsonFilter<"Conversation">
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    messages?: MessageListRelationFilter
    shares?: ConversationShareListRelationFilter
    exports?: ConversationExportListRelationFilter
  }, "id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    metadata?: SortOrder
    settings?: SortOrder
    analytics?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversation"> | string
    userId?: StringWithAggregatesFilter<"Conversation"> | string
    title?: StringWithAggregatesFilter<"Conversation"> | string
    metadata?: JsonWithAggregatesFilter<"Conversation">
    settings?: JsonWithAggregatesFilter<"Conversation">
    analytics?: JsonWithAggregatesFilter<"Conversation">
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    role?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    timestamp?: DateTimeFilter<"Message"> | Date | string
    metadata?: JsonFilter<"Message">
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    reactions?: MessageReactionListRelationFilter
    attachments?: MessageAttachmentListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
    reactions?: MessageReactionOrderByRelationAggregateInput
    attachments?: MessageAttachmentOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    conversationId?: StringFilter<"Message"> | string
    role?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    timestamp?: DateTimeFilter<"Message"> | Date | string
    metadata?: JsonFilter<"Message">
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    reactions?: MessageReactionListRelationFilter
    attachments?: MessageAttachmentListRelationFilter
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    conversationId?: StringWithAggregatesFilter<"Message"> | string
    role?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    timestamp?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    metadata?: JsonWithAggregatesFilter<"Message">
  }

  export type MessageReactionWhereInput = {
    AND?: MessageReactionWhereInput | MessageReactionWhereInput[]
    OR?: MessageReactionWhereInput[]
    NOT?: MessageReactionWhereInput | MessageReactionWhereInput[]
    id?: StringFilter<"MessageReaction"> | string
    messageId?: StringFilter<"MessageReaction"> | string
    userId?: StringFilter<"MessageReaction"> | string
    emoji?: StringFilter<"MessageReaction"> | string
    timestamp?: DateTimeFilter<"MessageReaction"> | Date | string
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MessageReactionOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    emoji?: SortOrder
    timestamp?: SortOrder
    message?: MessageOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MessageReactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId_userId_emoji?: MessageReactionMessageIdUserIdEmojiCompoundUniqueInput
    AND?: MessageReactionWhereInput | MessageReactionWhereInput[]
    OR?: MessageReactionWhereInput[]
    NOT?: MessageReactionWhereInput | MessageReactionWhereInput[]
    messageId?: StringFilter<"MessageReaction"> | string
    userId?: StringFilter<"MessageReaction"> | string
    emoji?: StringFilter<"MessageReaction"> | string
    timestamp?: DateTimeFilter<"MessageReaction"> | Date | string
    message?: XOR<MessageRelationFilter, MessageWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "messageId_userId_emoji">

  export type MessageReactionOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    emoji?: SortOrder
    timestamp?: SortOrder
    _count?: MessageReactionCountOrderByAggregateInput
    _max?: MessageReactionMaxOrderByAggregateInput
    _min?: MessageReactionMinOrderByAggregateInput
  }

  export type MessageReactionScalarWhereWithAggregatesInput = {
    AND?: MessageReactionScalarWhereWithAggregatesInput | MessageReactionScalarWhereWithAggregatesInput[]
    OR?: MessageReactionScalarWhereWithAggregatesInput[]
    NOT?: MessageReactionScalarWhereWithAggregatesInput | MessageReactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageReaction"> | string
    messageId?: StringWithAggregatesFilter<"MessageReaction"> | string
    userId?: StringWithAggregatesFilter<"MessageReaction"> | string
    emoji?: StringWithAggregatesFilter<"MessageReaction"> | string
    timestamp?: DateTimeWithAggregatesFilter<"MessageReaction"> | Date | string
  }

  export type MessageAttachmentWhereInput = {
    AND?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    OR?: MessageAttachmentWhereInput[]
    NOT?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    id?: StringFilter<"MessageAttachment"> | string
    messageId?: StringFilter<"MessageAttachment"> | string
    type?: StringFilter<"MessageAttachment"> | string
    name?: StringFilter<"MessageAttachment"> | string
    url?: StringFilter<"MessageAttachment"> | string
    size?: BigIntNullableFilter<"MessageAttachment"> | bigint | number | null
    mimeType?: StringNullableFilter<"MessageAttachment"> | string | null
    metadata?: JsonFilter<"MessageAttachment">
    thumbnail?: StringNullableFilter<"MessageAttachment"> | string | null
    message?: XOR<MessageRelationFilter, MessageWhereInput>
  }

  export type MessageAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    url?: SortOrder
    size?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    metadata?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    message?: MessageOrderByWithRelationInput
  }

  export type MessageAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    OR?: MessageAttachmentWhereInput[]
    NOT?: MessageAttachmentWhereInput | MessageAttachmentWhereInput[]
    messageId?: StringFilter<"MessageAttachment"> | string
    type?: StringFilter<"MessageAttachment"> | string
    name?: StringFilter<"MessageAttachment"> | string
    url?: StringFilter<"MessageAttachment"> | string
    size?: BigIntNullableFilter<"MessageAttachment"> | bigint | number | null
    mimeType?: StringNullableFilter<"MessageAttachment"> | string | null
    metadata?: JsonFilter<"MessageAttachment">
    thumbnail?: StringNullableFilter<"MessageAttachment"> | string | null
    message?: XOR<MessageRelationFilter, MessageWhereInput>
  }, "id">

  export type MessageAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    url?: SortOrder
    size?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    metadata?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    _count?: MessageAttachmentCountOrderByAggregateInput
    _avg?: MessageAttachmentAvgOrderByAggregateInput
    _max?: MessageAttachmentMaxOrderByAggregateInput
    _min?: MessageAttachmentMinOrderByAggregateInput
    _sum?: MessageAttachmentSumOrderByAggregateInput
  }

  export type MessageAttachmentScalarWhereWithAggregatesInput = {
    AND?: MessageAttachmentScalarWhereWithAggregatesInput | MessageAttachmentScalarWhereWithAggregatesInput[]
    OR?: MessageAttachmentScalarWhereWithAggregatesInput[]
    NOT?: MessageAttachmentScalarWhereWithAggregatesInput | MessageAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageAttachment"> | string
    messageId?: StringWithAggregatesFilter<"MessageAttachment"> | string
    type?: StringWithAggregatesFilter<"MessageAttachment"> | string
    name?: StringWithAggregatesFilter<"MessageAttachment"> | string
    url?: StringWithAggregatesFilter<"MessageAttachment"> | string
    size?: BigIntNullableWithAggregatesFilter<"MessageAttachment"> | bigint | number | null
    mimeType?: StringNullableWithAggregatesFilter<"MessageAttachment"> | string | null
    metadata?: JsonWithAggregatesFilter<"MessageAttachment">
    thumbnail?: StringNullableWithAggregatesFilter<"MessageAttachment"> | string | null
  }

  export type ConversationShareWhereInput = {
    AND?: ConversationShareWhereInput | ConversationShareWhereInput[]
    OR?: ConversationShareWhereInput[]
    NOT?: ConversationShareWhereInput | ConversationShareWhereInput[]
    id?: StringFilter<"ConversationShare"> | string
    conversationId?: StringFilter<"ConversationShare"> | string
    shareId?: StringFilter<"ConversationShare"> | string
    createdBy?: StringFilter<"ConversationShare"> | string
    createdAt?: DateTimeFilter<"ConversationShare"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ConversationShare"> | Date | string | null
    permissions?: JsonFilter<"ConversationShare">
    settings?: JsonFilter<"ConversationShare">
    analytics?: JsonFilter<"ConversationShare">
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ConversationShareOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    shareId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    permissions?: SortOrder
    settings?: SortOrder
    analytics?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type ConversationShareWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shareId?: string
    AND?: ConversationShareWhereInput | ConversationShareWhereInput[]
    OR?: ConversationShareWhereInput[]
    NOT?: ConversationShareWhereInput | ConversationShareWhereInput[]
    conversationId?: StringFilter<"ConversationShare"> | string
    createdBy?: StringFilter<"ConversationShare"> | string
    createdAt?: DateTimeFilter<"ConversationShare"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ConversationShare"> | Date | string | null
    permissions?: JsonFilter<"ConversationShare">
    settings?: JsonFilter<"ConversationShare">
    analytics?: JsonFilter<"ConversationShare">
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
    creator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "shareId">

  export type ConversationShareOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    shareId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    permissions?: SortOrder
    settings?: SortOrder
    analytics?: SortOrder
    _count?: ConversationShareCountOrderByAggregateInput
    _max?: ConversationShareMaxOrderByAggregateInput
    _min?: ConversationShareMinOrderByAggregateInput
  }

  export type ConversationShareScalarWhereWithAggregatesInput = {
    AND?: ConversationShareScalarWhereWithAggregatesInput | ConversationShareScalarWhereWithAggregatesInput[]
    OR?: ConversationShareScalarWhereWithAggregatesInput[]
    NOT?: ConversationShareScalarWhereWithAggregatesInput | ConversationShareScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConversationShare"> | string
    conversationId?: StringWithAggregatesFilter<"ConversationShare"> | string
    shareId?: StringWithAggregatesFilter<"ConversationShare"> | string
    createdBy?: StringWithAggregatesFilter<"ConversationShare"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ConversationShare"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ConversationShare"> | Date | string | null
    permissions?: JsonWithAggregatesFilter<"ConversationShare">
    settings?: JsonWithAggregatesFilter<"ConversationShare">
    analytics?: JsonWithAggregatesFilter<"ConversationShare">
  }

  export type ConversationExportWhereInput = {
    AND?: ConversationExportWhereInput | ConversationExportWhereInput[]
    OR?: ConversationExportWhereInput[]
    NOT?: ConversationExportWhereInput | ConversationExportWhereInput[]
    id?: StringFilter<"ConversationExport"> | string
    conversationId?: StringFilter<"ConversationExport"> | string
    format?: StringFilter<"ConversationExport"> | string
    options?: JsonFilter<"ConversationExport">
    status?: StringFilter<"ConversationExport"> | string
    downloadUrl?: StringNullableFilter<"ConversationExport"> | string | null
    expiresAt?: DateTimeNullableFilter<"ConversationExport"> | Date | string | null
    createdAt?: DateTimeFilter<"ConversationExport"> | Date | string
    completedAt?: DateTimeNullableFilter<"ConversationExport"> | Date | string | null
    error?: StringNullableFilter<"ConversationExport"> | string | null
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
  }

  export type ConversationExportOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    format?: SortOrder
    options?: SortOrder
    status?: SortOrder
    downloadUrl?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    conversation?: ConversationOrderByWithRelationInput
  }

  export type ConversationExportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationExportWhereInput | ConversationExportWhereInput[]
    OR?: ConversationExportWhereInput[]
    NOT?: ConversationExportWhereInput | ConversationExportWhereInput[]
    conversationId?: StringFilter<"ConversationExport"> | string
    format?: StringFilter<"ConversationExport"> | string
    options?: JsonFilter<"ConversationExport">
    status?: StringFilter<"ConversationExport"> | string
    downloadUrl?: StringNullableFilter<"ConversationExport"> | string | null
    expiresAt?: DateTimeNullableFilter<"ConversationExport"> | Date | string | null
    createdAt?: DateTimeFilter<"ConversationExport"> | Date | string
    completedAt?: DateTimeNullableFilter<"ConversationExport"> | Date | string | null
    error?: StringNullableFilter<"ConversationExport"> | string | null
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
  }, "id">

  export type ConversationExportOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    format?: SortOrder
    options?: SortOrder
    status?: SortOrder
    downloadUrl?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    _count?: ConversationExportCountOrderByAggregateInput
    _max?: ConversationExportMaxOrderByAggregateInput
    _min?: ConversationExportMinOrderByAggregateInput
  }

  export type ConversationExportScalarWhereWithAggregatesInput = {
    AND?: ConversationExportScalarWhereWithAggregatesInput | ConversationExportScalarWhereWithAggregatesInput[]
    OR?: ConversationExportScalarWhereWithAggregatesInput[]
    NOT?: ConversationExportScalarWhereWithAggregatesInput | ConversationExportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConversationExport"> | string
    conversationId?: StringWithAggregatesFilter<"ConversationExport"> | string
    format?: StringWithAggregatesFilter<"ConversationExport"> | string
    options?: JsonWithAggregatesFilter<"ConversationExport">
    status?: StringWithAggregatesFilter<"ConversationExport"> | string
    downloadUrl?: StringNullableWithAggregatesFilter<"ConversationExport"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ConversationExport"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ConversationExport"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"ConversationExport"> | Date | string | null
    error?: StringNullableWithAggregatesFilter<"ConversationExport"> | string | null
  }

  export type ContextSourceWhereInput = {
    AND?: ContextSourceWhereInput | ContextSourceWhereInput[]
    OR?: ContextSourceWhereInput[]
    NOT?: ContextSourceWhereInput | ContextSourceWhereInput[]
    id?: StringFilter<"ContextSource"> | string
    type?: StringFilter<"ContextSource"> | string
    title?: StringFilter<"ContextSource"> | string
    content?: StringFilter<"ContextSource"> | string
    url?: StringNullableFilter<"ContextSource"> | string | null
    libraryId?: StringNullableFilter<"ContextSource"> | string | null
    version?: StringNullableFilter<"ContextSource"> | string | null
    language?: StringFilter<"ContextSource"> | string
    tags?: StringNullableListFilter<"ContextSource">
    relevanceScore?: FloatFilter<"ContextSource"> | number
    freshness?: FloatFilter<"ContextSource"> | number
    popularity?: FloatFilter<"ContextSource"> | number
    lastUpdated?: DateTimeFilter<"ContextSource"> | Date | string
    createdAt?: DateTimeFilter<"ContextSource"> | Date | string
    updatedAt?: DateTimeFilter<"ContextSource"> | Date | string
    chunks?: ContextChunkListRelationFilter
  }

  export type ContextSourceOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    url?: SortOrderInput | SortOrder
    libraryId?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    language?: SortOrder
    tags?: SortOrder
    relevanceScore?: SortOrder
    freshness?: SortOrder
    popularity?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    chunks?: ContextChunkOrderByRelationAggregateInput
  }

  export type ContextSourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContextSourceWhereInput | ContextSourceWhereInput[]
    OR?: ContextSourceWhereInput[]
    NOT?: ContextSourceWhereInput | ContextSourceWhereInput[]
    type?: StringFilter<"ContextSource"> | string
    title?: StringFilter<"ContextSource"> | string
    content?: StringFilter<"ContextSource"> | string
    url?: StringNullableFilter<"ContextSource"> | string | null
    libraryId?: StringNullableFilter<"ContextSource"> | string | null
    version?: StringNullableFilter<"ContextSource"> | string | null
    language?: StringFilter<"ContextSource"> | string
    tags?: StringNullableListFilter<"ContextSource">
    relevanceScore?: FloatFilter<"ContextSource"> | number
    freshness?: FloatFilter<"ContextSource"> | number
    popularity?: FloatFilter<"ContextSource"> | number
    lastUpdated?: DateTimeFilter<"ContextSource"> | Date | string
    createdAt?: DateTimeFilter<"ContextSource"> | Date | string
    updatedAt?: DateTimeFilter<"ContextSource"> | Date | string
    chunks?: ContextChunkListRelationFilter
  }, "id">

  export type ContextSourceOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    url?: SortOrderInput | SortOrder
    libraryId?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    language?: SortOrder
    tags?: SortOrder
    relevanceScore?: SortOrder
    freshness?: SortOrder
    popularity?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContextSourceCountOrderByAggregateInput
    _avg?: ContextSourceAvgOrderByAggregateInput
    _max?: ContextSourceMaxOrderByAggregateInput
    _min?: ContextSourceMinOrderByAggregateInput
    _sum?: ContextSourceSumOrderByAggregateInput
  }

  export type ContextSourceScalarWhereWithAggregatesInput = {
    AND?: ContextSourceScalarWhereWithAggregatesInput | ContextSourceScalarWhereWithAggregatesInput[]
    OR?: ContextSourceScalarWhereWithAggregatesInput[]
    NOT?: ContextSourceScalarWhereWithAggregatesInput | ContextSourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContextSource"> | string
    type?: StringWithAggregatesFilter<"ContextSource"> | string
    title?: StringWithAggregatesFilter<"ContextSource"> | string
    content?: StringWithAggregatesFilter<"ContextSource"> | string
    url?: StringNullableWithAggregatesFilter<"ContextSource"> | string | null
    libraryId?: StringNullableWithAggregatesFilter<"ContextSource"> | string | null
    version?: StringNullableWithAggregatesFilter<"ContextSource"> | string | null
    language?: StringWithAggregatesFilter<"ContextSource"> | string
    tags?: StringNullableListFilter<"ContextSource">
    relevanceScore?: FloatWithAggregatesFilter<"ContextSource"> | number
    freshness?: FloatWithAggregatesFilter<"ContextSource"> | number
    popularity?: FloatWithAggregatesFilter<"ContextSource"> | number
    lastUpdated?: DateTimeWithAggregatesFilter<"ContextSource"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ContextSource"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContextSource"> | Date | string
  }

  export type ContextChunkWhereInput = {
    AND?: ContextChunkWhereInput | ContextChunkWhereInput[]
    OR?: ContextChunkWhereInput[]
    NOT?: ContextChunkWhereInput | ContextChunkWhereInput[]
    id?: StringFilter<"ContextChunk"> | string
    sourceId?: StringFilter<"ContextChunk"> | string
    content?: StringFilter<"ContextChunk"> | string
    positionStart?: IntFilter<"ContextChunk"> | number
    positionEnd?: IntFilter<"ContextChunk"> | number
    positionIndex?: IntFilter<"ContextChunk"> | number
    positionTotal?: IntFilter<"ContextChunk"> | number
    sectionTitle?: StringNullableFilter<"ContextChunk"> | string | null
    codeBlocks?: IntFilter<"ContextChunk"> | number
    links?: IntFilter<"ContextChunk"> | number
    images?: IntFilter<"ContextChunk"> | number
    complexity?: StringFilter<"ContextChunk"> | string
    embedding?: FloatNullableListFilter<"ContextChunk">
    createdAt?: DateTimeFilter<"ContextChunk"> | Date | string
    updatedAt?: DateTimeFilter<"ContextChunk"> | Date | string
    source?: XOR<ContextSourceRelationFilter, ContextSourceWhereInput>
  }

  export type ContextChunkOrderByWithRelationInput = {
    id?: SortOrder
    sourceId?: SortOrder
    content?: SortOrder
    positionStart?: SortOrder
    positionEnd?: SortOrder
    positionIndex?: SortOrder
    positionTotal?: SortOrder
    sectionTitle?: SortOrderInput | SortOrder
    codeBlocks?: SortOrder
    links?: SortOrder
    images?: SortOrder
    complexity?: SortOrder
    embedding?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    source?: ContextSourceOrderByWithRelationInput
  }

  export type ContextChunkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContextChunkWhereInput | ContextChunkWhereInput[]
    OR?: ContextChunkWhereInput[]
    NOT?: ContextChunkWhereInput | ContextChunkWhereInput[]
    sourceId?: StringFilter<"ContextChunk"> | string
    content?: StringFilter<"ContextChunk"> | string
    positionStart?: IntFilter<"ContextChunk"> | number
    positionEnd?: IntFilter<"ContextChunk"> | number
    positionIndex?: IntFilter<"ContextChunk"> | number
    positionTotal?: IntFilter<"ContextChunk"> | number
    sectionTitle?: StringNullableFilter<"ContextChunk"> | string | null
    codeBlocks?: IntFilter<"ContextChunk"> | number
    links?: IntFilter<"ContextChunk"> | number
    images?: IntFilter<"ContextChunk"> | number
    complexity?: StringFilter<"ContextChunk"> | string
    embedding?: FloatNullableListFilter<"ContextChunk">
    createdAt?: DateTimeFilter<"ContextChunk"> | Date | string
    updatedAt?: DateTimeFilter<"ContextChunk"> | Date | string
    source?: XOR<ContextSourceRelationFilter, ContextSourceWhereInput>
  }, "id">

  export type ContextChunkOrderByWithAggregationInput = {
    id?: SortOrder
    sourceId?: SortOrder
    content?: SortOrder
    positionStart?: SortOrder
    positionEnd?: SortOrder
    positionIndex?: SortOrder
    positionTotal?: SortOrder
    sectionTitle?: SortOrderInput | SortOrder
    codeBlocks?: SortOrder
    links?: SortOrder
    images?: SortOrder
    complexity?: SortOrder
    embedding?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContextChunkCountOrderByAggregateInput
    _avg?: ContextChunkAvgOrderByAggregateInput
    _max?: ContextChunkMaxOrderByAggregateInput
    _min?: ContextChunkMinOrderByAggregateInput
    _sum?: ContextChunkSumOrderByAggregateInput
  }

  export type ContextChunkScalarWhereWithAggregatesInput = {
    AND?: ContextChunkScalarWhereWithAggregatesInput | ContextChunkScalarWhereWithAggregatesInput[]
    OR?: ContextChunkScalarWhereWithAggregatesInput[]
    NOT?: ContextChunkScalarWhereWithAggregatesInput | ContextChunkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContextChunk"> | string
    sourceId?: StringWithAggregatesFilter<"ContextChunk"> | string
    content?: StringWithAggregatesFilter<"ContextChunk"> | string
    positionStart?: IntWithAggregatesFilter<"ContextChunk"> | number
    positionEnd?: IntWithAggregatesFilter<"ContextChunk"> | number
    positionIndex?: IntWithAggregatesFilter<"ContextChunk"> | number
    positionTotal?: IntWithAggregatesFilter<"ContextChunk"> | number
    sectionTitle?: StringNullableWithAggregatesFilter<"ContextChunk"> | string | null
    codeBlocks?: IntWithAggregatesFilter<"ContextChunk"> | number
    links?: IntWithAggregatesFilter<"ContextChunk"> | number
    images?: IntWithAggregatesFilter<"ContextChunk"> | number
    complexity?: StringWithAggregatesFilter<"ContextChunk"> | string
    embedding?: FloatNullableListFilter<"ContextChunk">
    createdAt?: DateTimeWithAggregatesFilter<"ContextChunk"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContextChunk"> | Date | string
  }

  export type ContextQueryWhereInput = {
    AND?: ContextQueryWhereInput | ContextQueryWhereInput[]
    OR?: ContextQueryWhereInput[]
    NOT?: ContextQueryWhereInput | ContextQueryWhereInput[]
    id?: StringFilter<"ContextQuery"> | string
    conversationId?: StringFilter<"ContextQuery"> | string
    messageId?: StringFilter<"ContextQuery"> | string
    queryText?: StringFilter<"ContextQuery"> | string
    intentType?: StringNullableFilter<"ContextQuery"> | string | null
    intentConfidence?: FloatNullableFilter<"ContextQuery"> | number | null
    intentKeywords?: StringNullableListFilter<"ContextQuery">
    intentCategory?: StringNullableFilter<"ContextQuery"> | string | null
    intentSubcategory?: StringNullableFilter<"ContextQuery"> | string | null
    entities?: JsonFilter<"ContextQuery">
    filters?: JsonFilter<"ContextQuery">
    options?: JsonFilter<"ContextQuery">
    createdAt?: DateTimeFilter<"ContextQuery"> | Date | string
    results?: ContextResultListRelationFilter
    analytics?: ContextQueryAnalyticsListRelationFilter
  }

  export type ContextQueryOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    messageId?: SortOrder
    queryText?: SortOrder
    intentType?: SortOrderInput | SortOrder
    intentConfidence?: SortOrderInput | SortOrder
    intentKeywords?: SortOrder
    intentCategory?: SortOrderInput | SortOrder
    intentSubcategory?: SortOrderInput | SortOrder
    entities?: SortOrder
    filters?: SortOrder
    options?: SortOrder
    createdAt?: SortOrder
    results?: ContextResultOrderByRelationAggregateInput
    analytics?: ContextQueryAnalyticsOrderByRelationAggregateInput
  }

  export type ContextQueryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContextQueryWhereInput | ContextQueryWhereInput[]
    OR?: ContextQueryWhereInput[]
    NOT?: ContextQueryWhereInput | ContextQueryWhereInput[]
    conversationId?: StringFilter<"ContextQuery"> | string
    messageId?: StringFilter<"ContextQuery"> | string
    queryText?: StringFilter<"ContextQuery"> | string
    intentType?: StringNullableFilter<"ContextQuery"> | string | null
    intentConfidence?: FloatNullableFilter<"ContextQuery"> | number | null
    intentKeywords?: StringNullableListFilter<"ContextQuery">
    intentCategory?: StringNullableFilter<"ContextQuery"> | string | null
    intentSubcategory?: StringNullableFilter<"ContextQuery"> | string | null
    entities?: JsonFilter<"ContextQuery">
    filters?: JsonFilter<"ContextQuery">
    options?: JsonFilter<"ContextQuery">
    createdAt?: DateTimeFilter<"ContextQuery"> | Date | string
    results?: ContextResultListRelationFilter
    analytics?: ContextQueryAnalyticsListRelationFilter
  }, "id">

  export type ContextQueryOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    messageId?: SortOrder
    queryText?: SortOrder
    intentType?: SortOrderInput | SortOrder
    intentConfidence?: SortOrderInput | SortOrder
    intentKeywords?: SortOrder
    intentCategory?: SortOrderInput | SortOrder
    intentSubcategory?: SortOrderInput | SortOrder
    entities?: SortOrder
    filters?: SortOrder
    options?: SortOrder
    createdAt?: SortOrder
    _count?: ContextQueryCountOrderByAggregateInput
    _avg?: ContextQueryAvgOrderByAggregateInput
    _max?: ContextQueryMaxOrderByAggregateInput
    _min?: ContextQueryMinOrderByAggregateInput
    _sum?: ContextQuerySumOrderByAggregateInput
  }

  export type ContextQueryScalarWhereWithAggregatesInput = {
    AND?: ContextQueryScalarWhereWithAggregatesInput | ContextQueryScalarWhereWithAggregatesInput[]
    OR?: ContextQueryScalarWhereWithAggregatesInput[]
    NOT?: ContextQueryScalarWhereWithAggregatesInput | ContextQueryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContextQuery"> | string
    conversationId?: StringWithAggregatesFilter<"ContextQuery"> | string
    messageId?: StringWithAggregatesFilter<"ContextQuery"> | string
    queryText?: StringWithAggregatesFilter<"ContextQuery"> | string
    intentType?: StringNullableWithAggregatesFilter<"ContextQuery"> | string | null
    intentConfidence?: FloatNullableWithAggregatesFilter<"ContextQuery"> | number | null
    intentKeywords?: StringNullableListFilter<"ContextQuery">
    intentCategory?: StringNullableWithAggregatesFilter<"ContextQuery"> | string | null
    intentSubcategory?: StringNullableWithAggregatesFilter<"ContextQuery"> | string | null
    entities?: JsonWithAggregatesFilter<"ContextQuery">
    filters?: JsonWithAggregatesFilter<"ContextQuery">
    options?: JsonWithAggregatesFilter<"ContextQuery">
    createdAt?: DateTimeWithAggregatesFilter<"ContextQuery"> | Date | string
  }

  export type ContextResultWhereInput = {
    AND?: ContextResultWhereInput | ContextResultWhereInput[]
    OR?: ContextResultWhereInput[]
    NOT?: ContextResultWhereInput | ContextResultWhereInput[]
    id?: StringFilter<"ContextResult"> | string
    queryId?: StringFilter<"ContextResult"> | string
    sources?: JsonFilter<"ContextResult">
    chunks?: JsonFilter<"ContextResult">
    summary?: StringNullableFilter<"ContextResult"> | string | null
    totalSources?: IntFilter<"ContextResult"> | number
    totalChunks?: IntFilter<"ContextResult"> | number
    queryTime?: IntFilter<"ContextResult"> | number
    relevanceScore?: FloatFilter<"ContextResult"> | number
    coverage?: FloatFilter<"ContextResult"> | number
    freshness?: FloatFilter<"ContextResult"> | number
    suggestions?: JsonFilter<"ContextResult">
    createdAt?: DateTimeFilter<"ContextResult"> | Date | string
    query?: XOR<ContextQueryRelationFilter, ContextQueryWhereInput>
  }

  export type ContextResultOrderByWithRelationInput = {
    id?: SortOrder
    queryId?: SortOrder
    sources?: SortOrder
    chunks?: SortOrder
    summary?: SortOrderInput | SortOrder
    totalSources?: SortOrder
    totalChunks?: SortOrder
    queryTime?: SortOrder
    relevanceScore?: SortOrder
    coverage?: SortOrder
    freshness?: SortOrder
    suggestions?: SortOrder
    createdAt?: SortOrder
    query?: ContextQueryOrderByWithRelationInput
  }

  export type ContextResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContextResultWhereInput | ContextResultWhereInput[]
    OR?: ContextResultWhereInput[]
    NOT?: ContextResultWhereInput | ContextResultWhereInput[]
    queryId?: StringFilter<"ContextResult"> | string
    sources?: JsonFilter<"ContextResult">
    chunks?: JsonFilter<"ContextResult">
    summary?: StringNullableFilter<"ContextResult"> | string | null
    totalSources?: IntFilter<"ContextResult"> | number
    totalChunks?: IntFilter<"ContextResult"> | number
    queryTime?: IntFilter<"ContextResult"> | number
    relevanceScore?: FloatFilter<"ContextResult"> | number
    coverage?: FloatFilter<"ContextResult"> | number
    freshness?: FloatFilter<"ContextResult"> | number
    suggestions?: JsonFilter<"ContextResult">
    createdAt?: DateTimeFilter<"ContextResult"> | Date | string
    query?: XOR<ContextQueryRelationFilter, ContextQueryWhereInput>
  }, "id">

  export type ContextResultOrderByWithAggregationInput = {
    id?: SortOrder
    queryId?: SortOrder
    sources?: SortOrder
    chunks?: SortOrder
    summary?: SortOrderInput | SortOrder
    totalSources?: SortOrder
    totalChunks?: SortOrder
    queryTime?: SortOrder
    relevanceScore?: SortOrder
    coverage?: SortOrder
    freshness?: SortOrder
    suggestions?: SortOrder
    createdAt?: SortOrder
    _count?: ContextResultCountOrderByAggregateInput
    _avg?: ContextResultAvgOrderByAggregateInput
    _max?: ContextResultMaxOrderByAggregateInput
    _min?: ContextResultMinOrderByAggregateInput
    _sum?: ContextResultSumOrderByAggregateInput
  }

  export type ContextResultScalarWhereWithAggregatesInput = {
    AND?: ContextResultScalarWhereWithAggregatesInput | ContextResultScalarWhereWithAggregatesInput[]
    OR?: ContextResultScalarWhereWithAggregatesInput[]
    NOT?: ContextResultScalarWhereWithAggregatesInput | ContextResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContextResult"> | string
    queryId?: StringWithAggregatesFilter<"ContextResult"> | string
    sources?: JsonWithAggregatesFilter<"ContextResult">
    chunks?: JsonWithAggregatesFilter<"ContextResult">
    summary?: StringNullableWithAggregatesFilter<"ContextResult"> | string | null
    totalSources?: IntWithAggregatesFilter<"ContextResult"> | number
    totalChunks?: IntWithAggregatesFilter<"ContextResult"> | number
    queryTime?: IntWithAggregatesFilter<"ContextResult"> | number
    relevanceScore?: FloatWithAggregatesFilter<"ContextResult"> | number
    coverage?: FloatWithAggregatesFilter<"ContextResult"> | number
    freshness?: FloatWithAggregatesFilter<"ContextResult"> | number
    suggestions?: JsonWithAggregatesFilter<"ContextResult">
    createdAt?: DateTimeWithAggregatesFilter<"ContextResult"> | Date | string
  }

  export type ContextInjectionWhereInput = {
    AND?: ContextInjectionWhereInput | ContextInjectionWhereInput[]
    OR?: ContextInjectionWhereInput[]
    NOT?: ContextInjectionWhereInput | ContextInjectionWhereInput[]
    id?: StringFilter<"ContextInjection"> | string
    conversationId?: StringFilter<"ContextInjection"> | string
    messageId?: StringFilter<"ContextInjection"> | string
    context?: JsonFilter<"ContextInjection">
    templateId?: StringNullableFilter<"ContextInjection"> | string | null
    injectedPrompt?: StringFilter<"ContextInjection"> | string
    originalLength?: IntFilter<"ContextInjection"> | number
    injectedLength?: IntFilter<"ContextInjection"> | number
    compressionRatio?: FloatFilter<"ContextInjection"> | number
    relevanceScore?: FloatFilter<"ContextInjection"> | number
    createdAt?: DateTimeFilter<"ContextInjection"> | Date | string
  }

  export type ContextInjectionOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    messageId?: SortOrder
    context?: SortOrder
    templateId?: SortOrderInput | SortOrder
    injectedPrompt?: SortOrder
    originalLength?: SortOrder
    injectedLength?: SortOrder
    compressionRatio?: SortOrder
    relevanceScore?: SortOrder
    createdAt?: SortOrder
  }

  export type ContextInjectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContextInjectionWhereInput | ContextInjectionWhereInput[]
    OR?: ContextInjectionWhereInput[]
    NOT?: ContextInjectionWhereInput | ContextInjectionWhereInput[]
    conversationId?: StringFilter<"ContextInjection"> | string
    messageId?: StringFilter<"ContextInjection"> | string
    context?: JsonFilter<"ContextInjection">
    templateId?: StringNullableFilter<"ContextInjection"> | string | null
    injectedPrompt?: StringFilter<"ContextInjection"> | string
    originalLength?: IntFilter<"ContextInjection"> | number
    injectedLength?: IntFilter<"ContextInjection"> | number
    compressionRatio?: FloatFilter<"ContextInjection"> | number
    relevanceScore?: FloatFilter<"ContextInjection"> | number
    createdAt?: DateTimeFilter<"ContextInjection"> | Date | string
  }, "id">

  export type ContextInjectionOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    messageId?: SortOrder
    context?: SortOrder
    templateId?: SortOrderInput | SortOrder
    injectedPrompt?: SortOrder
    originalLength?: SortOrder
    injectedLength?: SortOrder
    compressionRatio?: SortOrder
    relevanceScore?: SortOrder
    createdAt?: SortOrder
    _count?: ContextInjectionCountOrderByAggregateInput
    _avg?: ContextInjectionAvgOrderByAggregateInput
    _max?: ContextInjectionMaxOrderByAggregateInput
    _min?: ContextInjectionMinOrderByAggregateInput
    _sum?: ContextInjectionSumOrderByAggregateInput
  }

  export type ContextInjectionScalarWhereWithAggregatesInput = {
    AND?: ContextInjectionScalarWhereWithAggregatesInput | ContextInjectionScalarWhereWithAggregatesInput[]
    OR?: ContextInjectionScalarWhereWithAggregatesInput[]
    NOT?: ContextInjectionScalarWhereWithAggregatesInput | ContextInjectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContextInjection"> | string
    conversationId?: StringWithAggregatesFilter<"ContextInjection"> | string
    messageId?: StringWithAggregatesFilter<"ContextInjection"> | string
    context?: JsonWithAggregatesFilter<"ContextInjection">
    templateId?: StringNullableWithAggregatesFilter<"ContextInjection"> | string | null
    injectedPrompt?: StringWithAggregatesFilter<"ContextInjection"> | string
    originalLength?: IntWithAggregatesFilter<"ContextInjection"> | number
    injectedLength?: IntWithAggregatesFilter<"ContextInjection"> | number
    compressionRatio?: FloatWithAggregatesFilter<"ContextInjection"> | number
    relevanceScore?: FloatWithAggregatesFilter<"ContextInjection"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ContextInjection"> | Date | string
  }

  export type ContextTemplateWhereInput = {
    AND?: ContextTemplateWhereInput | ContextTemplateWhereInput[]
    OR?: ContextTemplateWhereInput[]
    NOT?: ContextTemplateWhereInput | ContextTemplateWhereInput[]
    id?: StringFilter<"ContextTemplate"> | string
    name?: StringFilter<"ContextTemplate"> | string
    type?: StringFilter<"ContextTemplate"> | string
    template?: StringFilter<"ContextTemplate"> | string
    variables?: StringNullableListFilter<"ContextTemplate">
    description?: StringNullableFilter<"ContextTemplate"> | string | null
    version?: StringFilter<"ContextTemplate"> | string
    usageCount?: IntFilter<"ContextTemplate"> | number
    createdAt?: DateTimeFilter<"ContextTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ContextTemplate"> | Date | string
  }

  export type ContextTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    template?: SortOrder
    variables?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContextTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ContextTemplateWhereInput | ContextTemplateWhereInput[]
    OR?: ContextTemplateWhereInput[]
    NOT?: ContextTemplateWhereInput | ContextTemplateWhereInput[]
    type?: StringFilter<"ContextTemplate"> | string
    template?: StringFilter<"ContextTemplate"> | string
    variables?: StringNullableListFilter<"ContextTemplate">
    description?: StringNullableFilter<"ContextTemplate"> | string | null
    version?: StringFilter<"ContextTemplate"> | string
    usageCount?: IntFilter<"ContextTemplate"> | number
    createdAt?: DateTimeFilter<"ContextTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ContextTemplate"> | Date | string
  }, "id" | "name">

  export type ContextTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    template?: SortOrder
    variables?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContextTemplateCountOrderByAggregateInput
    _avg?: ContextTemplateAvgOrderByAggregateInput
    _max?: ContextTemplateMaxOrderByAggregateInput
    _min?: ContextTemplateMinOrderByAggregateInput
    _sum?: ContextTemplateSumOrderByAggregateInput
  }

  export type ContextTemplateScalarWhereWithAggregatesInput = {
    AND?: ContextTemplateScalarWhereWithAggregatesInput | ContextTemplateScalarWhereWithAggregatesInput[]
    OR?: ContextTemplateScalarWhereWithAggregatesInput[]
    NOT?: ContextTemplateScalarWhereWithAggregatesInput | ContextTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContextTemplate"> | string
    name?: StringWithAggregatesFilter<"ContextTemplate"> | string
    type?: StringWithAggregatesFilter<"ContextTemplate"> | string
    template?: StringWithAggregatesFilter<"ContextTemplate"> | string
    variables?: StringNullableListFilter<"ContextTemplate">
    description?: StringNullableWithAggregatesFilter<"ContextTemplate"> | string | null
    version?: StringWithAggregatesFilter<"ContextTemplate"> | string
    usageCount?: IntWithAggregatesFilter<"ContextTemplate"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ContextTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContextTemplate"> | Date | string
  }

  export type ContextQueryAnalyticsWhereInput = {
    AND?: ContextQueryAnalyticsWhereInput | ContextQueryAnalyticsWhereInput[]
    OR?: ContextQueryAnalyticsWhereInput[]
    NOT?: ContextQueryAnalyticsWhereInput | ContextQueryAnalyticsWhereInput[]
    id?: StringFilter<"ContextQueryAnalytics"> | string
    queryId?: StringNullableFilter<"ContextQueryAnalytics"> | string | null
    conversationId?: StringFilter<"ContextQueryAnalytics"> | string
    queryText?: StringFilter<"ContextQueryAnalytics"> | string
    intent?: JsonFilter<"ContextQueryAnalytics">
    entities?: JsonFilter<"ContextQueryAnalytics">
    filters?: JsonFilter<"ContextQueryAnalytics">
    options?: JsonFilter<"ContextQueryAnalytics">
    resultMetadata?: JsonFilter<"ContextQueryAnalytics">
    createdAt?: DateTimeFilter<"ContextQueryAnalytics"> | Date | string
    query?: XOR<ContextQueryNullableRelationFilter, ContextQueryWhereInput> | null
  }

  export type ContextQueryAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    queryId?: SortOrderInput | SortOrder
    conversationId?: SortOrder
    queryText?: SortOrder
    intent?: SortOrder
    entities?: SortOrder
    filters?: SortOrder
    options?: SortOrder
    resultMetadata?: SortOrder
    createdAt?: SortOrder
    query?: ContextQueryOrderByWithRelationInput
  }

  export type ContextQueryAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContextQueryAnalyticsWhereInput | ContextQueryAnalyticsWhereInput[]
    OR?: ContextQueryAnalyticsWhereInput[]
    NOT?: ContextQueryAnalyticsWhereInput | ContextQueryAnalyticsWhereInput[]
    queryId?: StringNullableFilter<"ContextQueryAnalytics"> | string | null
    conversationId?: StringFilter<"ContextQueryAnalytics"> | string
    queryText?: StringFilter<"ContextQueryAnalytics"> | string
    intent?: JsonFilter<"ContextQueryAnalytics">
    entities?: JsonFilter<"ContextQueryAnalytics">
    filters?: JsonFilter<"ContextQueryAnalytics">
    options?: JsonFilter<"ContextQueryAnalytics">
    resultMetadata?: JsonFilter<"ContextQueryAnalytics">
    createdAt?: DateTimeFilter<"ContextQueryAnalytics"> | Date | string
    query?: XOR<ContextQueryNullableRelationFilter, ContextQueryWhereInput> | null
  }, "id">

  export type ContextQueryAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    queryId?: SortOrderInput | SortOrder
    conversationId?: SortOrder
    queryText?: SortOrder
    intent?: SortOrder
    entities?: SortOrder
    filters?: SortOrder
    options?: SortOrder
    resultMetadata?: SortOrder
    createdAt?: SortOrder
    _count?: ContextQueryAnalyticsCountOrderByAggregateInput
    _max?: ContextQueryAnalyticsMaxOrderByAggregateInput
    _min?: ContextQueryAnalyticsMinOrderByAggregateInput
  }

  export type ContextQueryAnalyticsScalarWhereWithAggregatesInput = {
    AND?: ContextQueryAnalyticsScalarWhereWithAggregatesInput | ContextQueryAnalyticsScalarWhereWithAggregatesInput[]
    OR?: ContextQueryAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: ContextQueryAnalyticsScalarWhereWithAggregatesInput | ContextQueryAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContextQueryAnalytics"> | string
    queryId?: StringNullableWithAggregatesFilter<"ContextQueryAnalytics"> | string | null
    conversationId?: StringWithAggregatesFilter<"ContextQueryAnalytics"> | string
    queryText?: StringWithAggregatesFilter<"ContextQueryAnalytics"> | string
    intent?: JsonWithAggregatesFilter<"ContextQueryAnalytics">
    entities?: JsonWithAggregatesFilter<"ContextQueryAnalytics">
    filters?: JsonWithAggregatesFilter<"ContextQueryAnalytics">
    options?: JsonWithAggregatesFilter<"ContextQueryAnalytics">
    resultMetadata?: JsonWithAggregatesFilter<"ContextQueryAnalytics">
    createdAt?: DateTimeWithAggregatesFilter<"ContextQueryAnalytics"> | Date | string
  }

  export type ContextCacheWhereInput = {
    AND?: ContextCacheWhereInput | ContextCacheWhereInput[]
    OR?: ContextCacheWhereInput[]
    NOT?: ContextCacheWhereInput | ContextCacheWhereInput[]
    id?: StringFilter<"ContextCache"> | string
    cacheKey?: StringFilter<"ContextCache"> | string
    queryText?: StringFilter<"ContextCache"> | string
    result?: JsonFilter<"ContextCache">
    expiresAt?: DateTimeFilter<"ContextCache"> | Date | string
    hitCount?: IntFilter<"ContextCache"> | number
    lastAccessed?: DateTimeFilter<"ContextCache"> | Date | string
    createdAt?: DateTimeFilter<"ContextCache"> | Date | string
  }

  export type ContextCacheOrderByWithRelationInput = {
    id?: SortOrder
    cacheKey?: SortOrder
    queryText?: SortOrder
    result?: SortOrder
    expiresAt?: SortOrder
    hitCount?: SortOrder
    lastAccessed?: SortOrder
    createdAt?: SortOrder
  }

  export type ContextCacheWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cacheKey?: string
    AND?: ContextCacheWhereInput | ContextCacheWhereInput[]
    OR?: ContextCacheWhereInput[]
    NOT?: ContextCacheWhereInput | ContextCacheWhereInput[]
    queryText?: StringFilter<"ContextCache"> | string
    result?: JsonFilter<"ContextCache">
    expiresAt?: DateTimeFilter<"ContextCache"> | Date | string
    hitCount?: IntFilter<"ContextCache"> | number
    lastAccessed?: DateTimeFilter<"ContextCache"> | Date | string
    createdAt?: DateTimeFilter<"ContextCache"> | Date | string
  }, "id" | "cacheKey">

  export type ContextCacheOrderByWithAggregationInput = {
    id?: SortOrder
    cacheKey?: SortOrder
    queryText?: SortOrder
    result?: SortOrder
    expiresAt?: SortOrder
    hitCount?: SortOrder
    lastAccessed?: SortOrder
    createdAt?: SortOrder
    _count?: ContextCacheCountOrderByAggregateInput
    _avg?: ContextCacheAvgOrderByAggregateInput
    _max?: ContextCacheMaxOrderByAggregateInput
    _min?: ContextCacheMinOrderByAggregateInput
    _sum?: ContextCacheSumOrderByAggregateInput
  }

  export type ContextCacheScalarWhereWithAggregatesInput = {
    AND?: ContextCacheScalarWhereWithAggregatesInput | ContextCacheScalarWhereWithAggregatesInput[]
    OR?: ContextCacheScalarWhereWithAggregatesInput[]
    NOT?: ContextCacheScalarWhereWithAggregatesInput | ContextCacheScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContextCache"> | string
    cacheKey?: StringWithAggregatesFilter<"ContextCache"> | string
    queryText?: StringWithAggregatesFilter<"ContextCache"> | string
    result?: JsonWithAggregatesFilter<"ContextCache">
    expiresAt?: DateTimeWithAggregatesFilter<"ContextCache"> | Date | string
    hitCount?: IntWithAggregatesFilter<"ContextCache"> | number
    lastAccessed?: DateTimeWithAggregatesFilter<"ContextCache"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ContextCache"> | Date | string
  }

  export type UserPreferencesWhereInput = {
    AND?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    OR?: UserPreferencesWhereInput[]
    NOT?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    id?: StringFilter<"UserPreferences"> | string
    userId?: StringFilter<"UserPreferences"> | string
    preferences?: JsonFilter<"UserPreferences">
    createdAt?: DateTimeFilter<"UserPreferences"> | Date | string
    updatedAt?: DateTimeFilter<"UserPreferences"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type UserPreferencesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserPreferencesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    OR?: UserPreferencesWhereInput[]
    NOT?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    preferences?: JsonFilter<"UserPreferences">
    createdAt?: DateTimeFilter<"UserPreferences"> | Date | string
    updatedAt?: DateTimeFilter<"UserPreferences"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "userId">

  export type UserPreferencesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserPreferencesCountOrderByAggregateInput
    _max?: UserPreferencesMaxOrderByAggregateInput
    _min?: UserPreferencesMinOrderByAggregateInput
  }

  export type UserPreferencesScalarWhereWithAggregatesInput = {
    AND?: UserPreferencesScalarWhereWithAggregatesInput | UserPreferencesScalarWhereWithAggregatesInput[]
    OR?: UserPreferencesScalarWhereWithAggregatesInput[]
    NOT?: UserPreferencesScalarWhereWithAggregatesInput | UserPreferencesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPreferences"> | string
    userId?: StringWithAggregatesFilter<"UserPreferences"> | string
    preferences?: JsonWithAggregatesFilter<"UserPreferences">
    createdAt?: DateTimeWithAggregatesFilter<"UserPreferences"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserPreferences"> | Date | string
  }

  export type ThemeWhereInput = {
    AND?: ThemeWhereInput | ThemeWhereInput[]
    OR?: ThemeWhereInput[]
    NOT?: ThemeWhereInput | ThemeWhereInput[]
    id?: StringFilter<"Theme"> | string
    name?: StringFilter<"Theme"> | string
    description?: StringNullableFilter<"Theme"> | string | null
    category?: StringFilter<"Theme"> | string
    colors?: JsonFilter<"Theme">
    typography?: JsonFilter<"Theme">
    spacing?: JsonFilter<"Theme">
    shadows?: JsonFilter<"Theme">
    borderRadius?: JsonFilter<"Theme">
    animations?: JsonFilter<"Theme">
    custom?: BoolFilter<"Theme"> | boolean
    createdBy?: StringNullableFilter<"Theme"> | string | null
    createdAt?: DateTimeFilter<"Theme"> | Date | string
    updatedAt?: DateTimeFilter<"Theme"> | Date | string
    creator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ThemeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    colors?: SortOrder
    typography?: SortOrder
    spacing?: SortOrder
    shadows?: SortOrder
    borderRadius?: SortOrder
    animations?: SortOrder
    custom?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
  }

  export type ThemeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ThemeWhereInput | ThemeWhereInput[]
    OR?: ThemeWhereInput[]
    NOT?: ThemeWhereInput | ThemeWhereInput[]
    name?: StringFilter<"Theme"> | string
    description?: StringNullableFilter<"Theme"> | string | null
    category?: StringFilter<"Theme"> | string
    colors?: JsonFilter<"Theme">
    typography?: JsonFilter<"Theme">
    spacing?: JsonFilter<"Theme">
    shadows?: JsonFilter<"Theme">
    borderRadius?: JsonFilter<"Theme">
    animations?: JsonFilter<"Theme">
    custom?: BoolFilter<"Theme"> | boolean
    createdBy?: StringNullableFilter<"Theme"> | string | null
    createdAt?: DateTimeFilter<"Theme"> | Date | string
    updatedAt?: DateTimeFilter<"Theme"> | Date | string
    creator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ThemeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    colors?: SortOrder
    typography?: SortOrder
    spacing?: SortOrder
    shadows?: SortOrder
    borderRadius?: SortOrder
    animations?: SortOrder
    custom?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ThemeCountOrderByAggregateInput
    _max?: ThemeMaxOrderByAggregateInput
    _min?: ThemeMinOrderByAggregateInput
  }

  export type ThemeScalarWhereWithAggregatesInput = {
    AND?: ThemeScalarWhereWithAggregatesInput | ThemeScalarWhereWithAggregatesInput[]
    OR?: ThemeScalarWhereWithAggregatesInput[]
    NOT?: ThemeScalarWhereWithAggregatesInput | ThemeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Theme"> | string
    name?: StringWithAggregatesFilter<"Theme"> | string
    description?: StringNullableWithAggregatesFilter<"Theme"> | string | null
    category?: StringWithAggregatesFilter<"Theme"> | string
    colors?: JsonWithAggregatesFilter<"Theme">
    typography?: JsonWithAggregatesFilter<"Theme">
    spacing?: JsonWithAggregatesFilter<"Theme">
    shadows?: JsonWithAggregatesFilter<"Theme">
    borderRadius?: JsonWithAggregatesFilter<"Theme">
    animations?: JsonWithAggregatesFilter<"Theme">
    custom?: BoolWithAggregatesFilter<"Theme"> | boolean
    createdBy?: StringNullableWithAggregatesFilter<"Theme"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Theme"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Theme"> | Date | string
  }

  export type PersonalizationAnalyticsWhereInput = {
    AND?: PersonalizationAnalyticsWhereInput | PersonalizationAnalyticsWhereInput[]
    OR?: PersonalizationAnalyticsWhereInput[]
    NOT?: PersonalizationAnalyticsWhereInput | PersonalizationAnalyticsWhereInput[]
    id?: StringFilter<"PersonalizationAnalytics"> | string
    userId?: StringFilter<"PersonalizationAnalytics"> | string
    actionType?: StringFilter<"PersonalizationAnalytics"> | string
    metadata?: JsonFilter<"PersonalizationAnalytics">
    createdAt?: DateTimeFilter<"PersonalizationAnalytics"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PersonalizationAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PersonalizationAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PersonalizationAnalyticsWhereInput | PersonalizationAnalyticsWhereInput[]
    OR?: PersonalizationAnalyticsWhereInput[]
    NOT?: PersonalizationAnalyticsWhereInput | PersonalizationAnalyticsWhereInput[]
    userId?: StringFilter<"PersonalizationAnalytics"> | string
    actionType?: StringFilter<"PersonalizationAnalytics"> | string
    metadata?: JsonFilter<"PersonalizationAnalytics">
    createdAt?: DateTimeFilter<"PersonalizationAnalytics"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type PersonalizationAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    _count?: PersonalizationAnalyticsCountOrderByAggregateInput
    _max?: PersonalizationAnalyticsMaxOrderByAggregateInput
    _min?: PersonalizationAnalyticsMinOrderByAggregateInput
  }

  export type PersonalizationAnalyticsScalarWhereWithAggregatesInput = {
    AND?: PersonalizationAnalyticsScalarWhereWithAggregatesInput | PersonalizationAnalyticsScalarWhereWithAggregatesInput[]
    OR?: PersonalizationAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: PersonalizationAnalyticsScalarWhereWithAggregatesInput | PersonalizationAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PersonalizationAnalytics"> | string
    userId?: StringWithAggregatesFilter<"PersonalizationAnalytics"> | string
    actionType?: StringWithAggregatesFilter<"PersonalizationAnalytics"> | string
    metadata?: JsonWithAggregatesFilter<"PersonalizationAnalytics">
    createdAt?: DateTimeWithAggregatesFilter<"PersonalizationAnalytics"> | Date | string
  }

  export type UserProfileWhereInput = {
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    id?: StringFilter<"UserProfile"> | string
    userId?: StringFilter<"UserProfile"> | string
    firstName?: StringNullableFilter<"UserProfile"> | string | null
    lastName?: StringNullableFilter<"UserProfile"> | string | null
    email?: StringNullableFilter<"UserProfile"> | string | null
    phone?: StringNullableFilter<"UserProfile"> | string | null
    address?: StringNullableFilter<"UserProfile"> | string | null
    city?: StringNullableFilter<"UserProfile"> | string | null
    state?: StringNullableFilter<"UserProfile"> | string | null
    country?: StringNullableFilter<"UserProfile"> | string | null
    postalCode?: StringNullableFilter<"UserProfile"> | string | null
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    invoices?: InvoiceListRelationFilter
    payments?: PaymentListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    credits?: CreditListRelationFilter
  }

  export type UserProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoices?: InvoiceOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    credits?: CreditOrderByRelationAggregateInput
  }

  export type UserProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    firstName?: StringNullableFilter<"UserProfile"> | string | null
    lastName?: StringNullableFilter<"UserProfile"> | string | null
    email?: StringNullableFilter<"UserProfile"> | string | null
    phone?: StringNullableFilter<"UserProfile"> | string | null
    address?: StringNullableFilter<"UserProfile"> | string | null
    city?: StringNullableFilter<"UserProfile"> | string | null
    state?: StringNullableFilter<"UserProfile"> | string | null
    country?: StringNullableFilter<"UserProfile"> | string | null
    postalCode?: StringNullableFilter<"UserProfile"> | string | null
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    invoices?: InvoiceListRelationFilter
    payments?: PaymentListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    credits?: CreditListRelationFilter
  }, "id" | "userId">

  export type UserProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserProfileCountOrderByAggregateInput
    _max?: UserProfileMaxOrderByAggregateInput
    _min?: UserProfileMinOrderByAggregateInput
  }

  export type UserProfileScalarWhereWithAggregatesInput = {
    AND?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    OR?: UserProfileScalarWhereWithAggregatesInput[]
    NOT?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserProfile"> | string
    userId?: StringWithAggregatesFilter<"UserProfile"> | string
    firstName?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    email?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    phone?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    address?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    city?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    state?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    country?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    number?: StringFilter<"Invoice"> | string
    userId?: StringFilter<"Invoice"> | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | InvoiceStatus
    period?: JsonFilter<"Invoice">
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    paidDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Invoice"> | string
    items?: JsonFilter<"Invoice">
    billingAddress?: JsonFilter<"Invoice">
    metadata?: JsonFilter<"Invoice">
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    userProfile?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
    payments?: PaymentListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    period?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    items?: SortOrder
    billingAddress?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userProfile?: UserProfileOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    number?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    userId?: StringFilter<"Invoice"> | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | InvoiceStatus
    period?: JsonFilter<"Invoice">
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    paidDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Invoice"> | string
    items?: JsonFilter<"Invoice">
    billingAddress?: JsonFilter<"Invoice">
    metadata?: JsonFilter<"Invoice">
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    userProfile?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
    payments?: PaymentListRelationFilter
  }, "id" | "number">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    period?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    items?: SortOrder
    billingAddress?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    number?: StringWithAggregatesFilter<"Invoice"> | string
    userId?: StringWithAggregatesFilter<"Invoice"> | string
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | InvoiceStatus
    period?: JsonWithAggregatesFilter<"Invoice">
    issueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    paidDate?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    subtotal?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Invoice"> | string
    items?: JsonWithAggregatesFilter<"Invoice">
    billingAddress?: JsonWithAggregatesFilter<"Invoice">
    metadata?: JsonWithAggregatesFilter<"Invoice">
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    invoiceId?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | PaymentStatus
    providerTransactionId?: StringNullableFilter<"Payment"> | string | null
    failureReason?: StringNullableFilter<"Payment"> | string | null
    refundedAmount?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    processedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    metadata?: JsonFilter<"Payment">
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
    userProfile?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    providerTransactionId?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    refundedAmount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    metadata?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    userProfile?: UserProfileOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    invoiceId?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | PaymentStatus
    providerTransactionId?: StringNullableFilter<"Payment"> | string | null
    failureReason?: StringNullableFilter<"Payment"> | string | null
    refundedAmount?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    processedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    metadata?: JsonFilter<"Payment">
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
    userProfile?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    providerTransactionId?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    refundedAmount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    metadata?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    invoiceId?: StringWithAggregatesFilter<"Payment"> | string
    userId?: StringWithAggregatesFilter<"Payment"> | string
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Payment"> | string
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | PaymentStatus
    providerTransactionId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    failureReason?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    refundedAmount?: DecimalNullableWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    metadata?: JsonWithAggregatesFilter<"Payment">
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    plan?: StringFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusFilter<"Subscription"> | SubscriptionStatus
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    amount?: DecimalFilter<"Subscription"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Subscription"> | string
    interval?: EnumSubscriptionIntervalFilter<"Subscription"> | SubscriptionInterval
    intervalCount?: IntFilter<"Subscription"> | number
    trialStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    metadata?: JsonFilter<"Subscription">
    userProfile?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    intervalCount?: SortOrder
    trialStart?: SortOrderInput | SortOrder
    trialEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrder
    userProfile?: UserProfileOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    userId?: StringFilter<"Subscription"> | string
    plan?: StringFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusFilter<"Subscription"> | SubscriptionStatus
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    amount?: DecimalFilter<"Subscription"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Subscription"> | string
    interval?: EnumSubscriptionIntervalFilter<"Subscription"> | SubscriptionInterval
    intervalCount?: IntFilter<"Subscription"> | number
    trialStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    metadata?: JsonFilter<"Subscription">
    userProfile?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
  }, "id">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    intervalCount?: SortOrder
    trialStart?: SortOrderInput | SortOrder
    trialEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    userId?: StringWithAggregatesFilter<"Subscription"> | string
    plan?: StringWithAggregatesFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusWithAggregatesFilter<"Subscription"> | SubscriptionStatus
    currentPeriodStart?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    cancelAtPeriodEnd?: BoolWithAggregatesFilter<"Subscription"> | boolean
    amount?: DecimalWithAggregatesFilter<"Subscription"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Subscription"> | string
    interval?: EnumSubscriptionIntervalWithAggregatesFilter<"Subscription"> | SubscriptionInterval
    intervalCount?: IntWithAggregatesFilter<"Subscription"> | number
    trialStart?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    trialEnd?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    metadata?: JsonWithAggregatesFilter<"Subscription">
  }

  export type CreditWhereInput = {
    AND?: CreditWhereInput | CreditWhereInput[]
    OR?: CreditWhereInput[]
    NOT?: CreditWhereInput | CreditWhereInput[]
    id?: StringFilter<"Credit"> | string
    userId?: StringFilter<"Credit"> | string
    amount?: DecimalFilter<"Credit"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Credit"> | string
    reason?: StringFilter<"Credit"> | string
    type?: EnumCreditTypeFilter<"Credit"> | CreditType
    expiresAt?: DateTimeNullableFilter<"Credit"> | Date | string | null
    usedAt?: DateTimeNullableFilter<"Credit"> | Date | string | null
    invoiceId?: StringNullableFilter<"Credit"> | string | null
    createdAt?: DateTimeFilter<"Credit"> | Date | string
    metadata?: JsonFilter<"Credit">
    userProfile?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
  }

  export type CreditOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    reason?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    usedAt?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    metadata?: SortOrder
    userProfile?: UserProfileOrderByWithRelationInput
  }

  export type CreditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CreditWhereInput | CreditWhereInput[]
    OR?: CreditWhereInput[]
    NOT?: CreditWhereInput | CreditWhereInput[]
    userId?: StringFilter<"Credit"> | string
    amount?: DecimalFilter<"Credit"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Credit"> | string
    reason?: StringFilter<"Credit"> | string
    type?: EnumCreditTypeFilter<"Credit"> | CreditType
    expiresAt?: DateTimeNullableFilter<"Credit"> | Date | string | null
    usedAt?: DateTimeNullableFilter<"Credit"> | Date | string | null
    invoiceId?: StringNullableFilter<"Credit"> | string | null
    createdAt?: DateTimeFilter<"Credit"> | Date | string
    metadata?: JsonFilter<"Credit">
    userProfile?: XOR<UserProfileRelationFilter, UserProfileWhereInput>
  }, "id">

  export type CreditOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    reason?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    usedAt?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    metadata?: SortOrder
    _count?: CreditCountOrderByAggregateInput
    _avg?: CreditAvgOrderByAggregateInput
    _max?: CreditMaxOrderByAggregateInput
    _min?: CreditMinOrderByAggregateInput
    _sum?: CreditSumOrderByAggregateInput
  }

  export type CreditScalarWhereWithAggregatesInput = {
    AND?: CreditScalarWhereWithAggregatesInput | CreditScalarWhereWithAggregatesInput[]
    OR?: CreditScalarWhereWithAggregatesInput[]
    NOT?: CreditScalarWhereWithAggregatesInput | CreditScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Credit"> | string
    userId?: StringWithAggregatesFilter<"Credit"> | string
    amount?: DecimalWithAggregatesFilter<"Credit"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Credit"> | string
    reason?: StringWithAggregatesFilter<"Credit"> | string
    type?: EnumCreditTypeWithAggregatesFilter<"Credit"> | CreditType
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Credit"> | Date | string | null
    usedAt?: DateTimeNullableWithAggregatesFilter<"Credit"> | Date | string | null
    invoiceId?: StringNullableWithAggregatesFilter<"Credit"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Credit"> | Date | string
    metadata?: JsonWithAggregatesFilter<"Credit">
  }

  export type BillingAlertWhereInput = {
    AND?: BillingAlertWhereInput | BillingAlertWhereInput[]
    OR?: BillingAlertWhereInput[]
    NOT?: BillingAlertWhereInput | BillingAlertWhereInput[]
    id?: StringFilter<"BillingAlert"> | string
    userId?: StringFilter<"BillingAlert"> | string
    type?: EnumBillingAlertTypeFilter<"BillingAlert"> | BillingAlertType
    threshold?: DecimalNullableFilter<"BillingAlert"> | Decimal | DecimalJsLike | number | string | null
    currentValue?: DecimalNullableFilter<"BillingAlert"> | Decimal | DecimalJsLike | number | string | null
    message?: StringFilter<"BillingAlert"> | string
    isRead?: BoolFilter<"BillingAlert"> | boolean
    createdAt?: DateTimeFilter<"BillingAlert"> | Date | string
    readAt?: DateTimeNullableFilter<"BillingAlert"> | Date | string | null
    metadata?: JsonFilter<"BillingAlert">
  }

  export type BillingAlertOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    threshold?: SortOrderInput | SortOrder
    currentValue?: SortOrderInput | SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    metadata?: SortOrder
  }

  export type BillingAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BillingAlertWhereInput | BillingAlertWhereInput[]
    OR?: BillingAlertWhereInput[]
    NOT?: BillingAlertWhereInput | BillingAlertWhereInput[]
    userId?: StringFilter<"BillingAlert"> | string
    type?: EnumBillingAlertTypeFilter<"BillingAlert"> | BillingAlertType
    threshold?: DecimalNullableFilter<"BillingAlert"> | Decimal | DecimalJsLike | number | string | null
    currentValue?: DecimalNullableFilter<"BillingAlert"> | Decimal | DecimalJsLike | number | string | null
    message?: StringFilter<"BillingAlert"> | string
    isRead?: BoolFilter<"BillingAlert"> | boolean
    createdAt?: DateTimeFilter<"BillingAlert"> | Date | string
    readAt?: DateTimeNullableFilter<"BillingAlert"> | Date | string | null
    metadata?: JsonFilter<"BillingAlert">
  }, "id">

  export type BillingAlertOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    threshold?: SortOrderInput | SortOrder
    currentValue?: SortOrderInput | SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrderInput | SortOrder
    metadata?: SortOrder
    _count?: BillingAlertCountOrderByAggregateInput
    _avg?: BillingAlertAvgOrderByAggregateInput
    _max?: BillingAlertMaxOrderByAggregateInput
    _min?: BillingAlertMinOrderByAggregateInput
    _sum?: BillingAlertSumOrderByAggregateInput
  }

  export type BillingAlertScalarWhereWithAggregatesInput = {
    AND?: BillingAlertScalarWhereWithAggregatesInput | BillingAlertScalarWhereWithAggregatesInput[]
    OR?: BillingAlertScalarWhereWithAggregatesInput[]
    NOT?: BillingAlertScalarWhereWithAggregatesInput | BillingAlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BillingAlert"> | string
    userId?: StringWithAggregatesFilter<"BillingAlert"> | string
    type?: EnumBillingAlertTypeWithAggregatesFilter<"BillingAlert"> | BillingAlertType
    threshold?: DecimalNullableWithAggregatesFilter<"BillingAlert"> | Decimal | DecimalJsLike | number | string | null
    currentValue?: DecimalNullableWithAggregatesFilter<"BillingAlert"> | Decimal | DecimalJsLike | number | string | null
    message?: StringWithAggregatesFilter<"BillingAlert"> | string
    isRead?: BoolWithAggregatesFilter<"BillingAlert"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BillingAlert"> | Date | string
    readAt?: DateTimeNullableWithAggregatesFilter<"BillingAlert"> | Date | string | null
    metadata?: JsonWithAggregatesFilter<"BillingAlert">
  }

  export type PlanWhereInput = {
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    id?: StringFilter<"Plan"> | string
    name?: StringFilter<"Plan"> | string
    description?: StringNullableFilter<"Plan"> | string | null
    amount?: DecimalFilter<"Plan"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Plan"> | string
    interval?: EnumPlanIntervalFilter<"Plan"> | PlanInterval
    features?: StringNullableListFilter<"Plan">
    limits?: JsonFilter<"Plan">
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
    metadata?: JsonFilter<"Plan">
  }

  export type PlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    features?: SortOrder
    limits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrder
  }

  export type PlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    name?: StringFilter<"Plan"> | string
    description?: StringNullableFilter<"Plan"> | string | null
    amount?: DecimalFilter<"Plan"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Plan"> | string
    interval?: EnumPlanIntervalFilter<"Plan"> | PlanInterval
    features?: StringNullableListFilter<"Plan">
    limits?: JsonFilter<"Plan">
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
    metadata?: JsonFilter<"Plan">
  }, "id">

  export type PlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    features?: SortOrder
    limits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrder
    _count?: PlanCountOrderByAggregateInput
    _avg?: PlanAvgOrderByAggregateInput
    _max?: PlanMaxOrderByAggregateInput
    _min?: PlanMinOrderByAggregateInput
    _sum?: PlanSumOrderByAggregateInput
  }

  export type PlanScalarWhereWithAggregatesInput = {
    AND?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    OR?: PlanScalarWhereWithAggregatesInput[]
    NOT?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Plan"> | string
    name?: StringWithAggregatesFilter<"Plan"> | string
    description?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    amount?: DecimalWithAggregatesFilter<"Plan"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Plan"> | string
    interval?: EnumPlanIntervalWithAggregatesFilter<"Plan"> | PlanInterval
    features?: StringNullableListFilter<"Plan">
    limits?: JsonWithAggregatesFilter<"Plan">
    createdAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
    metadata?: JsonWithAggregatesFilter<"Plan">
  }

  export type ClientCreateInput = {
    id?: string
    name: string
    domain?: string | null
    apiKeys: JsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleOnClientCreateNestedManyWithoutClientInput
    environmentVariables?: EnvironmentVariableCreateNestedManyWithoutClientInput
    users?: UserCreateNestedManyWithoutClientInput
    libraries?: LibraryCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    name: string
    domain?: string | null
    apiKeys: JsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleOnClientUncheckedCreateNestedManyWithoutClientInput
    environmentVariables?: EnvironmentVariableUncheckedCreateNestedManyWithoutClientInput
    users?: UserUncheckedCreateNestedManyWithoutClientInput
    libraries?: LibraryUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    apiKeys?: JsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleOnClientUpdateManyWithoutClientNestedInput
    environmentVariables?: EnvironmentVariableUpdateManyWithoutClientNestedInput
    users?: UserUpdateManyWithoutClientNestedInput
    libraries?: LibraryUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    apiKeys?: JsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleOnClientUncheckedUpdateManyWithoutClientNestedInput
    environmentVariables?: EnvironmentVariableUncheckedUpdateManyWithoutClientNestedInput
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
    libraries?: LibraryUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    name: string
    domain?: string | null
    apiKeys: JsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    apiKeys?: JsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    apiKeys?: JsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleCreateInput = {
    id?: string
    name: string
    description?: string | null
    version?: string | null
    clients?: ModuleOnClientCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    version?: string | null
    clients?: ModuleOnClientUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    clients?: ModuleOnClientUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    clients?: ModuleOnClientUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    version?: string | null
  }

  export type ModuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ModuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ModuleOnClientCreateInput = {
    id?: string
    enabled?: boolean
    client: ClientCreateNestedOneWithoutModulesInput
    module: ModuleCreateNestedOneWithoutClientsInput
  }

  export type ModuleOnClientUncheckedCreateInput = {
    id?: string
    clientId: string
    moduleId: string
    enabled?: boolean
  }

  export type ModuleOnClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    client?: ClientUpdateOneRequiredWithoutModulesNestedInput
    module?: ModuleUpdateOneRequiredWithoutClientsNestedInput
  }

  export type ModuleOnClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ModuleOnClientCreateManyInput = {
    id?: string
    clientId: string
    moduleId: string
    enabled?: boolean
  }

  export type ModuleOnClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ModuleOnClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EnvironmentVariableCreateInput = {
    id?: string
    key: string
    value: string
    environment?: Environment
    client: ClientCreateNestedOneWithoutEnvironmentVariablesInput
  }

  export type EnvironmentVariableUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    environment?: Environment
    clientId: string
  }

  export type EnvironmentVariableUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    environment?: EnumEnvironmentFieldUpdateOperationsInput | Environment
    client?: ClientUpdateOneRequiredWithoutEnvironmentVariablesNestedInput
  }

  export type EnvironmentVariableUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    environment?: EnumEnvironmentFieldUpdateOperationsInput | Environment
    clientId?: StringFieldUpdateOperationsInput | string
  }

  export type EnvironmentVariableCreateManyInput = {
    id?: string
    key: string
    value: string
    environment?: Environment
    clientId: string
  }

  export type EnvironmentVariableUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    environment?: EnumEnvironmentFieldUpdateOperationsInput | Environment
  }

  export type EnvironmentVariableUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    environment?: EnumEnvironmentFieldUpdateOperationsInput | Environment
    clientId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    hashedPassword?: string | null
    oauthProvider?: string | null
    oauthId?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutUsersInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    mcpConfigurations?: MCPConfigurationCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messageReactions?: MessageReactionCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    themes?: ThemeCreateNestedManyWithoutCreatorInput
    personalizationAnalytics?: PersonalizationAnalyticsCreateNestedManyWithoutUserInput
    conversationShares?: ConversationShareCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    hashedPassword?: string | null
    oauthProvider?: string | null
    oauthId?: string | null
    role?: Role
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    mcpConfigurations?: MCPConfigurationUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messageReactions?: MessageReactionUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    themes?: ThemeUncheckedCreateNestedManyWithoutCreatorInput
    personalizationAnalytics?: PersonalizationAnalyticsUncheckedCreateNestedManyWithoutUserInput
    conversationShares?: ConversationShareUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutUsersNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    mcpConfigurations?: MCPConfigurationUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messageReactions?: MessageReactionUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    themes?: ThemeUpdateManyWithoutCreatorNestedInput
    personalizationAnalytics?: PersonalizationAnalyticsUpdateManyWithoutUserNestedInput
    conversationShares?: ConversationShareUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    mcpConfigurations?: MCPConfigurationUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messageReactions?: MessageReactionUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    themes?: ThemeUncheckedUpdateManyWithoutCreatorNestedInput
    personalizationAnalytics?: PersonalizationAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    conversationShares?: ConversationShareUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    hashedPassword?: string | null
    oauthProvider?: string | null
    oauthId?: string | null
    role?: Role
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryCreateInput = {
    id: string
    name: string
    displayName: string
    description?: string | null
    vendor?: string | null
    repoUrl?: string | null
    docsUrl?: string | null
    defaultVersion?: string | null
    popularityScore?: number
    totalSnippets?: number
    totalTokens?: number
    language: string
    ecosystem: string
    tags?: LibraryCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastCrawledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutLibrariesInput
    versions?: LibraryVersionCreateNestedManyWithoutLibraryInput
    aliases?: LibraryAliasCreateNestedManyWithoutLibraryInput
    documentationChunks?: DocumentationChunkCreateNestedManyWithoutLibraryInput
    usageLogs?: UsageLogCreateNestedManyWithoutLibraryInput
  }

  export type LibraryUncheckedCreateInput = {
    id: string
    name: string
    displayName: string
    description?: string | null
    vendor?: string | null
    repoUrl?: string | null
    docsUrl?: string | null
    defaultVersion?: string | null
    popularityScore?: number
    totalSnippets?: number
    totalTokens?: number
    language: string
    ecosystem: string
    tags?: LibraryCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    clientId: string
    lastCrawledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: LibraryVersionUncheckedCreateNestedManyWithoutLibraryInput
    aliases?: LibraryAliasUncheckedCreateNestedManyWithoutLibraryInput
    documentationChunks?: DocumentationChunkUncheckedCreateNestedManyWithoutLibraryInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutLibraryInput
  }

  export type LibraryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    docsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    defaultVersion?: NullableStringFieldUpdateOperationsInput | string | null
    popularityScore?: FloatFieldUpdateOperationsInput | number
    totalSnippets?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    ecosystem?: StringFieldUpdateOperationsInput | string
    tags?: LibraryUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastCrawledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutLibrariesNestedInput
    versions?: LibraryVersionUpdateManyWithoutLibraryNestedInput
    aliases?: LibraryAliasUpdateManyWithoutLibraryNestedInput
    documentationChunks?: DocumentationChunkUpdateManyWithoutLibraryNestedInput
    usageLogs?: UsageLogUpdateManyWithoutLibraryNestedInput
  }

  export type LibraryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    docsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    defaultVersion?: NullableStringFieldUpdateOperationsInput | string | null
    popularityScore?: FloatFieldUpdateOperationsInput | number
    totalSnippets?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    ecosystem?: StringFieldUpdateOperationsInput | string
    tags?: LibraryUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    clientId?: StringFieldUpdateOperationsInput | string
    lastCrawledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: LibraryVersionUncheckedUpdateManyWithoutLibraryNestedInput
    aliases?: LibraryAliasUncheckedUpdateManyWithoutLibraryNestedInput
    documentationChunks?: DocumentationChunkUncheckedUpdateManyWithoutLibraryNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutLibraryNestedInput
  }

  export type LibraryCreateManyInput = {
    id: string
    name: string
    displayName: string
    description?: string | null
    vendor?: string | null
    repoUrl?: string | null
    docsUrl?: string | null
    defaultVersion?: string | null
    popularityScore?: number
    totalSnippets?: number
    totalTokens?: number
    language: string
    ecosystem: string
    tags?: LibraryCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    clientId: string
    lastCrawledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    docsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    defaultVersion?: NullableStringFieldUpdateOperationsInput | string | null
    popularityScore?: FloatFieldUpdateOperationsInput | number
    totalSnippets?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    ecosystem?: StringFieldUpdateOperationsInput | string
    tags?: LibraryUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastCrawledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    docsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    defaultVersion?: NullableStringFieldUpdateOperationsInput | string | null
    popularityScore?: FloatFieldUpdateOperationsInput | number
    totalSnippets?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    ecosystem?: StringFieldUpdateOperationsInput | string
    tags?: LibraryUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    clientId?: StringFieldUpdateOperationsInput | string
    lastCrawledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryVersionCreateInput = {
    id?: string
    version: string
    releaseDate?: Date | string | null
    isLatest?: boolean
    docsSnapshotUrl?: string | null
    library: LibraryCreateNestedOneWithoutVersionsInput
    documentationChunks?: DocumentationChunkCreateNestedManyWithoutLibraryVersionInput
  }

  export type LibraryVersionUncheckedCreateInput = {
    id?: string
    libraryId: string
    version: string
    releaseDate?: Date | string | null
    isLatest?: boolean
    docsSnapshotUrl?: string | null
    documentationChunks?: DocumentationChunkUncheckedCreateNestedManyWithoutLibraryVersionInput
  }

  export type LibraryVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    docsSnapshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    library?: LibraryUpdateOneRequiredWithoutVersionsNestedInput
    documentationChunks?: DocumentationChunkUpdateManyWithoutLibraryVersionNestedInput
  }

  export type LibraryVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    libraryId?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    docsSnapshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    documentationChunks?: DocumentationChunkUncheckedUpdateManyWithoutLibraryVersionNestedInput
  }

  export type LibraryVersionCreateManyInput = {
    id?: string
    libraryId: string
    version: string
    releaseDate?: Date | string | null
    isLatest?: boolean
    docsSnapshotUrl?: string | null
  }

  export type LibraryVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    docsSnapshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LibraryVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    libraryId?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    docsSnapshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LibraryAliasCreateInput = {
    id?: string
    alias: string
    library: LibraryCreateNestedOneWithoutAliasesInput
  }

  export type LibraryAliasUncheckedCreateInput = {
    id?: string
    libraryId: string
    alias: string
  }

  export type LibraryAliasUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    library?: LibraryUpdateOneRequiredWithoutAliasesNestedInput
  }

  export type LibraryAliasUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    libraryId?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
  }

  export type LibraryAliasCreateManyInput = {
    id?: string
    libraryId: string
    alias: string
  }

  export type LibraryAliasUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
  }

  export type LibraryAliasUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    libraryId?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentationChunkCreateInput = {
    id?: string
    chunkIndex: number
    content: string
    contentType: string
    sourceUrl?: string | null
    tokenCount: number
    embeddingId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    libraryVersion: LibraryVersionCreateNestedOneWithoutDocumentationChunksInput
    Library?: LibraryCreateNestedOneWithoutDocumentationChunksInput
  }

  export type DocumentationChunkUncheckedCreateInput = {
    id?: string
    libraryVersionId: string
    chunkIndex: number
    content: string
    contentType: string
    sourceUrl?: string | null
    tokenCount: number
    embeddingId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    libraryId?: string | null
  }

  export type DocumentationChunkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tokenCount?: IntFieldUpdateOperationsInput | number
    embeddingId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryVersion?: LibraryVersionUpdateOneRequiredWithoutDocumentationChunksNestedInput
    Library?: LibraryUpdateOneWithoutDocumentationChunksNestedInput
  }

  export type DocumentationChunkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    libraryVersionId?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tokenCount?: IntFieldUpdateOperationsInput | number
    embeddingId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentationChunkCreateManyInput = {
    id?: string
    libraryVersionId: string
    chunkIndex: number
    content: string
    contentType: string
    sourceUrl?: string | null
    tokenCount: number
    embeddingId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    libraryId?: string | null
  }

  export type DocumentationChunkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tokenCount?: IntFieldUpdateOperationsInput | number
    embeddingId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentationChunkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    libraryVersionId?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tokenCount?: IntFieldUpdateOperationsInput | number
    embeddingId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApiKeyCreateInput = {
    id?: string
    keyHash: string
    keyPrefix: string
    name?: string | null
    tier?: string
    quotaDaily?: number
    quotaMonthly?: number
    usedDaily?: number
    usedMonthly?: number
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
    user: UserCreateNestedOneWithoutApiKeysInput
    usageLogs?: UsageLogCreateNestedManyWithoutApiKeyInput
  }

  export type ApiKeyUncheckedCreateInput = {
    id?: string
    userId: string
    keyHash: string
    keyPrefix: string
    name?: string | null
    tier?: string
    quotaDaily?: number
    quotaMonthly?: number
    usedDaily?: number
    usedMonthly?: number
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutApiKeyInput
  }

  export type ApiKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: StringFieldUpdateOperationsInput | string
    quotaDaily?: IntFieldUpdateOperationsInput | number
    quotaMonthly?: IntFieldUpdateOperationsInput | number
    usedDaily?: IntFieldUpdateOperationsInput | number
    usedMonthly?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutApiKeysNestedInput
    usageLogs?: UsageLogUpdateManyWithoutApiKeyNestedInput
  }

  export type ApiKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: StringFieldUpdateOperationsInput | string
    quotaDaily?: IntFieldUpdateOperationsInput | number
    quotaMonthly?: IntFieldUpdateOperationsInput | number
    usedDaily?: IntFieldUpdateOperationsInput | number
    usedMonthly?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLogs?: UsageLogUncheckedUpdateManyWithoutApiKeyNestedInput
  }

  export type ApiKeyCreateManyInput = {
    id?: string
    userId: string
    keyHash: string
    keyPrefix: string
    name?: string | null
    tier?: string
    quotaDaily?: number
    quotaMonthly?: number
    usedDaily?: number
    usedMonthly?: number
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type ApiKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: StringFieldUpdateOperationsInput | string
    quotaDaily?: IntFieldUpdateOperationsInput | number
    quotaMonthly?: IntFieldUpdateOperationsInput | number
    usedDaily?: IntFieldUpdateOperationsInput | number
    usedMonthly?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: StringFieldUpdateOperationsInput | string
    quotaDaily?: IntFieldUpdateOperationsInput | number
    quotaMonthly?: IntFieldUpdateOperationsInput | number
    usedDaily?: IntFieldUpdateOperationsInput | number
    usedMonthly?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsageLogCreateInput = {
    id?: string
    toolName: string
    query?: string | null
    tokensReturned?: number | null
    responseTimeMs?: number | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutUsageLogsInput
    apiKey?: ApiKeyCreateNestedOneWithoutUsageLogsInput
    library?: LibraryCreateNestedOneWithoutUsageLogsInput
  }

  export type UsageLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    apiKeyId?: string | null
    libraryId?: string | null
    toolName: string
    query?: string | null
    tokensReturned?: number | null
    responseTimeMs?: number | null
    createdAt?: Date | string
  }

  export type UsageLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    toolName?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    tokensReturned?: NullableIntFieldUpdateOperationsInput | number | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutUsageLogsNestedInput
    apiKey?: ApiKeyUpdateOneWithoutUsageLogsNestedInput
    library?: LibraryUpdateOneWithoutUsageLogsNestedInput
  }

  export type UsageLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    apiKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    libraryId?: NullableStringFieldUpdateOperationsInput | string | null
    toolName?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    tokensReturned?: NullableIntFieldUpdateOperationsInput | number | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLogCreateManyInput = {
    id?: string
    userId?: string | null
    apiKeyId?: string | null
    libraryId?: string | null
    toolName: string
    query?: string | null
    tokensReturned?: number | null
    responseTimeMs?: number | null
    createdAt?: Date | string
  }

  export type UsageLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    toolName?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    tokensReturned?: NullableIntFieldUpdateOperationsInput | number | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    apiKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    libraryId?: NullableStringFieldUpdateOperationsInput | string | null
    toolName?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    tokensReturned?: NullableIntFieldUpdateOperationsInput | number | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MCPConfigurationCreateInput = {
    id?: string
    name: string
    description?: string | null
    configData: JsonNullValueInput | InputJsonValue
    status?: ConfigStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMcpConfigurationsInput
  }

  export type MCPConfigurationUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    configData: JsonNullValueInput | InputJsonValue
    status?: ConfigStatus
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MCPConfigurationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    configData?: JsonNullValueInput | InputJsonValue
    status?: EnumConfigStatusFieldUpdateOperationsInput | ConfigStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMcpConfigurationsNestedInput
  }

  export type MCPConfigurationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    configData?: JsonNullValueInput | InputJsonValue
    status?: EnumConfigStatusFieldUpdateOperationsInput | ConfigStatus
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MCPConfigurationCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    configData: JsonNullValueInput | InputJsonValue
    status?: ConfigStatus
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MCPConfigurationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    configData?: JsonNullValueInput | InputJsonValue
    status?: EnumConfigStatusFieldUpdateOperationsInput | ConfigStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MCPConfigurationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    configData?: JsonNullValueInput | InputJsonValue
    status?: EnumConfigStatusFieldUpdateOperationsInput | ConfigStatus
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthTokenCreateInput = {
    id?: string
    provider: string
    accessToken: string
    refreshToken?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutOauthTokensInput
  }

  export type OAuthTokenUncheckedCreateInput = {
    id?: string
    userId: string
    provider: string
    accessToken: string
    refreshToken?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OAuthTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOauthTokensNestedInput
  }

  export type OAuthTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthTokenCreateManyInput = {
    id?: string
    userId: string
    provider: string
    accessToken: string
    refreshToken?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OAuthTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthClientCreateInput = {
    id?: string
    clientId: string
    clientSecretHash: string
    name: string
    redirectUris?: OAuthClientCreateredirectUrisInput | string[]
    allowedScopes?: OAuthClientCreateallowedScopesInput | string[]
    grantTypes?: OAuthClientCreategrantTypesInput | string[]
    requirePkce?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    authorizationCodes?: OAuthAuthorizationCodeCreateNestedManyWithoutClientInput
    accessTokens?: OAuthAccessTokenCreateNestedManyWithoutClientInput
    refreshTokens?: OAuthRefreshTokenCreateNestedManyWithoutClientInput
  }

  export type OAuthClientUncheckedCreateInput = {
    id?: string
    clientId: string
    clientSecretHash: string
    name: string
    redirectUris?: OAuthClientCreateredirectUrisInput | string[]
    allowedScopes?: OAuthClientCreateallowedScopesInput | string[]
    grantTypes?: OAuthClientCreategrantTypesInput | string[]
    requirePkce?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    authorizationCodes?: OAuthAuthorizationCodeUncheckedCreateNestedManyWithoutClientInput
    accessTokens?: OAuthAccessTokenUncheckedCreateNestedManyWithoutClientInput
    refreshTokens?: OAuthRefreshTokenUncheckedCreateNestedManyWithoutClientInput
  }

  export type OAuthClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecretHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    redirectUris?: OAuthClientUpdateredirectUrisInput | string[]
    allowedScopes?: OAuthClientUpdateallowedScopesInput | string[]
    grantTypes?: OAuthClientUpdategrantTypesInput | string[]
    requirePkce?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorizationCodes?: OAuthAuthorizationCodeUpdateManyWithoutClientNestedInput
    accessTokens?: OAuthAccessTokenUpdateManyWithoutClientNestedInput
    refreshTokens?: OAuthRefreshTokenUpdateManyWithoutClientNestedInput
  }

  export type OAuthClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecretHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    redirectUris?: OAuthClientUpdateredirectUrisInput | string[]
    allowedScopes?: OAuthClientUpdateallowedScopesInput | string[]
    grantTypes?: OAuthClientUpdategrantTypesInput | string[]
    requirePkce?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorizationCodes?: OAuthAuthorizationCodeUncheckedUpdateManyWithoutClientNestedInput
    accessTokens?: OAuthAccessTokenUncheckedUpdateManyWithoutClientNestedInput
    refreshTokens?: OAuthRefreshTokenUncheckedUpdateManyWithoutClientNestedInput
  }

  export type OAuthClientCreateManyInput = {
    id?: string
    clientId: string
    clientSecretHash: string
    name: string
    redirectUris?: OAuthClientCreateredirectUrisInput | string[]
    allowedScopes?: OAuthClientCreateallowedScopesInput | string[]
    grantTypes?: OAuthClientCreategrantTypesInput | string[]
    requirePkce?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OAuthClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecretHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    redirectUris?: OAuthClientUpdateredirectUrisInput | string[]
    allowedScopes?: OAuthClientUpdateallowedScopesInput | string[]
    grantTypes?: OAuthClientUpdategrantTypesInput | string[]
    requirePkce?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecretHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    redirectUris?: OAuthClientUpdateredirectUrisInput | string[]
    allowedScopes?: OAuthClientUpdateallowedScopesInput | string[]
    grantTypes?: OAuthClientUpdategrantTypesInput | string[]
    requirePkce?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAuthorizationCodeCreateInput = {
    id?: string
    code: string
    userId: string
    redirectUri: string
    scopes?: OAuthAuthorizationCodeCreatescopesInput | string[]
    codeChallenge?: string | null
    codeChallengeMethod?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    client: OAuthClientCreateNestedOneWithoutAuthorizationCodesInput
  }

  export type OAuthAuthorizationCodeUncheckedCreateInput = {
    id?: string
    code: string
    clientId: string
    userId: string
    redirectUri: string
    scopes?: OAuthAuthorizationCodeCreatescopesInput | string[]
    codeChallenge?: string | null
    codeChallengeMethod?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OAuthAuthorizationCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    redirectUri?: StringFieldUpdateOperationsInput | string
    scopes?: OAuthAuthorizationCodeUpdatescopesInput | string[]
    codeChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    codeChallengeMethod?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: OAuthClientUpdateOneRequiredWithoutAuthorizationCodesNestedInput
  }

  export type OAuthAuthorizationCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    redirectUri?: StringFieldUpdateOperationsInput | string
    scopes?: OAuthAuthorizationCodeUpdatescopesInput | string[]
    codeChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    codeChallengeMethod?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAuthorizationCodeCreateManyInput = {
    id?: string
    code: string
    clientId: string
    userId: string
    redirectUri: string
    scopes?: OAuthAuthorizationCodeCreatescopesInput | string[]
    codeChallenge?: string | null
    codeChallengeMethod?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OAuthAuthorizationCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    redirectUri?: StringFieldUpdateOperationsInput | string
    scopes?: OAuthAuthorizationCodeUpdatescopesInput | string[]
    codeChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    codeChallengeMethod?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAuthorizationCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    redirectUri?: StringFieldUpdateOperationsInput | string
    scopes?: OAuthAuthorizationCodeUpdatescopesInput | string[]
    codeChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    codeChallengeMethod?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAccessTokenCreateInput = {
    id?: string
    tokenHash: string
    userId: string
    scopes?: OAuthAccessTokenCreatescopesInput | string[]
    expiresAt: Date | string
    createdAt?: Date | string
    client: OAuthClientCreateNestedOneWithoutAccessTokensInput
    refreshToken?: OAuthRefreshTokenCreateNestedManyWithoutAccessTokenInput
  }

  export type OAuthAccessTokenUncheckedCreateInput = {
    id?: string
    tokenHash: string
    clientId: string
    userId: string
    scopes?: OAuthAccessTokenCreatescopesInput | string[]
    expiresAt: Date | string
    createdAt?: Date | string
    refreshToken?: OAuthRefreshTokenUncheckedCreateNestedManyWithoutAccessTokenInput
  }

  export type OAuthAccessTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scopes?: OAuthAccessTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: OAuthClientUpdateOneRequiredWithoutAccessTokensNestedInput
    refreshToken?: OAuthRefreshTokenUpdateManyWithoutAccessTokenNestedInput
  }

  export type OAuthAccessTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scopes?: OAuthAccessTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: OAuthRefreshTokenUncheckedUpdateManyWithoutAccessTokenNestedInput
  }

  export type OAuthAccessTokenCreateManyInput = {
    id?: string
    tokenHash: string
    clientId: string
    userId: string
    scopes?: OAuthAccessTokenCreatescopesInput | string[]
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OAuthAccessTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scopes?: OAuthAccessTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAccessTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scopes?: OAuthAccessTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthRefreshTokenCreateInput = {
    id?: string
    tokenHash: string
    userId: string
    scopes?: OAuthRefreshTokenCreatescopesInput | string[]
    expiresAt: Date | string
    isRevoked?: boolean
    createdAt?: Date | string
    accessToken: OAuthAccessTokenCreateNestedOneWithoutRefreshTokenInput
    client: OAuthClientCreateNestedOneWithoutRefreshTokensInput
  }

  export type OAuthRefreshTokenUncheckedCreateInput = {
    id?: string
    tokenHash: string
    accessTokenId: string
    clientId: string
    userId: string
    scopes?: OAuthRefreshTokenCreatescopesInput | string[]
    expiresAt: Date | string
    isRevoked?: boolean
    createdAt?: Date | string
  }

  export type OAuthRefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scopes?: OAuthRefreshTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: OAuthAccessTokenUpdateOneRequiredWithoutRefreshTokenNestedInput
    client?: OAuthClientUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type OAuthRefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    accessTokenId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scopes?: OAuthRefreshTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthRefreshTokenCreateManyInput = {
    id?: string
    tokenHash: string
    accessTokenId: string
    clientId: string
    userId: string
    scopes?: OAuthRefreshTokenCreatescopesInput | string[]
    expiresAt: Date | string
    isRevoked?: boolean
    createdAt?: Date | string
  }

  export type OAuthRefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scopes?: OAuthRefreshTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthRefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    accessTokenId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scopes?: OAuthRefreshTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DownloadTaskCreateInput = {
    id?: string
    type: string
    source: JsonNullValueInput | InputJsonValue
    options: JsonNullValueInput | InputJsonValue
    priority?: string
    status?: string
    progress: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    error?: string | null
    retry_count?: number
    downloadResults?: DownloadResultCreateNestedManyWithoutDownloadTaskInput
  }

  export type DownloadTaskUncheckedCreateInput = {
    id?: string
    type: string
    source: JsonNullValueInput | InputJsonValue
    options: JsonNullValueInput | InputJsonValue
    priority?: string
    status?: string
    progress: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    error?: string | null
    retry_count?: number
    downloadResults?: DownloadResultUncheckedCreateNestedManyWithoutDownloadTaskInput
  }

  export type DownloadTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    source?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retry_count?: IntFieldUpdateOperationsInput | number
    downloadResults?: DownloadResultUpdateManyWithoutDownloadTaskNestedInput
  }

  export type DownloadTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    source?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retry_count?: IntFieldUpdateOperationsInput | number
    downloadResults?: DownloadResultUncheckedUpdateManyWithoutDownloadTaskNestedInput
  }

  export type DownloadTaskCreateManyInput = {
    id?: string
    type: string
    source: JsonNullValueInput | InputJsonValue
    options: JsonNullValueInput | InputJsonValue
    priority?: string
    status?: string
    progress: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    error?: string | null
    retry_count?: number
  }

  export type DownloadTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    source?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retry_count?: IntFieldUpdateOperationsInput | number
  }

  export type DownloadTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    source?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retry_count?: IntFieldUpdateOperationsInput | number
  }

  export type DownloadResultCreateInput = {
    id?: string
    success?: boolean
    local_path: string
    metadata: JsonNullValueInput | InputJsonValue
    files: JsonNullValueInput | InputJsonValue
    errors?: DownloadResultCreateerrorsInput | string[]
    created_at?: Date | string
    downloadTask: DownloadTaskCreateNestedOneWithoutDownloadResultsInput
  }

  export type DownloadResultUncheckedCreateInput = {
    id?: string
    task_id: string
    success?: boolean
    local_path: string
    metadata: JsonNullValueInput | InputJsonValue
    files: JsonNullValueInput | InputJsonValue
    errors?: DownloadResultCreateerrorsInput | string[]
    created_at?: Date | string
  }

  export type DownloadResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    local_path?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    files?: JsonNullValueInput | InputJsonValue
    errors?: DownloadResultUpdateerrorsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    downloadTask?: DownloadTaskUpdateOneRequiredWithoutDownloadResultsNestedInput
  }

  export type DownloadResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    task_id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    local_path?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    files?: JsonNullValueInput | InputJsonValue
    errors?: DownloadResultUpdateerrorsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DownloadResultCreateManyInput = {
    id?: string
    task_id: string
    success?: boolean
    local_path: string
    metadata: JsonNullValueInput | InputJsonValue
    files: JsonNullValueInput | InputJsonValue
    errors?: DownloadResultCreateerrorsInput | string[]
    created_at?: Date | string
  }

  export type DownloadResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    local_path?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    files?: JsonNullValueInput | InputJsonValue
    errors?: DownloadResultUpdateerrorsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DownloadResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    task_id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    local_path?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    files?: JsonNullValueInput | InputJsonValue
    errors?: DownloadResultUpdateerrorsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptCategoryCreateInput = {
    id: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    templates?: PromptTemplateCreateNestedManyWithoutCategoryRelInput
    parent?: PromptCategoryCreateNestedOneWithoutChildrenInput
    children?: PromptCategoryCreateNestedManyWithoutParentInput
  }

  export type PromptCategoryUncheckedCreateInput = {
    id: string
    name: string
    description?: string | null
    parentCategory?: string | null
    icon?: string | null
    color?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    templates?: PromptTemplateUncheckedCreateNestedManyWithoutCategoryRelInput
    children?: PromptCategoryUncheckedCreateNestedManyWithoutParentInput
  }

  export type PromptCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templates?: PromptTemplateUpdateManyWithoutCategoryRelNestedInput
    parent?: PromptCategoryUpdateOneWithoutChildrenNestedInput
    children?: PromptCategoryUpdateManyWithoutParentNestedInput
  }

  export type PromptCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentCategory?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templates?: PromptTemplateUncheckedUpdateManyWithoutCategoryRelNestedInput
    children?: PromptCategoryUncheckedUpdateManyWithoutParentNestedInput
  }

  export type PromptCategoryCreateManyInput = {
    id: string
    name: string
    description?: string | null
    parentCategory?: string | null
    icon?: string | null
    color?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromptCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentCategory?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptTemplateCreateInput = {
    id: string
    version: string
    name: string
    description?: string | null
    status?: string
    template: string
    variables?: JsonNullValueInput | InputJsonValue
    examples?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    optimization?: JsonNullValueInput | InputJsonValue
    testing?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryRel: PromptCategoryCreateNestedOneWithoutTemplatesInput
    executions?: PromptExecutionCreateNestedManyWithoutTemplateInput
    changes?: TemplateChangeCreateNestedManyWithoutTemplateInput
    optimizations?: OptimizationRecordCreateNestedManyWithoutTemplateInput
  }

  export type PromptTemplateUncheckedCreateInput = {
    id: string
    version: string
    name: string
    description?: string | null
    category: string
    status?: string
    template: string
    variables?: JsonNullValueInput | InputJsonValue
    examples?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    optimization?: JsonNullValueInput | InputJsonValue
    testing?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: PromptExecutionUncheckedCreateNestedManyWithoutTemplateInput
    changes?: TemplateChangeUncheckedCreateNestedManyWithoutTemplateInput
    optimizations?: OptimizationRecordUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type PromptTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    examples?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    optimization?: JsonNullValueInput | InputJsonValue
    testing?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryRel?: PromptCategoryUpdateOneRequiredWithoutTemplatesNestedInput
    executions?: PromptExecutionUpdateManyWithoutTemplateNestedInput
    changes?: TemplateChangeUpdateManyWithoutTemplateNestedInput
    optimizations?: OptimizationRecordUpdateManyWithoutTemplateNestedInput
  }

  export type PromptTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    examples?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    optimization?: JsonNullValueInput | InputJsonValue
    testing?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: PromptExecutionUncheckedUpdateManyWithoutTemplateNestedInput
    changes?: TemplateChangeUncheckedUpdateManyWithoutTemplateNestedInput
    optimizations?: OptimizationRecordUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type PromptTemplateCreateManyInput = {
    id: string
    version: string
    name: string
    description?: string | null
    category: string
    status?: string
    template: string
    variables?: JsonNullValueInput | InputJsonValue
    examples?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    optimization?: JsonNullValueInput | InputJsonValue
    testing?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromptTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    examples?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    optimization?: JsonNullValueInput | InputJsonValue
    testing?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    examples?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    optimization?: JsonNullValueInput | InputJsonValue
    testing?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateChangeCreateInput = {
    id?: string
    fromVersion: string
    toVersion: string
    changes: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    template: PromptTemplateCreateNestedOneWithoutChangesInput
  }

  export type TemplateChangeUncheckedCreateInput = {
    id?: string
    templateId: string
    fromVersion: string
    toVersion: string
    changes: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TemplateChangeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromVersion?: StringFieldUpdateOperationsInput | string
    toVersion?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: PromptTemplateUpdateOneRequiredWithoutChangesNestedInput
  }

  export type TemplateChangeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    fromVersion?: StringFieldUpdateOperationsInput | string
    toVersion?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateChangeCreateManyInput = {
    id?: string
    templateId: string
    fromVersion: string
    toVersion: string
    changes: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TemplateChangeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromVersion?: StringFieldUpdateOperationsInput | string
    toVersion?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateChangeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    fromVersion?: StringFieldUpdateOperationsInput | string
    toVersion?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptExecutionCreateInput = {
    id?: string
    templateVersion: string
    variables?: JsonNullValueInput | InputJsonValue
    renderedPrompt: string
    context?: NullableJsonNullValueInput | InputJsonValue
    model: string
    provider: string
    response?: string | null
    metrics?: JsonNullValueInput | InputJsonValue
    quality?: JsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    abTestVariant?: string | null
    userId?: string | null
    createdAt?: Date | string
    template: PromptTemplateCreateNestedOneWithoutExecutionsInput
  }

  export type PromptExecutionUncheckedCreateInput = {
    id?: string
    templateId: string
    templateVersion: string
    variables?: JsonNullValueInput | InputJsonValue
    renderedPrompt: string
    context?: NullableJsonNullValueInput | InputJsonValue
    model: string
    provider: string
    response?: string | null
    metrics?: JsonNullValueInput | InputJsonValue
    quality?: JsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    abTestVariant?: string | null
    userId?: string | null
    createdAt?: Date | string
  }

  export type PromptExecutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateVersion?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    renderedPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    model?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: JsonNullValueInput | InputJsonValue
    quality?: JsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    abTestVariant?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: PromptTemplateUpdateOneRequiredWithoutExecutionsNestedInput
  }

  export type PromptExecutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    templateVersion?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    renderedPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    model?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: JsonNullValueInput | InputJsonValue
    quality?: JsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    abTestVariant?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptExecutionCreateManyInput = {
    id?: string
    templateId: string
    templateVersion: string
    variables?: JsonNullValueInput | InputJsonValue
    renderedPrompt: string
    context?: NullableJsonNullValueInput | InputJsonValue
    model: string
    provider: string
    response?: string | null
    metrics?: JsonNullValueInput | InputJsonValue
    quality?: JsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    abTestVariant?: string | null
    userId?: string | null
    createdAt?: Date | string
  }

  export type PromptExecutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateVersion?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    renderedPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    model?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: JsonNullValueInput | InputJsonValue
    quality?: JsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    abTestVariant?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptExecutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    templateVersion?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    renderedPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    model?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: JsonNullValueInput | InputJsonValue
    quality?: JsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    abTestVariant?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptExecutionErrorCreateInput = {
    id?: string
    templateId: string
    variables?: JsonNullValueInput | InputJsonValue
    errorMessage: string
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PromptExecutionErrorUncheckedCreateInput = {
    id?: string
    templateId: string
    variables?: JsonNullValueInput | InputJsonValue
    errorMessage: string
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PromptExecutionErrorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    errorMessage?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptExecutionErrorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    errorMessage?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptExecutionErrorCreateManyInput = {
    id?: string
    templateId: string
    variables?: JsonNullValueInput | InputJsonValue
    errorMessage: string
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PromptExecutionErrorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    errorMessage?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptExecutionErrorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    errorMessage?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABTestCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    variants?: JsonNullValueInput | InputJsonValue
    trafficSplit?: JsonNullValueInput | InputJsonValue
    startDate?: Date | string | null
    endDate?: Date | string | null
    sampleSize?: number
    confidence?: Decimal | DecimalJsLike | number | string
    results?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ABTestUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    variants?: JsonNullValueInput | InputJsonValue
    trafficSplit?: JsonNullValueInput | InputJsonValue
    startDate?: Date | string | null
    endDate?: Date | string | null
    sampleSize?: number
    confidence?: Decimal | DecimalJsLike | number | string
    results?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ABTestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    variants?: JsonNullValueInput | InputJsonValue
    trafficSplit?: JsonNullValueInput | InputJsonValue
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    results?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABTestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    variants?: JsonNullValueInput | InputJsonValue
    trafficSplit?: JsonNullValueInput | InputJsonValue
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    results?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABTestCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    variants?: JsonNullValueInput | InputJsonValue
    trafficSplit?: JsonNullValueInput | InputJsonValue
    startDate?: Date | string | null
    endDate?: Date | string | null
    sampleSize?: number
    confidence?: Decimal | DecimalJsLike | number | string
    results?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ABTestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    variants?: JsonNullValueInput | InputJsonValue
    trafficSplit?: JsonNullValueInput | InputJsonValue
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    results?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ABTestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    variants?: JsonNullValueInput | InputJsonValue
    trafficSplit?: JsonNullValueInput | InputJsonValue
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sampleSize?: IntFieldUpdateOperationsInput | number
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    results?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptimizationRecordCreateInput = {
    id?: string
    timestamp: Date | string
    type: string
    reason?: string | null
    changes?: JsonNullValueInput | InputJsonValue
    metricsBefore?: JsonNullValueInput | InputJsonValue
    metricsAfter?: JsonNullValueInput | InputJsonValue
    improvement?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    template: PromptTemplateCreateNestedOneWithoutOptimizationsInput
  }

  export type OptimizationRecordUncheckedCreateInput = {
    id?: string
    templateId: string
    timestamp: Date | string
    type: string
    reason?: string | null
    changes?: JsonNullValueInput | InputJsonValue
    metricsBefore?: JsonNullValueInput | InputJsonValue
    metricsAfter?: JsonNullValueInput | InputJsonValue
    improvement?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type OptimizationRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: JsonNullValueInput | InputJsonValue
    metricsBefore?: JsonNullValueInput | InputJsonValue
    metricsAfter?: JsonNullValueInput | InputJsonValue
    improvement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: PromptTemplateUpdateOneRequiredWithoutOptimizationsNestedInput
  }

  export type OptimizationRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: JsonNullValueInput | InputJsonValue
    metricsBefore?: JsonNullValueInput | InputJsonValue
    metricsAfter?: JsonNullValueInput | InputJsonValue
    improvement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptimizationRecordCreateManyInput = {
    id?: string
    templateId: string
    timestamp: Date | string
    type: string
    reason?: string | null
    changes?: JsonNullValueInput | InputJsonValue
    metricsBefore?: JsonNullValueInput | InputJsonValue
    metricsAfter?: JsonNullValueInput | InputJsonValue
    improvement?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type OptimizationRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: JsonNullValueInput | InputJsonValue
    metricsBefore?: JsonNullValueInput | InputJsonValue
    metricsAfter?: JsonNullValueInput | InputJsonValue
    improvement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptimizationRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: JsonNullValueInput | InputJsonValue
    metricsBefore?: JsonNullValueInput | InputJsonValue
    metricsAfter?: JsonNullValueInput | InputJsonValue
    improvement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateInput = {
    id?: string
    title: string
    metadata?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    shares?: ConversationShareCreateNestedManyWithoutConversationInput
    exports?: ConversationExportCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    metadata?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    shares?: ConversationShareUncheckedCreateNestedManyWithoutConversationInput
    exports?: ConversationExportUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    shares?: ConversationShareUpdateManyWithoutConversationNestedInput
    exports?: ConversationExportUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    shares?: ConversationShareUncheckedUpdateManyWithoutConversationNestedInput
    exports?: ConversationExportUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    userId: string
    title: string
    metadata?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    role: string
    content: string
    timestamp?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    reactions?: MessageReactionCreateNestedManyWithoutMessageInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    role: string
    content: string
    timestamp?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    reactions?: MessageReactionUncheckedCreateNestedManyWithoutMessageInput
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    reactions?: MessageReactionUpdateManyWithoutMessageNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    reactions?: MessageReactionUncheckedUpdateManyWithoutMessageNestedInput
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    conversationId: string
    role: string
    content: string
    timestamp?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type MessageReactionCreateInput = {
    id?: string
    emoji: string
    timestamp?: Date | string
    message: MessageCreateNestedOneWithoutReactionsInput
    user: UserCreateNestedOneWithoutMessageReactionsInput
  }

  export type MessageReactionUncheckedCreateInput = {
    id?: string
    messageId: string
    userId: string
    emoji: string
    timestamp?: Date | string
  }

  export type MessageReactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutReactionsNestedInput
    user?: UserUpdateOneRequiredWithoutMessageReactionsNestedInput
  }

  export type MessageReactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReactionCreateManyInput = {
    id?: string
    messageId: string
    userId: string
    emoji: string
    timestamp?: Date | string
  }

  export type MessageReactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentCreateInput = {
    id?: string
    type: string
    name: string
    url: string
    size?: bigint | number | null
    mimeType?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    thumbnail?: string | null
    message: MessageCreateNestedOneWithoutAttachmentsInput
  }

  export type MessageAttachmentUncheckedCreateInput = {
    id?: string
    messageId: string
    type: string
    name: string
    url: string
    size?: bigint | number | null
    mimeType?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    thumbnail?: string | null
  }

  export type MessageAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    message?: MessageUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type MessageAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageAttachmentCreateManyInput = {
    id?: string
    messageId: string
    type: string
    name: string
    url: string
    size?: bigint | number | null
    mimeType?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    thumbnail?: string | null
  }

  export type MessageAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversationShareCreateInput = {
    id?: string
    shareId: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    conversation: ConversationCreateNestedOneWithoutSharesInput
    creator: UserCreateNestedOneWithoutConversationSharesInput
  }

  export type ConversationShareUncheckedCreateInput = {
    id?: string
    conversationId: string
    shareId: string
    createdBy: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
  }

  export type ConversationShareUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shareId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    conversation?: ConversationUpdateOneRequiredWithoutSharesNestedInput
    creator?: UserUpdateOneRequiredWithoutConversationSharesNestedInput
  }

  export type ConversationShareUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    shareId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
  }

  export type ConversationShareCreateManyInput = {
    id?: string
    conversationId: string
    shareId: string
    createdBy: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
  }

  export type ConversationShareUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shareId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
  }

  export type ConversationShareUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    shareId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
  }

  export type ConversationExportCreateInput = {
    id?: string
    format: string
    options?: JsonNullValueInput | InputJsonValue
    status?: string
    downloadUrl?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    error?: string | null
    conversation: ConversationCreateNestedOneWithoutExportsInput
  }

  export type ConversationExportUncheckedCreateInput = {
    id?: string
    conversationId: string
    format: string
    options?: JsonNullValueInput | InputJsonValue
    status?: string
    downloadUrl?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    error?: string | null
  }

  export type ConversationExportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    conversation?: ConversationUpdateOneRequiredWithoutExportsNestedInput
  }

  export type ConversationExportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversationExportCreateManyInput = {
    id?: string
    conversationId: string
    format: string
    options?: JsonNullValueInput | InputJsonValue
    status?: string
    downloadUrl?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    error?: string | null
  }

  export type ConversationExportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversationExportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContextSourceCreateInput = {
    id?: string
    type: string
    title: string
    content: string
    url?: string | null
    libraryId?: string | null
    version?: string | null
    language: string
    tags?: ContextSourceCreatetagsInput | string[]
    relevanceScore?: number
    freshness?: number
    popularity?: number
    lastUpdated?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    chunks?: ContextChunkCreateNestedManyWithoutSourceInput
  }

  export type ContextSourceUncheckedCreateInput = {
    id?: string
    type: string
    title: string
    content: string
    url?: string | null
    libraryId?: string | null
    version?: string | null
    language: string
    tags?: ContextSourceCreatetagsInput | string[]
    relevanceScore?: number
    freshness?: number
    popularity?: number
    lastUpdated?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    chunks?: ContextChunkUncheckedCreateNestedManyWithoutSourceInput
  }

  export type ContextSourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    libraryId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    tags?: ContextSourceUpdatetagsInput | string[]
    relevanceScore?: FloatFieldUpdateOperationsInput | number
    freshness?: FloatFieldUpdateOperationsInput | number
    popularity?: FloatFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chunks?: ContextChunkUpdateManyWithoutSourceNestedInput
  }

  export type ContextSourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    libraryId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    tags?: ContextSourceUpdatetagsInput | string[]
    relevanceScore?: FloatFieldUpdateOperationsInput | number
    freshness?: FloatFieldUpdateOperationsInput | number
    popularity?: FloatFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chunks?: ContextChunkUncheckedUpdateManyWithoutSourceNestedInput
  }

  export type ContextSourceCreateManyInput = {
    id?: string
    type: string
    title: string
    content: string
    url?: string | null
    libraryId?: string | null
    version?: string | null
    language: string
    tags?: ContextSourceCreatetagsInput | string[]
    relevanceScore?: number
    freshness?: number
    popularity?: number
    lastUpdated?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContextSourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    libraryId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    tags?: ContextSourceUpdatetagsInput | string[]
    relevanceScore?: FloatFieldUpdateOperationsInput | number
    freshness?: FloatFieldUpdateOperationsInput | number
    popularity?: FloatFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextSourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    libraryId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    tags?: ContextSourceUpdatetagsInput | string[]
    relevanceScore?: FloatFieldUpdateOperationsInput | number
    freshness?: FloatFieldUpdateOperationsInput | number
    popularity?: FloatFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextChunkCreateInput = {
    id?: string
    content: string
    positionStart?: number
    positionEnd?: number
    positionIndex?: number
    positionTotal?: number
    sectionTitle?: string | null
    codeBlocks?: number
    links?: number
    images?: number
    complexity?: string
    embedding?: ContextChunkCreateembeddingInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
    source: ContextSourceCreateNestedOneWithoutChunksInput
  }

  export type ContextChunkUncheckedCreateInput = {
    id?: string
    sourceId: string
    content: string
    positionStart?: number
    positionEnd?: number
    positionIndex?: number
    positionTotal?: number
    sectionTitle?: string | null
    codeBlocks?: number
    links?: number
    images?: number
    complexity?: string
    embedding?: ContextChunkCreateembeddingInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContextChunkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    positionStart?: IntFieldUpdateOperationsInput | number
    positionEnd?: IntFieldUpdateOperationsInput | number
    positionIndex?: IntFieldUpdateOperationsInput | number
    positionTotal?: IntFieldUpdateOperationsInput | number
    sectionTitle?: NullableStringFieldUpdateOperationsInput | string | null
    codeBlocks?: IntFieldUpdateOperationsInput | number
    links?: IntFieldUpdateOperationsInput | number
    images?: IntFieldUpdateOperationsInput | number
    complexity?: StringFieldUpdateOperationsInput | string
    embedding?: ContextChunkUpdateembeddingInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: ContextSourceUpdateOneRequiredWithoutChunksNestedInput
  }

  export type ContextChunkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    positionStart?: IntFieldUpdateOperationsInput | number
    positionEnd?: IntFieldUpdateOperationsInput | number
    positionIndex?: IntFieldUpdateOperationsInput | number
    positionTotal?: IntFieldUpdateOperationsInput | number
    sectionTitle?: NullableStringFieldUpdateOperationsInput | string | null
    codeBlocks?: IntFieldUpdateOperationsInput | number
    links?: IntFieldUpdateOperationsInput | number
    images?: IntFieldUpdateOperationsInput | number
    complexity?: StringFieldUpdateOperationsInput | string
    embedding?: ContextChunkUpdateembeddingInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextChunkCreateManyInput = {
    id?: string
    sourceId: string
    content: string
    positionStart?: number
    positionEnd?: number
    positionIndex?: number
    positionTotal?: number
    sectionTitle?: string | null
    codeBlocks?: number
    links?: number
    images?: number
    complexity?: string
    embedding?: ContextChunkCreateembeddingInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContextChunkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    positionStart?: IntFieldUpdateOperationsInput | number
    positionEnd?: IntFieldUpdateOperationsInput | number
    positionIndex?: IntFieldUpdateOperationsInput | number
    positionTotal?: IntFieldUpdateOperationsInput | number
    sectionTitle?: NullableStringFieldUpdateOperationsInput | string | null
    codeBlocks?: IntFieldUpdateOperationsInput | number
    links?: IntFieldUpdateOperationsInput | number
    images?: IntFieldUpdateOperationsInput | number
    complexity?: StringFieldUpdateOperationsInput | string
    embedding?: ContextChunkUpdateembeddingInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextChunkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    positionStart?: IntFieldUpdateOperationsInput | number
    positionEnd?: IntFieldUpdateOperationsInput | number
    positionIndex?: IntFieldUpdateOperationsInput | number
    positionTotal?: IntFieldUpdateOperationsInput | number
    sectionTitle?: NullableStringFieldUpdateOperationsInput | string | null
    codeBlocks?: IntFieldUpdateOperationsInput | number
    links?: IntFieldUpdateOperationsInput | number
    images?: IntFieldUpdateOperationsInput | number
    complexity?: StringFieldUpdateOperationsInput | string
    embedding?: ContextChunkUpdateembeddingInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextQueryCreateInput = {
    id?: string
    conversationId: string
    messageId: string
    queryText: string
    intentType?: string | null
    intentConfidence?: number | null
    intentKeywords?: ContextQueryCreateintentKeywordsInput | string[]
    intentCategory?: string | null
    intentSubcategory?: string | null
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    results?: ContextResultCreateNestedManyWithoutQueryInput
    analytics?: ContextQueryAnalyticsCreateNestedManyWithoutQueryInput
  }

  export type ContextQueryUncheckedCreateInput = {
    id?: string
    conversationId: string
    messageId: string
    queryText: string
    intentType?: string | null
    intentConfidence?: number | null
    intentKeywords?: ContextQueryCreateintentKeywordsInput | string[]
    intentCategory?: string | null
    intentSubcategory?: string | null
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    results?: ContextResultUncheckedCreateNestedManyWithoutQueryInput
    analytics?: ContextQueryAnalyticsUncheckedCreateNestedManyWithoutQueryInput
  }

  export type ContextQueryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    queryText?: StringFieldUpdateOperationsInput | string
    intentType?: NullableStringFieldUpdateOperationsInput | string | null
    intentConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    intentKeywords?: ContextQueryUpdateintentKeywordsInput | string[]
    intentCategory?: NullableStringFieldUpdateOperationsInput | string | null
    intentSubcategory?: NullableStringFieldUpdateOperationsInput | string | null
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: ContextResultUpdateManyWithoutQueryNestedInput
    analytics?: ContextQueryAnalyticsUpdateManyWithoutQueryNestedInput
  }

  export type ContextQueryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    queryText?: StringFieldUpdateOperationsInput | string
    intentType?: NullableStringFieldUpdateOperationsInput | string | null
    intentConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    intentKeywords?: ContextQueryUpdateintentKeywordsInput | string[]
    intentCategory?: NullableStringFieldUpdateOperationsInput | string | null
    intentSubcategory?: NullableStringFieldUpdateOperationsInput | string | null
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: ContextResultUncheckedUpdateManyWithoutQueryNestedInput
    analytics?: ContextQueryAnalyticsUncheckedUpdateManyWithoutQueryNestedInput
  }

  export type ContextQueryCreateManyInput = {
    id?: string
    conversationId: string
    messageId: string
    queryText: string
    intentType?: string | null
    intentConfidence?: number | null
    intentKeywords?: ContextQueryCreateintentKeywordsInput | string[]
    intentCategory?: string | null
    intentSubcategory?: string | null
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ContextQueryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    queryText?: StringFieldUpdateOperationsInput | string
    intentType?: NullableStringFieldUpdateOperationsInput | string | null
    intentConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    intentKeywords?: ContextQueryUpdateintentKeywordsInput | string[]
    intentCategory?: NullableStringFieldUpdateOperationsInput | string | null
    intentSubcategory?: NullableStringFieldUpdateOperationsInput | string | null
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextQueryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    queryText?: StringFieldUpdateOperationsInput | string
    intentType?: NullableStringFieldUpdateOperationsInput | string | null
    intentConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    intentKeywords?: ContextQueryUpdateintentKeywordsInput | string[]
    intentCategory?: NullableStringFieldUpdateOperationsInput | string | null
    intentSubcategory?: NullableStringFieldUpdateOperationsInput | string | null
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextResultCreateInput = {
    id?: string
    sources?: JsonNullValueInput | InputJsonValue
    chunks?: JsonNullValueInput | InputJsonValue
    summary?: string | null
    totalSources?: number
    totalChunks?: number
    queryTime?: number
    relevanceScore?: number
    coverage?: number
    freshness?: number
    suggestions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    query: ContextQueryCreateNestedOneWithoutResultsInput
  }

  export type ContextResultUncheckedCreateInput = {
    id?: string
    queryId: string
    sources?: JsonNullValueInput | InputJsonValue
    chunks?: JsonNullValueInput | InputJsonValue
    summary?: string | null
    totalSources?: number
    totalChunks?: number
    queryTime?: number
    relevanceScore?: number
    coverage?: number
    freshness?: number
    suggestions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ContextResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sources?: JsonNullValueInput | InputJsonValue
    chunks?: JsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    totalSources?: IntFieldUpdateOperationsInput | number
    totalChunks?: IntFieldUpdateOperationsInput | number
    queryTime?: IntFieldUpdateOperationsInput | number
    relevanceScore?: FloatFieldUpdateOperationsInput | number
    coverage?: FloatFieldUpdateOperationsInput | number
    freshness?: FloatFieldUpdateOperationsInput | number
    suggestions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    query?: ContextQueryUpdateOneRequiredWithoutResultsNestedInput
  }

  export type ContextResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryId?: StringFieldUpdateOperationsInput | string
    sources?: JsonNullValueInput | InputJsonValue
    chunks?: JsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    totalSources?: IntFieldUpdateOperationsInput | number
    totalChunks?: IntFieldUpdateOperationsInput | number
    queryTime?: IntFieldUpdateOperationsInput | number
    relevanceScore?: FloatFieldUpdateOperationsInput | number
    coverage?: FloatFieldUpdateOperationsInput | number
    freshness?: FloatFieldUpdateOperationsInput | number
    suggestions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextResultCreateManyInput = {
    id?: string
    queryId: string
    sources?: JsonNullValueInput | InputJsonValue
    chunks?: JsonNullValueInput | InputJsonValue
    summary?: string | null
    totalSources?: number
    totalChunks?: number
    queryTime?: number
    relevanceScore?: number
    coverage?: number
    freshness?: number
    suggestions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ContextResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sources?: JsonNullValueInput | InputJsonValue
    chunks?: JsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    totalSources?: IntFieldUpdateOperationsInput | number
    totalChunks?: IntFieldUpdateOperationsInput | number
    queryTime?: IntFieldUpdateOperationsInput | number
    relevanceScore?: FloatFieldUpdateOperationsInput | number
    coverage?: FloatFieldUpdateOperationsInput | number
    freshness?: FloatFieldUpdateOperationsInput | number
    suggestions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryId?: StringFieldUpdateOperationsInput | string
    sources?: JsonNullValueInput | InputJsonValue
    chunks?: JsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    totalSources?: IntFieldUpdateOperationsInput | number
    totalChunks?: IntFieldUpdateOperationsInput | number
    queryTime?: IntFieldUpdateOperationsInput | number
    relevanceScore?: FloatFieldUpdateOperationsInput | number
    coverage?: FloatFieldUpdateOperationsInput | number
    freshness?: FloatFieldUpdateOperationsInput | number
    suggestions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextInjectionCreateInput = {
    id?: string
    conversationId: string
    messageId: string
    context: JsonNullValueInput | InputJsonValue
    templateId?: string | null
    injectedPrompt: string
    originalLength?: number
    injectedLength?: number
    compressionRatio?: number
    relevanceScore?: number
    createdAt?: Date | string
  }

  export type ContextInjectionUncheckedCreateInput = {
    id?: string
    conversationId: string
    messageId: string
    context: JsonNullValueInput | InputJsonValue
    templateId?: string | null
    injectedPrompt: string
    originalLength?: number
    injectedLength?: number
    compressionRatio?: number
    relevanceScore?: number
    createdAt?: Date | string
  }

  export type ContextInjectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    context?: JsonNullValueInput | InputJsonValue
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    injectedPrompt?: StringFieldUpdateOperationsInput | string
    originalLength?: IntFieldUpdateOperationsInput | number
    injectedLength?: IntFieldUpdateOperationsInput | number
    compressionRatio?: FloatFieldUpdateOperationsInput | number
    relevanceScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextInjectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    context?: JsonNullValueInput | InputJsonValue
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    injectedPrompt?: StringFieldUpdateOperationsInput | string
    originalLength?: IntFieldUpdateOperationsInput | number
    injectedLength?: IntFieldUpdateOperationsInput | number
    compressionRatio?: FloatFieldUpdateOperationsInput | number
    relevanceScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextInjectionCreateManyInput = {
    id?: string
    conversationId: string
    messageId: string
    context: JsonNullValueInput | InputJsonValue
    templateId?: string | null
    injectedPrompt: string
    originalLength?: number
    injectedLength?: number
    compressionRatio?: number
    relevanceScore?: number
    createdAt?: Date | string
  }

  export type ContextInjectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    context?: JsonNullValueInput | InputJsonValue
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    injectedPrompt?: StringFieldUpdateOperationsInput | string
    originalLength?: IntFieldUpdateOperationsInput | number
    injectedLength?: IntFieldUpdateOperationsInput | number
    compressionRatio?: FloatFieldUpdateOperationsInput | number
    relevanceScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextInjectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    context?: JsonNullValueInput | InputJsonValue
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    injectedPrompt?: StringFieldUpdateOperationsInput | string
    originalLength?: IntFieldUpdateOperationsInput | number
    injectedLength?: IntFieldUpdateOperationsInput | number
    compressionRatio?: FloatFieldUpdateOperationsInput | number
    relevanceScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextTemplateCreateInput = {
    id?: string
    name: string
    type: string
    template: string
    variables?: ContextTemplateCreatevariablesInput | string[]
    description?: string | null
    version?: string
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContextTemplateUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    template: string
    variables?: ContextTemplateCreatevariablesInput | string[]
    description?: string | null
    version?: string
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContextTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    variables?: ContextTemplateUpdatevariablesInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    variables?: ContextTemplateUpdatevariablesInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextTemplateCreateManyInput = {
    id?: string
    name: string
    type: string
    template: string
    variables?: ContextTemplateCreatevariablesInput | string[]
    description?: string | null
    version?: string
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContextTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    variables?: ContextTemplateUpdatevariablesInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    variables?: ContextTemplateUpdatevariablesInput | string[]
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextQueryAnalyticsCreateInput = {
    id?: string
    conversationId: string
    queryText: string
    intent: JsonNullValueInput | InputJsonValue
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    resultMetadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    query?: ContextQueryCreateNestedOneWithoutAnalyticsInput
  }

  export type ContextQueryAnalyticsUncheckedCreateInput = {
    id?: string
    queryId?: string | null
    conversationId: string
    queryText: string
    intent: JsonNullValueInput | InputJsonValue
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    resultMetadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ContextQueryAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    queryText?: StringFieldUpdateOperationsInput | string
    intent?: JsonNullValueInput | InputJsonValue
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    resultMetadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    query?: ContextQueryUpdateOneWithoutAnalyticsNestedInput
  }

  export type ContextQueryAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryId?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: StringFieldUpdateOperationsInput | string
    queryText?: StringFieldUpdateOperationsInput | string
    intent?: JsonNullValueInput | InputJsonValue
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    resultMetadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextQueryAnalyticsCreateManyInput = {
    id?: string
    queryId?: string | null
    conversationId: string
    queryText: string
    intent: JsonNullValueInput | InputJsonValue
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    resultMetadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ContextQueryAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    queryText?: StringFieldUpdateOperationsInput | string
    intent?: JsonNullValueInput | InputJsonValue
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    resultMetadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextQueryAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryId?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: StringFieldUpdateOperationsInput | string
    queryText?: StringFieldUpdateOperationsInput | string
    intent?: JsonNullValueInput | InputJsonValue
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    resultMetadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextCacheCreateInput = {
    id?: string
    cacheKey: string
    queryText: string
    result: JsonNullValueInput | InputJsonValue
    expiresAt: Date | string
    hitCount?: number
    lastAccessed?: Date | string
    createdAt?: Date | string
  }

  export type ContextCacheUncheckedCreateInput = {
    id?: string
    cacheKey: string
    queryText: string
    result: JsonNullValueInput | InputJsonValue
    expiresAt: Date | string
    hitCount?: number
    lastAccessed?: Date | string
    createdAt?: Date | string
  }

  export type ContextCacheUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cacheKey?: StringFieldUpdateOperationsInput | string
    queryText?: StringFieldUpdateOperationsInput | string
    result?: JsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hitCount?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextCacheUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cacheKey?: StringFieldUpdateOperationsInput | string
    queryText?: StringFieldUpdateOperationsInput | string
    result?: JsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hitCount?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextCacheCreateManyInput = {
    id?: string
    cacheKey: string
    queryText: string
    result: JsonNullValueInput | InputJsonValue
    expiresAt: Date | string
    hitCount?: number
    lastAccessed?: Date | string
    createdAt?: Date | string
  }

  export type ContextCacheUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cacheKey?: StringFieldUpdateOperationsInput | string
    queryText?: StringFieldUpdateOperationsInput | string
    result?: JsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hitCount?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextCacheUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cacheKey?: StringFieldUpdateOperationsInput | string
    queryText?: StringFieldUpdateOperationsInput | string
    result?: JsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hitCount?: IntFieldUpdateOperationsInput | number
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesCreateInput = {
    id?: string
    preferences: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutUserPreferencesInput
  }

  export type UserPreferencesUncheckedCreateInput = {
    id?: string
    userId: string
    preferences: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferencesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutUserPreferencesNestedInput
  }

  export type UserPreferencesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesCreateManyInput = {
    id?: string
    userId: string
    preferences: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferencesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThemeCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    colors: JsonNullValueInput | InputJsonValue
    typography: JsonNullValueInput | InputJsonValue
    spacing: JsonNullValueInput | InputJsonValue
    shadows: JsonNullValueInput | InputJsonValue
    borderRadius: JsonNullValueInput | InputJsonValue
    animations: JsonNullValueInput | InputJsonValue
    custom?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutThemesInput
  }

  export type ThemeUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    colors: JsonNullValueInput | InputJsonValue
    typography: JsonNullValueInput | InputJsonValue
    spacing: JsonNullValueInput | InputJsonValue
    shadows: JsonNullValueInput | InputJsonValue
    borderRadius: JsonNullValueInput | InputJsonValue
    animations: JsonNullValueInput | InputJsonValue
    custom?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ThemeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    colors?: JsonNullValueInput | InputJsonValue
    typography?: JsonNullValueInput | InputJsonValue
    spacing?: JsonNullValueInput | InputJsonValue
    shadows?: JsonNullValueInput | InputJsonValue
    borderRadius?: JsonNullValueInput | InputJsonValue
    animations?: JsonNullValueInput | InputJsonValue
    custom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutThemesNestedInput
  }

  export type ThemeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    colors?: JsonNullValueInput | InputJsonValue
    typography?: JsonNullValueInput | InputJsonValue
    spacing?: JsonNullValueInput | InputJsonValue
    shadows?: JsonNullValueInput | InputJsonValue
    borderRadius?: JsonNullValueInput | InputJsonValue
    animations?: JsonNullValueInput | InputJsonValue
    custom?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThemeCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    colors: JsonNullValueInput | InputJsonValue
    typography: JsonNullValueInput | InputJsonValue
    spacing: JsonNullValueInput | InputJsonValue
    shadows: JsonNullValueInput | InputJsonValue
    borderRadius: JsonNullValueInput | InputJsonValue
    animations: JsonNullValueInput | InputJsonValue
    custom?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ThemeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    colors?: JsonNullValueInput | InputJsonValue
    typography?: JsonNullValueInput | InputJsonValue
    spacing?: JsonNullValueInput | InputJsonValue
    shadows?: JsonNullValueInput | InputJsonValue
    borderRadius?: JsonNullValueInput | InputJsonValue
    animations?: JsonNullValueInput | InputJsonValue
    custom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThemeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    colors?: JsonNullValueInput | InputJsonValue
    typography?: JsonNullValueInput | InputJsonValue
    spacing?: JsonNullValueInput | InputJsonValue
    shadows?: JsonNullValueInput | InputJsonValue
    borderRadius?: JsonNullValueInput | InputJsonValue
    animations?: JsonNullValueInput | InputJsonValue
    custom?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalizationAnalyticsCreateInput = {
    id?: string
    actionType: string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPersonalizationAnalyticsInput
  }

  export type PersonalizationAnalyticsUncheckedCreateInput = {
    id?: string
    userId: string
    actionType: string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PersonalizationAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPersonalizationAnalyticsNestedInput
  }

  export type PersonalizationAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalizationAnalyticsCreateManyInput = {
    id?: string
    userId: string
    actionType: string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PersonalizationAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalizationAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileCreateInput = {
    id?: string
    userId: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutUserProfileInput
    payments?: PaymentCreateNestedManyWithoutUserProfileInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserProfileInput
    credits?: CreditCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateInput = {
    id?: string
    userId: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserProfileInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserProfileInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserProfileInput
    credits?: CreditUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutUserProfileNestedInput
    payments?: PaymentUpdateManyWithoutUserProfileNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserProfileNestedInput
    credits?: CreditUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutUserProfileNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserProfileNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserProfileNestedInput
    credits?: CreditUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileCreateManyInput = {
    id?: string
    userId: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    number: string
    status?: InvoiceStatus
    period: JsonNullValueInput | InputJsonValue
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    currency?: string
    items?: JsonNullValueInput | InputJsonValue
    billingAddress?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userProfile: UserProfileCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    number: string
    userId: string
    status?: InvoiceStatus
    period: JsonNullValueInput | InputJsonValue
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    currency?: string
    items?: JsonNullValueInput | InputJsonValue
    billingAddress?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    period?: JsonNullValueInput | InputJsonValue
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    billingAddress?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProfile?: UserProfileUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    period?: JsonNullValueInput | InputJsonValue
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    billingAddress?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    number: string
    userId: string
    status?: InvoiceStatus
    period: JsonNullValueInput | InputJsonValue
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    currency?: string
    items?: JsonNullValueInput | InputJsonValue
    billingAddress?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    period?: JsonNullValueInput | InputJsonValue
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    billingAddress?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    period?: JsonNullValueInput | InputJsonValue
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    billingAddress?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status?: PaymentStatus
    providerTransactionId?: string | null
    failureReason?: string | null
    refundedAmount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
    userProfile: UserProfileCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    invoiceId: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status?: PaymentStatus
    providerTransactionId?: string | null
    failureReason?: string | null
    refundedAmount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | PaymentStatus
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
    userProfile?: UserProfileUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | PaymentStatus
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type PaymentCreateManyInput = {
    id?: string
    invoiceId: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status?: PaymentStatus
    providerTransactionId?: string | null
    failureReason?: string | null
    refundedAmount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | PaymentStatus
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | PaymentStatus
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type SubscriptionCreateInput = {
    id?: string
    plan: string
    status?: SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    interval?: SubscriptionInterval
    intervalCount?: number
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    userProfile: UserProfileCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    plan: string
    status?: SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    interval?: SubscriptionInterval
    intervalCount?: number
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumSubscriptionIntervalFieldUpdateOperationsInput | SubscriptionInterval
    intervalCount?: IntFieldUpdateOperationsInput | number
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    userProfile?: UserProfileUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumSubscriptionIntervalFieldUpdateOperationsInput | SubscriptionInterval
    intervalCount?: IntFieldUpdateOperationsInput | number
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    userId: string
    plan: string
    status?: SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    interval?: SubscriptionInterval
    intervalCount?: number
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumSubscriptionIntervalFieldUpdateOperationsInput | SubscriptionInterval
    intervalCount?: IntFieldUpdateOperationsInput | number
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumSubscriptionIntervalFieldUpdateOperationsInput | SubscriptionInterval
    intervalCount?: IntFieldUpdateOperationsInput | number
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type CreditCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    reason: string
    type: CreditType
    expiresAt?: Date | string | null
    usedAt?: Date | string | null
    invoiceId?: string | null
    createdAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    userProfile: UserProfileCreateNestedOneWithoutCreditsInput
  }

  export type CreditUncheckedCreateInput = {
    id?: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    reason: string
    type: CreditType
    expiresAt?: Date | string | null
    usedAt?: Date | string | null
    invoiceId?: string | null
    createdAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type CreditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    type?: EnumCreditTypeFieldUpdateOperationsInput | CreditType
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    userProfile?: UserProfileUpdateOneRequiredWithoutCreditsNestedInput
  }

  export type CreditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    type?: EnumCreditTypeFieldUpdateOperationsInput | CreditType
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type CreditCreateManyInput = {
    id?: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    reason: string
    type: CreditType
    expiresAt?: Date | string | null
    usedAt?: Date | string | null
    invoiceId?: string | null
    createdAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type CreditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    type?: EnumCreditTypeFieldUpdateOperationsInput | CreditType
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type CreditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    type?: EnumCreditTypeFieldUpdateOperationsInput | CreditType
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type BillingAlertCreateInput = {
    id?: string
    userId: string
    type: BillingAlertType
    threshold?: Decimal | DecimalJsLike | number | string | null
    currentValue?: Decimal | DecimalJsLike | number | string | null
    message: string
    isRead?: boolean
    createdAt?: Date | string
    readAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type BillingAlertUncheckedCreateInput = {
    id?: string
    userId: string
    type: BillingAlertType
    threshold?: Decimal | DecimalJsLike | number | string | null
    currentValue?: Decimal | DecimalJsLike | number | string | null
    message: string
    isRead?: boolean
    createdAt?: Date | string
    readAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type BillingAlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumBillingAlertTypeFieldUpdateOperationsInput | BillingAlertType
    threshold?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type BillingAlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumBillingAlertTypeFieldUpdateOperationsInput | BillingAlertType
    threshold?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type BillingAlertCreateManyInput = {
    id?: string
    userId: string
    type: BillingAlertType
    threshold?: Decimal | DecimalJsLike | number | string | null
    currentValue?: Decimal | DecimalJsLike | number | string | null
    message: string
    isRead?: boolean
    createdAt?: Date | string
    readAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type BillingAlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumBillingAlertTypeFieldUpdateOperationsInput | BillingAlertType
    threshold?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type BillingAlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumBillingAlertTypeFieldUpdateOperationsInput | BillingAlertType
    threshold?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currentValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type PlanCreateInput = {
    id?: string
    name: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    interval?: PlanInterval
    features?: PlanCreatefeaturesInput | string[]
    limits?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type PlanUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    interval?: PlanInterval
    features?: PlanCreatefeaturesInput | string[]
    limits?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type PlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumPlanIntervalFieldUpdateOperationsInput | PlanInterval
    features?: PlanUpdatefeaturesInput | string[]
    limits?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type PlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumPlanIntervalFieldUpdateOperationsInput | PlanInterval
    features?: PlanUpdatefeaturesInput | string[]
    limits?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type PlanCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    interval?: PlanInterval
    features?: PlanCreatefeaturesInput | string[]
    limits?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type PlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumPlanIntervalFieldUpdateOperationsInput | PlanInterval
    features?: PlanUpdatefeaturesInput | string[]
    limits?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type PlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumPlanIntervalFieldUpdateOperationsInput | PlanInterval
    features?: PlanUpdatefeaturesInput | string[]
    limits?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ModuleOnClientListRelationFilter = {
    every?: ModuleOnClientWhereInput
    some?: ModuleOnClientWhereInput
    none?: ModuleOnClientWhereInput
  }

  export type EnvironmentVariableListRelationFilter = {
    every?: EnvironmentVariableWhereInput
    some?: EnvironmentVariableWhereInput
    none?: EnvironmentVariableWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type LibraryListRelationFilter = {
    every?: LibraryWhereInput
    some?: LibraryWhereInput
    none?: LibraryWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ModuleOnClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnvironmentVariableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LibraryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    apiKeys?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ModuleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
  }

  export type ModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
  }

  export type ModuleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ClientRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type ModuleRelationFilter = {
    is?: ModuleWhereInput
    isNot?: ModuleWhereInput
  }

  export type ModuleOnClientClientIdModuleIdCompoundUniqueInput = {
    clientId: string
    moduleId: string
  }

  export type ModuleOnClientCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    moduleId?: SortOrder
    enabled?: SortOrder
  }

  export type ModuleOnClientMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    moduleId?: SortOrder
    enabled?: SortOrder
  }

  export type ModuleOnClientMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    moduleId?: SortOrder
    enabled?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumEnvironmentFilter<$PrismaModel = never> = {
    equals?: Environment | EnumEnvironmentFieldRefInput<$PrismaModel>
    in?: Environment[] | ListEnumEnvironmentFieldRefInput<$PrismaModel>
    notIn?: Environment[] | ListEnumEnvironmentFieldRefInput<$PrismaModel>
    not?: NestedEnumEnvironmentFilter<$PrismaModel> | Environment
  }

  export type EnvironmentVariableKeyEnvironmentClientIdCompoundUniqueInput = {
    key: string
    environment: Environment
    clientId: string
  }

  export type EnvironmentVariableCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    environment?: SortOrder
    clientId?: SortOrder
  }

  export type EnvironmentVariableMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    environment?: SortOrder
    clientId?: SortOrder
  }

  export type EnvironmentVariableMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    environment?: SortOrder
    clientId?: SortOrder
  }

  export type EnumEnvironmentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Environment | EnumEnvironmentFieldRefInput<$PrismaModel>
    in?: Environment[] | ListEnumEnvironmentFieldRefInput<$PrismaModel>
    notIn?: Environment[] | ListEnumEnvironmentFieldRefInput<$PrismaModel>
    not?: NestedEnumEnvironmentWithAggregatesFilter<$PrismaModel> | Environment
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnvironmentFilter<$PrismaModel>
    _max?: NestedEnumEnvironmentFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | Role
  }

  export type ApiKeyListRelationFilter = {
    every?: ApiKeyWhereInput
    some?: ApiKeyWhereInput
    none?: ApiKeyWhereInput
  }

  export type MCPConfigurationListRelationFilter = {
    every?: MCPConfigurationWhereInput
    some?: MCPConfigurationWhereInput
    none?: MCPConfigurationWhereInput
  }

  export type UsageLogListRelationFilter = {
    every?: UsageLogWhereInput
    some?: UsageLogWhereInput
    none?: UsageLogWhereInput
  }

  export type OAuthTokenListRelationFilter = {
    every?: OAuthTokenWhereInput
    some?: OAuthTokenWhereInput
    none?: OAuthTokenWhereInput
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type MessageReactionListRelationFilter = {
    every?: MessageReactionWhereInput
    some?: MessageReactionWhereInput
    none?: MessageReactionWhereInput
  }

  export type UserPreferencesNullableRelationFilter = {
    is?: UserPreferencesWhereInput | null
    isNot?: UserPreferencesWhereInput | null
  }

  export type ThemeListRelationFilter = {
    every?: ThemeWhereInput
    some?: ThemeWhereInput
    none?: ThemeWhereInput
  }

  export type PersonalizationAnalyticsListRelationFilter = {
    every?: PersonalizationAnalyticsWhereInput
    some?: PersonalizationAnalyticsWhereInput
    none?: PersonalizationAnalyticsWhereInput
  }

  export type ConversationShareListRelationFilter = {
    every?: ConversationShareWhereInput
    some?: ConversationShareWhereInput
    none?: ConversationShareWhereInput
  }

  export type ApiKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MCPConfigurationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsageLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OAuthTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageReactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ThemeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonalizationAnalyticsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationShareOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    hashedPassword?: SortOrder
    oauthProvider?: SortOrder
    oauthId?: SortOrder
    role?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    hashedPassword?: SortOrder
    oauthProvider?: SortOrder
    oauthId?: SortOrder
    role?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    hashedPassword?: SortOrder
    oauthProvider?: SortOrder
    oauthId?: SortOrder
    role?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type LibraryVersionListRelationFilter = {
    every?: LibraryVersionWhereInput
    some?: LibraryVersionWhereInput
    none?: LibraryVersionWhereInput
  }

  export type LibraryAliasListRelationFilter = {
    every?: LibraryAliasWhereInput
    some?: LibraryAliasWhereInput
    none?: LibraryAliasWhereInput
  }

  export type DocumentationChunkListRelationFilter = {
    every?: DocumentationChunkWhereInput
    some?: DocumentationChunkWhereInput
    none?: DocumentationChunkWhereInput
  }

  export type LibraryVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LibraryAliasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentationChunkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LibraryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    vendor?: SortOrder
    repoUrl?: SortOrder
    docsUrl?: SortOrder
    defaultVersion?: SortOrder
    popularityScore?: SortOrder
    totalSnippets?: SortOrder
    totalTokens?: SortOrder
    language?: SortOrder
    ecosystem?: SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    clientId?: SortOrder
    lastCrawledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryAvgOrderByAggregateInput = {
    popularityScore?: SortOrder
    totalSnippets?: SortOrder
    totalTokens?: SortOrder
  }

  export type LibraryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    vendor?: SortOrder
    repoUrl?: SortOrder
    docsUrl?: SortOrder
    defaultVersion?: SortOrder
    popularityScore?: SortOrder
    totalSnippets?: SortOrder
    totalTokens?: SortOrder
    language?: SortOrder
    ecosystem?: SortOrder
    clientId?: SortOrder
    lastCrawledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibraryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    vendor?: SortOrder
    repoUrl?: SortOrder
    docsUrl?: SortOrder
    defaultVersion?: SortOrder
    popularityScore?: SortOrder
    totalSnippets?: SortOrder
    totalTokens?: SortOrder
    language?: SortOrder
    ecosystem?: SortOrder
    clientId?: SortOrder
    lastCrawledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LibrarySumOrderByAggregateInput = {
    popularityScore?: SortOrder
    totalSnippets?: SortOrder
    totalTokens?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type LibraryRelationFilter = {
    is?: LibraryWhereInput
    isNot?: LibraryWhereInput
  }

  export type LibraryVersionLibraryIdVersionCompoundUniqueInput = {
    libraryId: string
    version: string
  }

  export type LibraryVersionCountOrderByAggregateInput = {
    id?: SortOrder
    libraryId?: SortOrder
    version?: SortOrder
    releaseDate?: SortOrder
    isLatest?: SortOrder
    docsSnapshotUrl?: SortOrder
  }

  export type LibraryVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    libraryId?: SortOrder
    version?: SortOrder
    releaseDate?: SortOrder
    isLatest?: SortOrder
    docsSnapshotUrl?: SortOrder
  }

  export type LibraryVersionMinOrderByAggregateInput = {
    id?: SortOrder
    libraryId?: SortOrder
    version?: SortOrder
    releaseDate?: SortOrder
    isLatest?: SortOrder
    docsSnapshotUrl?: SortOrder
  }

  export type LibraryAliasLibraryIdAliasCompoundUniqueInput = {
    libraryId: string
    alias: string
  }

  export type LibraryAliasCountOrderByAggregateInput = {
    id?: SortOrder
    libraryId?: SortOrder
    alias?: SortOrder
  }

  export type LibraryAliasMaxOrderByAggregateInput = {
    id?: SortOrder
    libraryId?: SortOrder
    alias?: SortOrder
  }

  export type LibraryAliasMinOrderByAggregateInput = {
    id?: SortOrder
    libraryId?: SortOrder
    alias?: SortOrder
  }

  export type LibraryVersionRelationFilter = {
    is?: LibraryVersionWhereInput
    isNot?: LibraryVersionWhereInput
  }

  export type LibraryNullableRelationFilter = {
    is?: LibraryWhereInput | null
    isNot?: LibraryWhereInput | null
  }

  export type DocumentationChunkCountOrderByAggregateInput = {
    id?: SortOrder
    libraryVersionId?: SortOrder
    chunkIndex?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    sourceUrl?: SortOrder
    tokenCount?: SortOrder
    embeddingId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    libraryId?: SortOrder
  }

  export type DocumentationChunkAvgOrderByAggregateInput = {
    chunkIndex?: SortOrder
    tokenCount?: SortOrder
  }

  export type DocumentationChunkMaxOrderByAggregateInput = {
    id?: SortOrder
    libraryVersionId?: SortOrder
    chunkIndex?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    sourceUrl?: SortOrder
    tokenCount?: SortOrder
    embeddingId?: SortOrder
    createdAt?: SortOrder
    libraryId?: SortOrder
  }

  export type DocumentationChunkMinOrderByAggregateInput = {
    id?: SortOrder
    libraryVersionId?: SortOrder
    chunkIndex?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    sourceUrl?: SortOrder
    tokenCount?: SortOrder
    embeddingId?: SortOrder
    createdAt?: SortOrder
    libraryId?: SortOrder
  }

  export type DocumentationChunkSumOrderByAggregateInput = {
    chunkIndex?: SortOrder
    tokenCount?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ApiKeyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    keyHash?: SortOrder
    keyPrefix?: SortOrder
    name?: SortOrder
    tier?: SortOrder
    quotaDaily?: SortOrder
    quotaMonthly?: SortOrder
    usedDaily?: SortOrder
    usedMonthly?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type ApiKeyAvgOrderByAggregateInput = {
    quotaDaily?: SortOrder
    quotaMonthly?: SortOrder
    usedDaily?: SortOrder
    usedMonthly?: SortOrder
  }

  export type ApiKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    keyHash?: SortOrder
    keyPrefix?: SortOrder
    name?: SortOrder
    tier?: SortOrder
    quotaDaily?: SortOrder
    quotaMonthly?: SortOrder
    usedDaily?: SortOrder
    usedMonthly?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type ApiKeyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    keyHash?: SortOrder
    keyPrefix?: SortOrder
    name?: SortOrder
    tier?: SortOrder
    quotaDaily?: SortOrder
    quotaMonthly?: SortOrder
    usedDaily?: SortOrder
    usedMonthly?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type ApiKeySumOrderByAggregateInput = {
    quotaDaily?: SortOrder
    quotaMonthly?: SortOrder
    usedDaily?: SortOrder
    usedMonthly?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ApiKeyNullableRelationFilter = {
    is?: ApiKeyWhereInput | null
    isNot?: ApiKeyWhereInput | null
  }

  export type UsageLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    apiKeyId?: SortOrder
    libraryId?: SortOrder
    toolName?: SortOrder
    query?: SortOrder
    tokensReturned?: SortOrder
    responseTimeMs?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageLogAvgOrderByAggregateInput = {
    tokensReturned?: SortOrder
    responseTimeMs?: SortOrder
  }

  export type UsageLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    apiKeyId?: SortOrder
    libraryId?: SortOrder
    toolName?: SortOrder
    query?: SortOrder
    tokensReturned?: SortOrder
    responseTimeMs?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    apiKeyId?: SortOrder
    libraryId?: SortOrder
    toolName?: SortOrder
    query?: SortOrder
    tokensReturned?: SortOrder
    responseTimeMs?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageLogSumOrderByAggregateInput = {
    tokensReturned?: SortOrder
    responseTimeMs?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumConfigStatusFilter<$PrismaModel = never> = {
    equals?: ConfigStatus | EnumConfigStatusFieldRefInput<$PrismaModel>
    in?: ConfigStatus[] | ListEnumConfigStatusFieldRefInput<$PrismaModel>
    notIn?: ConfigStatus[] | ListEnumConfigStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConfigStatusFilter<$PrismaModel> | ConfigStatus
  }

  export type MCPConfigurationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    configData?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MCPConfigurationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MCPConfigurationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumConfigStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: ConfigStatus | EnumConfigStatusFieldRefInput<$PrismaModel>
    in?: ConfigStatus[] | ListEnumConfigStatusFieldRefInput<$PrismaModel>
    notIn?: ConfigStatus[] | ListEnumConfigStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConfigStatusWithAggregatesFilter<$PrismaModel> | ConfigStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConfigStatusFilter<$PrismaModel>
    _max?: NestedEnumConfigStatusFilter<$PrismaModel>
  }

  export type OAuthTokenUserIdProviderCompoundUniqueInput = {
    userId: string
    provider: string
  }

  export type OAuthTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OAuthTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OAuthTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OAuthAuthorizationCodeListRelationFilter = {
    every?: OAuthAuthorizationCodeWhereInput
    some?: OAuthAuthorizationCodeWhereInput
    none?: OAuthAuthorizationCodeWhereInput
  }

  export type OAuthAccessTokenListRelationFilter = {
    every?: OAuthAccessTokenWhereInput
    some?: OAuthAccessTokenWhereInput
    none?: OAuthAccessTokenWhereInput
  }

  export type OAuthRefreshTokenListRelationFilter = {
    every?: OAuthRefreshTokenWhereInput
    some?: OAuthRefreshTokenWhereInput
    none?: OAuthRefreshTokenWhereInput
  }

  export type OAuthAuthorizationCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OAuthAccessTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OAuthRefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OAuthClientCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    clientSecretHash?: SortOrder
    name?: SortOrder
    redirectUris?: SortOrder
    allowedScopes?: SortOrder
    grantTypes?: SortOrder
    requirePkce?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OAuthClientMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    clientSecretHash?: SortOrder
    name?: SortOrder
    requirePkce?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OAuthClientMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    clientSecretHash?: SortOrder
    name?: SortOrder
    requirePkce?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OAuthClientRelationFilter = {
    is?: OAuthClientWhereInput
    isNot?: OAuthClientWhereInput
  }

  export type OAuthAuthorizationCodeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    clientId?: SortOrder
    userId?: SortOrder
    redirectUri?: SortOrder
    scopes?: SortOrder
    codeChallenge?: SortOrder
    codeChallengeMethod?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OAuthAuthorizationCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    clientId?: SortOrder
    userId?: SortOrder
    redirectUri?: SortOrder
    codeChallenge?: SortOrder
    codeChallengeMethod?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OAuthAuthorizationCodeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    clientId?: SortOrder
    userId?: SortOrder
    redirectUri?: SortOrder
    codeChallenge?: SortOrder
    codeChallengeMethod?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OAuthAccessTokenCountOrderByAggregateInput = {
    id?: SortOrder
    tokenHash?: SortOrder
    clientId?: SortOrder
    userId?: SortOrder
    scopes?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OAuthAccessTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    tokenHash?: SortOrder
    clientId?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OAuthAccessTokenMinOrderByAggregateInput = {
    id?: SortOrder
    tokenHash?: SortOrder
    clientId?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type OAuthAccessTokenRelationFilter = {
    is?: OAuthAccessTokenWhereInput
    isNot?: OAuthAccessTokenWhereInput
  }

  export type OAuthRefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    tokenHash?: SortOrder
    accessTokenId?: SortOrder
    clientId?: SortOrder
    userId?: SortOrder
    scopes?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    createdAt?: SortOrder
  }

  export type OAuthRefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    tokenHash?: SortOrder
    accessTokenId?: SortOrder
    clientId?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    createdAt?: SortOrder
  }

  export type OAuthRefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    tokenHash?: SortOrder
    accessTokenId?: SortOrder
    clientId?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    createdAt?: SortOrder
  }

  export type DownloadResultListRelationFilter = {
    every?: DownloadResultWhereInput
    some?: DownloadResultWhereInput
    none?: DownloadResultWhereInput
  }

  export type DownloadResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DownloadTaskCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    source?: SortOrder
    options?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
    error?: SortOrder
    retry_count?: SortOrder
  }

  export type DownloadTaskAvgOrderByAggregateInput = {
    retry_count?: SortOrder
  }

  export type DownloadTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
    error?: SortOrder
    retry_count?: SortOrder
  }

  export type DownloadTaskMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
    error?: SortOrder
    retry_count?: SortOrder
  }

  export type DownloadTaskSumOrderByAggregateInput = {
    retry_count?: SortOrder
  }

  export type DownloadTaskRelationFilter = {
    is?: DownloadTaskWhereInput
    isNot?: DownloadTaskWhereInput
  }

  export type DownloadResultCountOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    success?: SortOrder
    local_path?: SortOrder
    metadata?: SortOrder
    files?: SortOrder
    errors?: SortOrder
    created_at?: SortOrder
  }

  export type DownloadResultMaxOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    success?: SortOrder
    local_path?: SortOrder
    created_at?: SortOrder
  }

  export type DownloadResultMinOrderByAggregateInput = {
    id?: SortOrder
    task_id?: SortOrder
    success?: SortOrder
    local_path?: SortOrder
    created_at?: SortOrder
  }

  export type PromptTemplateListRelationFilter = {
    every?: PromptTemplateWhereInput
    some?: PromptTemplateWhereInput
    none?: PromptTemplateWhereInput
  }

  export type PromptCategoryNullableRelationFilter = {
    is?: PromptCategoryWhereInput | null
    isNot?: PromptCategoryWhereInput | null
  }

  export type PromptCategoryListRelationFilter = {
    every?: PromptCategoryWhereInput
    some?: PromptCategoryWhereInput
    none?: PromptCategoryWhereInput
  }

  export type PromptTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromptCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromptCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    parentCategory?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromptCategoryAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type PromptCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    parentCategory?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromptCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    parentCategory?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromptCategorySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type PromptCategoryRelationFilter = {
    is?: PromptCategoryWhereInput
    isNot?: PromptCategoryWhereInput
  }

  export type PromptExecutionListRelationFilter = {
    every?: PromptExecutionWhereInput
    some?: PromptExecutionWhereInput
    none?: PromptExecutionWhereInput
  }

  export type TemplateChangeListRelationFilter = {
    every?: TemplateChangeWhereInput
    some?: TemplateChangeWhereInput
    none?: TemplateChangeWhereInput
  }

  export type OptimizationRecordListRelationFilter = {
    every?: OptimizationRecordWhereInput
    some?: OptimizationRecordWhereInput
    none?: OptimizationRecordWhereInput
  }

  export type PromptExecutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TemplateChangeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OptimizationRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromptTemplateIdVersionCompoundUniqueInput = {
    id: string
    version: string
  }

  export type PromptTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    template?: SortOrder
    variables?: SortOrder
    examples?: SortOrder
    metadata?: SortOrder
    constraints?: SortOrder
    optimization?: SortOrder
    testing?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromptTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    template?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromptTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    template?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromptTemplateRelationFilter = {
    is?: PromptTemplateWhereInput
    isNot?: PromptTemplateWhereInput
  }

  export type TemplateChangeCountOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    fromVersion?: SortOrder
    toVersion?: SortOrder
    changes?: SortOrder
    createdAt?: SortOrder
  }

  export type TemplateChangeMaxOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    fromVersion?: SortOrder
    toVersion?: SortOrder
    createdAt?: SortOrder
  }

  export type TemplateChangeMinOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    fromVersion?: SortOrder
    toVersion?: SortOrder
    createdAt?: SortOrder
  }

  export type PromptExecutionCountOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    templateVersion?: SortOrder
    variables?: SortOrder
    renderedPrompt?: SortOrder
    context?: SortOrder
    model?: SortOrder
    provider?: SortOrder
    response?: SortOrder
    metrics?: SortOrder
    quality?: SortOrder
    feedback?: SortOrder
    abTestVariant?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PromptExecutionMaxOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    templateVersion?: SortOrder
    renderedPrompt?: SortOrder
    model?: SortOrder
    provider?: SortOrder
    response?: SortOrder
    abTestVariant?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PromptExecutionMinOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    templateVersion?: SortOrder
    renderedPrompt?: SortOrder
    model?: SortOrder
    provider?: SortOrder
    response?: SortOrder
    abTestVariant?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PromptExecutionErrorCountOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    variables?: SortOrder
    errorMessage?: SortOrder
    context?: SortOrder
    createdAt?: SortOrder
  }

  export type PromptExecutionErrorMaxOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type PromptExecutionErrorMinOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ABTestCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    variants?: SortOrder
    trafficSplit?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    sampleSize?: SortOrder
    confidence?: SortOrder
    results?: SortOrder
    createdAt?: SortOrder
  }

  export type ABTestAvgOrderByAggregateInput = {
    sampleSize?: SortOrder
    confidence?: SortOrder
  }

  export type ABTestMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    sampleSize?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
  }

  export type ABTestMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    sampleSize?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
  }

  export type ABTestSumOrderByAggregateInput = {
    sampleSize?: SortOrder
    confidence?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type OptimizationRecordCountOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    changes?: SortOrder
    metricsBefore?: SortOrder
    metricsAfter?: SortOrder
    improvement?: SortOrder
    createdAt?: SortOrder
  }

  export type OptimizationRecordAvgOrderByAggregateInput = {
    improvement?: SortOrder
  }

  export type OptimizationRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    improvement?: SortOrder
    createdAt?: SortOrder
  }

  export type OptimizationRecordMinOrderByAggregateInput = {
    id?: SortOrder
    templateId?: SortOrder
    timestamp?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    improvement?: SortOrder
    createdAt?: SortOrder
  }

  export type OptimizationRecordSumOrderByAggregateInput = {
    improvement?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type ConversationExportListRelationFilter = {
    every?: ConversationExportWhereInput
    some?: ConversationExportWhereInput
    none?: ConversationExportWhereInput
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationExportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    metadata?: SortOrder
    settings?: SortOrder
    analytics?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type MessageAttachmentListRelationFilter = {
    every?: MessageAttachmentWhereInput
    some?: MessageAttachmentWhereInput
    none?: MessageAttachmentWhereInput
  }

  export type MessageAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
  }

  export type MessageRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type MessageReactionMessageIdUserIdEmojiCompoundUniqueInput = {
    messageId: string
    userId: string
    emoji: string
  }

  export type MessageReactionCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    emoji?: SortOrder
    timestamp?: SortOrder
  }

  export type MessageReactionMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    emoji?: SortOrder
    timestamp?: SortOrder
  }

  export type MessageReactionMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    emoji?: SortOrder
    timestamp?: SortOrder
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type MessageAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    url?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    metadata?: SortOrder
    thumbnail?: SortOrder
  }

  export type MessageAttachmentAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type MessageAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    url?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    thumbnail?: SortOrder
  }

  export type MessageAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    url?: SortOrder
    size?: SortOrder
    mimeType?: SortOrder
    thumbnail?: SortOrder
  }

  export type MessageAttachmentSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type ConversationShareCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    shareId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    permissions?: SortOrder
    settings?: SortOrder
    analytics?: SortOrder
  }

  export type ConversationShareMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    shareId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type ConversationShareMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    shareId?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type ConversationExportCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    format?: SortOrder
    options?: SortOrder
    status?: SortOrder
    downloadUrl?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
    error?: SortOrder
  }

  export type ConversationExportMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    format?: SortOrder
    status?: SortOrder
    downloadUrl?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
    error?: SortOrder
  }

  export type ConversationExportMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    format?: SortOrder
    status?: SortOrder
    downloadUrl?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
    error?: SortOrder
  }

  export type ContextChunkListRelationFilter = {
    every?: ContextChunkWhereInput
    some?: ContextChunkWhereInput
    none?: ContextChunkWhereInput
  }

  export type ContextChunkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContextSourceCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    url?: SortOrder
    libraryId?: SortOrder
    version?: SortOrder
    language?: SortOrder
    tags?: SortOrder
    relevanceScore?: SortOrder
    freshness?: SortOrder
    popularity?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContextSourceAvgOrderByAggregateInput = {
    relevanceScore?: SortOrder
    freshness?: SortOrder
    popularity?: SortOrder
  }

  export type ContextSourceMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    url?: SortOrder
    libraryId?: SortOrder
    version?: SortOrder
    language?: SortOrder
    relevanceScore?: SortOrder
    freshness?: SortOrder
    popularity?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContextSourceMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    url?: SortOrder
    libraryId?: SortOrder
    version?: SortOrder
    language?: SortOrder
    relevanceScore?: SortOrder
    freshness?: SortOrder
    popularity?: SortOrder
    lastUpdated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContextSourceSumOrderByAggregateInput = {
    relevanceScore?: SortOrder
    freshness?: SortOrder
    popularity?: SortOrder
  }

  export type FloatNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    has?: number | FloatFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListFloatFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListFloatFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ContextSourceRelationFilter = {
    is?: ContextSourceWhereInput
    isNot?: ContextSourceWhereInput
  }

  export type ContextChunkCountOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    content?: SortOrder
    positionStart?: SortOrder
    positionEnd?: SortOrder
    positionIndex?: SortOrder
    positionTotal?: SortOrder
    sectionTitle?: SortOrder
    codeBlocks?: SortOrder
    links?: SortOrder
    images?: SortOrder
    complexity?: SortOrder
    embedding?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContextChunkAvgOrderByAggregateInput = {
    positionStart?: SortOrder
    positionEnd?: SortOrder
    positionIndex?: SortOrder
    positionTotal?: SortOrder
    codeBlocks?: SortOrder
    links?: SortOrder
    images?: SortOrder
    embedding?: SortOrder
  }

  export type ContextChunkMaxOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    content?: SortOrder
    positionStart?: SortOrder
    positionEnd?: SortOrder
    positionIndex?: SortOrder
    positionTotal?: SortOrder
    sectionTitle?: SortOrder
    codeBlocks?: SortOrder
    links?: SortOrder
    images?: SortOrder
    complexity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContextChunkMinOrderByAggregateInput = {
    id?: SortOrder
    sourceId?: SortOrder
    content?: SortOrder
    positionStart?: SortOrder
    positionEnd?: SortOrder
    positionIndex?: SortOrder
    positionTotal?: SortOrder
    sectionTitle?: SortOrder
    codeBlocks?: SortOrder
    links?: SortOrder
    images?: SortOrder
    complexity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContextChunkSumOrderByAggregateInput = {
    positionStart?: SortOrder
    positionEnd?: SortOrder
    positionIndex?: SortOrder
    positionTotal?: SortOrder
    codeBlocks?: SortOrder
    links?: SortOrder
    images?: SortOrder
    embedding?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ContextResultListRelationFilter = {
    every?: ContextResultWhereInput
    some?: ContextResultWhereInput
    none?: ContextResultWhereInput
  }

  export type ContextQueryAnalyticsListRelationFilter = {
    every?: ContextQueryAnalyticsWhereInput
    some?: ContextQueryAnalyticsWhereInput
    none?: ContextQueryAnalyticsWhereInput
  }

  export type ContextResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContextQueryAnalyticsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContextQueryCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    messageId?: SortOrder
    queryText?: SortOrder
    intentType?: SortOrder
    intentConfidence?: SortOrder
    intentKeywords?: SortOrder
    intentCategory?: SortOrder
    intentSubcategory?: SortOrder
    entities?: SortOrder
    filters?: SortOrder
    options?: SortOrder
    createdAt?: SortOrder
  }

  export type ContextQueryAvgOrderByAggregateInput = {
    intentConfidence?: SortOrder
  }

  export type ContextQueryMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    messageId?: SortOrder
    queryText?: SortOrder
    intentType?: SortOrder
    intentConfidence?: SortOrder
    intentCategory?: SortOrder
    intentSubcategory?: SortOrder
    createdAt?: SortOrder
  }

  export type ContextQueryMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    messageId?: SortOrder
    queryText?: SortOrder
    intentType?: SortOrder
    intentConfidence?: SortOrder
    intentCategory?: SortOrder
    intentSubcategory?: SortOrder
    createdAt?: SortOrder
  }

  export type ContextQuerySumOrderByAggregateInput = {
    intentConfidence?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ContextQueryRelationFilter = {
    is?: ContextQueryWhereInput
    isNot?: ContextQueryWhereInput
  }

  export type ContextResultCountOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    sources?: SortOrder
    chunks?: SortOrder
    summary?: SortOrder
    totalSources?: SortOrder
    totalChunks?: SortOrder
    queryTime?: SortOrder
    relevanceScore?: SortOrder
    coverage?: SortOrder
    freshness?: SortOrder
    suggestions?: SortOrder
    createdAt?: SortOrder
  }

  export type ContextResultAvgOrderByAggregateInput = {
    totalSources?: SortOrder
    totalChunks?: SortOrder
    queryTime?: SortOrder
    relevanceScore?: SortOrder
    coverage?: SortOrder
    freshness?: SortOrder
  }

  export type ContextResultMaxOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    summary?: SortOrder
    totalSources?: SortOrder
    totalChunks?: SortOrder
    queryTime?: SortOrder
    relevanceScore?: SortOrder
    coverage?: SortOrder
    freshness?: SortOrder
    createdAt?: SortOrder
  }

  export type ContextResultMinOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    summary?: SortOrder
    totalSources?: SortOrder
    totalChunks?: SortOrder
    queryTime?: SortOrder
    relevanceScore?: SortOrder
    coverage?: SortOrder
    freshness?: SortOrder
    createdAt?: SortOrder
  }

  export type ContextResultSumOrderByAggregateInput = {
    totalSources?: SortOrder
    totalChunks?: SortOrder
    queryTime?: SortOrder
    relevanceScore?: SortOrder
    coverage?: SortOrder
    freshness?: SortOrder
  }

  export type ContextInjectionCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    messageId?: SortOrder
    context?: SortOrder
    templateId?: SortOrder
    injectedPrompt?: SortOrder
    originalLength?: SortOrder
    injectedLength?: SortOrder
    compressionRatio?: SortOrder
    relevanceScore?: SortOrder
    createdAt?: SortOrder
  }

  export type ContextInjectionAvgOrderByAggregateInput = {
    originalLength?: SortOrder
    injectedLength?: SortOrder
    compressionRatio?: SortOrder
    relevanceScore?: SortOrder
  }

  export type ContextInjectionMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    messageId?: SortOrder
    templateId?: SortOrder
    injectedPrompt?: SortOrder
    originalLength?: SortOrder
    injectedLength?: SortOrder
    compressionRatio?: SortOrder
    relevanceScore?: SortOrder
    createdAt?: SortOrder
  }

  export type ContextInjectionMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    messageId?: SortOrder
    templateId?: SortOrder
    injectedPrompt?: SortOrder
    originalLength?: SortOrder
    injectedLength?: SortOrder
    compressionRatio?: SortOrder
    relevanceScore?: SortOrder
    createdAt?: SortOrder
  }

  export type ContextInjectionSumOrderByAggregateInput = {
    originalLength?: SortOrder
    injectedLength?: SortOrder
    compressionRatio?: SortOrder
    relevanceScore?: SortOrder
  }

  export type ContextTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    template?: SortOrder
    variables?: SortOrder
    description?: SortOrder
    version?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContextTemplateAvgOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type ContextTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    template?: SortOrder
    description?: SortOrder
    version?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContextTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    template?: SortOrder
    description?: SortOrder
    version?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContextTemplateSumOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type ContextQueryNullableRelationFilter = {
    is?: ContextQueryWhereInput | null
    isNot?: ContextQueryWhereInput | null
  }

  export type ContextQueryAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    conversationId?: SortOrder
    queryText?: SortOrder
    intent?: SortOrder
    entities?: SortOrder
    filters?: SortOrder
    options?: SortOrder
    resultMetadata?: SortOrder
    createdAt?: SortOrder
  }

  export type ContextQueryAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    conversationId?: SortOrder
    queryText?: SortOrder
    createdAt?: SortOrder
  }

  export type ContextQueryAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    conversationId?: SortOrder
    queryText?: SortOrder
    createdAt?: SortOrder
  }

  export type ContextCacheCountOrderByAggregateInput = {
    id?: SortOrder
    cacheKey?: SortOrder
    queryText?: SortOrder
    result?: SortOrder
    expiresAt?: SortOrder
    hitCount?: SortOrder
    lastAccessed?: SortOrder
    createdAt?: SortOrder
  }

  export type ContextCacheAvgOrderByAggregateInput = {
    hitCount?: SortOrder
  }

  export type ContextCacheMaxOrderByAggregateInput = {
    id?: SortOrder
    cacheKey?: SortOrder
    queryText?: SortOrder
    expiresAt?: SortOrder
    hitCount?: SortOrder
    lastAccessed?: SortOrder
    createdAt?: SortOrder
  }

  export type ContextCacheMinOrderByAggregateInput = {
    id?: SortOrder
    cacheKey?: SortOrder
    queryText?: SortOrder
    expiresAt?: SortOrder
    hitCount?: SortOrder
    lastAccessed?: SortOrder
    createdAt?: SortOrder
  }

  export type ContextCacheSumOrderByAggregateInput = {
    hitCount?: SortOrder
  }

  export type UserPreferencesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPreferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPreferencesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ThemeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    colors?: SortOrder
    typography?: SortOrder
    spacing?: SortOrder
    shadows?: SortOrder
    borderRadius?: SortOrder
    animations?: SortOrder
    custom?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ThemeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    custom?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ThemeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    custom?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonalizationAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type PersonalizationAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    createdAt?: SortOrder
  }

  export type PersonalizationAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    createdAt?: SortOrder
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type CreditListRelationFilter = {
    every?: CreditWhereInput
    some?: CreditWhereInput
    none?: CreditWhereInput
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    postalCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | InvoiceStatus
  }

  export type UserProfileRelationFilter = {
    is?: UserProfileWhereInput
    isNot?: UserProfileWhereInput
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    period?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    items?: SortOrder
    billingAddress?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
    currency?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    total?: SortOrder
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | PaymentStatus
  }

  export type InvoiceRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    providerTransactionId?: SortOrder
    failureReason?: SortOrder
    refundedAmount?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
    metadata?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
    refundedAmount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    providerTransactionId?: SortOrder
    failureReason?: SortOrder
    refundedAmount?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    providerTransactionId?: SortOrder
    failureReason?: SortOrder
    refundedAmount?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
    refundedAmount?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | SubscriptionStatus
  }

  export type EnumSubscriptionIntervalFilter<$PrismaModel = never> = {
    equals?: SubscriptionInterval | EnumSubscriptionIntervalFieldRefInput<$PrismaModel>
    in?: SubscriptionInterval[] | ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel>
    notIn?: SubscriptionInterval[] | ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionIntervalFilter<$PrismaModel> | SubscriptionInterval
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    intervalCount?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    amount?: SortOrder
    intervalCount?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    intervalCount?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    intervalCount?: SortOrder
    trialStart?: SortOrder
    trialEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    amount?: SortOrder
    intervalCount?: SortOrder
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type EnumSubscriptionIntervalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: SubscriptionInterval | EnumSubscriptionIntervalFieldRefInput<$PrismaModel>
    in?: SubscriptionInterval[] | ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel>
    notIn?: SubscriptionInterval[] | ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionIntervalWithAggregatesFilter<$PrismaModel> | SubscriptionInterval
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionIntervalFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionIntervalFilter<$PrismaModel>
  }

  export type EnumCreditTypeFilter<$PrismaModel = never> = {
    equals?: CreditType | EnumCreditTypeFieldRefInput<$PrismaModel>
    in?: CreditType[] | ListEnumCreditTypeFieldRefInput<$PrismaModel>
    notIn?: CreditType[] | ListEnumCreditTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditTypeFilter<$PrismaModel> | CreditType
  }

  export type CreditCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    reason?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    invoiceId?: SortOrder
    createdAt?: SortOrder
    metadata?: SortOrder
  }

  export type CreditAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type CreditMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    reason?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    invoiceId?: SortOrder
    createdAt?: SortOrder
  }

  export type CreditMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    reason?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    invoiceId?: SortOrder
    createdAt?: SortOrder
  }

  export type CreditSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumCreditTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: CreditType | EnumCreditTypeFieldRefInput<$PrismaModel>
    in?: CreditType[] | ListEnumCreditTypeFieldRefInput<$PrismaModel>
    notIn?: CreditType[] | ListEnumCreditTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditTypeWithAggregatesFilter<$PrismaModel> | CreditType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreditTypeFilter<$PrismaModel>
    _max?: NestedEnumCreditTypeFilter<$PrismaModel>
  }

  export type EnumBillingAlertTypeFilter<$PrismaModel = never> = {
    equals?: BillingAlertType | EnumBillingAlertTypeFieldRefInput<$PrismaModel>
    in?: BillingAlertType[] | ListEnumBillingAlertTypeFieldRefInput<$PrismaModel>
    notIn?: BillingAlertType[] | ListEnumBillingAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingAlertTypeFilter<$PrismaModel> | BillingAlertType
  }

  export type BillingAlertCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    threshold?: SortOrder
    currentValue?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
    metadata?: SortOrder
  }

  export type BillingAlertAvgOrderByAggregateInput = {
    threshold?: SortOrder
    currentValue?: SortOrder
  }

  export type BillingAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    threshold?: SortOrder
    currentValue?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type BillingAlertMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    threshold?: SortOrder
    currentValue?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    readAt?: SortOrder
  }

  export type BillingAlertSumOrderByAggregateInput = {
    threshold?: SortOrder
    currentValue?: SortOrder
  }

  export type EnumBillingAlertTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: BillingAlertType | EnumBillingAlertTypeFieldRefInput<$PrismaModel>
    in?: BillingAlertType[] | ListEnumBillingAlertTypeFieldRefInput<$PrismaModel>
    notIn?: BillingAlertType[] | ListEnumBillingAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingAlertTypeWithAggregatesFilter<$PrismaModel> | BillingAlertType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillingAlertTypeFilter<$PrismaModel>
    _max?: NestedEnumBillingAlertTypeFilter<$PrismaModel>
  }

  export type EnumPlanIntervalFilter<$PrismaModel = never> = {
    equals?: PlanInterval | EnumPlanIntervalFieldRefInput<$PrismaModel>
    in?: PlanInterval[] | ListEnumPlanIntervalFieldRefInput<$PrismaModel>
    notIn?: PlanInterval[] | ListEnumPlanIntervalFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanIntervalFilter<$PrismaModel> | PlanInterval
  }

  export type PlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    features?: SortOrder
    limits?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrder
  }

  export type PlanAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPlanIntervalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: PlanInterval | EnumPlanIntervalFieldRefInput<$PrismaModel>
    in?: PlanInterval[] | ListEnumPlanIntervalFieldRefInput<$PrismaModel>
    notIn?: PlanInterval[] | ListEnumPlanIntervalFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanIntervalWithAggregatesFilter<$PrismaModel> | PlanInterval
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanIntervalFilter<$PrismaModel>
    _max?: NestedEnumPlanIntervalFilter<$PrismaModel>
  }

  export type ModuleOnClientCreateNestedManyWithoutClientInput = {
    create?: XOR<ModuleOnClientCreateWithoutClientInput, ModuleOnClientUncheckedCreateWithoutClientInput> | ModuleOnClientCreateWithoutClientInput[] | ModuleOnClientUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ModuleOnClientCreateOrConnectWithoutClientInput | ModuleOnClientCreateOrConnectWithoutClientInput[]
    createMany?: ModuleOnClientCreateManyClientInputEnvelope
    connect?: ModuleOnClientWhereUniqueInput | ModuleOnClientWhereUniqueInput[]
  }

  export type EnvironmentVariableCreateNestedManyWithoutClientInput = {
    create?: XOR<EnvironmentVariableCreateWithoutClientInput, EnvironmentVariableUncheckedCreateWithoutClientInput> | EnvironmentVariableCreateWithoutClientInput[] | EnvironmentVariableUncheckedCreateWithoutClientInput[]
    connectOrCreate?: EnvironmentVariableCreateOrConnectWithoutClientInput | EnvironmentVariableCreateOrConnectWithoutClientInput[]
    createMany?: EnvironmentVariableCreateManyClientInputEnvelope
    connect?: EnvironmentVariableWhereUniqueInput | EnvironmentVariableWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutClientInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput> | UserCreateWithoutClientInput[] | UserUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClientInput | UserCreateOrConnectWithoutClientInput[]
    createMany?: UserCreateManyClientInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type LibraryCreateNestedManyWithoutClientInput = {
    create?: XOR<LibraryCreateWithoutClientInput, LibraryUncheckedCreateWithoutClientInput> | LibraryCreateWithoutClientInput[] | LibraryUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LibraryCreateOrConnectWithoutClientInput | LibraryCreateOrConnectWithoutClientInput[]
    createMany?: LibraryCreateManyClientInputEnvelope
    connect?: LibraryWhereUniqueInput | LibraryWhereUniqueInput[]
  }

  export type ModuleOnClientUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ModuleOnClientCreateWithoutClientInput, ModuleOnClientUncheckedCreateWithoutClientInput> | ModuleOnClientCreateWithoutClientInput[] | ModuleOnClientUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ModuleOnClientCreateOrConnectWithoutClientInput | ModuleOnClientCreateOrConnectWithoutClientInput[]
    createMany?: ModuleOnClientCreateManyClientInputEnvelope
    connect?: ModuleOnClientWhereUniqueInput | ModuleOnClientWhereUniqueInput[]
  }

  export type EnvironmentVariableUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<EnvironmentVariableCreateWithoutClientInput, EnvironmentVariableUncheckedCreateWithoutClientInput> | EnvironmentVariableCreateWithoutClientInput[] | EnvironmentVariableUncheckedCreateWithoutClientInput[]
    connectOrCreate?: EnvironmentVariableCreateOrConnectWithoutClientInput | EnvironmentVariableCreateOrConnectWithoutClientInput[]
    createMany?: EnvironmentVariableCreateManyClientInputEnvelope
    connect?: EnvironmentVariableWhereUniqueInput | EnvironmentVariableWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput> | UserCreateWithoutClientInput[] | UserUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClientInput | UserCreateOrConnectWithoutClientInput[]
    createMany?: UserCreateManyClientInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type LibraryUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<LibraryCreateWithoutClientInput, LibraryUncheckedCreateWithoutClientInput> | LibraryCreateWithoutClientInput[] | LibraryUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LibraryCreateOrConnectWithoutClientInput | LibraryCreateOrConnectWithoutClientInput[]
    createMany?: LibraryCreateManyClientInputEnvelope
    connect?: LibraryWhereUniqueInput | LibraryWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ModuleOnClientUpdateManyWithoutClientNestedInput = {
    create?: XOR<ModuleOnClientCreateWithoutClientInput, ModuleOnClientUncheckedCreateWithoutClientInput> | ModuleOnClientCreateWithoutClientInput[] | ModuleOnClientUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ModuleOnClientCreateOrConnectWithoutClientInput | ModuleOnClientCreateOrConnectWithoutClientInput[]
    upsert?: ModuleOnClientUpsertWithWhereUniqueWithoutClientInput | ModuleOnClientUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ModuleOnClientCreateManyClientInputEnvelope
    set?: ModuleOnClientWhereUniqueInput | ModuleOnClientWhereUniqueInput[]
    disconnect?: ModuleOnClientWhereUniqueInput | ModuleOnClientWhereUniqueInput[]
    delete?: ModuleOnClientWhereUniqueInput | ModuleOnClientWhereUniqueInput[]
    connect?: ModuleOnClientWhereUniqueInput | ModuleOnClientWhereUniqueInput[]
    update?: ModuleOnClientUpdateWithWhereUniqueWithoutClientInput | ModuleOnClientUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ModuleOnClientUpdateManyWithWhereWithoutClientInput | ModuleOnClientUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ModuleOnClientScalarWhereInput | ModuleOnClientScalarWhereInput[]
  }

  export type EnvironmentVariableUpdateManyWithoutClientNestedInput = {
    create?: XOR<EnvironmentVariableCreateWithoutClientInput, EnvironmentVariableUncheckedCreateWithoutClientInput> | EnvironmentVariableCreateWithoutClientInput[] | EnvironmentVariableUncheckedCreateWithoutClientInput[]
    connectOrCreate?: EnvironmentVariableCreateOrConnectWithoutClientInput | EnvironmentVariableCreateOrConnectWithoutClientInput[]
    upsert?: EnvironmentVariableUpsertWithWhereUniqueWithoutClientInput | EnvironmentVariableUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: EnvironmentVariableCreateManyClientInputEnvelope
    set?: EnvironmentVariableWhereUniqueInput | EnvironmentVariableWhereUniqueInput[]
    disconnect?: EnvironmentVariableWhereUniqueInput | EnvironmentVariableWhereUniqueInput[]
    delete?: EnvironmentVariableWhereUniqueInput | EnvironmentVariableWhereUniqueInput[]
    connect?: EnvironmentVariableWhereUniqueInput | EnvironmentVariableWhereUniqueInput[]
    update?: EnvironmentVariableUpdateWithWhereUniqueWithoutClientInput | EnvironmentVariableUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: EnvironmentVariableUpdateManyWithWhereWithoutClientInput | EnvironmentVariableUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: EnvironmentVariableScalarWhereInput | EnvironmentVariableScalarWhereInput[]
  }

  export type UserUpdateManyWithoutClientNestedInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput> | UserCreateWithoutClientInput[] | UserUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClientInput | UserCreateOrConnectWithoutClientInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutClientInput | UserUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: UserCreateManyClientInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutClientInput | UserUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: UserUpdateManyWithWhereWithoutClientInput | UserUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type LibraryUpdateManyWithoutClientNestedInput = {
    create?: XOR<LibraryCreateWithoutClientInput, LibraryUncheckedCreateWithoutClientInput> | LibraryCreateWithoutClientInput[] | LibraryUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LibraryCreateOrConnectWithoutClientInput | LibraryCreateOrConnectWithoutClientInput[]
    upsert?: LibraryUpsertWithWhereUniqueWithoutClientInput | LibraryUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: LibraryCreateManyClientInputEnvelope
    set?: LibraryWhereUniqueInput | LibraryWhereUniqueInput[]
    disconnect?: LibraryWhereUniqueInput | LibraryWhereUniqueInput[]
    delete?: LibraryWhereUniqueInput | LibraryWhereUniqueInput[]
    connect?: LibraryWhereUniqueInput | LibraryWhereUniqueInput[]
    update?: LibraryUpdateWithWhereUniqueWithoutClientInput | LibraryUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: LibraryUpdateManyWithWhereWithoutClientInput | LibraryUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: LibraryScalarWhereInput | LibraryScalarWhereInput[]
  }

  export type ModuleOnClientUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ModuleOnClientCreateWithoutClientInput, ModuleOnClientUncheckedCreateWithoutClientInput> | ModuleOnClientCreateWithoutClientInput[] | ModuleOnClientUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ModuleOnClientCreateOrConnectWithoutClientInput | ModuleOnClientCreateOrConnectWithoutClientInput[]
    upsert?: ModuleOnClientUpsertWithWhereUniqueWithoutClientInput | ModuleOnClientUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ModuleOnClientCreateManyClientInputEnvelope
    set?: ModuleOnClientWhereUniqueInput | ModuleOnClientWhereUniqueInput[]
    disconnect?: ModuleOnClientWhereUniqueInput | ModuleOnClientWhereUniqueInput[]
    delete?: ModuleOnClientWhereUniqueInput | ModuleOnClientWhereUniqueInput[]
    connect?: ModuleOnClientWhereUniqueInput | ModuleOnClientWhereUniqueInput[]
    update?: ModuleOnClientUpdateWithWhereUniqueWithoutClientInput | ModuleOnClientUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ModuleOnClientUpdateManyWithWhereWithoutClientInput | ModuleOnClientUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ModuleOnClientScalarWhereInput | ModuleOnClientScalarWhereInput[]
  }

  export type EnvironmentVariableUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<EnvironmentVariableCreateWithoutClientInput, EnvironmentVariableUncheckedCreateWithoutClientInput> | EnvironmentVariableCreateWithoutClientInput[] | EnvironmentVariableUncheckedCreateWithoutClientInput[]
    connectOrCreate?: EnvironmentVariableCreateOrConnectWithoutClientInput | EnvironmentVariableCreateOrConnectWithoutClientInput[]
    upsert?: EnvironmentVariableUpsertWithWhereUniqueWithoutClientInput | EnvironmentVariableUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: EnvironmentVariableCreateManyClientInputEnvelope
    set?: EnvironmentVariableWhereUniqueInput | EnvironmentVariableWhereUniqueInput[]
    disconnect?: EnvironmentVariableWhereUniqueInput | EnvironmentVariableWhereUniqueInput[]
    delete?: EnvironmentVariableWhereUniqueInput | EnvironmentVariableWhereUniqueInput[]
    connect?: EnvironmentVariableWhereUniqueInput | EnvironmentVariableWhereUniqueInput[]
    update?: EnvironmentVariableUpdateWithWhereUniqueWithoutClientInput | EnvironmentVariableUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: EnvironmentVariableUpdateManyWithWhereWithoutClientInput | EnvironmentVariableUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: EnvironmentVariableScalarWhereInput | EnvironmentVariableScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput> | UserCreateWithoutClientInput[] | UserUncheckedCreateWithoutClientInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClientInput | UserCreateOrConnectWithoutClientInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutClientInput | UserUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: UserCreateManyClientInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutClientInput | UserUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: UserUpdateManyWithWhereWithoutClientInput | UserUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type LibraryUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<LibraryCreateWithoutClientInput, LibraryUncheckedCreateWithoutClientInput> | LibraryCreateWithoutClientInput[] | LibraryUncheckedCreateWithoutClientInput[]
    connectOrCreate?: LibraryCreateOrConnectWithoutClientInput | LibraryCreateOrConnectWithoutClientInput[]
    upsert?: LibraryUpsertWithWhereUniqueWithoutClientInput | LibraryUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: LibraryCreateManyClientInputEnvelope
    set?: LibraryWhereUniqueInput | LibraryWhereUniqueInput[]
    disconnect?: LibraryWhereUniqueInput | LibraryWhereUniqueInput[]
    delete?: LibraryWhereUniqueInput | LibraryWhereUniqueInput[]
    connect?: LibraryWhereUniqueInput | LibraryWhereUniqueInput[]
    update?: LibraryUpdateWithWhereUniqueWithoutClientInput | LibraryUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: LibraryUpdateManyWithWhereWithoutClientInput | LibraryUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: LibraryScalarWhereInput | LibraryScalarWhereInput[]
  }

  export type ModuleOnClientCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleOnClientCreateWithoutModuleInput, ModuleOnClientUncheckedCreateWithoutModuleInput> | ModuleOnClientCreateWithoutModuleInput[] | ModuleOnClientUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleOnClientCreateOrConnectWithoutModuleInput | ModuleOnClientCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleOnClientCreateManyModuleInputEnvelope
    connect?: ModuleOnClientWhereUniqueInput | ModuleOnClientWhereUniqueInput[]
  }

  export type ModuleOnClientUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleOnClientCreateWithoutModuleInput, ModuleOnClientUncheckedCreateWithoutModuleInput> | ModuleOnClientCreateWithoutModuleInput[] | ModuleOnClientUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleOnClientCreateOrConnectWithoutModuleInput | ModuleOnClientCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleOnClientCreateManyModuleInputEnvelope
    connect?: ModuleOnClientWhereUniqueInput | ModuleOnClientWhereUniqueInput[]
  }

  export type ModuleOnClientUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleOnClientCreateWithoutModuleInput, ModuleOnClientUncheckedCreateWithoutModuleInput> | ModuleOnClientCreateWithoutModuleInput[] | ModuleOnClientUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleOnClientCreateOrConnectWithoutModuleInput | ModuleOnClientCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleOnClientUpsertWithWhereUniqueWithoutModuleInput | ModuleOnClientUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleOnClientCreateManyModuleInputEnvelope
    set?: ModuleOnClientWhereUniqueInput | ModuleOnClientWhereUniqueInput[]
    disconnect?: ModuleOnClientWhereUniqueInput | ModuleOnClientWhereUniqueInput[]
    delete?: ModuleOnClientWhereUniqueInput | ModuleOnClientWhereUniqueInput[]
    connect?: ModuleOnClientWhereUniqueInput | ModuleOnClientWhereUniqueInput[]
    update?: ModuleOnClientUpdateWithWhereUniqueWithoutModuleInput | ModuleOnClientUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleOnClientUpdateManyWithWhereWithoutModuleInput | ModuleOnClientUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleOnClientScalarWhereInput | ModuleOnClientScalarWhereInput[]
  }

  export type ModuleOnClientUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleOnClientCreateWithoutModuleInput, ModuleOnClientUncheckedCreateWithoutModuleInput> | ModuleOnClientCreateWithoutModuleInput[] | ModuleOnClientUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleOnClientCreateOrConnectWithoutModuleInput | ModuleOnClientCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleOnClientUpsertWithWhereUniqueWithoutModuleInput | ModuleOnClientUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleOnClientCreateManyModuleInputEnvelope
    set?: ModuleOnClientWhereUniqueInput | ModuleOnClientWhereUniqueInput[]
    disconnect?: ModuleOnClientWhereUniqueInput | ModuleOnClientWhereUniqueInput[]
    delete?: ModuleOnClientWhereUniqueInput | ModuleOnClientWhereUniqueInput[]
    connect?: ModuleOnClientWhereUniqueInput | ModuleOnClientWhereUniqueInput[]
    update?: ModuleOnClientUpdateWithWhereUniqueWithoutModuleInput | ModuleOnClientUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleOnClientUpdateManyWithWhereWithoutModuleInput | ModuleOnClientUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleOnClientScalarWhereInput | ModuleOnClientScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutModulesInput = {
    create?: XOR<ClientCreateWithoutModulesInput, ClientUncheckedCreateWithoutModulesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutModulesInput
    connect?: ClientWhereUniqueInput
  }

  export type ModuleCreateNestedOneWithoutClientsInput = {
    create?: XOR<ModuleCreateWithoutClientsInput, ModuleUncheckedCreateWithoutClientsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutClientsInput
    connect?: ModuleWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ClientUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<ClientCreateWithoutModulesInput, ClientUncheckedCreateWithoutModulesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutModulesInput
    upsert?: ClientUpsertWithoutModulesInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutModulesInput, ClientUpdateWithoutModulesInput>, ClientUncheckedUpdateWithoutModulesInput>
  }

  export type ModuleUpdateOneRequiredWithoutClientsNestedInput = {
    create?: XOR<ModuleCreateWithoutClientsInput, ModuleUncheckedCreateWithoutClientsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutClientsInput
    upsert?: ModuleUpsertWithoutClientsInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutClientsInput, ModuleUpdateWithoutClientsInput>, ModuleUncheckedUpdateWithoutClientsInput>
  }

  export type ClientCreateNestedOneWithoutEnvironmentVariablesInput = {
    create?: XOR<ClientCreateWithoutEnvironmentVariablesInput, ClientUncheckedCreateWithoutEnvironmentVariablesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutEnvironmentVariablesInput
    connect?: ClientWhereUniqueInput
  }

  export type EnumEnvironmentFieldUpdateOperationsInput = {
    set?: Environment
  }

  export type ClientUpdateOneRequiredWithoutEnvironmentVariablesNestedInput = {
    create?: XOR<ClientCreateWithoutEnvironmentVariablesInput, ClientUncheckedCreateWithoutEnvironmentVariablesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutEnvironmentVariablesInput
    upsert?: ClientUpsertWithoutEnvironmentVariablesInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutEnvironmentVariablesInput, ClientUpdateWithoutEnvironmentVariablesInput>, ClientUncheckedUpdateWithoutEnvironmentVariablesInput>
  }

  export type ClientCreateNestedOneWithoutUsersInput = {
    create?: XOR<ClientCreateWithoutUsersInput, ClientUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUsersInput
    connect?: ClientWhereUniqueInput
  }

  export type ApiKeyCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type MCPConfigurationCreateNestedManyWithoutUserInput = {
    create?: XOR<MCPConfigurationCreateWithoutUserInput, MCPConfigurationUncheckedCreateWithoutUserInput> | MCPConfigurationCreateWithoutUserInput[] | MCPConfigurationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MCPConfigurationCreateOrConnectWithoutUserInput | MCPConfigurationCreateOrConnectWithoutUserInput[]
    createMany?: MCPConfigurationCreateManyUserInputEnvelope
    connect?: MCPConfigurationWhereUniqueInput | MCPConfigurationWhereUniqueInput[]
  }

  export type UsageLogCreateNestedManyWithoutUserInput = {
    create?: XOR<UsageLogCreateWithoutUserInput, UsageLogUncheckedCreateWithoutUserInput> | UsageLogCreateWithoutUserInput[] | UsageLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageLogCreateOrConnectWithoutUserInput | UsageLogCreateOrConnectWithoutUserInput[]
    createMany?: UsageLogCreateManyUserInputEnvelope
    connect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
  }

  export type OAuthTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<OAuthTokenCreateWithoutUserInput, OAuthTokenUncheckedCreateWithoutUserInput> | OAuthTokenCreateWithoutUserInput[] | OAuthTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthTokenCreateOrConnectWithoutUserInput | OAuthTokenCreateOrConnectWithoutUserInput[]
    createMany?: OAuthTokenCreateManyUserInputEnvelope
    connect?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type MessageReactionCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageReactionCreateWithoutUserInput, MessageReactionUncheckedCreateWithoutUserInput> | MessageReactionCreateWithoutUserInput[] | MessageReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageReactionCreateOrConnectWithoutUserInput | MessageReactionCreateOrConnectWithoutUserInput[]
    createMany?: MessageReactionCreateManyUserInputEnvelope
    connect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
  }

  export type UserPreferencesCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    connect?: UserPreferencesWhereUniqueInput
  }

  export type ThemeCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ThemeCreateWithoutCreatorInput, ThemeUncheckedCreateWithoutCreatorInput> | ThemeCreateWithoutCreatorInput[] | ThemeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ThemeCreateOrConnectWithoutCreatorInput | ThemeCreateOrConnectWithoutCreatorInput[]
    createMany?: ThemeCreateManyCreatorInputEnvelope
    connect?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
  }

  export type PersonalizationAnalyticsCreateNestedManyWithoutUserInput = {
    create?: XOR<PersonalizationAnalyticsCreateWithoutUserInput, PersonalizationAnalyticsUncheckedCreateWithoutUserInput> | PersonalizationAnalyticsCreateWithoutUserInput[] | PersonalizationAnalyticsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PersonalizationAnalyticsCreateOrConnectWithoutUserInput | PersonalizationAnalyticsCreateOrConnectWithoutUserInput[]
    createMany?: PersonalizationAnalyticsCreateManyUserInputEnvelope
    connect?: PersonalizationAnalyticsWhereUniqueInput | PersonalizationAnalyticsWhereUniqueInput[]
  }

  export type ConversationShareCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ConversationShareCreateWithoutCreatorInput, ConversationShareUncheckedCreateWithoutCreatorInput> | ConversationShareCreateWithoutCreatorInput[] | ConversationShareUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ConversationShareCreateOrConnectWithoutCreatorInput | ConversationShareCreateOrConnectWithoutCreatorInput[]
    createMany?: ConversationShareCreateManyCreatorInputEnvelope
    connect?: ConversationShareWhereUniqueInput | ConversationShareWhereUniqueInput[]
  }

  export type ApiKeyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type MCPConfigurationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MCPConfigurationCreateWithoutUserInput, MCPConfigurationUncheckedCreateWithoutUserInput> | MCPConfigurationCreateWithoutUserInput[] | MCPConfigurationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MCPConfigurationCreateOrConnectWithoutUserInput | MCPConfigurationCreateOrConnectWithoutUserInput[]
    createMany?: MCPConfigurationCreateManyUserInputEnvelope
    connect?: MCPConfigurationWhereUniqueInput | MCPConfigurationWhereUniqueInput[]
  }

  export type UsageLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UsageLogCreateWithoutUserInput, UsageLogUncheckedCreateWithoutUserInput> | UsageLogCreateWithoutUserInput[] | UsageLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageLogCreateOrConnectWithoutUserInput | UsageLogCreateOrConnectWithoutUserInput[]
    createMany?: UsageLogCreateManyUserInputEnvelope
    connect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
  }

  export type OAuthTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OAuthTokenCreateWithoutUserInput, OAuthTokenUncheckedCreateWithoutUserInput> | OAuthTokenCreateWithoutUserInput[] | OAuthTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthTokenCreateOrConnectWithoutUserInput | OAuthTokenCreateOrConnectWithoutUserInput[]
    createMany?: OAuthTokenCreateManyUserInputEnvelope
    connect?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type MessageReactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageReactionCreateWithoutUserInput, MessageReactionUncheckedCreateWithoutUserInput> | MessageReactionCreateWithoutUserInput[] | MessageReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageReactionCreateOrConnectWithoutUserInput | MessageReactionCreateOrConnectWithoutUserInput[]
    createMany?: MessageReactionCreateManyUserInputEnvelope
    connect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
  }

  export type UserPreferencesUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    connect?: UserPreferencesWhereUniqueInput
  }

  export type ThemeUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ThemeCreateWithoutCreatorInput, ThemeUncheckedCreateWithoutCreatorInput> | ThemeCreateWithoutCreatorInput[] | ThemeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ThemeCreateOrConnectWithoutCreatorInput | ThemeCreateOrConnectWithoutCreatorInput[]
    createMany?: ThemeCreateManyCreatorInputEnvelope
    connect?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
  }

  export type PersonalizationAnalyticsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PersonalizationAnalyticsCreateWithoutUserInput, PersonalizationAnalyticsUncheckedCreateWithoutUserInput> | PersonalizationAnalyticsCreateWithoutUserInput[] | PersonalizationAnalyticsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PersonalizationAnalyticsCreateOrConnectWithoutUserInput | PersonalizationAnalyticsCreateOrConnectWithoutUserInput[]
    createMany?: PersonalizationAnalyticsCreateManyUserInputEnvelope
    connect?: PersonalizationAnalyticsWhereUniqueInput | PersonalizationAnalyticsWhereUniqueInput[]
  }

  export type ConversationShareUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ConversationShareCreateWithoutCreatorInput, ConversationShareUncheckedCreateWithoutCreatorInput> | ConversationShareCreateWithoutCreatorInput[] | ConversationShareUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ConversationShareCreateOrConnectWithoutCreatorInput | ConversationShareCreateOrConnectWithoutCreatorInput[]
    createMany?: ConversationShareCreateManyCreatorInputEnvelope
    connect?: ConversationShareWhereUniqueInput | ConversationShareWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: Role
  }

  export type ClientUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<ClientCreateWithoutUsersInput, ClientUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutUsersInput
    upsert?: ClientUpsertWithoutUsersInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutUsersInput, ClientUpdateWithoutUsersInput>, ClientUncheckedUpdateWithoutUsersInput>
  }

  export type ApiKeyUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutUserInput | ApiKeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutUserInput | ApiKeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutUserInput | ApiKeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type MCPConfigurationUpdateManyWithoutUserNestedInput = {
    create?: XOR<MCPConfigurationCreateWithoutUserInput, MCPConfigurationUncheckedCreateWithoutUserInput> | MCPConfigurationCreateWithoutUserInput[] | MCPConfigurationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MCPConfigurationCreateOrConnectWithoutUserInput | MCPConfigurationCreateOrConnectWithoutUserInput[]
    upsert?: MCPConfigurationUpsertWithWhereUniqueWithoutUserInput | MCPConfigurationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MCPConfigurationCreateManyUserInputEnvelope
    set?: MCPConfigurationWhereUniqueInput | MCPConfigurationWhereUniqueInput[]
    disconnect?: MCPConfigurationWhereUniqueInput | MCPConfigurationWhereUniqueInput[]
    delete?: MCPConfigurationWhereUniqueInput | MCPConfigurationWhereUniqueInput[]
    connect?: MCPConfigurationWhereUniqueInput | MCPConfigurationWhereUniqueInput[]
    update?: MCPConfigurationUpdateWithWhereUniqueWithoutUserInput | MCPConfigurationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MCPConfigurationUpdateManyWithWhereWithoutUserInput | MCPConfigurationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MCPConfigurationScalarWhereInput | MCPConfigurationScalarWhereInput[]
  }

  export type UsageLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsageLogCreateWithoutUserInput, UsageLogUncheckedCreateWithoutUserInput> | UsageLogCreateWithoutUserInput[] | UsageLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageLogCreateOrConnectWithoutUserInput | UsageLogCreateOrConnectWithoutUserInput[]
    upsert?: UsageLogUpsertWithWhereUniqueWithoutUserInput | UsageLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsageLogCreateManyUserInputEnvelope
    set?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    disconnect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    delete?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    connect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    update?: UsageLogUpdateWithWhereUniqueWithoutUserInput | UsageLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsageLogUpdateManyWithWhereWithoutUserInput | UsageLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsageLogScalarWhereInput | UsageLogScalarWhereInput[]
  }

  export type OAuthTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<OAuthTokenCreateWithoutUserInput, OAuthTokenUncheckedCreateWithoutUserInput> | OAuthTokenCreateWithoutUserInput[] | OAuthTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthTokenCreateOrConnectWithoutUserInput | OAuthTokenCreateOrConnectWithoutUserInput[]
    upsert?: OAuthTokenUpsertWithWhereUniqueWithoutUserInput | OAuthTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OAuthTokenCreateManyUserInputEnvelope
    set?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    disconnect?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    delete?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    connect?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    update?: OAuthTokenUpdateWithWhereUniqueWithoutUserInput | OAuthTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OAuthTokenUpdateManyWithWhereWithoutUserInput | OAuthTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OAuthTokenScalarWhereInput | OAuthTokenScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUserInput | ConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUserInput | ConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUserInput | ConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type MessageReactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageReactionCreateWithoutUserInput, MessageReactionUncheckedCreateWithoutUserInput> | MessageReactionCreateWithoutUserInput[] | MessageReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageReactionCreateOrConnectWithoutUserInput | MessageReactionCreateOrConnectWithoutUserInput[]
    upsert?: MessageReactionUpsertWithWhereUniqueWithoutUserInput | MessageReactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageReactionCreateManyUserInputEnvelope
    set?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    disconnect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    delete?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    connect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    update?: MessageReactionUpdateWithWhereUniqueWithoutUserInput | MessageReactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageReactionUpdateManyWithWhereWithoutUserInput | MessageReactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageReactionScalarWhereInput | MessageReactionScalarWhereInput[]
  }

  export type UserPreferencesUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    upsert?: UserPreferencesUpsertWithoutUserInput
    disconnect?: UserPreferencesWhereInput | boolean
    delete?: UserPreferencesWhereInput | boolean
    connect?: UserPreferencesWhereUniqueInput
    update?: XOR<XOR<UserPreferencesUpdateToOneWithWhereWithoutUserInput, UserPreferencesUpdateWithoutUserInput>, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type ThemeUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ThemeCreateWithoutCreatorInput, ThemeUncheckedCreateWithoutCreatorInput> | ThemeCreateWithoutCreatorInput[] | ThemeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ThemeCreateOrConnectWithoutCreatorInput | ThemeCreateOrConnectWithoutCreatorInput[]
    upsert?: ThemeUpsertWithWhereUniqueWithoutCreatorInput | ThemeUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ThemeCreateManyCreatorInputEnvelope
    set?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
    disconnect?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
    delete?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
    connect?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
    update?: ThemeUpdateWithWhereUniqueWithoutCreatorInput | ThemeUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ThemeUpdateManyWithWhereWithoutCreatorInput | ThemeUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ThemeScalarWhereInput | ThemeScalarWhereInput[]
  }

  export type PersonalizationAnalyticsUpdateManyWithoutUserNestedInput = {
    create?: XOR<PersonalizationAnalyticsCreateWithoutUserInput, PersonalizationAnalyticsUncheckedCreateWithoutUserInput> | PersonalizationAnalyticsCreateWithoutUserInput[] | PersonalizationAnalyticsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PersonalizationAnalyticsCreateOrConnectWithoutUserInput | PersonalizationAnalyticsCreateOrConnectWithoutUserInput[]
    upsert?: PersonalizationAnalyticsUpsertWithWhereUniqueWithoutUserInput | PersonalizationAnalyticsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PersonalizationAnalyticsCreateManyUserInputEnvelope
    set?: PersonalizationAnalyticsWhereUniqueInput | PersonalizationAnalyticsWhereUniqueInput[]
    disconnect?: PersonalizationAnalyticsWhereUniqueInput | PersonalizationAnalyticsWhereUniqueInput[]
    delete?: PersonalizationAnalyticsWhereUniqueInput | PersonalizationAnalyticsWhereUniqueInput[]
    connect?: PersonalizationAnalyticsWhereUniqueInput | PersonalizationAnalyticsWhereUniqueInput[]
    update?: PersonalizationAnalyticsUpdateWithWhereUniqueWithoutUserInput | PersonalizationAnalyticsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PersonalizationAnalyticsUpdateManyWithWhereWithoutUserInput | PersonalizationAnalyticsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PersonalizationAnalyticsScalarWhereInput | PersonalizationAnalyticsScalarWhereInput[]
  }

  export type ConversationShareUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ConversationShareCreateWithoutCreatorInput, ConversationShareUncheckedCreateWithoutCreatorInput> | ConversationShareCreateWithoutCreatorInput[] | ConversationShareUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ConversationShareCreateOrConnectWithoutCreatorInput | ConversationShareCreateOrConnectWithoutCreatorInput[]
    upsert?: ConversationShareUpsertWithWhereUniqueWithoutCreatorInput | ConversationShareUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ConversationShareCreateManyCreatorInputEnvelope
    set?: ConversationShareWhereUniqueInput | ConversationShareWhereUniqueInput[]
    disconnect?: ConversationShareWhereUniqueInput | ConversationShareWhereUniqueInput[]
    delete?: ConversationShareWhereUniqueInput | ConversationShareWhereUniqueInput[]
    connect?: ConversationShareWhereUniqueInput | ConversationShareWhereUniqueInput[]
    update?: ConversationShareUpdateWithWhereUniqueWithoutCreatorInput | ConversationShareUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ConversationShareUpdateManyWithWhereWithoutCreatorInput | ConversationShareUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ConversationShareScalarWhereInput | ConversationShareScalarWhereInput[]
  }

  export type ApiKeyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutUserInput | ApiKeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutUserInput | ApiKeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutUserInput | ApiKeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type MCPConfigurationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MCPConfigurationCreateWithoutUserInput, MCPConfigurationUncheckedCreateWithoutUserInput> | MCPConfigurationCreateWithoutUserInput[] | MCPConfigurationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MCPConfigurationCreateOrConnectWithoutUserInput | MCPConfigurationCreateOrConnectWithoutUserInput[]
    upsert?: MCPConfigurationUpsertWithWhereUniqueWithoutUserInput | MCPConfigurationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MCPConfigurationCreateManyUserInputEnvelope
    set?: MCPConfigurationWhereUniqueInput | MCPConfigurationWhereUniqueInput[]
    disconnect?: MCPConfigurationWhereUniqueInput | MCPConfigurationWhereUniqueInput[]
    delete?: MCPConfigurationWhereUniqueInput | MCPConfigurationWhereUniqueInput[]
    connect?: MCPConfigurationWhereUniqueInput | MCPConfigurationWhereUniqueInput[]
    update?: MCPConfigurationUpdateWithWhereUniqueWithoutUserInput | MCPConfigurationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MCPConfigurationUpdateManyWithWhereWithoutUserInput | MCPConfigurationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MCPConfigurationScalarWhereInput | MCPConfigurationScalarWhereInput[]
  }

  export type UsageLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsageLogCreateWithoutUserInput, UsageLogUncheckedCreateWithoutUserInput> | UsageLogCreateWithoutUserInput[] | UsageLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageLogCreateOrConnectWithoutUserInput | UsageLogCreateOrConnectWithoutUserInput[]
    upsert?: UsageLogUpsertWithWhereUniqueWithoutUserInput | UsageLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsageLogCreateManyUserInputEnvelope
    set?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    disconnect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    delete?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    connect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    update?: UsageLogUpdateWithWhereUniqueWithoutUserInput | UsageLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsageLogUpdateManyWithWhereWithoutUserInput | UsageLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsageLogScalarWhereInput | UsageLogScalarWhereInput[]
  }

  export type OAuthTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OAuthTokenCreateWithoutUserInput, OAuthTokenUncheckedCreateWithoutUserInput> | OAuthTokenCreateWithoutUserInput[] | OAuthTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OAuthTokenCreateOrConnectWithoutUserInput | OAuthTokenCreateOrConnectWithoutUserInput[]
    upsert?: OAuthTokenUpsertWithWhereUniqueWithoutUserInput | OAuthTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OAuthTokenCreateManyUserInputEnvelope
    set?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    disconnect?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    delete?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    connect?: OAuthTokenWhereUniqueInput | OAuthTokenWhereUniqueInput[]
    update?: OAuthTokenUpdateWithWhereUniqueWithoutUserInput | OAuthTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OAuthTokenUpdateManyWithWhereWithoutUserInput | OAuthTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OAuthTokenScalarWhereInput | OAuthTokenScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUserInput | ConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUserInput | ConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUserInput | ConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type MessageReactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageReactionCreateWithoutUserInput, MessageReactionUncheckedCreateWithoutUserInput> | MessageReactionCreateWithoutUserInput[] | MessageReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageReactionCreateOrConnectWithoutUserInput | MessageReactionCreateOrConnectWithoutUserInput[]
    upsert?: MessageReactionUpsertWithWhereUniqueWithoutUserInput | MessageReactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageReactionCreateManyUserInputEnvelope
    set?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    disconnect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    delete?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    connect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    update?: MessageReactionUpdateWithWhereUniqueWithoutUserInput | MessageReactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageReactionUpdateManyWithWhereWithoutUserInput | MessageReactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageReactionScalarWhereInput | MessageReactionScalarWhereInput[]
  }

  export type UserPreferencesUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    upsert?: UserPreferencesUpsertWithoutUserInput
    disconnect?: UserPreferencesWhereInput | boolean
    delete?: UserPreferencesWhereInput | boolean
    connect?: UserPreferencesWhereUniqueInput
    update?: XOR<XOR<UserPreferencesUpdateToOneWithWhereWithoutUserInput, UserPreferencesUpdateWithoutUserInput>, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type ThemeUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ThemeCreateWithoutCreatorInput, ThemeUncheckedCreateWithoutCreatorInput> | ThemeCreateWithoutCreatorInput[] | ThemeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ThemeCreateOrConnectWithoutCreatorInput | ThemeCreateOrConnectWithoutCreatorInput[]
    upsert?: ThemeUpsertWithWhereUniqueWithoutCreatorInput | ThemeUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ThemeCreateManyCreatorInputEnvelope
    set?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
    disconnect?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
    delete?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
    connect?: ThemeWhereUniqueInput | ThemeWhereUniqueInput[]
    update?: ThemeUpdateWithWhereUniqueWithoutCreatorInput | ThemeUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ThemeUpdateManyWithWhereWithoutCreatorInput | ThemeUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ThemeScalarWhereInput | ThemeScalarWhereInput[]
  }

  export type PersonalizationAnalyticsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PersonalizationAnalyticsCreateWithoutUserInput, PersonalizationAnalyticsUncheckedCreateWithoutUserInput> | PersonalizationAnalyticsCreateWithoutUserInput[] | PersonalizationAnalyticsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PersonalizationAnalyticsCreateOrConnectWithoutUserInput | PersonalizationAnalyticsCreateOrConnectWithoutUserInput[]
    upsert?: PersonalizationAnalyticsUpsertWithWhereUniqueWithoutUserInput | PersonalizationAnalyticsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PersonalizationAnalyticsCreateManyUserInputEnvelope
    set?: PersonalizationAnalyticsWhereUniqueInput | PersonalizationAnalyticsWhereUniqueInput[]
    disconnect?: PersonalizationAnalyticsWhereUniqueInput | PersonalizationAnalyticsWhereUniqueInput[]
    delete?: PersonalizationAnalyticsWhereUniqueInput | PersonalizationAnalyticsWhereUniqueInput[]
    connect?: PersonalizationAnalyticsWhereUniqueInput | PersonalizationAnalyticsWhereUniqueInput[]
    update?: PersonalizationAnalyticsUpdateWithWhereUniqueWithoutUserInput | PersonalizationAnalyticsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PersonalizationAnalyticsUpdateManyWithWhereWithoutUserInput | PersonalizationAnalyticsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PersonalizationAnalyticsScalarWhereInput | PersonalizationAnalyticsScalarWhereInput[]
  }

  export type ConversationShareUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ConversationShareCreateWithoutCreatorInput, ConversationShareUncheckedCreateWithoutCreatorInput> | ConversationShareCreateWithoutCreatorInput[] | ConversationShareUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ConversationShareCreateOrConnectWithoutCreatorInput | ConversationShareCreateOrConnectWithoutCreatorInput[]
    upsert?: ConversationShareUpsertWithWhereUniqueWithoutCreatorInput | ConversationShareUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ConversationShareCreateManyCreatorInputEnvelope
    set?: ConversationShareWhereUniqueInput | ConversationShareWhereUniqueInput[]
    disconnect?: ConversationShareWhereUniqueInput | ConversationShareWhereUniqueInput[]
    delete?: ConversationShareWhereUniqueInput | ConversationShareWhereUniqueInput[]
    connect?: ConversationShareWhereUniqueInput | ConversationShareWhereUniqueInput[]
    update?: ConversationShareUpdateWithWhereUniqueWithoutCreatorInput | ConversationShareUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ConversationShareUpdateManyWithWhereWithoutCreatorInput | ConversationShareUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ConversationShareScalarWhereInput | ConversationShareScalarWhereInput[]
  }

  export type LibraryCreatetagsInput = {
    set: string[]
  }

  export type ClientCreateNestedOneWithoutLibrariesInput = {
    create?: XOR<ClientCreateWithoutLibrariesInput, ClientUncheckedCreateWithoutLibrariesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutLibrariesInput
    connect?: ClientWhereUniqueInput
  }

  export type LibraryVersionCreateNestedManyWithoutLibraryInput = {
    create?: XOR<LibraryVersionCreateWithoutLibraryInput, LibraryVersionUncheckedCreateWithoutLibraryInput> | LibraryVersionCreateWithoutLibraryInput[] | LibraryVersionUncheckedCreateWithoutLibraryInput[]
    connectOrCreate?: LibraryVersionCreateOrConnectWithoutLibraryInput | LibraryVersionCreateOrConnectWithoutLibraryInput[]
    createMany?: LibraryVersionCreateManyLibraryInputEnvelope
    connect?: LibraryVersionWhereUniqueInput | LibraryVersionWhereUniqueInput[]
  }

  export type LibraryAliasCreateNestedManyWithoutLibraryInput = {
    create?: XOR<LibraryAliasCreateWithoutLibraryInput, LibraryAliasUncheckedCreateWithoutLibraryInput> | LibraryAliasCreateWithoutLibraryInput[] | LibraryAliasUncheckedCreateWithoutLibraryInput[]
    connectOrCreate?: LibraryAliasCreateOrConnectWithoutLibraryInput | LibraryAliasCreateOrConnectWithoutLibraryInput[]
    createMany?: LibraryAliasCreateManyLibraryInputEnvelope
    connect?: LibraryAliasWhereUniqueInput | LibraryAliasWhereUniqueInput[]
  }

  export type DocumentationChunkCreateNestedManyWithoutLibraryInput = {
    create?: XOR<DocumentationChunkCreateWithoutLibraryInput, DocumentationChunkUncheckedCreateWithoutLibraryInput> | DocumentationChunkCreateWithoutLibraryInput[] | DocumentationChunkUncheckedCreateWithoutLibraryInput[]
    connectOrCreate?: DocumentationChunkCreateOrConnectWithoutLibraryInput | DocumentationChunkCreateOrConnectWithoutLibraryInput[]
    createMany?: DocumentationChunkCreateManyLibraryInputEnvelope
    connect?: DocumentationChunkWhereUniqueInput | DocumentationChunkWhereUniqueInput[]
  }

  export type UsageLogCreateNestedManyWithoutLibraryInput = {
    create?: XOR<UsageLogCreateWithoutLibraryInput, UsageLogUncheckedCreateWithoutLibraryInput> | UsageLogCreateWithoutLibraryInput[] | UsageLogUncheckedCreateWithoutLibraryInput[]
    connectOrCreate?: UsageLogCreateOrConnectWithoutLibraryInput | UsageLogCreateOrConnectWithoutLibraryInput[]
    createMany?: UsageLogCreateManyLibraryInputEnvelope
    connect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
  }

  export type LibraryVersionUncheckedCreateNestedManyWithoutLibraryInput = {
    create?: XOR<LibraryVersionCreateWithoutLibraryInput, LibraryVersionUncheckedCreateWithoutLibraryInput> | LibraryVersionCreateWithoutLibraryInput[] | LibraryVersionUncheckedCreateWithoutLibraryInput[]
    connectOrCreate?: LibraryVersionCreateOrConnectWithoutLibraryInput | LibraryVersionCreateOrConnectWithoutLibraryInput[]
    createMany?: LibraryVersionCreateManyLibraryInputEnvelope
    connect?: LibraryVersionWhereUniqueInput | LibraryVersionWhereUniqueInput[]
  }

  export type LibraryAliasUncheckedCreateNestedManyWithoutLibraryInput = {
    create?: XOR<LibraryAliasCreateWithoutLibraryInput, LibraryAliasUncheckedCreateWithoutLibraryInput> | LibraryAliasCreateWithoutLibraryInput[] | LibraryAliasUncheckedCreateWithoutLibraryInput[]
    connectOrCreate?: LibraryAliasCreateOrConnectWithoutLibraryInput | LibraryAliasCreateOrConnectWithoutLibraryInput[]
    createMany?: LibraryAliasCreateManyLibraryInputEnvelope
    connect?: LibraryAliasWhereUniqueInput | LibraryAliasWhereUniqueInput[]
  }

  export type DocumentationChunkUncheckedCreateNestedManyWithoutLibraryInput = {
    create?: XOR<DocumentationChunkCreateWithoutLibraryInput, DocumentationChunkUncheckedCreateWithoutLibraryInput> | DocumentationChunkCreateWithoutLibraryInput[] | DocumentationChunkUncheckedCreateWithoutLibraryInput[]
    connectOrCreate?: DocumentationChunkCreateOrConnectWithoutLibraryInput | DocumentationChunkCreateOrConnectWithoutLibraryInput[]
    createMany?: DocumentationChunkCreateManyLibraryInputEnvelope
    connect?: DocumentationChunkWhereUniqueInput | DocumentationChunkWhereUniqueInput[]
  }

  export type UsageLogUncheckedCreateNestedManyWithoutLibraryInput = {
    create?: XOR<UsageLogCreateWithoutLibraryInput, UsageLogUncheckedCreateWithoutLibraryInput> | UsageLogCreateWithoutLibraryInput[] | UsageLogUncheckedCreateWithoutLibraryInput[]
    connectOrCreate?: UsageLogCreateOrConnectWithoutLibraryInput | UsageLogCreateOrConnectWithoutLibraryInput[]
    createMany?: UsageLogCreateManyLibraryInputEnvelope
    connect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LibraryUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ClientUpdateOneRequiredWithoutLibrariesNestedInput = {
    create?: XOR<ClientCreateWithoutLibrariesInput, ClientUncheckedCreateWithoutLibrariesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutLibrariesInput
    upsert?: ClientUpsertWithoutLibrariesInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutLibrariesInput, ClientUpdateWithoutLibrariesInput>, ClientUncheckedUpdateWithoutLibrariesInput>
  }

  export type LibraryVersionUpdateManyWithoutLibraryNestedInput = {
    create?: XOR<LibraryVersionCreateWithoutLibraryInput, LibraryVersionUncheckedCreateWithoutLibraryInput> | LibraryVersionCreateWithoutLibraryInput[] | LibraryVersionUncheckedCreateWithoutLibraryInput[]
    connectOrCreate?: LibraryVersionCreateOrConnectWithoutLibraryInput | LibraryVersionCreateOrConnectWithoutLibraryInput[]
    upsert?: LibraryVersionUpsertWithWhereUniqueWithoutLibraryInput | LibraryVersionUpsertWithWhereUniqueWithoutLibraryInput[]
    createMany?: LibraryVersionCreateManyLibraryInputEnvelope
    set?: LibraryVersionWhereUniqueInput | LibraryVersionWhereUniqueInput[]
    disconnect?: LibraryVersionWhereUniqueInput | LibraryVersionWhereUniqueInput[]
    delete?: LibraryVersionWhereUniqueInput | LibraryVersionWhereUniqueInput[]
    connect?: LibraryVersionWhereUniqueInput | LibraryVersionWhereUniqueInput[]
    update?: LibraryVersionUpdateWithWhereUniqueWithoutLibraryInput | LibraryVersionUpdateWithWhereUniqueWithoutLibraryInput[]
    updateMany?: LibraryVersionUpdateManyWithWhereWithoutLibraryInput | LibraryVersionUpdateManyWithWhereWithoutLibraryInput[]
    deleteMany?: LibraryVersionScalarWhereInput | LibraryVersionScalarWhereInput[]
  }

  export type LibraryAliasUpdateManyWithoutLibraryNestedInput = {
    create?: XOR<LibraryAliasCreateWithoutLibraryInput, LibraryAliasUncheckedCreateWithoutLibraryInput> | LibraryAliasCreateWithoutLibraryInput[] | LibraryAliasUncheckedCreateWithoutLibraryInput[]
    connectOrCreate?: LibraryAliasCreateOrConnectWithoutLibraryInput | LibraryAliasCreateOrConnectWithoutLibraryInput[]
    upsert?: LibraryAliasUpsertWithWhereUniqueWithoutLibraryInput | LibraryAliasUpsertWithWhereUniqueWithoutLibraryInput[]
    createMany?: LibraryAliasCreateManyLibraryInputEnvelope
    set?: LibraryAliasWhereUniqueInput | LibraryAliasWhereUniqueInput[]
    disconnect?: LibraryAliasWhereUniqueInput | LibraryAliasWhereUniqueInput[]
    delete?: LibraryAliasWhereUniqueInput | LibraryAliasWhereUniqueInput[]
    connect?: LibraryAliasWhereUniqueInput | LibraryAliasWhereUniqueInput[]
    update?: LibraryAliasUpdateWithWhereUniqueWithoutLibraryInput | LibraryAliasUpdateWithWhereUniqueWithoutLibraryInput[]
    updateMany?: LibraryAliasUpdateManyWithWhereWithoutLibraryInput | LibraryAliasUpdateManyWithWhereWithoutLibraryInput[]
    deleteMany?: LibraryAliasScalarWhereInput | LibraryAliasScalarWhereInput[]
  }

  export type DocumentationChunkUpdateManyWithoutLibraryNestedInput = {
    create?: XOR<DocumentationChunkCreateWithoutLibraryInput, DocumentationChunkUncheckedCreateWithoutLibraryInput> | DocumentationChunkCreateWithoutLibraryInput[] | DocumentationChunkUncheckedCreateWithoutLibraryInput[]
    connectOrCreate?: DocumentationChunkCreateOrConnectWithoutLibraryInput | DocumentationChunkCreateOrConnectWithoutLibraryInput[]
    upsert?: DocumentationChunkUpsertWithWhereUniqueWithoutLibraryInput | DocumentationChunkUpsertWithWhereUniqueWithoutLibraryInput[]
    createMany?: DocumentationChunkCreateManyLibraryInputEnvelope
    set?: DocumentationChunkWhereUniqueInput | DocumentationChunkWhereUniqueInput[]
    disconnect?: DocumentationChunkWhereUniqueInput | DocumentationChunkWhereUniqueInput[]
    delete?: DocumentationChunkWhereUniqueInput | DocumentationChunkWhereUniqueInput[]
    connect?: DocumentationChunkWhereUniqueInput | DocumentationChunkWhereUniqueInput[]
    update?: DocumentationChunkUpdateWithWhereUniqueWithoutLibraryInput | DocumentationChunkUpdateWithWhereUniqueWithoutLibraryInput[]
    updateMany?: DocumentationChunkUpdateManyWithWhereWithoutLibraryInput | DocumentationChunkUpdateManyWithWhereWithoutLibraryInput[]
    deleteMany?: DocumentationChunkScalarWhereInput | DocumentationChunkScalarWhereInput[]
  }

  export type UsageLogUpdateManyWithoutLibraryNestedInput = {
    create?: XOR<UsageLogCreateWithoutLibraryInput, UsageLogUncheckedCreateWithoutLibraryInput> | UsageLogCreateWithoutLibraryInput[] | UsageLogUncheckedCreateWithoutLibraryInput[]
    connectOrCreate?: UsageLogCreateOrConnectWithoutLibraryInput | UsageLogCreateOrConnectWithoutLibraryInput[]
    upsert?: UsageLogUpsertWithWhereUniqueWithoutLibraryInput | UsageLogUpsertWithWhereUniqueWithoutLibraryInput[]
    createMany?: UsageLogCreateManyLibraryInputEnvelope
    set?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    disconnect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    delete?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    connect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    update?: UsageLogUpdateWithWhereUniqueWithoutLibraryInput | UsageLogUpdateWithWhereUniqueWithoutLibraryInput[]
    updateMany?: UsageLogUpdateManyWithWhereWithoutLibraryInput | UsageLogUpdateManyWithWhereWithoutLibraryInput[]
    deleteMany?: UsageLogScalarWhereInput | UsageLogScalarWhereInput[]
  }

  export type LibraryVersionUncheckedUpdateManyWithoutLibraryNestedInput = {
    create?: XOR<LibraryVersionCreateWithoutLibraryInput, LibraryVersionUncheckedCreateWithoutLibraryInput> | LibraryVersionCreateWithoutLibraryInput[] | LibraryVersionUncheckedCreateWithoutLibraryInput[]
    connectOrCreate?: LibraryVersionCreateOrConnectWithoutLibraryInput | LibraryVersionCreateOrConnectWithoutLibraryInput[]
    upsert?: LibraryVersionUpsertWithWhereUniqueWithoutLibraryInput | LibraryVersionUpsertWithWhereUniqueWithoutLibraryInput[]
    createMany?: LibraryVersionCreateManyLibraryInputEnvelope
    set?: LibraryVersionWhereUniqueInput | LibraryVersionWhereUniqueInput[]
    disconnect?: LibraryVersionWhereUniqueInput | LibraryVersionWhereUniqueInput[]
    delete?: LibraryVersionWhereUniqueInput | LibraryVersionWhereUniqueInput[]
    connect?: LibraryVersionWhereUniqueInput | LibraryVersionWhereUniqueInput[]
    update?: LibraryVersionUpdateWithWhereUniqueWithoutLibraryInput | LibraryVersionUpdateWithWhereUniqueWithoutLibraryInput[]
    updateMany?: LibraryVersionUpdateManyWithWhereWithoutLibraryInput | LibraryVersionUpdateManyWithWhereWithoutLibraryInput[]
    deleteMany?: LibraryVersionScalarWhereInput | LibraryVersionScalarWhereInput[]
  }

  export type LibraryAliasUncheckedUpdateManyWithoutLibraryNestedInput = {
    create?: XOR<LibraryAliasCreateWithoutLibraryInput, LibraryAliasUncheckedCreateWithoutLibraryInput> | LibraryAliasCreateWithoutLibraryInput[] | LibraryAliasUncheckedCreateWithoutLibraryInput[]
    connectOrCreate?: LibraryAliasCreateOrConnectWithoutLibraryInput | LibraryAliasCreateOrConnectWithoutLibraryInput[]
    upsert?: LibraryAliasUpsertWithWhereUniqueWithoutLibraryInput | LibraryAliasUpsertWithWhereUniqueWithoutLibraryInput[]
    createMany?: LibraryAliasCreateManyLibraryInputEnvelope
    set?: LibraryAliasWhereUniqueInput | LibraryAliasWhereUniqueInput[]
    disconnect?: LibraryAliasWhereUniqueInput | LibraryAliasWhereUniqueInput[]
    delete?: LibraryAliasWhereUniqueInput | LibraryAliasWhereUniqueInput[]
    connect?: LibraryAliasWhereUniqueInput | LibraryAliasWhereUniqueInput[]
    update?: LibraryAliasUpdateWithWhereUniqueWithoutLibraryInput | LibraryAliasUpdateWithWhereUniqueWithoutLibraryInput[]
    updateMany?: LibraryAliasUpdateManyWithWhereWithoutLibraryInput | LibraryAliasUpdateManyWithWhereWithoutLibraryInput[]
    deleteMany?: LibraryAliasScalarWhereInput | LibraryAliasScalarWhereInput[]
  }

  export type DocumentationChunkUncheckedUpdateManyWithoutLibraryNestedInput = {
    create?: XOR<DocumentationChunkCreateWithoutLibraryInput, DocumentationChunkUncheckedCreateWithoutLibraryInput> | DocumentationChunkCreateWithoutLibraryInput[] | DocumentationChunkUncheckedCreateWithoutLibraryInput[]
    connectOrCreate?: DocumentationChunkCreateOrConnectWithoutLibraryInput | DocumentationChunkCreateOrConnectWithoutLibraryInput[]
    upsert?: DocumentationChunkUpsertWithWhereUniqueWithoutLibraryInput | DocumentationChunkUpsertWithWhereUniqueWithoutLibraryInput[]
    createMany?: DocumentationChunkCreateManyLibraryInputEnvelope
    set?: DocumentationChunkWhereUniqueInput | DocumentationChunkWhereUniqueInput[]
    disconnect?: DocumentationChunkWhereUniqueInput | DocumentationChunkWhereUniqueInput[]
    delete?: DocumentationChunkWhereUniqueInput | DocumentationChunkWhereUniqueInput[]
    connect?: DocumentationChunkWhereUniqueInput | DocumentationChunkWhereUniqueInput[]
    update?: DocumentationChunkUpdateWithWhereUniqueWithoutLibraryInput | DocumentationChunkUpdateWithWhereUniqueWithoutLibraryInput[]
    updateMany?: DocumentationChunkUpdateManyWithWhereWithoutLibraryInput | DocumentationChunkUpdateManyWithWhereWithoutLibraryInput[]
    deleteMany?: DocumentationChunkScalarWhereInput | DocumentationChunkScalarWhereInput[]
  }

  export type UsageLogUncheckedUpdateManyWithoutLibraryNestedInput = {
    create?: XOR<UsageLogCreateWithoutLibraryInput, UsageLogUncheckedCreateWithoutLibraryInput> | UsageLogCreateWithoutLibraryInput[] | UsageLogUncheckedCreateWithoutLibraryInput[]
    connectOrCreate?: UsageLogCreateOrConnectWithoutLibraryInput | UsageLogCreateOrConnectWithoutLibraryInput[]
    upsert?: UsageLogUpsertWithWhereUniqueWithoutLibraryInput | UsageLogUpsertWithWhereUniqueWithoutLibraryInput[]
    createMany?: UsageLogCreateManyLibraryInputEnvelope
    set?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    disconnect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    delete?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    connect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    update?: UsageLogUpdateWithWhereUniqueWithoutLibraryInput | UsageLogUpdateWithWhereUniqueWithoutLibraryInput[]
    updateMany?: UsageLogUpdateManyWithWhereWithoutLibraryInput | UsageLogUpdateManyWithWhereWithoutLibraryInput[]
    deleteMany?: UsageLogScalarWhereInput | UsageLogScalarWhereInput[]
  }

  export type LibraryCreateNestedOneWithoutVersionsInput = {
    create?: XOR<LibraryCreateWithoutVersionsInput, LibraryUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: LibraryCreateOrConnectWithoutVersionsInput
    connect?: LibraryWhereUniqueInput
  }

  export type DocumentationChunkCreateNestedManyWithoutLibraryVersionInput = {
    create?: XOR<DocumentationChunkCreateWithoutLibraryVersionInput, DocumentationChunkUncheckedCreateWithoutLibraryVersionInput> | DocumentationChunkCreateWithoutLibraryVersionInput[] | DocumentationChunkUncheckedCreateWithoutLibraryVersionInput[]
    connectOrCreate?: DocumentationChunkCreateOrConnectWithoutLibraryVersionInput | DocumentationChunkCreateOrConnectWithoutLibraryVersionInput[]
    createMany?: DocumentationChunkCreateManyLibraryVersionInputEnvelope
    connect?: DocumentationChunkWhereUniqueInput | DocumentationChunkWhereUniqueInput[]
  }

  export type DocumentationChunkUncheckedCreateNestedManyWithoutLibraryVersionInput = {
    create?: XOR<DocumentationChunkCreateWithoutLibraryVersionInput, DocumentationChunkUncheckedCreateWithoutLibraryVersionInput> | DocumentationChunkCreateWithoutLibraryVersionInput[] | DocumentationChunkUncheckedCreateWithoutLibraryVersionInput[]
    connectOrCreate?: DocumentationChunkCreateOrConnectWithoutLibraryVersionInput | DocumentationChunkCreateOrConnectWithoutLibraryVersionInput[]
    createMany?: DocumentationChunkCreateManyLibraryVersionInputEnvelope
    connect?: DocumentationChunkWhereUniqueInput | DocumentationChunkWhereUniqueInput[]
  }

  export type LibraryUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<LibraryCreateWithoutVersionsInput, LibraryUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: LibraryCreateOrConnectWithoutVersionsInput
    upsert?: LibraryUpsertWithoutVersionsInput
    connect?: LibraryWhereUniqueInput
    update?: XOR<XOR<LibraryUpdateToOneWithWhereWithoutVersionsInput, LibraryUpdateWithoutVersionsInput>, LibraryUncheckedUpdateWithoutVersionsInput>
  }

  export type DocumentationChunkUpdateManyWithoutLibraryVersionNestedInput = {
    create?: XOR<DocumentationChunkCreateWithoutLibraryVersionInput, DocumentationChunkUncheckedCreateWithoutLibraryVersionInput> | DocumentationChunkCreateWithoutLibraryVersionInput[] | DocumentationChunkUncheckedCreateWithoutLibraryVersionInput[]
    connectOrCreate?: DocumentationChunkCreateOrConnectWithoutLibraryVersionInput | DocumentationChunkCreateOrConnectWithoutLibraryVersionInput[]
    upsert?: DocumentationChunkUpsertWithWhereUniqueWithoutLibraryVersionInput | DocumentationChunkUpsertWithWhereUniqueWithoutLibraryVersionInput[]
    createMany?: DocumentationChunkCreateManyLibraryVersionInputEnvelope
    set?: DocumentationChunkWhereUniqueInput | DocumentationChunkWhereUniqueInput[]
    disconnect?: DocumentationChunkWhereUniqueInput | DocumentationChunkWhereUniqueInput[]
    delete?: DocumentationChunkWhereUniqueInput | DocumentationChunkWhereUniqueInput[]
    connect?: DocumentationChunkWhereUniqueInput | DocumentationChunkWhereUniqueInput[]
    update?: DocumentationChunkUpdateWithWhereUniqueWithoutLibraryVersionInput | DocumentationChunkUpdateWithWhereUniqueWithoutLibraryVersionInput[]
    updateMany?: DocumentationChunkUpdateManyWithWhereWithoutLibraryVersionInput | DocumentationChunkUpdateManyWithWhereWithoutLibraryVersionInput[]
    deleteMany?: DocumentationChunkScalarWhereInput | DocumentationChunkScalarWhereInput[]
  }

  export type DocumentationChunkUncheckedUpdateManyWithoutLibraryVersionNestedInput = {
    create?: XOR<DocumentationChunkCreateWithoutLibraryVersionInput, DocumentationChunkUncheckedCreateWithoutLibraryVersionInput> | DocumentationChunkCreateWithoutLibraryVersionInput[] | DocumentationChunkUncheckedCreateWithoutLibraryVersionInput[]
    connectOrCreate?: DocumentationChunkCreateOrConnectWithoutLibraryVersionInput | DocumentationChunkCreateOrConnectWithoutLibraryVersionInput[]
    upsert?: DocumentationChunkUpsertWithWhereUniqueWithoutLibraryVersionInput | DocumentationChunkUpsertWithWhereUniqueWithoutLibraryVersionInput[]
    createMany?: DocumentationChunkCreateManyLibraryVersionInputEnvelope
    set?: DocumentationChunkWhereUniqueInput | DocumentationChunkWhereUniqueInput[]
    disconnect?: DocumentationChunkWhereUniqueInput | DocumentationChunkWhereUniqueInput[]
    delete?: DocumentationChunkWhereUniqueInput | DocumentationChunkWhereUniqueInput[]
    connect?: DocumentationChunkWhereUniqueInput | DocumentationChunkWhereUniqueInput[]
    update?: DocumentationChunkUpdateWithWhereUniqueWithoutLibraryVersionInput | DocumentationChunkUpdateWithWhereUniqueWithoutLibraryVersionInput[]
    updateMany?: DocumentationChunkUpdateManyWithWhereWithoutLibraryVersionInput | DocumentationChunkUpdateManyWithWhereWithoutLibraryVersionInput[]
    deleteMany?: DocumentationChunkScalarWhereInput | DocumentationChunkScalarWhereInput[]
  }

  export type LibraryCreateNestedOneWithoutAliasesInput = {
    create?: XOR<LibraryCreateWithoutAliasesInput, LibraryUncheckedCreateWithoutAliasesInput>
    connectOrCreate?: LibraryCreateOrConnectWithoutAliasesInput
    connect?: LibraryWhereUniqueInput
  }

  export type LibraryUpdateOneRequiredWithoutAliasesNestedInput = {
    create?: XOR<LibraryCreateWithoutAliasesInput, LibraryUncheckedCreateWithoutAliasesInput>
    connectOrCreate?: LibraryCreateOrConnectWithoutAliasesInput
    upsert?: LibraryUpsertWithoutAliasesInput
    connect?: LibraryWhereUniqueInput
    update?: XOR<XOR<LibraryUpdateToOneWithWhereWithoutAliasesInput, LibraryUpdateWithoutAliasesInput>, LibraryUncheckedUpdateWithoutAliasesInput>
  }

  export type LibraryVersionCreateNestedOneWithoutDocumentationChunksInput = {
    create?: XOR<LibraryVersionCreateWithoutDocumentationChunksInput, LibraryVersionUncheckedCreateWithoutDocumentationChunksInput>
    connectOrCreate?: LibraryVersionCreateOrConnectWithoutDocumentationChunksInput
    connect?: LibraryVersionWhereUniqueInput
  }

  export type LibraryCreateNestedOneWithoutDocumentationChunksInput = {
    create?: XOR<LibraryCreateWithoutDocumentationChunksInput, LibraryUncheckedCreateWithoutDocumentationChunksInput>
    connectOrCreate?: LibraryCreateOrConnectWithoutDocumentationChunksInput
    connect?: LibraryWhereUniqueInput
  }

  export type LibraryVersionUpdateOneRequiredWithoutDocumentationChunksNestedInput = {
    create?: XOR<LibraryVersionCreateWithoutDocumentationChunksInput, LibraryVersionUncheckedCreateWithoutDocumentationChunksInput>
    connectOrCreate?: LibraryVersionCreateOrConnectWithoutDocumentationChunksInput
    upsert?: LibraryVersionUpsertWithoutDocumentationChunksInput
    connect?: LibraryVersionWhereUniqueInput
    update?: XOR<XOR<LibraryVersionUpdateToOneWithWhereWithoutDocumentationChunksInput, LibraryVersionUpdateWithoutDocumentationChunksInput>, LibraryVersionUncheckedUpdateWithoutDocumentationChunksInput>
  }

  export type LibraryUpdateOneWithoutDocumentationChunksNestedInput = {
    create?: XOR<LibraryCreateWithoutDocumentationChunksInput, LibraryUncheckedCreateWithoutDocumentationChunksInput>
    connectOrCreate?: LibraryCreateOrConnectWithoutDocumentationChunksInput
    upsert?: LibraryUpsertWithoutDocumentationChunksInput
    disconnect?: LibraryWhereInput | boolean
    delete?: LibraryWhereInput | boolean
    connect?: LibraryWhereUniqueInput
    update?: XOR<XOR<LibraryUpdateToOneWithWhereWithoutDocumentationChunksInput, LibraryUpdateWithoutDocumentationChunksInput>, LibraryUncheckedUpdateWithoutDocumentationChunksInput>
  }

  export type UserCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput
    connect?: UserWhereUniqueInput
  }

  export type UsageLogCreateNestedManyWithoutApiKeyInput = {
    create?: XOR<UsageLogCreateWithoutApiKeyInput, UsageLogUncheckedCreateWithoutApiKeyInput> | UsageLogCreateWithoutApiKeyInput[] | UsageLogUncheckedCreateWithoutApiKeyInput[]
    connectOrCreate?: UsageLogCreateOrConnectWithoutApiKeyInput | UsageLogCreateOrConnectWithoutApiKeyInput[]
    createMany?: UsageLogCreateManyApiKeyInputEnvelope
    connect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
  }

  export type UsageLogUncheckedCreateNestedManyWithoutApiKeyInput = {
    create?: XOR<UsageLogCreateWithoutApiKeyInput, UsageLogUncheckedCreateWithoutApiKeyInput> | UsageLogCreateWithoutApiKeyInput[] | UsageLogUncheckedCreateWithoutApiKeyInput[]
    connectOrCreate?: UsageLogCreateOrConnectWithoutApiKeyInput | UsageLogCreateOrConnectWithoutApiKeyInput[]
    createMany?: UsageLogCreateManyApiKeyInputEnvelope
    connect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutApiKeysNestedInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput
    upsert?: UserUpsertWithoutApiKeysInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApiKeysInput, UserUpdateWithoutApiKeysInput>, UserUncheckedUpdateWithoutApiKeysInput>
  }

  export type UsageLogUpdateManyWithoutApiKeyNestedInput = {
    create?: XOR<UsageLogCreateWithoutApiKeyInput, UsageLogUncheckedCreateWithoutApiKeyInput> | UsageLogCreateWithoutApiKeyInput[] | UsageLogUncheckedCreateWithoutApiKeyInput[]
    connectOrCreate?: UsageLogCreateOrConnectWithoutApiKeyInput | UsageLogCreateOrConnectWithoutApiKeyInput[]
    upsert?: UsageLogUpsertWithWhereUniqueWithoutApiKeyInput | UsageLogUpsertWithWhereUniqueWithoutApiKeyInput[]
    createMany?: UsageLogCreateManyApiKeyInputEnvelope
    set?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    disconnect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    delete?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    connect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    update?: UsageLogUpdateWithWhereUniqueWithoutApiKeyInput | UsageLogUpdateWithWhereUniqueWithoutApiKeyInput[]
    updateMany?: UsageLogUpdateManyWithWhereWithoutApiKeyInput | UsageLogUpdateManyWithWhereWithoutApiKeyInput[]
    deleteMany?: UsageLogScalarWhereInput | UsageLogScalarWhereInput[]
  }

  export type UsageLogUncheckedUpdateManyWithoutApiKeyNestedInput = {
    create?: XOR<UsageLogCreateWithoutApiKeyInput, UsageLogUncheckedCreateWithoutApiKeyInput> | UsageLogCreateWithoutApiKeyInput[] | UsageLogUncheckedCreateWithoutApiKeyInput[]
    connectOrCreate?: UsageLogCreateOrConnectWithoutApiKeyInput | UsageLogCreateOrConnectWithoutApiKeyInput[]
    upsert?: UsageLogUpsertWithWhereUniqueWithoutApiKeyInput | UsageLogUpsertWithWhereUniqueWithoutApiKeyInput[]
    createMany?: UsageLogCreateManyApiKeyInputEnvelope
    set?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    disconnect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    delete?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    connect?: UsageLogWhereUniqueInput | UsageLogWhereUniqueInput[]
    update?: UsageLogUpdateWithWhereUniqueWithoutApiKeyInput | UsageLogUpdateWithWhereUniqueWithoutApiKeyInput[]
    updateMany?: UsageLogUpdateManyWithWhereWithoutApiKeyInput | UsageLogUpdateManyWithWhereWithoutApiKeyInput[]
    deleteMany?: UsageLogScalarWhereInput | UsageLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUsageLogsInput = {
    create?: XOR<UserCreateWithoutUsageLogsInput, UserUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsageLogsInput
    connect?: UserWhereUniqueInput
  }

  export type ApiKeyCreateNestedOneWithoutUsageLogsInput = {
    create?: XOR<ApiKeyCreateWithoutUsageLogsInput, ApiKeyUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUsageLogsInput
    connect?: ApiKeyWhereUniqueInput
  }

  export type LibraryCreateNestedOneWithoutUsageLogsInput = {
    create?: XOR<LibraryCreateWithoutUsageLogsInput, LibraryUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: LibraryCreateOrConnectWithoutUsageLogsInput
    connect?: LibraryWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutUsageLogsNestedInput = {
    create?: XOR<UserCreateWithoutUsageLogsInput, UserUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsageLogsInput
    upsert?: UserUpsertWithoutUsageLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUsageLogsInput, UserUpdateWithoutUsageLogsInput>, UserUncheckedUpdateWithoutUsageLogsInput>
  }

  export type ApiKeyUpdateOneWithoutUsageLogsNestedInput = {
    create?: XOR<ApiKeyCreateWithoutUsageLogsInput, ApiKeyUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUsageLogsInput
    upsert?: ApiKeyUpsertWithoutUsageLogsInput
    disconnect?: ApiKeyWhereInput | boolean
    delete?: ApiKeyWhereInput | boolean
    connect?: ApiKeyWhereUniqueInput
    update?: XOR<XOR<ApiKeyUpdateToOneWithWhereWithoutUsageLogsInput, ApiKeyUpdateWithoutUsageLogsInput>, ApiKeyUncheckedUpdateWithoutUsageLogsInput>
  }

  export type LibraryUpdateOneWithoutUsageLogsNestedInput = {
    create?: XOR<LibraryCreateWithoutUsageLogsInput, LibraryUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: LibraryCreateOrConnectWithoutUsageLogsInput
    upsert?: LibraryUpsertWithoutUsageLogsInput
    disconnect?: LibraryWhereInput | boolean
    delete?: LibraryWhereInput | boolean
    connect?: LibraryWhereUniqueInput
    update?: XOR<XOR<LibraryUpdateToOneWithWhereWithoutUsageLogsInput, LibraryUpdateWithoutUsageLogsInput>, LibraryUncheckedUpdateWithoutUsageLogsInput>
  }

  export type UserCreateNestedOneWithoutMcpConfigurationsInput = {
    create?: XOR<UserCreateWithoutMcpConfigurationsInput, UserUncheckedCreateWithoutMcpConfigurationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMcpConfigurationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumConfigStatusFieldUpdateOperationsInput = {
    set?: ConfigStatus
  }

  export type UserUpdateOneRequiredWithoutMcpConfigurationsNestedInput = {
    create?: XOR<UserCreateWithoutMcpConfigurationsInput, UserUncheckedCreateWithoutMcpConfigurationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMcpConfigurationsInput
    upsert?: UserUpsertWithoutMcpConfigurationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMcpConfigurationsInput, UserUpdateWithoutMcpConfigurationsInput>, UserUncheckedUpdateWithoutMcpConfigurationsInput>
  }

  export type UserCreateNestedOneWithoutOauthTokensInput = {
    create?: XOR<UserCreateWithoutOauthTokensInput, UserUncheckedCreateWithoutOauthTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutOauthTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutOauthTokensNestedInput = {
    create?: XOR<UserCreateWithoutOauthTokensInput, UserUncheckedCreateWithoutOauthTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutOauthTokensInput
    upsert?: UserUpsertWithoutOauthTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOauthTokensInput, UserUpdateWithoutOauthTokensInput>, UserUncheckedUpdateWithoutOauthTokensInput>
  }

  export type OAuthClientCreateredirectUrisInput = {
    set: string[]
  }

  export type OAuthClientCreateallowedScopesInput = {
    set: string[]
  }

  export type OAuthClientCreategrantTypesInput = {
    set: string[]
  }

  export type OAuthAuthorizationCodeCreateNestedManyWithoutClientInput = {
    create?: XOR<OAuthAuthorizationCodeCreateWithoutClientInput, OAuthAuthorizationCodeUncheckedCreateWithoutClientInput> | OAuthAuthorizationCodeCreateWithoutClientInput[] | OAuthAuthorizationCodeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OAuthAuthorizationCodeCreateOrConnectWithoutClientInput | OAuthAuthorizationCodeCreateOrConnectWithoutClientInput[]
    createMany?: OAuthAuthorizationCodeCreateManyClientInputEnvelope
    connect?: OAuthAuthorizationCodeWhereUniqueInput | OAuthAuthorizationCodeWhereUniqueInput[]
  }

  export type OAuthAccessTokenCreateNestedManyWithoutClientInput = {
    create?: XOR<OAuthAccessTokenCreateWithoutClientInput, OAuthAccessTokenUncheckedCreateWithoutClientInput> | OAuthAccessTokenCreateWithoutClientInput[] | OAuthAccessTokenUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OAuthAccessTokenCreateOrConnectWithoutClientInput | OAuthAccessTokenCreateOrConnectWithoutClientInput[]
    createMany?: OAuthAccessTokenCreateManyClientInputEnvelope
    connect?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
  }

  export type OAuthRefreshTokenCreateNestedManyWithoutClientInput = {
    create?: XOR<OAuthRefreshTokenCreateWithoutClientInput, OAuthRefreshTokenUncheckedCreateWithoutClientInput> | OAuthRefreshTokenCreateWithoutClientInput[] | OAuthRefreshTokenUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OAuthRefreshTokenCreateOrConnectWithoutClientInput | OAuthRefreshTokenCreateOrConnectWithoutClientInput[]
    createMany?: OAuthRefreshTokenCreateManyClientInputEnvelope
    connect?: OAuthRefreshTokenWhereUniqueInput | OAuthRefreshTokenWhereUniqueInput[]
  }

  export type OAuthAuthorizationCodeUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<OAuthAuthorizationCodeCreateWithoutClientInput, OAuthAuthorizationCodeUncheckedCreateWithoutClientInput> | OAuthAuthorizationCodeCreateWithoutClientInput[] | OAuthAuthorizationCodeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OAuthAuthorizationCodeCreateOrConnectWithoutClientInput | OAuthAuthorizationCodeCreateOrConnectWithoutClientInput[]
    createMany?: OAuthAuthorizationCodeCreateManyClientInputEnvelope
    connect?: OAuthAuthorizationCodeWhereUniqueInput | OAuthAuthorizationCodeWhereUniqueInput[]
  }

  export type OAuthAccessTokenUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<OAuthAccessTokenCreateWithoutClientInput, OAuthAccessTokenUncheckedCreateWithoutClientInput> | OAuthAccessTokenCreateWithoutClientInput[] | OAuthAccessTokenUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OAuthAccessTokenCreateOrConnectWithoutClientInput | OAuthAccessTokenCreateOrConnectWithoutClientInput[]
    createMany?: OAuthAccessTokenCreateManyClientInputEnvelope
    connect?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
  }

  export type OAuthRefreshTokenUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<OAuthRefreshTokenCreateWithoutClientInput, OAuthRefreshTokenUncheckedCreateWithoutClientInput> | OAuthRefreshTokenCreateWithoutClientInput[] | OAuthRefreshTokenUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OAuthRefreshTokenCreateOrConnectWithoutClientInput | OAuthRefreshTokenCreateOrConnectWithoutClientInput[]
    createMany?: OAuthRefreshTokenCreateManyClientInputEnvelope
    connect?: OAuthRefreshTokenWhereUniqueInput | OAuthRefreshTokenWhereUniqueInput[]
  }

  export type OAuthClientUpdateredirectUrisInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OAuthClientUpdateallowedScopesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OAuthClientUpdategrantTypesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OAuthAuthorizationCodeUpdateManyWithoutClientNestedInput = {
    create?: XOR<OAuthAuthorizationCodeCreateWithoutClientInput, OAuthAuthorizationCodeUncheckedCreateWithoutClientInput> | OAuthAuthorizationCodeCreateWithoutClientInput[] | OAuthAuthorizationCodeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OAuthAuthorizationCodeCreateOrConnectWithoutClientInput | OAuthAuthorizationCodeCreateOrConnectWithoutClientInput[]
    upsert?: OAuthAuthorizationCodeUpsertWithWhereUniqueWithoutClientInput | OAuthAuthorizationCodeUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: OAuthAuthorizationCodeCreateManyClientInputEnvelope
    set?: OAuthAuthorizationCodeWhereUniqueInput | OAuthAuthorizationCodeWhereUniqueInput[]
    disconnect?: OAuthAuthorizationCodeWhereUniqueInput | OAuthAuthorizationCodeWhereUniqueInput[]
    delete?: OAuthAuthorizationCodeWhereUniqueInput | OAuthAuthorizationCodeWhereUniqueInput[]
    connect?: OAuthAuthorizationCodeWhereUniqueInput | OAuthAuthorizationCodeWhereUniqueInput[]
    update?: OAuthAuthorizationCodeUpdateWithWhereUniqueWithoutClientInput | OAuthAuthorizationCodeUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: OAuthAuthorizationCodeUpdateManyWithWhereWithoutClientInput | OAuthAuthorizationCodeUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: OAuthAuthorizationCodeScalarWhereInput | OAuthAuthorizationCodeScalarWhereInput[]
  }

  export type OAuthAccessTokenUpdateManyWithoutClientNestedInput = {
    create?: XOR<OAuthAccessTokenCreateWithoutClientInput, OAuthAccessTokenUncheckedCreateWithoutClientInput> | OAuthAccessTokenCreateWithoutClientInput[] | OAuthAccessTokenUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OAuthAccessTokenCreateOrConnectWithoutClientInput | OAuthAccessTokenCreateOrConnectWithoutClientInput[]
    upsert?: OAuthAccessTokenUpsertWithWhereUniqueWithoutClientInput | OAuthAccessTokenUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: OAuthAccessTokenCreateManyClientInputEnvelope
    set?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
    disconnect?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
    delete?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
    connect?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
    update?: OAuthAccessTokenUpdateWithWhereUniqueWithoutClientInput | OAuthAccessTokenUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: OAuthAccessTokenUpdateManyWithWhereWithoutClientInput | OAuthAccessTokenUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: OAuthAccessTokenScalarWhereInput | OAuthAccessTokenScalarWhereInput[]
  }

  export type OAuthRefreshTokenUpdateManyWithoutClientNestedInput = {
    create?: XOR<OAuthRefreshTokenCreateWithoutClientInput, OAuthRefreshTokenUncheckedCreateWithoutClientInput> | OAuthRefreshTokenCreateWithoutClientInput[] | OAuthRefreshTokenUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OAuthRefreshTokenCreateOrConnectWithoutClientInput | OAuthRefreshTokenCreateOrConnectWithoutClientInput[]
    upsert?: OAuthRefreshTokenUpsertWithWhereUniqueWithoutClientInput | OAuthRefreshTokenUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: OAuthRefreshTokenCreateManyClientInputEnvelope
    set?: OAuthRefreshTokenWhereUniqueInput | OAuthRefreshTokenWhereUniqueInput[]
    disconnect?: OAuthRefreshTokenWhereUniqueInput | OAuthRefreshTokenWhereUniqueInput[]
    delete?: OAuthRefreshTokenWhereUniqueInput | OAuthRefreshTokenWhereUniqueInput[]
    connect?: OAuthRefreshTokenWhereUniqueInput | OAuthRefreshTokenWhereUniqueInput[]
    update?: OAuthRefreshTokenUpdateWithWhereUniqueWithoutClientInput | OAuthRefreshTokenUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: OAuthRefreshTokenUpdateManyWithWhereWithoutClientInput | OAuthRefreshTokenUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: OAuthRefreshTokenScalarWhereInput | OAuthRefreshTokenScalarWhereInput[]
  }

  export type OAuthAuthorizationCodeUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<OAuthAuthorizationCodeCreateWithoutClientInput, OAuthAuthorizationCodeUncheckedCreateWithoutClientInput> | OAuthAuthorizationCodeCreateWithoutClientInput[] | OAuthAuthorizationCodeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OAuthAuthorizationCodeCreateOrConnectWithoutClientInput | OAuthAuthorizationCodeCreateOrConnectWithoutClientInput[]
    upsert?: OAuthAuthorizationCodeUpsertWithWhereUniqueWithoutClientInput | OAuthAuthorizationCodeUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: OAuthAuthorizationCodeCreateManyClientInputEnvelope
    set?: OAuthAuthorizationCodeWhereUniqueInput | OAuthAuthorizationCodeWhereUniqueInput[]
    disconnect?: OAuthAuthorizationCodeWhereUniqueInput | OAuthAuthorizationCodeWhereUniqueInput[]
    delete?: OAuthAuthorizationCodeWhereUniqueInput | OAuthAuthorizationCodeWhereUniqueInput[]
    connect?: OAuthAuthorizationCodeWhereUniqueInput | OAuthAuthorizationCodeWhereUniqueInput[]
    update?: OAuthAuthorizationCodeUpdateWithWhereUniqueWithoutClientInput | OAuthAuthorizationCodeUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: OAuthAuthorizationCodeUpdateManyWithWhereWithoutClientInput | OAuthAuthorizationCodeUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: OAuthAuthorizationCodeScalarWhereInput | OAuthAuthorizationCodeScalarWhereInput[]
  }

  export type OAuthAccessTokenUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<OAuthAccessTokenCreateWithoutClientInput, OAuthAccessTokenUncheckedCreateWithoutClientInput> | OAuthAccessTokenCreateWithoutClientInput[] | OAuthAccessTokenUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OAuthAccessTokenCreateOrConnectWithoutClientInput | OAuthAccessTokenCreateOrConnectWithoutClientInput[]
    upsert?: OAuthAccessTokenUpsertWithWhereUniqueWithoutClientInput | OAuthAccessTokenUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: OAuthAccessTokenCreateManyClientInputEnvelope
    set?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
    disconnect?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
    delete?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
    connect?: OAuthAccessTokenWhereUniqueInput | OAuthAccessTokenWhereUniqueInput[]
    update?: OAuthAccessTokenUpdateWithWhereUniqueWithoutClientInput | OAuthAccessTokenUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: OAuthAccessTokenUpdateManyWithWhereWithoutClientInput | OAuthAccessTokenUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: OAuthAccessTokenScalarWhereInput | OAuthAccessTokenScalarWhereInput[]
  }

  export type OAuthRefreshTokenUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<OAuthRefreshTokenCreateWithoutClientInput, OAuthRefreshTokenUncheckedCreateWithoutClientInput> | OAuthRefreshTokenCreateWithoutClientInput[] | OAuthRefreshTokenUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OAuthRefreshTokenCreateOrConnectWithoutClientInput | OAuthRefreshTokenCreateOrConnectWithoutClientInput[]
    upsert?: OAuthRefreshTokenUpsertWithWhereUniqueWithoutClientInput | OAuthRefreshTokenUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: OAuthRefreshTokenCreateManyClientInputEnvelope
    set?: OAuthRefreshTokenWhereUniqueInput | OAuthRefreshTokenWhereUniqueInput[]
    disconnect?: OAuthRefreshTokenWhereUniqueInput | OAuthRefreshTokenWhereUniqueInput[]
    delete?: OAuthRefreshTokenWhereUniqueInput | OAuthRefreshTokenWhereUniqueInput[]
    connect?: OAuthRefreshTokenWhereUniqueInput | OAuthRefreshTokenWhereUniqueInput[]
    update?: OAuthRefreshTokenUpdateWithWhereUniqueWithoutClientInput | OAuthRefreshTokenUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: OAuthRefreshTokenUpdateManyWithWhereWithoutClientInput | OAuthRefreshTokenUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: OAuthRefreshTokenScalarWhereInput | OAuthRefreshTokenScalarWhereInput[]
  }

  export type OAuthAuthorizationCodeCreatescopesInput = {
    set: string[]
  }

  export type OAuthClientCreateNestedOneWithoutAuthorizationCodesInput = {
    create?: XOR<OAuthClientCreateWithoutAuthorizationCodesInput, OAuthClientUncheckedCreateWithoutAuthorizationCodesInput>
    connectOrCreate?: OAuthClientCreateOrConnectWithoutAuthorizationCodesInput
    connect?: OAuthClientWhereUniqueInput
  }

  export type OAuthAuthorizationCodeUpdatescopesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OAuthClientUpdateOneRequiredWithoutAuthorizationCodesNestedInput = {
    create?: XOR<OAuthClientCreateWithoutAuthorizationCodesInput, OAuthClientUncheckedCreateWithoutAuthorizationCodesInput>
    connectOrCreate?: OAuthClientCreateOrConnectWithoutAuthorizationCodesInput
    upsert?: OAuthClientUpsertWithoutAuthorizationCodesInput
    connect?: OAuthClientWhereUniqueInput
    update?: XOR<XOR<OAuthClientUpdateToOneWithWhereWithoutAuthorizationCodesInput, OAuthClientUpdateWithoutAuthorizationCodesInput>, OAuthClientUncheckedUpdateWithoutAuthorizationCodesInput>
  }

  export type OAuthAccessTokenCreatescopesInput = {
    set: string[]
  }

  export type OAuthClientCreateNestedOneWithoutAccessTokensInput = {
    create?: XOR<OAuthClientCreateWithoutAccessTokensInput, OAuthClientUncheckedCreateWithoutAccessTokensInput>
    connectOrCreate?: OAuthClientCreateOrConnectWithoutAccessTokensInput
    connect?: OAuthClientWhereUniqueInput
  }

  export type OAuthRefreshTokenCreateNestedManyWithoutAccessTokenInput = {
    create?: XOR<OAuthRefreshTokenCreateWithoutAccessTokenInput, OAuthRefreshTokenUncheckedCreateWithoutAccessTokenInput> | OAuthRefreshTokenCreateWithoutAccessTokenInput[] | OAuthRefreshTokenUncheckedCreateWithoutAccessTokenInput[]
    connectOrCreate?: OAuthRefreshTokenCreateOrConnectWithoutAccessTokenInput | OAuthRefreshTokenCreateOrConnectWithoutAccessTokenInput[]
    createMany?: OAuthRefreshTokenCreateManyAccessTokenInputEnvelope
    connect?: OAuthRefreshTokenWhereUniqueInput | OAuthRefreshTokenWhereUniqueInput[]
  }

  export type OAuthRefreshTokenUncheckedCreateNestedManyWithoutAccessTokenInput = {
    create?: XOR<OAuthRefreshTokenCreateWithoutAccessTokenInput, OAuthRefreshTokenUncheckedCreateWithoutAccessTokenInput> | OAuthRefreshTokenCreateWithoutAccessTokenInput[] | OAuthRefreshTokenUncheckedCreateWithoutAccessTokenInput[]
    connectOrCreate?: OAuthRefreshTokenCreateOrConnectWithoutAccessTokenInput | OAuthRefreshTokenCreateOrConnectWithoutAccessTokenInput[]
    createMany?: OAuthRefreshTokenCreateManyAccessTokenInputEnvelope
    connect?: OAuthRefreshTokenWhereUniqueInput | OAuthRefreshTokenWhereUniqueInput[]
  }

  export type OAuthAccessTokenUpdatescopesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OAuthClientUpdateOneRequiredWithoutAccessTokensNestedInput = {
    create?: XOR<OAuthClientCreateWithoutAccessTokensInput, OAuthClientUncheckedCreateWithoutAccessTokensInput>
    connectOrCreate?: OAuthClientCreateOrConnectWithoutAccessTokensInput
    upsert?: OAuthClientUpsertWithoutAccessTokensInput
    connect?: OAuthClientWhereUniqueInput
    update?: XOR<XOR<OAuthClientUpdateToOneWithWhereWithoutAccessTokensInput, OAuthClientUpdateWithoutAccessTokensInput>, OAuthClientUncheckedUpdateWithoutAccessTokensInput>
  }

  export type OAuthRefreshTokenUpdateManyWithoutAccessTokenNestedInput = {
    create?: XOR<OAuthRefreshTokenCreateWithoutAccessTokenInput, OAuthRefreshTokenUncheckedCreateWithoutAccessTokenInput> | OAuthRefreshTokenCreateWithoutAccessTokenInput[] | OAuthRefreshTokenUncheckedCreateWithoutAccessTokenInput[]
    connectOrCreate?: OAuthRefreshTokenCreateOrConnectWithoutAccessTokenInput | OAuthRefreshTokenCreateOrConnectWithoutAccessTokenInput[]
    upsert?: OAuthRefreshTokenUpsertWithWhereUniqueWithoutAccessTokenInput | OAuthRefreshTokenUpsertWithWhereUniqueWithoutAccessTokenInput[]
    createMany?: OAuthRefreshTokenCreateManyAccessTokenInputEnvelope
    set?: OAuthRefreshTokenWhereUniqueInput | OAuthRefreshTokenWhereUniqueInput[]
    disconnect?: OAuthRefreshTokenWhereUniqueInput | OAuthRefreshTokenWhereUniqueInput[]
    delete?: OAuthRefreshTokenWhereUniqueInput | OAuthRefreshTokenWhereUniqueInput[]
    connect?: OAuthRefreshTokenWhereUniqueInput | OAuthRefreshTokenWhereUniqueInput[]
    update?: OAuthRefreshTokenUpdateWithWhereUniqueWithoutAccessTokenInput | OAuthRefreshTokenUpdateWithWhereUniqueWithoutAccessTokenInput[]
    updateMany?: OAuthRefreshTokenUpdateManyWithWhereWithoutAccessTokenInput | OAuthRefreshTokenUpdateManyWithWhereWithoutAccessTokenInput[]
    deleteMany?: OAuthRefreshTokenScalarWhereInput | OAuthRefreshTokenScalarWhereInput[]
  }

  export type OAuthRefreshTokenUncheckedUpdateManyWithoutAccessTokenNestedInput = {
    create?: XOR<OAuthRefreshTokenCreateWithoutAccessTokenInput, OAuthRefreshTokenUncheckedCreateWithoutAccessTokenInput> | OAuthRefreshTokenCreateWithoutAccessTokenInput[] | OAuthRefreshTokenUncheckedCreateWithoutAccessTokenInput[]
    connectOrCreate?: OAuthRefreshTokenCreateOrConnectWithoutAccessTokenInput | OAuthRefreshTokenCreateOrConnectWithoutAccessTokenInput[]
    upsert?: OAuthRefreshTokenUpsertWithWhereUniqueWithoutAccessTokenInput | OAuthRefreshTokenUpsertWithWhereUniqueWithoutAccessTokenInput[]
    createMany?: OAuthRefreshTokenCreateManyAccessTokenInputEnvelope
    set?: OAuthRefreshTokenWhereUniqueInput | OAuthRefreshTokenWhereUniqueInput[]
    disconnect?: OAuthRefreshTokenWhereUniqueInput | OAuthRefreshTokenWhereUniqueInput[]
    delete?: OAuthRefreshTokenWhereUniqueInput | OAuthRefreshTokenWhereUniqueInput[]
    connect?: OAuthRefreshTokenWhereUniqueInput | OAuthRefreshTokenWhereUniqueInput[]
    update?: OAuthRefreshTokenUpdateWithWhereUniqueWithoutAccessTokenInput | OAuthRefreshTokenUpdateWithWhereUniqueWithoutAccessTokenInput[]
    updateMany?: OAuthRefreshTokenUpdateManyWithWhereWithoutAccessTokenInput | OAuthRefreshTokenUpdateManyWithWhereWithoutAccessTokenInput[]
    deleteMany?: OAuthRefreshTokenScalarWhereInput | OAuthRefreshTokenScalarWhereInput[]
  }

  export type OAuthRefreshTokenCreatescopesInput = {
    set: string[]
  }

  export type OAuthAccessTokenCreateNestedOneWithoutRefreshTokenInput = {
    create?: XOR<OAuthAccessTokenCreateWithoutRefreshTokenInput, OAuthAccessTokenUncheckedCreateWithoutRefreshTokenInput>
    connectOrCreate?: OAuthAccessTokenCreateOrConnectWithoutRefreshTokenInput
    connect?: OAuthAccessTokenWhereUniqueInput
  }

  export type OAuthClientCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<OAuthClientCreateWithoutRefreshTokensInput, OAuthClientUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: OAuthClientCreateOrConnectWithoutRefreshTokensInput
    connect?: OAuthClientWhereUniqueInput
  }

  export type OAuthRefreshTokenUpdatescopesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OAuthAccessTokenUpdateOneRequiredWithoutRefreshTokenNestedInput = {
    create?: XOR<OAuthAccessTokenCreateWithoutRefreshTokenInput, OAuthAccessTokenUncheckedCreateWithoutRefreshTokenInput>
    connectOrCreate?: OAuthAccessTokenCreateOrConnectWithoutRefreshTokenInput
    upsert?: OAuthAccessTokenUpsertWithoutRefreshTokenInput
    connect?: OAuthAccessTokenWhereUniqueInput
    update?: XOR<XOR<OAuthAccessTokenUpdateToOneWithWhereWithoutRefreshTokenInput, OAuthAccessTokenUpdateWithoutRefreshTokenInput>, OAuthAccessTokenUncheckedUpdateWithoutRefreshTokenInput>
  }

  export type OAuthClientUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<OAuthClientCreateWithoutRefreshTokensInput, OAuthClientUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: OAuthClientCreateOrConnectWithoutRefreshTokensInput
    upsert?: OAuthClientUpsertWithoutRefreshTokensInput
    connect?: OAuthClientWhereUniqueInput
    update?: XOR<XOR<OAuthClientUpdateToOneWithWhereWithoutRefreshTokensInput, OAuthClientUpdateWithoutRefreshTokensInput>, OAuthClientUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type DownloadResultCreateNestedManyWithoutDownloadTaskInput = {
    create?: XOR<DownloadResultCreateWithoutDownloadTaskInput, DownloadResultUncheckedCreateWithoutDownloadTaskInput> | DownloadResultCreateWithoutDownloadTaskInput[] | DownloadResultUncheckedCreateWithoutDownloadTaskInput[]
    connectOrCreate?: DownloadResultCreateOrConnectWithoutDownloadTaskInput | DownloadResultCreateOrConnectWithoutDownloadTaskInput[]
    createMany?: DownloadResultCreateManyDownloadTaskInputEnvelope
    connect?: DownloadResultWhereUniqueInput | DownloadResultWhereUniqueInput[]
  }

  export type DownloadResultUncheckedCreateNestedManyWithoutDownloadTaskInput = {
    create?: XOR<DownloadResultCreateWithoutDownloadTaskInput, DownloadResultUncheckedCreateWithoutDownloadTaskInput> | DownloadResultCreateWithoutDownloadTaskInput[] | DownloadResultUncheckedCreateWithoutDownloadTaskInput[]
    connectOrCreate?: DownloadResultCreateOrConnectWithoutDownloadTaskInput | DownloadResultCreateOrConnectWithoutDownloadTaskInput[]
    createMany?: DownloadResultCreateManyDownloadTaskInputEnvelope
    connect?: DownloadResultWhereUniqueInput | DownloadResultWhereUniqueInput[]
  }

  export type DownloadResultUpdateManyWithoutDownloadTaskNestedInput = {
    create?: XOR<DownloadResultCreateWithoutDownloadTaskInput, DownloadResultUncheckedCreateWithoutDownloadTaskInput> | DownloadResultCreateWithoutDownloadTaskInput[] | DownloadResultUncheckedCreateWithoutDownloadTaskInput[]
    connectOrCreate?: DownloadResultCreateOrConnectWithoutDownloadTaskInput | DownloadResultCreateOrConnectWithoutDownloadTaskInput[]
    upsert?: DownloadResultUpsertWithWhereUniqueWithoutDownloadTaskInput | DownloadResultUpsertWithWhereUniqueWithoutDownloadTaskInput[]
    createMany?: DownloadResultCreateManyDownloadTaskInputEnvelope
    set?: DownloadResultWhereUniqueInput | DownloadResultWhereUniqueInput[]
    disconnect?: DownloadResultWhereUniqueInput | DownloadResultWhereUniqueInput[]
    delete?: DownloadResultWhereUniqueInput | DownloadResultWhereUniqueInput[]
    connect?: DownloadResultWhereUniqueInput | DownloadResultWhereUniqueInput[]
    update?: DownloadResultUpdateWithWhereUniqueWithoutDownloadTaskInput | DownloadResultUpdateWithWhereUniqueWithoutDownloadTaskInput[]
    updateMany?: DownloadResultUpdateManyWithWhereWithoutDownloadTaskInput | DownloadResultUpdateManyWithWhereWithoutDownloadTaskInput[]
    deleteMany?: DownloadResultScalarWhereInput | DownloadResultScalarWhereInput[]
  }

  export type DownloadResultUncheckedUpdateManyWithoutDownloadTaskNestedInput = {
    create?: XOR<DownloadResultCreateWithoutDownloadTaskInput, DownloadResultUncheckedCreateWithoutDownloadTaskInput> | DownloadResultCreateWithoutDownloadTaskInput[] | DownloadResultUncheckedCreateWithoutDownloadTaskInput[]
    connectOrCreate?: DownloadResultCreateOrConnectWithoutDownloadTaskInput | DownloadResultCreateOrConnectWithoutDownloadTaskInput[]
    upsert?: DownloadResultUpsertWithWhereUniqueWithoutDownloadTaskInput | DownloadResultUpsertWithWhereUniqueWithoutDownloadTaskInput[]
    createMany?: DownloadResultCreateManyDownloadTaskInputEnvelope
    set?: DownloadResultWhereUniqueInput | DownloadResultWhereUniqueInput[]
    disconnect?: DownloadResultWhereUniqueInput | DownloadResultWhereUniqueInput[]
    delete?: DownloadResultWhereUniqueInput | DownloadResultWhereUniqueInput[]
    connect?: DownloadResultWhereUniqueInput | DownloadResultWhereUniqueInput[]
    update?: DownloadResultUpdateWithWhereUniqueWithoutDownloadTaskInput | DownloadResultUpdateWithWhereUniqueWithoutDownloadTaskInput[]
    updateMany?: DownloadResultUpdateManyWithWhereWithoutDownloadTaskInput | DownloadResultUpdateManyWithWhereWithoutDownloadTaskInput[]
    deleteMany?: DownloadResultScalarWhereInput | DownloadResultScalarWhereInput[]
  }

  export type DownloadResultCreateerrorsInput = {
    set: string[]
  }

  export type DownloadTaskCreateNestedOneWithoutDownloadResultsInput = {
    create?: XOR<DownloadTaskCreateWithoutDownloadResultsInput, DownloadTaskUncheckedCreateWithoutDownloadResultsInput>
    connectOrCreate?: DownloadTaskCreateOrConnectWithoutDownloadResultsInput
    connect?: DownloadTaskWhereUniqueInput
  }

  export type DownloadResultUpdateerrorsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DownloadTaskUpdateOneRequiredWithoutDownloadResultsNestedInput = {
    create?: XOR<DownloadTaskCreateWithoutDownloadResultsInput, DownloadTaskUncheckedCreateWithoutDownloadResultsInput>
    connectOrCreate?: DownloadTaskCreateOrConnectWithoutDownloadResultsInput
    upsert?: DownloadTaskUpsertWithoutDownloadResultsInput
    connect?: DownloadTaskWhereUniqueInput
    update?: XOR<XOR<DownloadTaskUpdateToOneWithWhereWithoutDownloadResultsInput, DownloadTaskUpdateWithoutDownloadResultsInput>, DownloadTaskUncheckedUpdateWithoutDownloadResultsInput>
  }

  export type PromptTemplateCreateNestedManyWithoutCategoryRelInput = {
    create?: XOR<PromptTemplateCreateWithoutCategoryRelInput, PromptTemplateUncheckedCreateWithoutCategoryRelInput> | PromptTemplateCreateWithoutCategoryRelInput[] | PromptTemplateUncheckedCreateWithoutCategoryRelInput[]
    connectOrCreate?: PromptTemplateCreateOrConnectWithoutCategoryRelInput | PromptTemplateCreateOrConnectWithoutCategoryRelInput[]
    createMany?: PromptTemplateCreateManyCategoryRelInputEnvelope
    connect?: PromptTemplateWhereUniqueInput | PromptTemplateWhereUniqueInput[]
  }

  export type PromptCategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<PromptCategoryCreateWithoutChildrenInput, PromptCategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: PromptCategoryCreateOrConnectWithoutChildrenInput
    connect?: PromptCategoryWhereUniqueInput
  }

  export type PromptCategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<PromptCategoryCreateWithoutParentInput, PromptCategoryUncheckedCreateWithoutParentInput> | PromptCategoryCreateWithoutParentInput[] | PromptCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PromptCategoryCreateOrConnectWithoutParentInput | PromptCategoryCreateOrConnectWithoutParentInput[]
    createMany?: PromptCategoryCreateManyParentInputEnvelope
    connect?: PromptCategoryWhereUniqueInput | PromptCategoryWhereUniqueInput[]
  }

  export type PromptTemplateUncheckedCreateNestedManyWithoutCategoryRelInput = {
    create?: XOR<PromptTemplateCreateWithoutCategoryRelInput, PromptTemplateUncheckedCreateWithoutCategoryRelInput> | PromptTemplateCreateWithoutCategoryRelInput[] | PromptTemplateUncheckedCreateWithoutCategoryRelInput[]
    connectOrCreate?: PromptTemplateCreateOrConnectWithoutCategoryRelInput | PromptTemplateCreateOrConnectWithoutCategoryRelInput[]
    createMany?: PromptTemplateCreateManyCategoryRelInputEnvelope
    connect?: PromptTemplateWhereUniqueInput | PromptTemplateWhereUniqueInput[]
  }

  export type PromptCategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<PromptCategoryCreateWithoutParentInput, PromptCategoryUncheckedCreateWithoutParentInput> | PromptCategoryCreateWithoutParentInput[] | PromptCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PromptCategoryCreateOrConnectWithoutParentInput | PromptCategoryCreateOrConnectWithoutParentInput[]
    createMany?: PromptCategoryCreateManyParentInputEnvelope
    connect?: PromptCategoryWhereUniqueInput | PromptCategoryWhereUniqueInput[]
  }

  export type PromptTemplateUpdateManyWithoutCategoryRelNestedInput = {
    create?: XOR<PromptTemplateCreateWithoutCategoryRelInput, PromptTemplateUncheckedCreateWithoutCategoryRelInput> | PromptTemplateCreateWithoutCategoryRelInput[] | PromptTemplateUncheckedCreateWithoutCategoryRelInput[]
    connectOrCreate?: PromptTemplateCreateOrConnectWithoutCategoryRelInput | PromptTemplateCreateOrConnectWithoutCategoryRelInput[]
    upsert?: PromptTemplateUpsertWithWhereUniqueWithoutCategoryRelInput | PromptTemplateUpsertWithWhereUniqueWithoutCategoryRelInput[]
    createMany?: PromptTemplateCreateManyCategoryRelInputEnvelope
    set?: PromptTemplateWhereUniqueInput | PromptTemplateWhereUniqueInput[]
    disconnect?: PromptTemplateWhereUniqueInput | PromptTemplateWhereUniqueInput[]
    delete?: PromptTemplateWhereUniqueInput | PromptTemplateWhereUniqueInput[]
    connect?: PromptTemplateWhereUniqueInput | PromptTemplateWhereUniqueInput[]
    update?: PromptTemplateUpdateWithWhereUniqueWithoutCategoryRelInput | PromptTemplateUpdateWithWhereUniqueWithoutCategoryRelInput[]
    updateMany?: PromptTemplateUpdateManyWithWhereWithoutCategoryRelInput | PromptTemplateUpdateManyWithWhereWithoutCategoryRelInput[]
    deleteMany?: PromptTemplateScalarWhereInput | PromptTemplateScalarWhereInput[]
  }

  export type PromptCategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<PromptCategoryCreateWithoutChildrenInput, PromptCategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: PromptCategoryCreateOrConnectWithoutChildrenInput
    upsert?: PromptCategoryUpsertWithoutChildrenInput
    disconnect?: PromptCategoryWhereInput | boolean
    delete?: PromptCategoryWhereInput | boolean
    connect?: PromptCategoryWhereUniqueInput
    update?: XOR<XOR<PromptCategoryUpdateToOneWithWhereWithoutChildrenInput, PromptCategoryUpdateWithoutChildrenInput>, PromptCategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type PromptCategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<PromptCategoryCreateWithoutParentInput, PromptCategoryUncheckedCreateWithoutParentInput> | PromptCategoryCreateWithoutParentInput[] | PromptCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PromptCategoryCreateOrConnectWithoutParentInput | PromptCategoryCreateOrConnectWithoutParentInput[]
    upsert?: PromptCategoryUpsertWithWhereUniqueWithoutParentInput | PromptCategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: PromptCategoryCreateManyParentInputEnvelope
    set?: PromptCategoryWhereUniqueInput | PromptCategoryWhereUniqueInput[]
    disconnect?: PromptCategoryWhereUniqueInput | PromptCategoryWhereUniqueInput[]
    delete?: PromptCategoryWhereUniqueInput | PromptCategoryWhereUniqueInput[]
    connect?: PromptCategoryWhereUniqueInput | PromptCategoryWhereUniqueInput[]
    update?: PromptCategoryUpdateWithWhereUniqueWithoutParentInput | PromptCategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: PromptCategoryUpdateManyWithWhereWithoutParentInput | PromptCategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: PromptCategoryScalarWhereInput | PromptCategoryScalarWhereInput[]
  }

  export type PromptTemplateUncheckedUpdateManyWithoutCategoryRelNestedInput = {
    create?: XOR<PromptTemplateCreateWithoutCategoryRelInput, PromptTemplateUncheckedCreateWithoutCategoryRelInput> | PromptTemplateCreateWithoutCategoryRelInput[] | PromptTemplateUncheckedCreateWithoutCategoryRelInput[]
    connectOrCreate?: PromptTemplateCreateOrConnectWithoutCategoryRelInput | PromptTemplateCreateOrConnectWithoutCategoryRelInput[]
    upsert?: PromptTemplateUpsertWithWhereUniqueWithoutCategoryRelInput | PromptTemplateUpsertWithWhereUniqueWithoutCategoryRelInput[]
    createMany?: PromptTemplateCreateManyCategoryRelInputEnvelope
    set?: PromptTemplateWhereUniqueInput | PromptTemplateWhereUniqueInput[]
    disconnect?: PromptTemplateWhereUniqueInput | PromptTemplateWhereUniqueInput[]
    delete?: PromptTemplateWhereUniqueInput | PromptTemplateWhereUniqueInput[]
    connect?: PromptTemplateWhereUniqueInput | PromptTemplateWhereUniqueInput[]
    update?: PromptTemplateUpdateWithWhereUniqueWithoutCategoryRelInput | PromptTemplateUpdateWithWhereUniqueWithoutCategoryRelInput[]
    updateMany?: PromptTemplateUpdateManyWithWhereWithoutCategoryRelInput | PromptTemplateUpdateManyWithWhereWithoutCategoryRelInput[]
    deleteMany?: PromptTemplateScalarWhereInput | PromptTemplateScalarWhereInput[]
  }

  export type PromptCategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<PromptCategoryCreateWithoutParentInput, PromptCategoryUncheckedCreateWithoutParentInput> | PromptCategoryCreateWithoutParentInput[] | PromptCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PromptCategoryCreateOrConnectWithoutParentInput | PromptCategoryCreateOrConnectWithoutParentInput[]
    upsert?: PromptCategoryUpsertWithWhereUniqueWithoutParentInput | PromptCategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: PromptCategoryCreateManyParentInputEnvelope
    set?: PromptCategoryWhereUniqueInput | PromptCategoryWhereUniqueInput[]
    disconnect?: PromptCategoryWhereUniqueInput | PromptCategoryWhereUniqueInput[]
    delete?: PromptCategoryWhereUniqueInput | PromptCategoryWhereUniqueInput[]
    connect?: PromptCategoryWhereUniqueInput | PromptCategoryWhereUniqueInput[]
    update?: PromptCategoryUpdateWithWhereUniqueWithoutParentInput | PromptCategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: PromptCategoryUpdateManyWithWhereWithoutParentInput | PromptCategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: PromptCategoryScalarWhereInput | PromptCategoryScalarWhereInput[]
  }

  export type PromptCategoryCreateNestedOneWithoutTemplatesInput = {
    create?: XOR<PromptCategoryCreateWithoutTemplatesInput, PromptCategoryUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: PromptCategoryCreateOrConnectWithoutTemplatesInput
    connect?: PromptCategoryWhereUniqueInput
  }

  export type PromptExecutionCreateNestedManyWithoutTemplateInput = {
    create?: XOR<PromptExecutionCreateWithoutTemplateInput, PromptExecutionUncheckedCreateWithoutTemplateInput> | PromptExecutionCreateWithoutTemplateInput[] | PromptExecutionUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: PromptExecutionCreateOrConnectWithoutTemplateInput | PromptExecutionCreateOrConnectWithoutTemplateInput[]
    createMany?: PromptExecutionCreateManyTemplateInputEnvelope
    connect?: PromptExecutionWhereUniqueInput | PromptExecutionWhereUniqueInput[]
  }

  export type TemplateChangeCreateNestedManyWithoutTemplateInput = {
    create?: XOR<TemplateChangeCreateWithoutTemplateInput, TemplateChangeUncheckedCreateWithoutTemplateInput> | TemplateChangeCreateWithoutTemplateInput[] | TemplateChangeUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: TemplateChangeCreateOrConnectWithoutTemplateInput | TemplateChangeCreateOrConnectWithoutTemplateInput[]
    createMany?: TemplateChangeCreateManyTemplateInputEnvelope
    connect?: TemplateChangeWhereUniqueInput | TemplateChangeWhereUniqueInput[]
  }

  export type OptimizationRecordCreateNestedManyWithoutTemplateInput = {
    create?: XOR<OptimizationRecordCreateWithoutTemplateInput, OptimizationRecordUncheckedCreateWithoutTemplateInput> | OptimizationRecordCreateWithoutTemplateInput[] | OptimizationRecordUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: OptimizationRecordCreateOrConnectWithoutTemplateInput | OptimizationRecordCreateOrConnectWithoutTemplateInput[]
    createMany?: OptimizationRecordCreateManyTemplateInputEnvelope
    connect?: OptimizationRecordWhereUniqueInput | OptimizationRecordWhereUniqueInput[]
  }

  export type PromptExecutionUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<PromptExecutionCreateWithoutTemplateInput, PromptExecutionUncheckedCreateWithoutTemplateInput> | PromptExecutionCreateWithoutTemplateInput[] | PromptExecutionUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: PromptExecutionCreateOrConnectWithoutTemplateInput | PromptExecutionCreateOrConnectWithoutTemplateInput[]
    createMany?: PromptExecutionCreateManyTemplateInputEnvelope
    connect?: PromptExecutionWhereUniqueInput | PromptExecutionWhereUniqueInput[]
  }

  export type TemplateChangeUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<TemplateChangeCreateWithoutTemplateInput, TemplateChangeUncheckedCreateWithoutTemplateInput> | TemplateChangeCreateWithoutTemplateInput[] | TemplateChangeUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: TemplateChangeCreateOrConnectWithoutTemplateInput | TemplateChangeCreateOrConnectWithoutTemplateInput[]
    createMany?: TemplateChangeCreateManyTemplateInputEnvelope
    connect?: TemplateChangeWhereUniqueInput | TemplateChangeWhereUniqueInput[]
  }

  export type OptimizationRecordUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<OptimizationRecordCreateWithoutTemplateInput, OptimizationRecordUncheckedCreateWithoutTemplateInput> | OptimizationRecordCreateWithoutTemplateInput[] | OptimizationRecordUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: OptimizationRecordCreateOrConnectWithoutTemplateInput | OptimizationRecordCreateOrConnectWithoutTemplateInput[]
    createMany?: OptimizationRecordCreateManyTemplateInputEnvelope
    connect?: OptimizationRecordWhereUniqueInput | OptimizationRecordWhereUniqueInput[]
  }

  export type PromptCategoryUpdateOneRequiredWithoutTemplatesNestedInput = {
    create?: XOR<PromptCategoryCreateWithoutTemplatesInput, PromptCategoryUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: PromptCategoryCreateOrConnectWithoutTemplatesInput
    upsert?: PromptCategoryUpsertWithoutTemplatesInput
    connect?: PromptCategoryWhereUniqueInput
    update?: XOR<XOR<PromptCategoryUpdateToOneWithWhereWithoutTemplatesInput, PromptCategoryUpdateWithoutTemplatesInput>, PromptCategoryUncheckedUpdateWithoutTemplatesInput>
  }

  export type PromptExecutionUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<PromptExecutionCreateWithoutTemplateInput, PromptExecutionUncheckedCreateWithoutTemplateInput> | PromptExecutionCreateWithoutTemplateInput[] | PromptExecutionUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: PromptExecutionCreateOrConnectWithoutTemplateInput | PromptExecutionCreateOrConnectWithoutTemplateInput[]
    upsert?: PromptExecutionUpsertWithWhereUniqueWithoutTemplateInput | PromptExecutionUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: PromptExecutionCreateManyTemplateInputEnvelope
    set?: PromptExecutionWhereUniqueInput | PromptExecutionWhereUniqueInput[]
    disconnect?: PromptExecutionWhereUniqueInput | PromptExecutionWhereUniqueInput[]
    delete?: PromptExecutionWhereUniqueInput | PromptExecutionWhereUniqueInput[]
    connect?: PromptExecutionWhereUniqueInput | PromptExecutionWhereUniqueInput[]
    update?: PromptExecutionUpdateWithWhereUniqueWithoutTemplateInput | PromptExecutionUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: PromptExecutionUpdateManyWithWhereWithoutTemplateInput | PromptExecutionUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: PromptExecutionScalarWhereInput | PromptExecutionScalarWhereInput[]
  }

  export type TemplateChangeUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<TemplateChangeCreateWithoutTemplateInput, TemplateChangeUncheckedCreateWithoutTemplateInput> | TemplateChangeCreateWithoutTemplateInput[] | TemplateChangeUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: TemplateChangeCreateOrConnectWithoutTemplateInput | TemplateChangeCreateOrConnectWithoutTemplateInput[]
    upsert?: TemplateChangeUpsertWithWhereUniqueWithoutTemplateInput | TemplateChangeUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: TemplateChangeCreateManyTemplateInputEnvelope
    set?: TemplateChangeWhereUniqueInput | TemplateChangeWhereUniqueInput[]
    disconnect?: TemplateChangeWhereUniqueInput | TemplateChangeWhereUniqueInput[]
    delete?: TemplateChangeWhereUniqueInput | TemplateChangeWhereUniqueInput[]
    connect?: TemplateChangeWhereUniqueInput | TemplateChangeWhereUniqueInput[]
    update?: TemplateChangeUpdateWithWhereUniqueWithoutTemplateInput | TemplateChangeUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: TemplateChangeUpdateManyWithWhereWithoutTemplateInput | TemplateChangeUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: TemplateChangeScalarWhereInput | TemplateChangeScalarWhereInput[]
  }

  export type OptimizationRecordUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<OptimizationRecordCreateWithoutTemplateInput, OptimizationRecordUncheckedCreateWithoutTemplateInput> | OptimizationRecordCreateWithoutTemplateInput[] | OptimizationRecordUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: OptimizationRecordCreateOrConnectWithoutTemplateInput | OptimizationRecordCreateOrConnectWithoutTemplateInput[]
    upsert?: OptimizationRecordUpsertWithWhereUniqueWithoutTemplateInput | OptimizationRecordUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: OptimizationRecordCreateManyTemplateInputEnvelope
    set?: OptimizationRecordWhereUniqueInput | OptimizationRecordWhereUniqueInput[]
    disconnect?: OptimizationRecordWhereUniqueInput | OptimizationRecordWhereUniqueInput[]
    delete?: OptimizationRecordWhereUniqueInput | OptimizationRecordWhereUniqueInput[]
    connect?: OptimizationRecordWhereUniqueInput | OptimizationRecordWhereUniqueInput[]
    update?: OptimizationRecordUpdateWithWhereUniqueWithoutTemplateInput | OptimizationRecordUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: OptimizationRecordUpdateManyWithWhereWithoutTemplateInput | OptimizationRecordUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: OptimizationRecordScalarWhereInput | OptimizationRecordScalarWhereInput[]
  }

  export type PromptExecutionUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<PromptExecutionCreateWithoutTemplateInput, PromptExecutionUncheckedCreateWithoutTemplateInput> | PromptExecutionCreateWithoutTemplateInput[] | PromptExecutionUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: PromptExecutionCreateOrConnectWithoutTemplateInput | PromptExecutionCreateOrConnectWithoutTemplateInput[]
    upsert?: PromptExecutionUpsertWithWhereUniqueWithoutTemplateInput | PromptExecutionUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: PromptExecutionCreateManyTemplateInputEnvelope
    set?: PromptExecutionWhereUniqueInput | PromptExecutionWhereUniqueInput[]
    disconnect?: PromptExecutionWhereUniqueInput | PromptExecutionWhereUniqueInput[]
    delete?: PromptExecutionWhereUniqueInput | PromptExecutionWhereUniqueInput[]
    connect?: PromptExecutionWhereUniqueInput | PromptExecutionWhereUniqueInput[]
    update?: PromptExecutionUpdateWithWhereUniqueWithoutTemplateInput | PromptExecutionUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: PromptExecutionUpdateManyWithWhereWithoutTemplateInput | PromptExecutionUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: PromptExecutionScalarWhereInput | PromptExecutionScalarWhereInput[]
  }

  export type TemplateChangeUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<TemplateChangeCreateWithoutTemplateInput, TemplateChangeUncheckedCreateWithoutTemplateInput> | TemplateChangeCreateWithoutTemplateInput[] | TemplateChangeUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: TemplateChangeCreateOrConnectWithoutTemplateInput | TemplateChangeCreateOrConnectWithoutTemplateInput[]
    upsert?: TemplateChangeUpsertWithWhereUniqueWithoutTemplateInput | TemplateChangeUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: TemplateChangeCreateManyTemplateInputEnvelope
    set?: TemplateChangeWhereUniqueInput | TemplateChangeWhereUniqueInput[]
    disconnect?: TemplateChangeWhereUniqueInput | TemplateChangeWhereUniqueInput[]
    delete?: TemplateChangeWhereUniqueInput | TemplateChangeWhereUniqueInput[]
    connect?: TemplateChangeWhereUniqueInput | TemplateChangeWhereUniqueInput[]
    update?: TemplateChangeUpdateWithWhereUniqueWithoutTemplateInput | TemplateChangeUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: TemplateChangeUpdateManyWithWhereWithoutTemplateInput | TemplateChangeUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: TemplateChangeScalarWhereInput | TemplateChangeScalarWhereInput[]
  }

  export type OptimizationRecordUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<OptimizationRecordCreateWithoutTemplateInput, OptimizationRecordUncheckedCreateWithoutTemplateInput> | OptimizationRecordCreateWithoutTemplateInput[] | OptimizationRecordUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: OptimizationRecordCreateOrConnectWithoutTemplateInput | OptimizationRecordCreateOrConnectWithoutTemplateInput[]
    upsert?: OptimizationRecordUpsertWithWhereUniqueWithoutTemplateInput | OptimizationRecordUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: OptimizationRecordCreateManyTemplateInputEnvelope
    set?: OptimizationRecordWhereUniqueInput | OptimizationRecordWhereUniqueInput[]
    disconnect?: OptimizationRecordWhereUniqueInput | OptimizationRecordWhereUniqueInput[]
    delete?: OptimizationRecordWhereUniqueInput | OptimizationRecordWhereUniqueInput[]
    connect?: OptimizationRecordWhereUniqueInput | OptimizationRecordWhereUniqueInput[]
    update?: OptimizationRecordUpdateWithWhereUniqueWithoutTemplateInput | OptimizationRecordUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: OptimizationRecordUpdateManyWithWhereWithoutTemplateInput | OptimizationRecordUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: OptimizationRecordScalarWhereInput | OptimizationRecordScalarWhereInput[]
  }

  export type PromptTemplateCreateNestedOneWithoutChangesInput = {
    create?: XOR<PromptTemplateCreateWithoutChangesInput, PromptTemplateUncheckedCreateWithoutChangesInput>
    connectOrCreate?: PromptTemplateCreateOrConnectWithoutChangesInput
    connect?: PromptTemplateWhereUniqueInput
  }

  export type PromptTemplateUpdateOneRequiredWithoutChangesNestedInput = {
    create?: XOR<PromptTemplateCreateWithoutChangesInput, PromptTemplateUncheckedCreateWithoutChangesInput>
    connectOrCreate?: PromptTemplateCreateOrConnectWithoutChangesInput
    upsert?: PromptTemplateUpsertWithoutChangesInput
    connect?: PromptTemplateWhereUniqueInput
    update?: XOR<XOR<PromptTemplateUpdateToOneWithWhereWithoutChangesInput, PromptTemplateUpdateWithoutChangesInput>, PromptTemplateUncheckedUpdateWithoutChangesInput>
  }

  export type PromptTemplateCreateNestedOneWithoutExecutionsInput = {
    create?: XOR<PromptTemplateCreateWithoutExecutionsInput, PromptTemplateUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: PromptTemplateCreateOrConnectWithoutExecutionsInput
    connect?: PromptTemplateWhereUniqueInput
  }

  export type PromptTemplateUpdateOneRequiredWithoutExecutionsNestedInput = {
    create?: XOR<PromptTemplateCreateWithoutExecutionsInput, PromptTemplateUncheckedCreateWithoutExecutionsInput>
    connectOrCreate?: PromptTemplateCreateOrConnectWithoutExecutionsInput
    upsert?: PromptTemplateUpsertWithoutExecutionsInput
    connect?: PromptTemplateWhereUniqueInput
    update?: XOR<XOR<PromptTemplateUpdateToOneWithWhereWithoutExecutionsInput, PromptTemplateUpdateWithoutExecutionsInput>, PromptTemplateUncheckedUpdateWithoutExecutionsInput>
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type PromptTemplateCreateNestedOneWithoutOptimizationsInput = {
    create?: XOR<PromptTemplateCreateWithoutOptimizationsInput, PromptTemplateUncheckedCreateWithoutOptimizationsInput>
    connectOrCreate?: PromptTemplateCreateOrConnectWithoutOptimizationsInput
    connect?: PromptTemplateWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type PromptTemplateUpdateOneRequiredWithoutOptimizationsNestedInput = {
    create?: XOR<PromptTemplateCreateWithoutOptimizationsInput, PromptTemplateUncheckedCreateWithoutOptimizationsInput>
    connectOrCreate?: PromptTemplateCreateOrConnectWithoutOptimizationsInput
    upsert?: PromptTemplateUpsertWithoutOptimizationsInput
    connect?: PromptTemplateWhereUniqueInput
    update?: XOR<XOR<PromptTemplateUpdateToOneWithWhereWithoutOptimizationsInput, PromptTemplateUpdateWithoutOptimizationsInput>, PromptTemplateUncheckedUpdateWithoutOptimizationsInput>
  }

  export type UserCreateNestedOneWithoutConversationsInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput
    connect?: UserWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationShareCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationShareCreateWithoutConversationInput, ConversationShareUncheckedCreateWithoutConversationInput> | ConversationShareCreateWithoutConversationInput[] | ConversationShareUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationShareCreateOrConnectWithoutConversationInput | ConversationShareCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationShareCreateManyConversationInputEnvelope
    connect?: ConversationShareWhereUniqueInput | ConversationShareWhereUniqueInput[]
  }

  export type ConversationExportCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationExportCreateWithoutConversationInput, ConversationExportUncheckedCreateWithoutConversationInput> | ConversationExportCreateWithoutConversationInput[] | ConversationExportUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationExportCreateOrConnectWithoutConversationInput | ConversationExportCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationExportCreateManyConversationInputEnvelope
    connect?: ConversationExportWhereUniqueInput | ConversationExportWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationShareUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationShareCreateWithoutConversationInput, ConversationShareUncheckedCreateWithoutConversationInput> | ConversationShareCreateWithoutConversationInput[] | ConversationShareUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationShareCreateOrConnectWithoutConversationInput | ConversationShareCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationShareCreateManyConversationInputEnvelope
    connect?: ConversationShareWhereUniqueInput | ConversationShareWhereUniqueInput[]
  }

  export type ConversationExportUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationExportCreateWithoutConversationInput, ConversationExportUncheckedCreateWithoutConversationInput> | ConversationExportCreateWithoutConversationInput[] | ConversationExportUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationExportCreateOrConnectWithoutConversationInput | ConversationExportCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationExportCreateManyConversationInputEnvelope
    connect?: ConversationExportWhereUniqueInput | ConversationExportWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput
    upsert?: UserUpsertWithoutConversationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConversationsInput, UserUpdateWithoutConversationsInput>, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type MessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationShareUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationShareCreateWithoutConversationInput, ConversationShareUncheckedCreateWithoutConversationInput> | ConversationShareCreateWithoutConversationInput[] | ConversationShareUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationShareCreateOrConnectWithoutConversationInput | ConversationShareCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationShareUpsertWithWhereUniqueWithoutConversationInput | ConversationShareUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationShareCreateManyConversationInputEnvelope
    set?: ConversationShareWhereUniqueInput | ConversationShareWhereUniqueInput[]
    disconnect?: ConversationShareWhereUniqueInput | ConversationShareWhereUniqueInput[]
    delete?: ConversationShareWhereUniqueInput | ConversationShareWhereUniqueInput[]
    connect?: ConversationShareWhereUniqueInput | ConversationShareWhereUniqueInput[]
    update?: ConversationShareUpdateWithWhereUniqueWithoutConversationInput | ConversationShareUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationShareUpdateManyWithWhereWithoutConversationInput | ConversationShareUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationShareScalarWhereInput | ConversationShareScalarWhereInput[]
  }

  export type ConversationExportUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationExportCreateWithoutConversationInput, ConversationExportUncheckedCreateWithoutConversationInput> | ConversationExportCreateWithoutConversationInput[] | ConversationExportUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationExportCreateOrConnectWithoutConversationInput | ConversationExportCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationExportUpsertWithWhereUniqueWithoutConversationInput | ConversationExportUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationExportCreateManyConversationInputEnvelope
    set?: ConversationExportWhereUniqueInput | ConversationExportWhereUniqueInput[]
    disconnect?: ConversationExportWhereUniqueInput | ConversationExportWhereUniqueInput[]
    delete?: ConversationExportWhereUniqueInput | ConversationExportWhereUniqueInput[]
    connect?: ConversationExportWhereUniqueInput | ConversationExportWhereUniqueInput[]
    update?: ConversationExportUpdateWithWhereUniqueWithoutConversationInput | ConversationExportUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationExportUpdateManyWithWhereWithoutConversationInput | ConversationExportUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationExportScalarWhereInput | ConversationExportScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationShareUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationShareCreateWithoutConversationInput, ConversationShareUncheckedCreateWithoutConversationInput> | ConversationShareCreateWithoutConversationInput[] | ConversationShareUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationShareCreateOrConnectWithoutConversationInput | ConversationShareCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationShareUpsertWithWhereUniqueWithoutConversationInput | ConversationShareUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationShareCreateManyConversationInputEnvelope
    set?: ConversationShareWhereUniqueInput | ConversationShareWhereUniqueInput[]
    disconnect?: ConversationShareWhereUniqueInput | ConversationShareWhereUniqueInput[]
    delete?: ConversationShareWhereUniqueInput | ConversationShareWhereUniqueInput[]
    connect?: ConversationShareWhereUniqueInput | ConversationShareWhereUniqueInput[]
    update?: ConversationShareUpdateWithWhereUniqueWithoutConversationInput | ConversationShareUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationShareUpdateManyWithWhereWithoutConversationInput | ConversationShareUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationShareScalarWhereInput | ConversationShareScalarWhereInput[]
  }

  export type ConversationExportUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationExportCreateWithoutConversationInput, ConversationExportUncheckedCreateWithoutConversationInput> | ConversationExportCreateWithoutConversationInput[] | ConversationExportUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationExportCreateOrConnectWithoutConversationInput | ConversationExportCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationExportUpsertWithWhereUniqueWithoutConversationInput | ConversationExportUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationExportCreateManyConversationInputEnvelope
    set?: ConversationExportWhereUniqueInput | ConversationExportWhereUniqueInput[]
    disconnect?: ConversationExportWhereUniqueInput | ConversationExportWhereUniqueInput[]
    delete?: ConversationExportWhereUniqueInput | ConversationExportWhereUniqueInput[]
    connect?: ConversationExportWhereUniqueInput | ConversationExportWhereUniqueInput[]
    update?: ConversationExportUpdateWithWhereUniqueWithoutConversationInput | ConversationExportUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationExportUpdateManyWithWhereWithoutConversationInput | ConversationExportUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationExportScalarWhereInput | ConversationExportScalarWhereInput[]
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type MessageReactionCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageReactionCreateWithoutMessageInput, MessageReactionUncheckedCreateWithoutMessageInput> | MessageReactionCreateWithoutMessageInput[] | MessageReactionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReactionCreateOrConnectWithoutMessageInput | MessageReactionCreateOrConnectWithoutMessageInput[]
    createMany?: MessageReactionCreateManyMessageInputEnvelope
    connect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
  }

  export type MessageAttachmentCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
  }

  export type MessageReactionUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageReactionCreateWithoutMessageInput, MessageReactionUncheckedCreateWithoutMessageInput> | MessageReactionCreateWithoutMessageInput[] | MessageReactionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReactionCreateOrConnectWithoutMessageInput | MessageReactionCreateOrConnectWithoutMessageInput[]
    createMany?: MessageReactionCreateManyMessageInputEnvelope
    connect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
  }

  export type MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type MessageReactionUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageReactionCreateWithoutMessageInput, MessageReactionUncheckedCreateWithoutMessageInput> | MessageReactionCreateWithoutMessageInput[] | MessageReactionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReactionCreateOrConnectWithoutMessageInput | MessageReactionCreateOrConnectWithoutMessageInput[]
    upsert?: MessageReactionUpsertWithWhereUniqueWithoutMessageInput | MessageReactionUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageReactionCreateManyMessageInputEnvelope
    set?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    disconnect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    delete?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    connect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    update?: MessageReactionUpdateWithWhereUniqueWithoutMessageInput | MessageReactionUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageReactionUpdateManyWithWhereWithoutMessageInput | MessageReactionUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageReactionScalarWhereInput | MessageReactionScalarWhereInput[]
  }

  export type MessageAttachmentUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    upsert?: MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput | MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    set?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    disconnect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    delete?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    update?: MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput | MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageAttachmentUpdateManyWithWhereWithoutMessageInput | MessageAttachmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
  }

  export type MessageReactionUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageReactionCreateWithoutMessageInput, MessageReactionUncheckedCreateWithoutMessageInput> | MessageReactionCreateWithoutMessageInput[] | MessageReactionUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReactionCreateOrConnectWithoutMessageInput | MessageReactionCreateOrConnectWithoutMessageInput[]
    upsert?: MessageReactionUpsertWithWhereUniqueWithoutMessageInput | MessageReactionUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageReactionCreateManyMessageInputEnvelope
    set?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    disconnect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    delete?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    connect?: MessageReactionWhereUniqueInput | MessageReactionWhereUniqueInput[]
    update?: MessageReactionUpdateWithWhereUniqueWithoutMessageInput | MessageReactionUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageReactionUpdateManyWithWhereWithoutMessageInput | MessageReactionUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageReactionScalarWhereInput | MessageReactionScalarWhereInput[]
  }

  export type MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput> | MessageAttachmentCreateWithoutMessageInput[] | MessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageAttachmentCreateOrConnectWithoutMessageInput | MessageAttachmentCreateOrConnectWithoutMessageInput[]
    upsert?: MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput | MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageAttachmentCreateManyMessageInputEnvelope
    set?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    disconnect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    delete?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    connect?: MessageAttachmentWhereUniqueInput | MessageAttachmentWhereUniqueInput[]
    update?: MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput | MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageAttachmentUpdateManyWithWhereWithoutMessageInput | MessageAttachmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
  }

  export type MessageCreateNestedOneWithoutReactionsInput = {
    create?: XOR<MessageCreateWithoutReactionsInput, MessageUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutReactionsInput
    connect?: MessageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessageReactionsInput = {
    create?: XOR<UserCreateWithoutMessageReactionsInput, UserUncheckedCreateWithoutMessageReactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageReactionsInput
    connect?: UserWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutReactionsNestedInput = {
    create?: XOR<MessageCreateWithoutReactionsInput, MessageUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutReactionsInput
    upsert?: MessageUpsertWithoutReactionsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutReactionsInput, MessageUpdateWithoutReactionsInput>, MessageUncheckedUpdateWithoutReactionsInput>
  }

  export type UserUpdateOneRequiredWithoutMessageReactionsNestedInput = {
    create?: XOR<UserCreateWithoutMessageReactionsInput, UserUncheckedCreateWithoutMessageReactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessageReactionsInput
    upsert?: UserUpsertWithoutMessageReactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessageReactionsInput, UserUpdateWithoutMessageReactionsInput>, UserUncheckedUpdateWithoutMessageReactionsInput>
  }

  export type MessageCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutAttachmentsInput
    connect?: MessageWhereUniqueInput
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type MessageUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutAttachmentsInput
    upsert?: MessageUpsertWithoutAttachmentsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutAttachmentsInput, MessageUpdateWithoutAttachmentsInput>, MessageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type ConversationCreateNestedOneWithoutSharesInput = {
    create?: XOR<ConversationCreateWithoutSharesInput, ConversationUncheckedCreateWithoutSharesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutSharesInput
    connect?: ConversationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConversationSharesInput = {
    create?: XOR<UserCreateWithoutConversationSharesInput, UserUncheckedCreateWithoutConversationSharesInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationSharesInput
    connect?: UserWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutSharesNestedInput = {
    create?: XOR<ConversationCreateWithoutSharesInput, ConversationUncheckedCreateWithoutSharesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutSharesInput
    upsert?: ConversationUpsertWithoutSharesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutSharesInput, ConversationUpdateWithoutSharesInput>, ConversationUncheckedUpdateWithoutSharesInput>
  }

  export type UserUpdateOneRequiredWithoutConversationSharesNestedInput = {
    create?: XOR<UserCreateWithoutConversationSharesInput, UserUncheckedCreateWithoutConversationSharesInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationSharesInput
    upsert?: UserUpsertWithoutConversationSharesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConversationSharesInput, UserUpdateWithoutConversationSharesInput>, UserUncheckedUpdateWithoutConversationSharesInput>
  }

  export type ConversationCreateNestedOneWithoutExportsInput = {
    create?: XOR<ConversationCreateWithoutExportsInput, ConversationUncheckedCreateWithoutExportsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutExportsInput
    connect?: ConversationWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutExportsNestedInput = {
    create?: XOR<ConversationCreateWithoutExportsInput, ConversationUncheckedCreateWithoutExportsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutExportsInput
    upsert?: ConversationUpsertWithoutExportsInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutExportsInput, ConversationUpdateWithoutExportsInput>, ConversationUncheckedUpdateWithoutExportsInput>
  }

  export type ContextSourceCreatetagsInput = {
    set: string[]
  }

  export type ContextChunkCreateNestedManyWithoutSourceInput = {
    create?: XOR<ContextChunkCreateWithoutSourceInput, ContextChunkUncheckedCreateWithoutSourceInput> | ContextChunkCreateWithoutSourceInput[] | ContextChunkUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: ContextChunkCreateOrConnectWithoutSourceInput | ContextChunkCreateOrConnectWithoutSourceInput[]
    createMany?: ContextChunkCreateManySourceInputEnvelope
    connect?: ContextChunkWhereUniqueInput | ContextChunkWhereUniqueInput[]
  }

  export type ContextChunkUncheckedCreateNestedManyWithoutSourceInput = {
    create?: XOR<ContextChunkCreateWithoutSourceInput, ContextChunkUncheckedCreateWithoutSourceInput> | ContextChunkCreateWithoutSourceInput[] | ContextChunkUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: ContextChunkCreateOrConnectWithoutSourceInput | ContextChunkCreateOrConnectWithoutSourceInput[]
    createMany?: ContextChunkCreateManySourceInputEnvelope
    connect?: ContextChunkWhereUniqueInput | ContextChunkWhereUniqueInput[]
  }

  export type ContextSourceUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ContextChunkUpdateManyWithoutSourceNestedInput = {
    create?: XOR<ContextChunkCreateWithoutSourceInput, ContextChunkUncheckedCreateWithoutSourceInput> | ContextChunkCreateWithoutSourceInput[] | ContextChunkUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: ContextChunkCreateOrConnectWithoutSourceInput | ContextChunkCreateOrConnectWithoutSourceInput[]
    upsert?: ContextChunkUpsertWithWhereUniqueWithoutSourceInput | ContextChunkUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: ContextChunkCreateManySourceInputEnvelope
    set?: ContextChunkWhereUniqueInput | ContextChunkWhereUniqueInput[]
    disconnect?: ContextChunkWhereUniqueInput | ContextChunkWhereUniqueInput[]
    delete?: ContextChunkWhereUniqueInput | ContextChunkWhereUniqueInput[]
    connect?: ContextChunkWhereUniqueInput | ContextChunkWhereUniqueInput[]
    update?: ContextChunkUpdateWithWhereUniqueWithoutSourceInput | ContextChunkUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: ContextChunkUpdateManyWithWhereWithoutSourceInput | ContextChunkUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: ContextChunkScalarWhereInput | ContextChunkScalarWhereInput[]
  }

  export type ContextChunkUncheckedUpdateManyWithoutSourceNestedInput = {
    create?: XOR<ContextChunkCreateWithoutSourceInput, ContextChunkUncheckedCreateWithoutSourceInput> | ContextChunkCreateWithoutSourceInput[] | ContextChunkUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: ContextChunkCreateOrConnectWithoutSourceInput | ContextChunkCreateOrConnectWithoutSourceInput[]
    upsert?: ContextChunkUpsertWithWhereUniqueWithoutSourceInput | ContextChunkUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: ContextChunkCreateManySourceInputEnvelope
    set?: ContextChunkWhereUniqueInput | ContextChunkWhereUniqueInput[]
    disconnect?: ContextChunkWhereUniqueInput | ContextChunkWhereUniqueInput[]
    delete?: ContextChunkWhereUniqueInput | ContextChunkWhereUniqueInput[]
    connect?: ContextChunkWhereUniqueInput | ContextChunkWhereUniqueInput[]
    update?: ContextChunkUpdateWithWhereUniqueWithoutSourceInput | ContextChunkUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: ContextChunkUpdateManyWithWhereWithoutSourceInput | ContextChunkUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: ContextChunkScalarWhereInput | ContextChunkScalarWhereInput[]
  }

  export type ContextChunkCreateembeddingInput = {
    set: number[]
  }

  export type ContextSourceCreateNestedOneWithoutChunksInput = {
    create?: XOR<ContextSourceCreateWithoutChunksInput, ContextSourceUncheckedCreateWithoutChunksInput>
    connectOrCreate?: ContextSourceCreateOrConnectWithoutChunksInput
    connect?: ContextSourceWhereUniqueInput
  }

  export type ContextChunkUpdateembeddingInput = {
    set?: number[]
    push?: number | number[]
  }

  export type ContextSourceUpdateOneRequiredWithoutChunksNestedInput = {
    create?: XOR<ContextSourceCreateWithoutChunksInput, ContextSourceUncheckedCreateWithoutChunksInput>
    connectOrCreate?: ContextSourceCreateOrConnectWithoutChunksInput
    upsert?: ContextSourceUpsertWithoutChunksInput
    connect?: ContextSourceWhereUniqueInput
    update?: XOR<XOR<ContextSourceUpdateToOneWithWhereWithoutChunksInput, ContextSourceUpdateWithoutChunksInput>, ContextSourceUncheckedUpdateWithoutChunksInput>
  }

  export type ContextQueryCreateintentKeywordsInput = {
    set: string[]
  }

  export type ContextResultCreateNestedManyWithoutQueryInput = {
    create?: XOR<ContextResultCreateWithoutQueryInput, ContextResultUncheckedCreateWithoutQueryInput> | ContextResultCreateWithoutQueryInput[] | ContextResultUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ContextResultCreateOrConnectWithoutQueryInput | ContextResultCreateOrConnectWithoutQueryInput[]
    createMany?: ContextResultCreateManyQueryInputEnvelope
    connect?: ContextResultWhereUniqueInput | ContextResultWhereUniqueInput[]
  }

  export type ContextQueryAnalyticsCreateNestedManyWithoutQueryInput = {
    create?: XOR<ContextQueryAnalyticsCreateWithoutQueryInput, ContextQueryAnalyticsUncheckedCreateWithoutQueryInput> | ContextQueryAnalyticsCreateWithoutQueryInput[] | ContextQueryAnalyticsUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ContextQueryAnalyticsCreateOrConnectWithoutQueryInput | ContextQueryAnalyticsCreateOrConnectWithoutQueryInput[]
    createMany?: ContextQueryAnalyticsCreateManyQueryInputEnvelope
    connect?: ContextQueryAnalyticsWhereUniqueInput | ContextQueryAnalyticsWhereUniqueInput[]
  }

  export type ContextResultUncheckedCreateNestedManyWithoutQueryInput = {
    create?: XOR<ContextResultCreateWithoutQueryInput, ContextResultUncheckedCreateWithoutQueryInput> | ContextResultCreateWithoutQueryInput[] | ContextResultUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ContextResultCreateOrConnectWithoutQueryInput | ContextResultCreateOrConnectWithoutQueryInput[]
    createMany?: ContextResultCreateManyQueryInputEnvelope
    connect?: ContextResultWhereUniqueInput | ContextResultWhereUniqueInput[]
  }

  export type ContextQueryAnalyticsUncheckedCreateNestedManyWithoutQueryInput = {
    create?: XOR<ContextQueryAnalyticsCreateWithoutQueryInput, ContextQueryAnalyticsUncheckedCreateWithoutQueryInput> | ContextQueryAnalyticsCreateWithoutQueryInput[] | ContextQueryAnalyticsUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ContextQueryAnalyticsCreateOrConnectWithoutQueryInput | ContextQueryAnalyticsCreateOrConnectWithoutQueryInput[]
    createMany?: ContextQueryAnalyticsCreateManyQueryInputEnvelope
    connect?: ContextQueryAnalyticsWhereUniqueInput | ContextQueryAnalyticsWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ContextQueryUpdateintentKeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ContextResultUpdateManyWithoutQueryNestedInput = {
    create?: XOR<ContextResultCreateWithoutQueryInput, ContextResultUncheckedCreateWithoutQueryInput> | ContextResultCreateWithoutQueryInput[] | ContextResultUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ContextResultCreateOrConnectWithoutQueryInput | ContextResultCreateOrConnectWithoutQueryInput[]
    upsert?: ContextResultUpsertWithWhereUniqueWithoutQueryInput | ContextResultUpsertWithWhereUniqueWithoutQueryInput[]
    createMany?: ContextResultCreateManyQueryInputEnvelope
    set?: ContextResultWhereUniqueInput | ContextResultWhereUniqueInput[]
    disconnect?: ContextResultWhereUniqueInput | ContextResultWhereUniqueInput[]
    delete?: ContextResultWhereUniqueInput | ContextResultWhereUniqueInput[]
    connect?: ContextResultWhereUniqueInput | ContextResultWhereUniqueInput[]
    update?: ContextResultUpdateWithWhereUniqueWithoutQueryInput | ContextResultUpdateWithWhereUniqueWithoutQueryInput[]
    updateMany?: ContextResultUpdateManyWithWhereWithoutQueryInput | ContextResultUpdateManyWithWhereWithoutQueryInput[]
    deleteMany?: ContextResultScalarWhereInput | ContextResultScalarWhereInput[]
  }

  export type ContextQueryAnalyticsUpdateManyWithoutQueryNestedInput = {
    create?: XOR<ContextQueryAnalyticsCreateWithoutQueryInput, ContextQueryAnalyticsUncheckedCreateWithoutQueryInput> | ContextQueryAnalyticsCreateWithoutQueryInput[] | ContextQueryAnalyticsUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ContextQueryAnalyticsCreateOrConnectWithoutQueryInput | ContextQueryAnalyticsCreateOrConnectWithoutQueryInput[]
    upsert?: ContextQueryAnalyticsUpsertWithWhereUniqueWithoutQueryInput | ContextQueryAnalyticsUpsertWithWhereUniqueWithoutQueryInput[]
    createMany?: ContextQueryAnalyticsCreateManyQueryInputEnvelope
    set?: ContextQueryAnalyticsWhereUniqueInput | ContextQueryAnalyticsWhereUniqueInput[]
    disconnect?: ContextQueryAnalyticsWhereUniqueInput | ContextQueryAnalyticsWhereUniqueInput[]
    delete?: ContextQueryAnalyticsWhereUniqueInput | ContextQueryAnalyticsWhereUniqueInput[]
    connect?: ContextQueryAnalyticsWhereUniqueInput | ContextQueryAnalyticsWhereUniqueInput[]
    update?: ContextQueryAnalyticsUpdateWithWhereUniqueWithoutQueryInput | ContextQueryAnalyticsUpdateWithWhereUniqueWithoutQueryInput[]
    updateMany?: ContextQueryAnalyticsUpdateManyWithWhereWithoutQueryInput | ContextQueryAnalyticsUpdateManyWithWhereWithoutQueryInput[]
    deleteMany?: ContextQueryAnalyticsScalarWhereInput | ContextQueryAnalyticsScalarWhereInput[]
  }

  export type ContextResultUncheckedUpdateManyWithoutQueryNestedInput = {
    create?: XOR<ContextResultCreateWithoutQueryInput, ContextResultUncheckedCreateWithoutQueryInput> | ContextResultCreateWithoutQueryInput[] | ContextResultUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ContextResultCreateOrConnectWithoutQueryInput | ContextResultCreateOrConnectWithoutQueryInput[]
    upsert?: ContextResultUpsertWithWhereUniqueWithoutQueryInput | ContextResultUpsertWithWhereUniqueWithoutQueryInput[]
    createMany?: ContextResultCreateManyQueryInputEnvelope
    set?: ContextResultWhereUniqueInput | ContextResultWhereUniqueInput[]
    disconnect?: ContextResultWhereUniqueInput | ContextResultWhereUniqueInput[]
    delete?: ContextResultWhereUniqueInput | ContextResultWhereUniqueInput[]
    connect?: ContextResultWhereUniqueInput | ContextResultWhereUniqueInput[]
    update?: ContextResultUpdateWithWhereUniqueWithoutQueryInput | ContextResultUpdateWithWhereUniqueWithoutQueryInput[]
    updateMany?: ContextResultUpdateManyWithWhereWithoutQueryInput | ContextResultUpdateManyWithWhereWithoutQueryInput[]
    deleteMany?: ContextResultScalarWhereInput | ContextResultScalarWhereInput[]
  }

  export type ContextQueryAnalyticsUncheckedUpdateManyWithoutQueryNestedInput = {
    create?: XOR<ContextQueryAnalyticsCreateWithoutQueryInput, ContextQueryAnalyticsUncheckedCreateWithoutQueryInput> | ContextQueryAnalyticsCreateWithoutQueryInput[] | ContextQueryAnalyticsUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: ContextQueryAnalyticsCreateOrConnectWithoutQueryInput | ContextQueryAnalyticsCreateOrConnectWithoutQueryInput[]
    upsert?: ContextQueryAnalyticsUpsertWithWhereUniqueWithoutQueryInput | ContextQueryAnalyticsUpsertWithWhereUniqueWithoutQueryInput[]
    createMany?: ContextQueryAnalyticsCreateManyQueryInputEnvelope
    set?: ContextQueryAnalyticsWhereUniqueInput | ContextQueryAnalyticsWhereUniqueInput[]
    disconnect?: ContextQueryAnalyticsWhereUniqueInput | ContextQueryAnalyticsWhereUniqueInput[]
    delete?: ContextQueryAnalyticsWhereUniqueInput | ContextQueryAnalyticsWhereUniqueInput[]
    connect?: ContextQueryAnalyticsWhereUniqueInput | ContextQueryAnalyticsWhereUniqueInput[]
    update?: ContextQueryAnalyticsUpdateWithWhereUniqueWithoutQueryInput | ContextQueryAnalyticsUpdateWithWhereUniqueWithoutQueryInput[]
    updateMany?: ContextQueryAnalyticsUpdateManyWithWhereWithoutQueryInput | ContextQueryAnalyticsUpdateManyWithWhereWithoutQueryInput[]
    deleteMany?: ContextQueryAnalyticsScalarWhereInput | ContextQueryAnalyticsScalarWhereInput[]
  }

  export type ContextQueryCreateNestedOneWithoutResultsInput = {
    create?: XOR<ContextQueryCreateWithoutResultsInput, ContextQueryUncheckedCreateWithoutResultsInput>
    connectOrCreate?: ContextQueryCreateOrConnectWithoutResultsInput
    connect?: ContextQueryWhereUniqueInput
  }

  export type ContextQueryUpdateOneRequiredWithoutResultsNestedInput = {
    create?: XOR<ContextQueryCreateWithoutResultsInput, ContextQueryUncheckedCreateWithoutResultsInput>
    connectOrCreate?: ContextQueryCreateOrConnectWithoutResultsInput
    upsert?: ContextQueryUpsertWithoutResultsInput
    connect?: ContextQueryWhereUniqueInput
    update?: XOR<XOR<ContextQueryUpdateToOneWithWhereWithoutResultsInput, ContextQueryUpdateWithoutResultsInput>, ContextQueryUncheckedUpdateWithoutResultsInput>
  }

  export type ContextTemplateCreatevariablesInput = {
    set: string[]
  }

  export type ContextTemplateUpdatevariablesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ContextQueryCreateNestedOneWithoutAnalyticsInput = {
    create?: XOR<ContextQueryCreateWithoutAnalyticsInput, ContextQueryUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: ContextQueryCreateOrConnectWithoutAnalyticsInput
    connect?: ContextQueryWhereUniqueInput
  }

  export type ContextQueryUpdateOneWithoutAnalyticsNestedInput = {
    create?: XOR<ContextQueryCreateWithoutAnalyticsInput, ContextQueryUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: ContextQueryCreateOrConnectWithoutAnalyticsInput
    upsert?: ContextQueryUpsertWithoutAnalyticsInput
    disconnect?: ContextQueryWhereInput | boolean
    delete?: ContextQueryWhereInput | boolean
    connect?: ContextQueryWhereUniqueInput
    update?: XOR<XOR<ContextQueryUpdateToOneWithWhereWithoutAnalyticsInput, ContextQueryUpdateWithoutAnalyticsInput>, ContextQueryUncheckedUpdateWithoutAnalyticsInput>
  }

  export type UserCreateNestedOneWithoutUserPreferencesInput = {
    create?: XOR<UserCreateWithoutUserPreferencesInput, UserUncheckedCreateWithoutUserPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutUserPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutUserPreferencesInput, UserUncheckedCreateWithoutUserPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPreferencesInput
    upsert?: UserUpsertWithoutUserPreferencesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserPreferencesInput, UserUpdateWithoutUserPreferencesInput>, UserUncheckedUpdateWithoutUserPreferencesInput>
  }

  export type UserCreateNestedOneWithoutThemesInput = {
    create?: XOR<UserCreateWithoutThemesInput, UserUncheckedCreateWithoutThemesInput>
    connectOrCreate?: UserCreateOrConnectWithoutThemesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutThemesNestedInput = {
    create?: XOR<UserCreateWithoutThemesInput, UserUncheckedCreateWithoutThemesInput>
    connectOrCreate?: UserCreateOrConnectWithoutThemesInput
    upsert?: UserUpsertWithoutThemesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutThemesInput, UserUpdateWithoutThemesInput>, UserUncheckedUpdateWithoutThemesInput>
  }

  export type UserCreateNestedOneWithoutPersonalizationAnalyticsInput = {
    create?: XOR<UserCreateWithoutPersonalizationAnalyticsInput, UserUncheckedCreateWithoutPersonalizationAnalyticsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonalizationAnalyticsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPersonalizationAnalyticsNestedInput = {
    create?: XOR<UserCreateWithoutPersonalizationAnalyticsInput, UserUncheckedCreateWithoutPersonalizationAnalyticsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonalizationAnalyticsInput
    upsert?: UserUpsertWithoutPersonalizationAnalyticsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPersonalizationAnalyticsInput, UserUpdateWithoutPersonalizationAnalyticsInput>, UserUncheckedUpdateWithoutPersonalizationAnalyticsInput>
  }

  export type InvoiceCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<InvoiceCreateWithoutUserProfileInput, InvoiceUncheckedCreateWithoutUserProfileInput> | InvoiceCreateWithoutUserProfileInput[] | InvoiceUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserProfileInput | InvoiceCreateOrConnectWithoutUserProfileInput[]
    createMany?: InvoiceCreateManyUserProfileInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<PaymentCreateWithoutUserProfileInput, PaymentUncheckedCreateWithoutUserProfileInput> | PaymentCreateWithoutUserProfileInput[] | PaymentUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserProfileInput | PaymentCreateOrConnectWithoutUserProfileInput[]
    createMany?: PaymentCreateManyUserProfileInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<SubscriptionCreateWithoutUserProfileInput, SubscriptionUncheckedCreateWithoutUserProfileInput> | SubscriptionCreateWithoutUserProfileInput[] | SubscriptionUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserProfileInput | SubscriptionCreateOrConnectWithoutUserProfileInput[]
    createMany?: SubscriptionCreateManyUserProfileInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type CreditCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<CreditCreateWithoutUserProfileInput, CreditUncheckedCreateWithoutUserProfileInput> | CreditCreateWithoutUserProfileInput[] | CreditUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: CreditCreateOrConnectWithoutUserProfileInput | CreditCreateOrConnectWithoutUserProfileInput[]
    createMany?: CreditCreateManyUserProfileInputEnvelope
    connect?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<InvoiceCreateWithoutUserProfileInput, InvoiceUncheckedCreateWithoutUserProfileInput> | InvoiceCreateWithoutUserProfileInput[] | InvoiceUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserProfileInput | InvoiceCreateOrConnectWithoutUserProfileInput[]
    createMany?: InvoiceCreateManyUserProfileInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<PaymentCreateWithoutUserProfileInput, PaymentUncheckedCreateWithoutUserProfileInput> | PaymentCreateWithoutUserProfileInput[] | PaymentUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserProfileInput | PaymentCreateOrConnectWithoutUserProfileInput[]
    createMany?: PaymentCreateManyUserProfileInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<SubscriptionCreateWithoutUserProfileInput, SubscriptionUncheckedCreateWithoutUserProfileInput> | SubscriptionCreateWithoutUserProfileInput[] | SubscriptionUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserProfileInput | SubscriptionCreateOrConnectWithoutUserProfileInput[]
    createMany?: SubscriptionCreateManyUserProfileInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type CreditUncheckedCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<CreditCreateWithoutUserProfileInput, CreditUncheckedCreateWithoutUserProfileInput> | CreditCreateWithoutUserProfileInput[] | CreditUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: CreditCreateOrConnectWithoutUserProfileInput | CreditCreateOrConnectWithoutUserProfileInput[]
    createMany?: CreditCreateManyUserProfileInputEnvelope
    connect?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
  }

  export type InvoiceUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<InvoiceCreateWithoutUserProfileInput, InvoiceUncheckedCreateWithoutUserProfileInput> | InvoiceCreateWithoutUserProfileInput[] | InvoiceUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserProfileInput | InvoiceCreateOrConnectWithoutUserProfileInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUserProfileInput | InvoiceUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: InvoiceCreateManyUserProfileInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUserProfileInput | InvoiceUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUserProfileInput | InvoiceUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<PaymentCreateWithoutUserProfileInput, PaymentUncheckedCreateWithoutUserProfileInput> | PaymentCreateWithoutUserProfileInput[] | PaymentUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserProfileInput | PaymentCreateOrConnectWithoutUserProfileInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserProfileInput | PaymentUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: PaymentCreateManyUserProfileInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserProfileInput | PaymentUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserProfileInput | PaymentUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserProfileInput, SubscriptionUncheckedCreateWithoutUserProfileInput> | SubscriptionCreateWithoutUserProfileInput[] | SubscriptionUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserProfileInput | SubscriptionCreateOrConnectWithoutUserProfileInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutUserProfileInput | SubscriptionUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: SubscriptionCreateManyUserProfileInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutUserProfileInput | SubscriptionUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutUserProfileInput | SubscriptionUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type CreditUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<CreditCreateWithoutUserProfileInput, CreditUncheckedCreateWithoutUserProfileInput> | CreditCreateWithoutUserProfileInput[] | CreditUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: CreditCreateOrConnectWithoutUserProfileInput | CreditCreateOrConnectWithoutUserProfileInput[]
    upsert?: CreditUpsertWithWhereUniqueWithoutUserProfileInput | CreditUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: CreditCreateManyUserProfileInputEnvelope
    set?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
    disconnect?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
    delete?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
    connect?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
    update?: CreditUpdateWithWhereUniqueWithoutUserProfileInput | CreditUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: CreditUpdateManyWithWhereWithoutUserProfileInput | CreditUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: CreditScalarWhereInput | CreditScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<InvoiceCreateWithoutUserProfileInput, InvoiceUncheckedCreateWithoutUserProfileInput> | InvoiceCreateWithoutUserProfileInput[] | InvoiceUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserProfileInput | InvoiceCreateOrConnectWithoutUserProfileInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUserProfileInput | InvoiceUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: InvoiceCreateManyUserProfileInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUserProfileInput | InvoiceUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUserProfileInput | InvoiceUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<PaymentCreateWithoutUserProfileInput, PaymentUncheckedCreateWithoutUserProfileInput> | PaymentCreateWithoutUserProfileInput[] | PaymentUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserProfileInput | PaymentCreateOrConnectWithoutUserProfileInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserProfileInput | PaymentUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: PaymentCreateManyUserProfileInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserProfileInput | PaymentUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserProfileInput | PaymentUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserProfileInput, SubscriptionUncheckedCreateWithoutUserProfileInput> | SubscriptionCreateWithoutUserProfileInput[] | SubscriptionUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserProfileInput | SubscriptionCreateOrConnectWithoutUserProfileInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutUserProfileInput | SubscriptionUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: SubscriptionCreateManyUserProfileInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutUserProfileInput | SubscriptionUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutUserProfileInput | SubscriptionUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type CreditUncheckedUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<CreditCreateWithoutUserProfileInput, CreditUncheckedCreateWithoutUserProfileInput> | CreditCreateWithoutUserProfileInput[] | CreditUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: CreditCreateOrConnectWithoutUserProfileInput | CreditCreateOrConnectWithoutUserProfileInput[]
    upsert?: CreditUpsertWithWhereUniqueWithoutUserProfileInput | CreditUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: CreditCreateManyUserProfileInputEnvelope
    set?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
    disconnect?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
    delete?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
    connect?: CreditWhereUniqueInput | CreditWhereUniqueInput[]
    update?: CreditUpdateWithWhereUniqueWithoutUserProfileInput | CreditUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: CreditUpdateManyWithWhereWithoutUserProfileInput | CreditUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: CreditScalarWhereInput | CreditScalarWhereInput[]
  }

  export type UserProfileCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<UserProfileCreateWithoutInvoicesInput, UserProfileUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutInvoicesInput
    connect?: UserProfileWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: InvoiceStatus
  }

  export type UserProfileUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<UserProfileCreateWithoutInvoicesInput, UserProfileUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutInvoicesInput
    upsert?: UserProfileUpsertWithoutInvoicesInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutInvoicesInput, UserProfileUpdateWithoutInvoicesInput>, UserProfileUncheckedUpdateWithoutInvoicesInput>
  }

  export type PaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type UserProfileCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserProfileCreateWithoutPaymentsInput, UserProfileUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutPaymentsInput
    connect?: UserProfileWhereUniqueInput
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: PaymentStatus
  }

  export type InvoiceUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserProfileUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UserProfileCreateWithoutPaymentsInput, UserProfileUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutPaymentsInput
    upsert?: UserProfileUpsertWithoutPaymentsInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutPaymentsInput, UserProfileUpdateWithoutPaymentsInput>, UserProfileUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserProfileCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<UserProfileCreateWithoutSubscriptionsInput, UserProfileUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutSubscriptionsInput
    connect?: UserProfileWhereUniqueInput
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: SubscriptionStatus
  }

  export type EnumSubscriptionIntervalFieldUpdateOperationsInput = {
    set?: SubscriptionInterval
  }

  export type UserProfileUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<UserProfileCreateWithoutSubscriptionsInput, UserProfileUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutSubscriptionsInput
    upsert?: UserProfileUpsertWithoutSubscriptionsInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutSubscriptionsInput, UserProfileUpdateWithoutSubscriptionsInput>, UserProfileUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UserProfileCreateNestedOneWithoutCreditsInput = {
    create?: XOR<UserProfileCreateWithoutCreditsInput, UserProfileUncheckedCreateWithoutCreditsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutCreditsInput
    connect?: UserProfileWhereUniqueInput
  }

  export type EnumCreditTypeFieldUpdateOperationsInput = {
    set?: CreditType
  }

  export type UserProfileUpdateOneRequiredWithoutCreditsNestedInput = {
    create?: XOR<UserProfileCreateWithoutCreditsInput, UserProfileUncheckedCreateWithoutCreditsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutCreditsInput
    upsert?: UserProfileUpsertWithoutCreditsInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutCreditsInput, UserProfileUpdateWithoutCreditsInput>, UserProfileUncheckedUpdateWithoutCreditsInput>
  }

  export type EnumBillingAlertTypeFieldUpdateOperationsInput = {
    set?: BillingAlertType
  }

  export type PlanCreatefeaturesInput = {
    set: string[]
  }

  export type EnumPlanIntervalFieldUpdateOperationsInput = {
    set?: PlanInterval
  }

  export type PlanUpdatefeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumEnvironmentFilter<$PrismaModel = never> = {
    equals?: Environment | EnumEnvironmentFieldRefInput<$PrismaModel>
    in?: Environment[] | ListEnumEnvironmentFieldRefInput<$PrismaModel>
    notIn?: Environment[] | ListEnumEnvironmentFieldRefInput<$PrismaModel>
    not?: NestedEnumEnvironmentFilter<$PrismaModel> | Environment
  }

  export type NestedEnumEnvironmentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Environment | EnumEnvironmentFieldRefInput<$PrismaModel>
    in?: Environment[] | ListEnumEnvironmentFieldRefInput<$PrismaModel>
    notIn?: Environment[] | ListEnumEnvironmentFieldRefInput<$PrismaModel>
    not?: NestedEnumEnvironmentWithAggregatesFilter<$PrismaModel> | Environment
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEnvironmentFilter<$PrismaModel>
    _max?: NestedEnumEnvironmentFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumConfigStatusFilter<$PrismaModel = never> = {
    equals?: ConfigStatus | EnumConfigStatusFieldRefInput<$PrismaModel>
    in?: ConfigStatus[] | ListEnumConfigStatusFieldRefInput<$PrismaModel>
    notIn?: ConfigStatus[] | ListEnumConfigStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConfigStatusFilter<$PrismaModel> | ConfigStatus
  }

  export type NestedEnumConfigStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: ConfigStatus | EnumConfigStatusFieldRefInput<$PrismaModel>
    in?: ConfigStatus[] | ListEnumConfigStatusFieldRefInput<$PrismaModel>
    notIn?: ConfigStatus[] | ListEnumConfigStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConfigStatusWithAggregatesFilter<$PrismaModel> | ConfigStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConfigStatusFilter<$PrismaModel>
    _max?: NestedEnumConfigStatusFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | InvoiceStatus
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | PaymentStatus
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | SubscriptionStatus
  }

  export type NestedEnumSubscriptionIntervalFilter<$PrismaModel = never> = {
    equals?: SubscriptionInterval | EnumSubscriptionIntervalFieldRefInput<$PrismaModel>
    in?: SubscriptionInterval[] | ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel>
    notIn?: SubscriptionInterval[] | ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionIntervalFilter<$PrismaModel> | SubscriptionInterval
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionIntervalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: SubscriptionInterval | EnumSubscriptionIntervalFieldRefInput<$PrismaModel>
    in?: SubscriptionInterval[] | ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel>
    notIn?: SubscriptionInterval[] | ListEnumSubscriptionIntervalFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionIntervalWithAggregatesFilter<$PrismaModel> | SubscriptionInterval
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionIntervalFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionIntervalFilter<$PrismaModel>
  }

  export type NestedEnumCreditTypeFilter<$PrismaModel = never> = {
    equals?: CreditType | EnumCreditTypeFieldRefInput<$PrismaModel>
    in?: CreditType[] | ListEnumCreditTypeFieldRefInput<$PrismaModel>
    notIn?: CreditType[] | ListEnumCreditTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditTypeFilter<$PrismaModel> | CreditType
  }

  export type NestedEnumCreditTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: CreditType | EnumCreditTypeFieldRefInput<$PrismaModel>
    in?: CreditType[] | ListEnumCreditTypeFieldRefInput<$PrismaModel>
    notIn?: CreditType[] | ListEnumCreditTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditTypeWithAggregatesFilter<$PrismaModel> | CreditType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreditTypeFilter<$PrismaModel>
    _max?: NestedEnumCreditTypeFilter<$PrismaModel>
  }

  export type NestedEnumBillingAlertTypeFilter<$PrismaModel = never> = {
    equals?: BillingAlertType | EnumBillingAlertTypeFieldRefInput<$PrismaModel>
    in?: BillingAlertType[] | ListEnumBillingAlertTypeFieldRefInput<$PrismaModel>
    notIn?: BillingAlertType[] | ListEnumBillingAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingAlertTypeFilter<$PrismaModel> | BillingAlertType
  }

  export type NestedEnumBillingAlertTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: BillingAlertType | EnumBillingAlertTypeFieldRefInput<$PrismaModel>
    in?: BillingAlertType[] | ListEnumBillingAlertTypeFieldRefInput<$PrismaModel>
    notIn?: BillingAlertType[] | ListEnumBillingAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingAlertTypeWithAggregatesFilter<$PrismaModel> | BillingAlertType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillingAlertTypeFilter<$PrismaModel>
    _max?: NestedEnumBillingAlertTypeFilter<$PrismaModel>
  }

  export type NestedEnumPlanIntervalFilter<$PrismaModel = never> = {
    equals?: PlanInterval | EnumPlanIntervalFieldRefInput<$PrismaModel>
    in?: PlanInterval[] | ListEnumPlanIntervalFieldRefInput<$PrismaModel>
    notIn?: PlanInterval[] | ListEnumPlanIntervalFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanIntervalFilter<$PrismaModel> | PlanInterval
  }

  export type NestedEnumPlanIntervalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: PlanInterval | EnumPlanIntervalFieldRefInput<$PrismaModel>
    in?: PlanInterval[] | ListEnumPlanIntervalFieldRefInput<$PrismaModel>
    notIn?: PlanInterval[] | ListEnumPlanIntervalFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanIntervalWithAggregatesFilter<$PrismaModel> | PlanInterval
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanIntervalFilter<$PrismaModel>
    _max?: NestedEnumPlanIntervalFilter<$PrismaModel>
  }

  export type ModuleOnClientCreateWithoutClientInput = {
    id?: string
    enabled?: boolean
    module: ModuleCreateNestedOneWithoutClientsInput
  }

  export type ModuleOnClientUncheckedCreateWithoutClientInput = {
    id?: string
    moduleId: string
    enabled?: boolean
  }

  export type ModuleOnClientCreateOrConnectWithoutClientInput = {
    where: ModuleOnClientWhereUniqueInput
    create: XOR<ModuleOnClientCreateWithoutClientInput, ModuleOnClientUncheckedCreateWithoutClientInput>
  }

  export type ModuleOnClientCreateManyClientInputEnvelope = {
    data: ModuleOnClientCreateManyClientInput | ModuleOnClientCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type EnvironmentVariableCreateWithoutClientInput = {
    id?: string
    key: string
    value: string
    environment?: Environment
  }

  export type EnvironmentVariableUncheckedCreateWithoutClientInput = {
    id?: string
    key: string
    value: string
    environment?: Environment
  }

  export type EnvironmentVariableCreateOrConnectWithoutClientInput = {
    where: EnvironmentVariableWhereUniqueInput
    create: XOR<EnvironmentVariableCreateWithoutClientInput, EnvironmentVariableUncheckedCreateWithoutClientInput>
  }

  export type EnvironmentVariableCreateManyClientInputEnvelope = {
    data: EnvironmentVariableCreateManyClientInput | EnvironmentVariableCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutClientInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    hashedPassword?: string | null
    oauthProvider?: string | null
    oauthId?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    mcpConfigurations?: MCPConfigurationCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messageReactions?: MessageReactionCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    themes?: ThemeCreateNestedManyWithoutCreatorInput
    personalizationAnalytics?: PersonalizationAnalyticsCreateNestedManyWithoutUserInput
    conversationShares?: ConversationShareCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutClientInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    hashedPassword?: string | null
    oauthProvider?: string | null
    oauthId?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    mcpConfigurations?: MCPConfigurationUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messageReactions?: MessageReactionUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    themes?: ThemeUncheckedCreateNestedManyWithoutCreatorInput
    personalizationAnalytics?: PersonalizationAnalyticsUncheckedCreateNestedManyWithoutUserInput
    conversationShares?: ConversationShareUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutClientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
  }

  export type UserCreateManyClientInputEnvelope = {
    data: UserCreateManyClientInput | UserCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type LibraryCreateWithoutClientInput = {
    id: string
    name: string
    displayName: string
    description?: string | null
    vendor?: string | null
    repoUrl?: string | null
    docsUrl?: string | null
    defaultVersion?: string | null
    popularityScore?: number
    totalSnippets?: number
    totalTokens?: number
    language: string
    ecosystem: string
    tags?: LibraryCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastCrawledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: LibraryVersionCreateNestedManyWithoutLibraryInput
    aliases?: LibraryAliasCreateNestedManyWithoutLibraryInput
    documentationChunks?: DocumentationChunkCreateNestedManyWithoutLibraryInput
    usageLogs?: UsageLogCreateNestedManyWithoutLibraryInput
  }

  export type LibraryUncheckedCreateWithoutClientInput = {
    id: string
    name: string
    displayName: string
    description?: string | null
    vendor?: string | null
    repoUrl?: string | null
    docsUrl?: string | null
    defaultVersion?: string | null
    popularityScore?: number
    totalSnippets?: number
    totalTokens?: number
    language: string
    ecosystem: string
    tags?: LibraryCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastCrawledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: LibraryVersionUncheckedCreateNestedManyWithoutLibraryInput
    aliases?: LibraryAliasUncheckedCreateNestedManyWithoutLibraryInput
    documentationChunks?: DocumentationChunkUncheckedCreateNestedManyWithoutLibraryInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutLibraryInput
  }

  export type LibraryCreateOrConnectWithoutClientInput = {
    where: LibraryWhereUniqueInput
    create: XOR<LibraryCreateWithoutClientInput, LibraryUncheckedCreateWithoutClientInput>
  }

  export type LibraryCreateManyClientInputEnvelope = {
    data: LibraryCreateManyClientInput | LibraryCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ModuleOnClientUpsertWithWhereUniqueWithoutClientInput = {
    where: ModuleOnClientWhereUniqueInput
    update: XOR<ModuleOnClientUpdateWithoutClientInput, ModuleOnClientUncheckedUpdateWithoutClientInput>
    create: XOR<ModuleOnClientCreateWithoutClientInput, ModuleOnClientUncheckedCreateWithoutClientInput>
  }

  export type ModuleOnClientUpdateWithWhereUniqueWithoutClientInput = {
    where: ModuleOnClientWhereUniqueInput
    data: XOR<ModuleOnClientUpdateWithoutClientInput, ModuleOnClientUncheckedUpdateWithoutClientInput>
  }

  export type ModuleOnClientUpdateManyWithWhereWithoutClientInput = {
    where: ModuleOnClientScalarWhereInput
    data: XOR<ModuleOnClientUpdateManyMutationInput, ModuleOnClientUncheckedUpdateManyWithoutClientInput>
  }

  export type ModuleOnClientScalarWhereInput = {
    AND?: ModuleOnClientScalarWhereInput | ModuleOnClientScalarWhereInput[]
    OR?: ModuleOnClientScalarWhereInput[]
    NOT?: ModuleOnClientScalarWhereInput | ModuleOnClientScalarWhereInput[]
    id?: StringFilter<"ModuleOnClient"> | string
    clientId?: StringFilter<"ModuleOnClient"> | string
    moduleId?: StringFilter<"ModuleOnClient"> | string
    enabled?: BoolFilter<"ModuleOnClient"> | boolean
  }

  export type EnvironmentVariableUpsertWithWhereUniqueWithoutClientInput = {
    where: EnvironmentVariableWhereUniqueInput
    update: XOR<EnvironmentVariableUpdateWithoutClientInput, EnvironmentVariableUncheckedUpdateWithoutClientInput>
    create: XOR<EnvironmentVariableCreateWithoutClientInput, EnvironmentVariableUncheckedCreateWithoutClientInput>
  }

  export type EnvironmentVariableUpdateWithWhereUniqueWithoutClientInput = {
    where: EnvironmentVariableWhereUniqueInput
    data: XOR<EnvironmentVariableUpdateWithoutClientInput, EnvironmentVariableUncheckedUpdateWithoutClientInput>
  }

  export type EnvironmentVariableUpdateManyWithWhereWithoutClientInput = {
    where: EnvironmentVariableScalarWhereInput
    data: XOR<EnvironmentVariableUpdateManyMutationInput, EnvironmentVariableUncheckedUpdateManyWithoutClientInput>
  }

  export type EnvironmentVariableScalarWhereInput = {
    AND?: EnvironmentVariableScalarWhereInput | EnvironmentVariableScalarWhereInput[]
    OR?: EnvironmentVariableScalarWhereInput[]
    NOT?: EnvironmentVariableScalarWhereInput | EnvironmentVariableScalarWhereInput[]
    id?: StringFilter<"EnvironmentVariable"> | string
    key?: StringFilter<"EnvironmentVariable"> | string
    value?: StringFilter<"EnvironmentVariable"> | string
    environment?: EnumEnvironmentFilter<"EnvironmentVariable"> | Environment
    clientId?: StringFilter<"EnvironmentVariable"> | string
  }

  export type UserUpsertWithWhereUniqueWithoutClientInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutClientInput, UserUncheckedUpdateWithoutClientInput>
    create: XOR<UserCreateWithoutClientInput, UserUncheckedCreateWithoutClientInput>
  }

  export type UserUpdateWithWhereUniqueWithoutClientInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutClientInput, UserUncheckedUpdateWithoutClientInput>
  }

  export type UserUpdateManyWithWhereWithoutClientInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutClientInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    hashedPassword?: StringNullableFilter<"User"> | string | null
    oauthProvider?: StringNullableFilter<"User"> | string | null
    oauthId?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | Role
    clientId?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type LibraryUpsertWithWhereUniqueWithoutClientInput = {
    where: LibraryWhereUniqueInput
    update: XOR<LibraryUpdateWithoutClientInput, LibraryUncheckedUpdateWithoutClientInput>
    create: XOR<LibraryCreateWithoutClientInput, LibraryUncheckedCreateWithoutClientInput>
  }

  export type LibraryUpdateWithWhereUniqueWithoutClientInput = {
    where: LibraryWhereUniqueInput
    data: XOR<LibraryUpdateWithoutClientInput, LibraryUncheckedUpdateWithoutClientInput>
  }

  export type LibraryUpdateManyWithWhereWithoutClientInput = {
    where: LibraryScalarWhereInput
    data: XOR<LibraryUpdateManyMutationInput, LibraryUncheckedUpdateManyWithoutClientInput>
  }

  export type LibraryScalarWhereInput = {
    AND?: LibraryScalarWhereInput | LibraryScalarWhereInput[]
    OR?: LibraryScalarWhereInput[]
    NOT?: LibraryScalarWhereInput | LibraryScalarWhereInput[]
    id?: StringFilter<"Library"> | string
    name?: StringFilter<"Library"> | string
    displayName?: StringFilter<"Library"> | string
    description?: StringNullableFilter<"Library"> | string | null
    vendor?: StringNullableFilter<"Library"> | string | null
    repoUrl?: StringNullableFilter<"Library"> | string | null
    docsUrl?: StringNullableFilter<"Library"> | string | null
    defaultVersion?: StringNullableFilter<"Library"> | string | null
    popularityScore?: FloatFilter<"Library"> | number
    totalSnippets?: IntFilter<"Library"> | number
    totalTokens?: IntFilter<"Library"> | number
    language?: StringFilter<"Library"> | string
    ecosystem?: StringFilter<"Library"> | string
    tags?: StringNullableListFilter<"Library">
    metadata?: JsonNullableFilter<"Library">
    clientId?: StringFilter<"Library"> | string
    lastCrawledAt?: DateTimeNullableFilter<"Library"> | Date | string | null
    createdAt?: DateTimeFilter<"Library"> | Date | string
    updatedAt?: DateTimeFilter<"Library"> | Date | string
  }

  export type ModuleOnClientCreateWithoutModuleInput = {
    id?: string
    enabled?: boolean
    client: ClientCreateNestedOneWithoutModulesInput
  }

  export type ModuleOnClientUncheckedCreateWithoutModuleInput = {
    id?: string
    clientId: string
    enabled?: boolean
  }

  export type ModuleOnClientCreateOrConnectWithoutModuleInput = {
    where: ModuleOnClientWhereUniqueInput
    create: XOR<ModuleOnClientCreateWithoutModuleInput, ModuleOnClientUncheckedCreateWithoutModuleInput>
  }

  export type ModuleOnClientCreateManyModuleInputEnvelope = {
    data: ModuleOnClientCreateManyModuleInput | ModuleOnClientCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type ModuleOnClientUpsertWithWhereUniqueWithoutModuleInput = {
    where: ModuleOnClientWhereUniqueInput
    update: XOR<ModuleOnClientUpdateWithoutModuleInput, ModuleOnClientUncheckedUpdateWithoutModuleInput>
    create: XOR<ModuleOnClientCreateWithoutModuleInput, ModuleOnClientUncheckedCreateWithoutModuleInput>
  }

  export type ModuleOnClientUpdateWithWhereUniqueWithoutModuleInput = {
    where: ModuleOnClientWhereUniqueInput
    data: XOR<ModuleOnClientUpdateWithoutModuleInput, ModuleOnClientUncheckedUpdateWithoutModuleInput>
  }

  export type ModuleOnClientUpdateManyWithWhereWithoutModuleInput = {
    where: ModuleOnClientScalarWhereInput
    data: XOR<ModuleOnClientUpdateManyMutationInput, ModuleOnClientUncheckedUpdateManyWithoutModuleInput>
  }

  export type ClientCreateWithoutModulesInput = {
    id?: string
    name: string
    domain?: string | null
    apiKeys: JsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    environmentVariables?: EnvironmentVariableCreateNestedManyWithoutClientInput
    users?: UserCreateNestedManyWithoutClientInput
    libraries?: LibraryCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutModulesInput = {
    id?: string
    name: string
    domain?: string | null
    apiKeys: JsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    environmentVariables?: EnvironmentVariableUncheckedCreateNestedManyWithoutClientInput
    users?: UserUncheckedCreateNestedManyWithoutClientInput
    libraries?: LibraryUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutModulesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutModulesInput, ClientUncheckedCreateWithoutModulesInput>
  }

  export type ModuleCreateWithoutClientsInput = {
    id?: string
    name: string
    description?: string | null
    version?: string | null
  }

  export type ModuleUncheckedCreateWithoutClientsInput = {
    id?: string
    name: string
    description?: string | null
    version?: string | null
  }

  export type ModuleCreateOrConnectWithoutClientsInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutClientsInput, ModuleUncheckedCreateWithoutClientsInput>
  }

  export type ClientUpsertWithoutModulesInput = {
    update: XOR<ClientUpdateWithoutModulesInput, ClientUncheckedUpdateWithoutModulesInput>
    create: XOR<ClientCreateWithoutModulesInput, ClientUncheckedCreateWithoutModulesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutModulesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutModulesInput, ClientUncheckedUpdateWithoutModulesInput>
  }

  export type ClientUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    apiKeys?: JsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    environmentVariables?: EnvironmentVariableUpdateManyWithoutClientNestedInput
    users?: UserUpdateManyWithoutClientNestedInput
    libraries?: LibraryUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    apiKeys?: JsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    environmentVariables?: EnvironmentVariableUncheckedUpdateManyWithoutClientNestedInput
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
    libraries?: LibraryUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ModuleUpsertWithoutClientsInput = {
    update: XOR<ModuleUpdateWithoutClientsInput, ModuleUncheckedUpdateWithoutClientsInput>
    create: XOR<ModuleCreateWithoutClientsInput, ModuleUncheckedCreateWithoutClientsInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutClientsInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutClientsInput, ModuleUncheckedUpdateWithoutClientsInput>
  }

  export type ModuleUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ModuleUncheckedUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientCreateWithoutEnvironmentVariablesInput = {
    id?: string
    name: string
    domain?: string | null
    apiKeys: JsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleOnClientCreateNestedManyWithoutClientInput
    users?: UserCreateNestedManyWithoutClientInput
    libraries?: LibraryCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutEnvironmentVariablesInput = {
    id?: string
    name: string
    domain?: string | null
    apiKeys: JsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleOnClientUncheckedCreateNestedManyWithoutClientInput
    users?: UserUncheckedCreateNestedManyWithoutClientInput
    libraries?: LibraryUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutEnvironmentVariablesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutEnvironmentVariablesInput, ClientUncheckedCreateWithoutEnvironmentVariablesInput>
  }

  export type ClientUpsertWithoutEnvironmentVariablesInput = {
    update: XOR<ClientUpdateWithoutEnvironmentVariablesInput, ClientUncheckedUpdateWithoutEnvironmentVariablesInput>
    create: XOR<ClientCreateWithoutEnvironmentVariablesInput, ClientUncheckedCreateWithoutEnvironmentVariablesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutEnvironmentVariablesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutEnvironmentVariablesInput, ClientUncheckedUpdateWithoutEnvironmentVariablesInput>
  }

  export type ClientUpdateWithoutEnvironmentVariablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    apiKeys?: JsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleOnClientUpdateManyWithoutClientNestedInput
    users?: UserUpdateManyWithoutClientNestedInput
    libraries?: LibraryUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutEnvironmentVariablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    apiKeys?: JsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleOnClientUncheckedUpdateManyWithoutClientNestedInput
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
    libraries?: LibraryUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateWithoutUsersInput = {
    id?: string
    name: string
    domain?: string | null
    apiKeys: JsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleOnClientCreateNestedManyWithoutClientInput
    environmentVariables?: EnvironmentVariableCreateNestedManyWithoutClientInput
    libraries?: LibraryCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    domain?: string | null
    apiKeys: JsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleOnClientUncheckedCreateNestedManyWithoutClientInput
    environmentVariables?: EnvironmentVariableUncheckedCreateNestedManyWithoutClientInput
    libraries?: LibraryUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutUsersInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutUsersInput, ClientUncheckedCreateWithoutUsersInput>
  }

  export type ApiKeyCreateWithoutUserInput = {
    id?: string
    keyHash: string
    keyPrefix: string
    name?: string | null
    tier?: string
    quotaDaily?: number
    quotaMonthly?: number
    usedDaily?: number
    usedMonthly?: number
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
    usageLogs?: UsageLogCreateNestedManyWithoutApiKeyInput
  }

  export type ApiKeyUncheckedCreateWithoutUserInput = {
    id?: string
    keyHash: string
    keyPrefix: string
    name?: string | null
    tier?: string
    quotaDaily?: number
    quotaMonthly?: number
    usedDaily?: number
    usedMonthly?: number
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutApiKeyInput
  }

  export type ApiKeyCreateOrConnectWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    create: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>
  }

  export type ApiKeyCreateManyUserInputEnvelope = {
    data: ApiKeyCreateManyUserInput | ApiKeyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MCPConfigurationCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    configData: JsonNullValueInput | InputJsonValue
    status?: ConfigStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MCPConfigurationUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    configData: JsonNullValueInput | InputJsonValue
    status?: ConfigStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MCPConfigurationCreateOrConnectWithoutUserInput = {
    where: MCPConfigurationWhereUniqueInput
    create: XOR<MCPConfigurationCreateWithoutUserInput, MCPConfigurationUncheckedCreateWithoutUserInput>
  }

  export type MCPConfigurationCreateManyUserInputEnvelope = {
    data: MCPConfigurationCreateManyUserInput | MCPConfigurationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UsageLogCreateWithoutUserInput = {
    id?: string
    toolName: string
    query?: string | null
    tokensReturned?: number | null
    responseTimeMs?: number | null
    createdAt?: Date | string
    apiKey?: ApiKeyCreateNestedOneWithoutUsageLogsInput
    library?: LibraryCreateNestedOneWithoutUsageLogsInput
  }

  export type UsageLogUncheckedCreateWithoutUserInput = {
    id?: string
    apiKeyId?: string | null
    libraryId?: string | null
    toolName: string
    query?: string | null
    tokensReturned?: number | null
    responseTimeMs?: number | null
    createdAt?: Date | string
  }

  export type UsageLogCreateOrConnectWithoutUserInput = {
    where: UsageLogWhereUniqueInput
    create: XOR<UsageLogCreateWithoutUserInput, UsageLogUncheckedCreateWithoutUserInput>
  }

  export type UsageLogCreateManyUserInputEnvelope = {
    data: UsageLogCreateManyUserInput | UsageLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OAuthTokenCreateWithoutUserInput = {
    id?: string
    provider: string
    accessToken: string
    refreshToken?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OAuthTokenUncheckedCreateWithoutUserInput = {
    id?: string
    provider: string
    accessToken: string
    refreshToken?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OAuthTokenCreateOrConnectWithoutUserInput = {
    where: OAuthTokenWhereUniqueInput
    create: XOR<OAuthTokenCreateWithoutUserInput, OAuthTokenUncheckedCreateWithoutUserInput>
  }

  export type OAuthTokenCreateManyUserInputEnvelope = {
    data: OAuthTokenCreateManyUserInput | OAuthTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutUserInput = {
    id?: string
    title: string
    metadata?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageCreateNestedManyWithoutConversationInput
    shares?: ConversationShareCreateNestedManyWithoutConversationInput
    exports?: ConversationExportCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    metadata?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    shares?: ConversationShareUncheckedCreateNestedManyWithoutConversationInput
    exports?: ConversationExportUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutUserInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput>
  }

  export type ConversationCreateManyUserInputEnvelope = {
    data: ConversationCreateManyUserInput | ConversationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageReactionCreateWithoutUserInput = {
    id?: string
    emoji: string
    timestamp?: Date | string
    message: MessageCreateNestedOneWithoutReactionsInput
  }

  export type MessageReactionUncheckedCreateWithoutUserInput = {
    id?: string
    messageId: string
    emoji: string
    timestamp?: Date | string
  }

  export type MessageReactionCreateOrConnectWithoutUserInput = {
    where: MessageReactionWhereUniqueInput
    create: XOR<MessageReactionCreateWithoutUserInput, MessageReactionUncheckedCreateWithoutUserInput>
  }

  export type MessageReactionCreateManyUserInputEnvelope = {
    data: MessageReactionCreateManyUserInput | MessageReactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserPreferencesCreateWithoutUserInput = {
    id?: string
    preferences: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferencesUncheckedCreateWithoutUserInput = {
    id?: string
    preferences: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferencesCreateOrConnectWithoutUserInput = {
    where: UserPreferencesWhereUniqueInput
    create: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
  }

  export type ThemeCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    colors: JsonNullValueInput | InputJsonValue
    typography: JsonNullValueInput | InputJsonValue
    spacing: JsonNullValueInput | InputJsonValue
    shadows: JsonNullValueInput | InputJsonValue
    borderRadius: JsonNullValueInput | InputJsonValue
    animations: JsonNullValueInput | InputJsonValue
    custom?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ThemeUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    colors: JsonNullValueInput | InputJsonValue
    typography: JsonNullValueInput | InputJsonValue
    spacing: JsonNullValueInput | InputJsonValue
    shadows: JsonNullValueInput | InputJsonValue
    borderRadius: JsonNullValueInput | InputJsonValue
    animations: JsonNullValueInput | InputJsonValue
    custom?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ThemeCreateOrConnectWithoutCreatorInput = {
    where: ThemeWhereUniqueInput
    create: XOR<ThemeCreateWithoutCreatorInput, ThemeUncheckedCreateWithoutCreatorInput>
  }

  export type ThemeCreateManyCreatorInputEnvelope = {
    data: ThemeCreateManyCreatorInput | ThemeCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type PersonalizationAnalyticsCreateWithoutUserInput = {
    id?: string
    actionType: string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PersonalizationAnalyticsUncheckedCreateWithoutUserInput = {
    id?: string
    actionType: string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PersonalizationAnalyticsCreateOrConnectWithoutUserInput = {
    where: PersonalizationAnalyticsWhereUniqueInput
    create: XOR<PersonalizationAnalyticsCreateWithoutUserInput, PersonalizationAnalyticsUncheckedCreateWithoutUserInput>
  }

  export type PersonalizationAnalyticsCreateManyUserInputEnvelope = {
    data: PersonalizationAnalyticsCreateManyUserInput | PersonalizationAnalyticsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConversationShareCreateWithoutCreatorInput = {
    id?: string
    shareId: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    conversation: ConversationCreateNestedOneWithoutSharesInput
  }

  export type ConversationShareUncheckedCreateWithoutCreatorInput = {
    id?: string
    conversationId: string
    shareId: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
  }

  export type ConversationShareCreateOrConnectWithoutCreatorInput = {
    where: ConversationShareWhereUniqueInput
    create: XOR<ConversationShareCreateWithoutCreatorInput, ConversationShareUncheckedCreateWithoutCreatorInput>
  }

  export type ConversationShareCreateManyCreatorInputEnvelope = {
    data: ConversationShareCreateManyCreatorInput | ConversationShareCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutUsersInput = {
    update: XOR<ClientUpdateWithoutUsersInput, ClientUncheckedUpdateWithoutUsersInput>
    create: XOR<ClientCreateWithoutUsersInput, ClientUncheckedCreateWithoutUsersInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutUsersInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutUsersInput, ClientUncheckedUpdateWithoutUsersInput>
  }

  export type ClientUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    apiKeys?: JsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleOnClientUpdateManyWithoutClientNestedInput
    environmentVariables?: EnvironmentVariableUpdateManyWithoutClientNestedInput
    libraries?: LibraryUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    apiKeys?: JsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleOnClientUncheckedUpdateManyWithoutClientNestedInput
    environmentVariables?: EnvironmentVariableUncheckedUpdateManyWithoutClientNestedInput
    libraries?: LibraryUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ApiKeyUpsertWithWhereUniqueWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    update: XOR<ApiKeyUpdateWithoutUserInput, ApiKeyUncheckedUpdateWithoutUserInput>
    create: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>
  }

  export type ApiKeyUpdateWithWhereUniqueWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    data: XOR<ApiKeyUpdateWithoutUserInput, ApiKeyUncheckedUpdateWithoutUserInput>
  }

  export type ApiKeyUpdateManyWithWhereWithoutUserInput = {
    where: ApiKeyScalarWhereInput
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyWithoutUserInput>
  }

  export type ApiKeyScalarWhereInput = {
    AND?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    OR?: ApiKeyScalarWhereInput[]
    NOT?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    userId?: StringFilter<"ApiKey"> | string
    keyHash?: StringFilter<"ApiKey"> | string
    keyPrefix?: StringFilter<"ApiKey"> | string
    name?: StringNullableFilter<"ApiKey"> | string | null
    tier?: StringFilter<"ApiKey"> | string
    quotaDaily?: IntFilter<"ApiKey"> | number
    quotaMonthly?: IntFilter<"ApiKey"> | number
    usedDaily?: IntFilter<"ApiKey"> | number
    usedMonthly?: IntFilter<"ApiKey"> | number
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    isActive?: BoolFilter<"ApiKey"> | boolean
    permissions?: JsonFilter<"ApiKey">
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
    revokedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
  }

  export type MCPConfigurationUpsertWithWhereUniqueWithoutUserInput = {
    where: MCPConfigurationWhereUniqueInput
    update: XOR<MCPConfigurationUpdateWithoutUserInput, MCPConfigurationUncheckedUpdateWithoutUserInput>
    create: XOR<MCPConfigurationCreateWithoutUserInput, MCPConfigurationUncheckedCreateWithoutUserInput>
  }

  export type MCPConfigurationUpdateWithWhereUniqueWithoutUserInput = {
    where: MCPConfigurationWhereUniqueInput
    data: XOR<MCPConfigurationUpdateWithoutUserInput, MCPConfigurationUncheckedUpdateWithoutUserInput>
  }

  export type MCPConfigurationUpdateManyWithWhereWithoutUserInput = {
    where: MCPConfigurationScalarWhereInput
    data: XOR<MCPConfigurationUpdateManyMutationInput, MCPConfigurationUncheckedUpdateManyWithoutUserInput>
  }

  export type MCPConfigurationScalarWhereInput = {
    AND?: MCPConfigurationScalarWhereInput | MCPConfigurationScalarWhereInput[]
    OR?: MCPConfigurationScalarWhereInput[]
    NOT?: MCPConfigurationScalarWhereInput | MCPConfigurationScalarWhereInput[]
    id?: StringFilter<"MCPConfiguration"> | string
    name?: StringFilter<"MCPConfiguration"> | string
    description?: StringNullableFilter<"MCPConfiguration"> | string | null
    configData?: JsonFilter<"MCPConfiguration">
    status?: EnumConfigStatusFilter<"MCPConfiguration"> | ConfigStatus
    userId?: StringFilter<"MCPConfiguration"> | string
    createdAt?: DateTimeFilter<"MCPConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"MCPConfiguration"> | Date | string
  }

  export type UsageLogUpsertWithWhereUniqueWithoutUserInput = {
    where: UsageLogWhereUniqueInput
    update: XOR<UsageLogUpdateWithoutUserInput, UsageLogUncheckedUpdateWithoutUserInput>
    create: XOR<UsageLogCreateWithoutUserInput, UsageLogUncheckedCreateWithoutUserInput>
  }

  export type UsageLogUpdateWithWhereUniqueWithoutUserInput = {
    where: UsageLogWhereUniqueInput
    data: XOR<UsageLogUpdateWithoutUserInput, UsageLogUncheckedUpdateWithoutUserInput>
  }

  export type UsageLogUpdateManyWithWhereWithoutUserInput = {
    where: UsageLogScalarWhereInput
    data: XOR<UsageLogUpdateManyMutationInput, UsageLogUncheckedUpdateManyWithoutUserInput>
  }

  export type UsageLogScalarWhereInput = {
    AND?: UsageLogScalarWhereInput | UsageLogScalarWhereInput[]
    OR?: UsageLogScalarWhereInput[]
    NOT?: UsageLogScalarWhereInput | UsageLogScalarWhereInput[]
    id?: StringFilter<"UsageLog"> | string
    userId?: StringNullableFilter<"UsageLog"> | string | null
    apiKeyId?: StringNullableFilter<"UsageLog"> | string | null
    libraryId?: StringNullableFilter<"UsageLog"> | string | null
    toolName?: StringFilter<"UsageLog"> | string
    query?: StringNullableFilter<"UsageLog"> | string | null
    tokensReturned?: IntNullableFilter<"UsageLog"> | number | null
    responseTimeMs?: IntNullableFilter<"UsageLog"> | number | null
    createdAt?: DateTimeFilter<"UsageLog"> | Date | string
  }

  export type OAuthTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: OAuthTokenWhereUniqueInput
    update: XOR<OAuthTokenUpdateWithoutUserInput, OAuthTokenUncheckedUpdateWithoutUserInput>
    create: XOR<OAuthTokenCreateWithoutUserInput, OAuthTokenUncheckedCreateWithoutUserInput>
  }

  export type OAuthTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: OAuthTokenWhereUniqueInput
    data: XOR<OAuthTokenUpdateWithoutUserInput, OAuthTokenUncheckedUpdateWithoutUserInput>
  }

  export type OAuthTokenUpdateManyWithWhereWithoutUserInput = {
    where: OAuthTokenScalarWhereInput
    data: XOR<OAuthTokenUpdateManyMutationInput, OAuthTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type OAuthTokenScalarWhereInput = {
    AND?: OAuthTokenScalarWhereInput | OAuthTokenScalarWhereInput[]
    OR?: OAuthTokenScalarWhereInput[]
    NOT?: OAuthTokenScalarWhereInput | OAuthTokenScalarWhereInput[]
    id?: StringFilter<"OAuthToken"> | string
    userId?: StringFilter<"OAuthToken"> | string
    provider?: StringFilter<"OAuthToken"> | string
    accessToken?: StringFilter<"OAuthToken"> | string
    refreshToken?: StringNullableFilter<"OAuthToken"> | string | null
    expiresAt?: DateTimeFilter<"OAuthToken"> | Date | string
    createdAt?: DateTimeFilter<"OAuthToken"> | Date | string
  }

  export type ConversationUpsertWithWhereUniqueWithoutUserInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutUserInput, ConversationUncheckedUpdateWithoutUserInput>
    create: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutUserInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutUserInput, ConversationUncheckedUpdateWithoutUserInput>
  }

  export type ConversationUpdateManyWithWhereWithoutUserInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutUserInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: StringFilter<"Conversation"> | string
    userId?: StringFilter<"Conversation"> | string
    title?: StringFilter<"Conversation"> | string
    metadata?: JsonFilter<"Conversation">
    settings?: JsonFilter<"Conversation">
    analytics?: JsonFilter<"Conversation">
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
  }

  export type MessageReactionUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageReactionWhereUniqueInput
    update: XOR<MessageReactionUpdateWithoutUserInput, MessageReactionUncheckedUpdateWithoutUserInput>
    create: XOR<MessageReactionCreateWithoutUserInput, MessageReactionUncheckedCreateWithoutUserInput>
  }

  export type MessageReactionUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageReactionWhereUniqueInput
    data: XOR<MessageReactionUpdateWithoutUserInput, MessageReactionUncheckedUpdateWithoutUserInput>
  }

  export type MessageReactionUpdateManyWithWhereWithoutUserInput = {
    where: MessageReactionScalarWhereInput
    data: XOR<MessageReactionUpdateManyMutationInput, MessageReactionUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageReactionScalarWhereInput = {
    AND?: MessageReactionScalarWhereInput | MessageReactionScalarWhereInput[]
    OR?: MessageReactionScalarWhereInput[]
    NOT?: MessageReactionScalarWhereInput | MessageReactionScalarWhereInput[]
    id?: StringFilter<"MessageReaction"> | string
    messageId?: StringFilter<"MessageReaction"> | string
    userId?: StringFilter<"MessageReaction"> | string
    emoji?: StringFilter<"MessageReaction"> | string
    timestamp?: DateTimeFilter<"MessageReaction"> | Date | string
  }

  export type UserPreferencesUpsertWithoutUserInput = {
    update: XOR<UserPreferencesUpdateWithoutUserInput, UserPreferencesUncheckedUpdateWithoutUserInput>
    create: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    where?: UserPreferencesWhereInput
  }

  export type UserPreferencesUpdateToOneWithWhereWithoutUserInput = {
    where?: UserPreferencesWhereInput
    data: XOR<UserPreferencesUpdateWithoutUserInput, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type UserPreferencesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThemeUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ThemeWhereUniqueInput
    update: XOR<ThemeUpdateWithoutCreatorInput, ThemeUncheckedUpdateWithoutCreatorInput>
    create: XOR<ThemeCreateWithoutCreatorInput, ThemeUncheckedCreateWithoutCreatorInput>
  }

  export type ThemeUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ThemeWhereUniqueInput
    data: XOR<ThemeUpdateWithoutCreatorInput, ThemeUncheckedUpdateWithoutCreatorInput>
  }

  export type ThemeUpdateManyWithWhereWithoutCreatorInput = {
    where: ThemeScalarWhereInput
    data: XOR<ThemeUpdateManyMutationInput, ThemeUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ThemeScalarWhereInput = {
    AND?: ThemeScalarWhereInput | ThemeScalarWhereInput[]
    OR?: ThemeScalarWhereInput[]
    NOT?: ThemeScalarWhereInput | ThemeScalarWhereInput[]
    id?: StringFilter<"Theme"> | string
    name?: StringFilter<"Theme"> | string
    description?: StringNullableFilter<"Theme"> | string | null
    category?: StringFilter<"Theme"> | string
    colors?: JsonFilter<"Theme">
    typography?: JsonFilter<"Theme">
    spacing?: JsonFilter<"Theme">
    shadows?: JsonFilter<"Theme">
    borderRadius?: JsonFilter<"Theme">
    animations?: JsonFilter<"Theme">
    custom?: BoolFilter<"Theme"> | boolean
    createdBy?: StringNullableFilter<"Theme"> | string | null
    createdAt?: DateTimeFilter<"Theme"> | Date | string
    updatedAt?: DateTimeFilter<"Theme"> | Date | string
  }

  export type PersonalizationAnalyticsUpsertWithWhereUniqueWithoutUserInput = {
    where: PersonalizationAnalyticsWhereUniqueInput
    update: XOR<PersonalizationAnalyticsUpdateWithoutUserInput, PersonalizationAnalyticsUncheckedUpdateWithoutUserInput>
    create: XOR<PersonalizationAnalyticsCreateWithoutUserInput, PersonalizationAnalyticsUncheckedCreateWithoutUserInput>
  }

  export type PersonalizationAnalyticsUpdateWithWhereUniqueWithoutUserInput = {
    where: PersonalizationAnalyticsWhereUniqueInput
    data: XOR<PersonalizationAnalyticsUpdateWithoutUserInput, PersonalizationAnalyticsUncheckedUpdateWithoutUserInput>
  }

  export type PersonalizationAnalyticsUpdateManyWithWhereWithoutUserInput = {
    where: PersonalizationAnalyticsScalarWhereInput
    data: XOR<PersonalizationAnalyticsUpdateManyMutationInput, PersonalizationAnalyticsUncheckedUpdateManyWithoutUserInput>
  }

  export type PersonalizationAnalyticsScalarWhereInput = {
    AND?: PersonalizationAnalyticsScalarWhereInput | PersonalizationAnalyticsScalarWhereInput[]
    OR?: PersonalizationAnalyticsScalarWhereInput[]
    NOT?: PersonalizationAnalyticsScalarWhereInput | PersonalizationAnalyticsScalarWhereInput[]
    id?: StringFilter<"PersonalizationAnalytics"> | string
    userId?: StringFilter<"PersonalizationAnalytics"> | string
    actionType?: StringFilter<"PersonalizationAnalytics"> | string
    metadata?: JsonFilter<"PersonalizationAnalytics">
    createdAt?: DateTimeFilter<"PersonalizationAnalytics"> | Date | string
  }

  export type ConversationShareUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ConversationShareWhereUniqueInput
    update: XOR<ConversationShareUpdateWithoutCreatorInput, ConversationShareUncheckedUpdateWithoutCreatorInput>
    create: XOR<ConversationShareCreateWithoutCreatorInput, ConversationShareUncheckedCreateWithoutCreatorInput>
  }

  export type ConversationShareUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ConversationShareWhereUniqueInput
    data: XOR<ConversationShareUpdateWithoutCreatorInput, ConversationShareUncheckedUpdateWithoutCreatorInput>
  }

  export type ConversationShareUpdateManyWithWhereWithoutCreatorInput = {
    where: ConversationShareScalarWhereInput
    data: XOR<ConversationShareUpdateManyMutationInput, ConversationShareUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ConversationShareScalarWhereInput = {
    AND?: ConversationShareScalarWhereInput | ConversationShareScalarWhereInput[]
    OR?: ConversationShareScalarWhereInput[]
    NOT?: ConversationShareScalarWhereInput | ConversationShareScalarWhereInput[]
    id?: StringFilter<"ConversationShare"> | string
    conversationId?: StringFilter<"ConversationShare"> | string
    shareId?: StringFilter<"ConversationShare"> | string
    createdBy?: StringFilter<"ConversationShare"> | string
    createdAt?: DateTimeFilter<"ConversationShare"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ConversationShare"> | Date | string | null
    permissions?: JsonFilter<"ConversationShare">
    settings?: JsonFilter<"ConversationShare">
    analytics?: JsonFilter<"ConversationShare">
  }

  export type ClientCreateWithoutLibrariesInput = {
    id?: string
    name: string
    domain?: string | null
    apiKeys: JsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleOnClientCreateNestedManyWithoutClientInput
    environmentVariables?: EnvironmentVariableCreateNestedManyWithoutClientInput
    users?: UserCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutLibrariesInput = {
    id?: string
    name: string
    domain?: string | null
    apiKeys: JsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    modules?: ModuleOnClientUncheckedCreateNestedManyWithoutClientInput
    environmentVariables?: EnvironmentVariableUncheckedCreateNestedManyWithoutClientInput
    users?: UserUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutLibrariesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutLibrariesInput, ClientUncheckedCreateWithoutLibrariesInput>
  }

  export type LibraryVersionCreateWithoutLibraryInput = {
    id?: string
    version: string
    releaseDate?: Date | string | null
    isLatest?: boolean
    docsSnapshotUrl?: string | null
    documentationChunks?: DocumentationChunkCreateNestedManyWithoutLibraryVersionInput
  }

  export type LibraryVersionUncheckedCreateWithoutLibraryInput = {
    id?: string
    version: string
    releaseDate?: Date | string | null
    isLatest?: boolean
    docsSnapshotUrl?: string | null
    documentationChunks?: DocumentationChunkUncheckedCreateNestedManyWithoutLibraryVersionInput
  }

  export type LibraryVersionCreateOrConnectWithoutLibraryInput = {
    where: LibraryVersionWhereUniqueInput
    create: XOR<LibraryVersionCreateWithoutLibraryInput, LibraryVersionUncheckedCreateWithoutLibraryInput>
  }

  export type LibraryVersionCreateManyLibraryInputEnvelope = {
    data: LibraryVersionCreateManyLibraryInput | LibraryVersionCreateManyLibraryInput[]
    skipDuplicates?: boolean
  }

  export type LibraryAliasCreateWithoutLibraryInput = {
    id?: string
    alias: string
  }

  export type LibraryAliasUncheckedCreateWithoutLibraryInput = {
    id?: string
    alias: string
  }

  export type LibraryAliasCreateOrConnectWithoutLibraryInput = {
    where: LibraryAliasWhereUniqueInput
    create: XOR<LibraryAliasCreateWithoutLibraryInput, LibraryAliasUncheckedCreateWithoutLibraryInput>
  }

  export type LibraryAliasCreateManyLibraryInputEnvelope = {
    data: LibraryAliasCreateManyLibraryInput | LibraryAliasCreateManyLibraryInput[]
    skipDuplicates?: boolean
  }

  export type DocumentationChunkCreateWithoutLibraryInput = {
    id?: string
    chunkIndex: number
    content: string
    contentType: string
    sourceUrl?: string | null
    tokenCount: number
    embeddingId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    libraryVersion: LibraryVersionCreateNestedOneWithoutDocumentationChunksInput
  }

  export type DocumentationChunkUncheckedCreateWithoutLibraryInput = {
    id?: string
    libraryVersionId: string
    chunkIndex: number
    content: string
    contentType: string
    sourceUrl?: string | null
    tokenCount: number
    embeddingId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DocumentationChunkCreateOrConnectWithoutLibraryInput = {
    where: DocumentationChunkWhereUniqueInput
    create: XOR<DocumentationChunkCreateWithoutLibraryInput, DocumentationChunkUncheckedCreateWithoutLibraryInput>
  }

  export type DocumentationChunkCreateManyLibraryInputEnvelope = {
    data: DocumentationChunkCreateManyLibraryInput | DocumentationChunkCreateManyLibraryInput[]
    skipDuplicates?: boolean
  }

  export type UsageLogCreateWithoutLibraryInput = {
    id?: string
    toolName: string
    query?: string | null
    tokensReturned?: number | null
    responseTimeMs?: number | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutUsageLogsInput
    apiKey?: ApiKeyCreateNestedOneWithoutUsageLogsInput
  }

  export type UsageLogUncheckedCreateWithoutLibraryInput = {
    id?: string
    userId?: string | null
    apiKeyId?: string | null
    toolName: string
    query?: string | null
    tokensReturned?: number | null
    responseTimeMs?: number | null
    createdAt?: Date | string
  }

  export type UsageLogCreateOrConnectWithoutLibraryInput = {
    where: UsageLogWhereUniqueInput
    create: XOR<UsageLogCreateWithoutLibraryInput, UsageLogUncheckedCreateWithoutLibraryInput>
  }

  export type UsageLogCreateManyLibraryInputEnvelope = {
    data: UsageLogCreateManyLibraryInput | UsageLogCreateManyLibraryInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutLibrariesInput = {
    update: XOR<ClientUpdateWithoutLibrariesInput, ClientUncheckedUpdateWithoutLibrariesInput>
    create: XOR<ClientCreateWithoutLibrariesInput, ClientUncheckedCreateWithoutLibrariesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutLibrariesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutLibrariesInput, ClientUncheckedUpdateWithoutLibrariesInput>
  }

  export type ClientUpdateWithoutLibrariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    apiKeys?: JsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleOnClientUpdateManyWithoutClientNestedInput
    environmentVariables?: EnvironmentVariableUpdateManyWithoutClientNestedInput
    users?: UserUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutLibrariesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    apiKeys?: JsonNullValueInput | InputJsonValue
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    modules?: ModuleOnClientUncheckedUpdateManyWithoutClientNestedInput
    environmentVariables?: EnvironmentVariableUncheckedUpdateManyWithoutClientNestedInput
    users?: UserUncheckedUpdateManyWithoutClientNestedInput
  }

  export type LibraryVersionUpsertWithWhereUniqueWithoutLibraryInput = {
    where: LibraryVersionWhereUniqueInput
    update: XOR<LibraryVersionUpdateWithoutLibraryInput, LibraryVersionUncheckedUpdateWithoutLibraryInput>
    create: XOR<LibraryVersionCreateWithoutLibraryInput, LibraryVersionUncheckedCreateWithoutLibraryInput>
  }

  export type LibraryVersionUpdateWithWhereUniqueWithoutLibraryInput = {
    where: LibraryVersionWhereUniqueInput
    data: XOR<LibraryVersionUpdateWithoutLibraryInput, LibraryVersionUncheckedUpdateWithoutLibraryInput>
  }

  export type LibraryVersionUpdateManyWithWhereWithoutLibraryInput = {
    where: LibraryVersionScalarWhereInput
    data: XOR<LibraryVersionUpdateManyMutationInput, LibraryVersionUncheckedUpdateManyWithoutLibraryInput>
  }

  export type LibraryVersionScalarWhereInput = {
    AND?: LibraryVersionScalarWhereInput | LibraryVersionScalarWhereInput[]
    OR?: LibraryVersionScalarWhereInput[]
    NOT?: LibraryVersionScalarWhereInput | LibraryVersionScalarWhereInput[]
    id?: StringFilter<"LibraryVersion"> | string
    libraryId?: StringFilter<"LibraryVersion"> | string
    version?: StringFilter<"LibraryVersion"> | string
    releaseDate?: DateTimeNullableFilter<"LibraryVersion"> | Date | string | null
    isLatest?: BoolFilter<"LibraryVersion"> | boolean
    docsSnapshotUrl?: StringNullableFilter<"LibraryVersion"> | string | null
  }

  export type LibraryAliasUpsertWithWhereUniqueWithoutLibraryInput = {
    where: LibraryAliasWhereUniqueInput
    update: XOR<LibraryAliasUpdateWithoutLibraryInput, LibraryAliasUncheckedUpdateWithoutLibraryInput>
    create: XOR<LibraryAliasCreateWithoutLibraryInput, LibraryAliasUncheckedCreateWithoutLibraryInput>
  }

  export type LibraryAliasUpdateWithWhereUniqueWithoutLibraryInput = {
    where: LibraryAliasWhereUniqueInput
    data: XOR<LibraryAliasUpdateWithoutLibraryInput, LibraryAliasUncheckedUpdateWithoutLibraryInput>
  }

  export type LibraryAliasUpdateManyWithWhereWithoutLibraryInput = {
    where: LibraryAliasScalarWhereInput
    data: XOR<LibraryAliasUpdateManyMutationInput, LibraryAliasUncheckedUpdateManyWithoutLibraryInput>
  }

  export type LibraryAliasScalarWhereInput = {
    AND?: LibraryAliasScalarWhereInput | LibraryAliasScalarWhereInput[]
    OR?: LibraryAliasScalarWhereInput[]
    NOT?: LibraryAliasScalarWhereInput | LibraryAliasScalarWhereInput[]
    id?: StringFilter<"LibraryAlias"> | string
    libraryId?: StringFilter<"LibraryAlias"> | string
    alias?: StringFilter<"LibraryAlias"> | string
  }

  export type DocumentationChunkUpsertWithWhereUniqueWithoutLibraryInput = {
    where: DocumentationChunkWhereUniqueInput
    update: XOR<DocumentationChunkUpdateWithoutLibraryInput, DocumentationChunkUncheckedUpdateWithoutLibraryInput>
    create: XOR<DocumentationChunkCreateWithoutLibraryInput, DocumentationChunkUncheckedCreateWithoutLibraryInput>
  }

  export type DocumentationChunkUpdateWithWhereUniqueWithoutLibraryInput = {
    where: DocumentationChunkWhereUniqueInput
    data: XOR<DocumentationChunkUpdateWithoutLibraryInput, DocumentationChunkUncheckedUpdateWithoutLibraryInput>
  }

  export type DocumentationChunkUpdateManyWithWhereWithoutLibraryInput = {
    where: DocumentationChunkScalarWhereInput
    data: XOR<DocumentationChunkUpdateManyMutationInput, DocumentationChunkUncheckedUpdateManyWithoutLibraryInput>
  }

  export type DocumentationChunkScalarWhereInput = {
    AND?: DocumentationChunkScalarWhereInput | DocumentationChunkScalarWhereInput[]
    OR?: DocumentationChunkScalarWhereInput[]
    NOT?: DocumentationChunkScalarWhereInput | DocumentationChunkScalarWhereInput[]
    id?: StringFilter<"DocumentationChunk"> | string
    libraryVersionId?: StringFilter<"DocumentationChunk"> | string
    chunkIndex?: IntFilter<"DocumentationChunk"> | number
    content?: StringFilter<"DocumentationChunk"> | string
    contentType?: StringFilter<"DocumentationChunk"> | string
    sourceUrl?: StringNullableFilter<"DocumentationChunk"> | string | null
    tokenCount?: IntFilter<"DocumentationChunk"> | number
    embeddingId?: StringNullableFilter<"DocumentationChunk"> | string | null
    metadata?: JsonNullableFilter<"DocumentationChunk">
    createdAt?: DateTimeFilter<"DocumentationChunk"> | Date | string
    libraryId?: StringNullableFilter<"DocumentationChunk"> | string | null
  }

  export type UsageLogUpsertWithWhereUniqueWithoutLibraryInput = {
    where: UsageLogWhereUniqueInput
    update: XOR<UsageLogUpdateWithoutLibraryInput, UsageLogUncheckedUpdateWithoutLibraryInput>
    create: XOR<UsageLogCreateWithoutLibraryInput, UsageLogUncheckedCreateWithoutLibraryInput>
  }

  export type UsageLogUpdateWithWhereUniqueWithoutLibraryInput = {
    where: UsageLogWhereUniqueInput
    data: XOR<UsageLogUpdateWithoutLibraryInput, UsageLogUncheckedUpdateWithoutLibraryInput>
  }

  export type UsageLogUpdateManyWithWhereWithoutLibraryInput = {
    where: UsageLogScalarWhereInput
    data: XOR<UsageLogUpdateManyMutationInput, UsageLogUncheckedUpdateManyWithoutLibraryInput>
  }

  export type LibraryCreateWithoutVersionsInput = {
    id: string
    name: string
    displayName: string
    description?: string | null
    vendor?: string | null
    repoUrl?: string | null
    docsUrl?: string | null
    defaultVersion?: string | null
    popularityScore?: number
    totalSnippets?: number
    totalTokens?: number
    language: string
    ecosystem: string
    tags?: LibraryCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastCrawledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutLibrariesInput
    aliases?: LibraryAliasCreateNestedManyWithoutLibraryInput
    documentationChunks?: DocumentationChunkCreateNestedManyWithoutLibraryInput
    usageLogs?: UsageLogCreateNestedManyWithoutLibraryInput
  }

  export type LibraryUncheckedCreateWithoutVersionsInput = {
    id: string
    name: string
    displayName: string
    description?: string | null
    vendor?: string | null
    repoUrl?: string | null
    docsUrl?: string | null
    defaultVersion?: string | null
    popularityScore?: number
    totalSnippets?: number
    totalTokens?: number
    language: string
    ecosystem: string
    tags?: LibraryCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    clientId: string
    lastCrawledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    aliases?: LibraryAliasUncheckedCreateNestedManyWithoutLibraryInput
    documentationChunks?: DocumentationChunkUncheckedCreateNestedManyWithoutLibraryInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutLibraryInput
  }

  export type LibraryCreateOrConnectWithoutVersionsInput = {
    where: LibraryWhereUniqueInput
    create: XOR<LibraryCreateWithoutVersionsInput, LibraryUncheckedCreateWithoutVersionsInput>
  }

  export type DocumentationChunkCreateWithoutLibraryVersionInput = {
    id?: string
    chunkIndex: number
    content: string
    contentType: string
    sourceUrl?: string | null
    tokenCount: number
    embeddingId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    Library?: LibraryCreateNestedOneWithoutDocumentationChunksInput
  }

  export type DocumentationChunkUncheckedCreateWithoutLibraryVersionInput = {
    id?: string
    chunkIndex: number
    content: string
    contentType: string
    sourceUrl?: string | null
    tokenCount: number
    embeddingId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    libraryId?: string | null
  }

  export type DocumentationChunkCreateOrConnectWithoutLibraryVersionInput = {
    where: DocumentationChunkWhereUniqueInput
    create: XOR<DocumentationChunkCreateWithoutLibraryVersionInput, DocumentationChunkUncheckedCreateWithoutLibraryVersionInput>
  }

  export type DocumentationChunkCreateManyLibraryVersionInputEnvelope = {
    data: DocumentationChunkCreateManyLibraryVersionInput | DocumentationChunkCreateManyLibraryVersionInput[]
    skipDuplicates?: boolean
  }

  export type LibraryUpsertWithoutVersionsInput = {
    update: XOR<LibraryUpdateWithoutVersionsInput, LibraryUncheckedUpdateWithoutVersionsInput>
    create: XOR<LibraryCreateWithoutVersionsInput, LibraryUncheckedCreateWithoutVersionsInput>
    where?: LibraryWhereInput
  }

  export type LibraryUpdateToOneWithWhereWithoutVersionsInput = {
    where?: LibraryWhereInput
    data: XOR<LibraryUpdateWithoutVersionsInput, LibraryUncheckedUpdateWithoutVersionsInput>
  }

  export type LibraryUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    docsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    defaultVersion?: NullableStringFieldUpdateOperationsInput | string | null
    popularityScore?: FloatFieldUpdateOperationsInput | number
    totalSnippets?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    ecosystem?: StringFieldUpdateOperationsInput | string
    tags?: LibraryUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastCrawledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutLibrariesNestedInput
    aliases?: LibraryAliasUpdateManyWithoutLibraryNestedInput
    documentationChunks?: DocumentationChunkUpdateManyWithoutLibraryNestedInput
    usageLogs?: UsageLogUpdateManyWithoutLibraryNestedInput
  }

  export type LibraryUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    docsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    defaultVersion?: NullableStringFieldUpdateOperationsInput | string | null
    popularityScore?: FloatFieldUpdateOperationsInput | number
    totalSnippets?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    ecosystem?: StringFieldUpdateOperationsInput | string
    tags?: LibraryUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    clientId?: StringFieldUpdateOperationsInput | string
    lastCrawledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aliases?: LibraryAliasUncheckedUpdateManyWithoutLibraryNestedInput
    documentationChunks?: DocumentationChunkUncheckedUpdateManyWithoutLibraryNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutLibraryNestedInput
  }

  export type DocumentationChunkUpsertWithWhereUniqueWithoutLibraryVersionInput = {
    where: DocumentationChunkWhereUniqueInput
    update: XOR<DocumentationChunkUpdateWithoutLibraryVersionInput, DocumentationChunkUncheckedUpdateWithoutLibraryVersionInput>
    create: XOR<DocumentationChunkCreateWithoutLibraryVersionInput, DocumentationChunkUncheckedCreateWithoutLibraryVersionInput>
  }

  export type DocumentationChunkUpdateWithWhereUniqueWithoutLibraryVersionInput = {
    where: DocumentationChunkWhereUniqueInput
    data: XOR<DocumentationChunkUpdateWithoutLibraryVersionInput, DocumentationChunkUncheckedUpdateWithoutLibraryVersionInput>
  }

  export type DocumentationChunkUpdateManyWithWhereWithoutLibraryVersionInput = {
    where: DocumentationChunkScalarWhereInput
    data: XOR<DocumentationChunkUpdateManyMutationInput, DocumentationChunkUncheckedUpdateManyWithoutLibraryVersionInput>
  }

  export type LibraryCreateWithoutAliasesInput = {
    id: string
    name: string
    displayName: string
    description?: string | null
    vendor?: string | null
    repoUrl?: string | null
    docsUrl?: string | null
    defaultVersion?: string | null
    popularityScore?: number
    totalSnippets?: number
    totalTokens?: number
    language: string
    ecosystem: string
    tags?: LibraryCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastCrawledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutLibrariesInput
    versions?: LibraryVersionCreateNestedManyWithoutLibraryInput
    documentationChunks?: DocumentationChunkCreateNestedManyWithoutLibraryInput
    usageLogs?: UsageLogCreateNestedManyWithoutLibraryInput
  }

  export type LibraryUncheckedCreateWithoutAliasesInput = {
    id: string
    name: string
    displayName: string
    description?: string | null
    vendor?: string | null
    repoUrl?: string | null
    docsUrl?: string | null
    defaultVersion?: string | null
    popularityScore?: number
    totalSnippets?: number
    totalTokens?: number
    language: string
    ecosystem: string
    tags?: LibraryCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    clientId: string
    lastCrawledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: LibraryVersionUncheckedCreateNestedManyWithoutLibraryInput
    documentationChunks?: DocumentationChunkUncheckedCreateNestedManyWithoutLibraryInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutLibraryInput
  }

  export type LibraryCreateOrConnectWithoutAliasesInput = {
    where: LibraryWhereUniqueInput
    create: XOR<LibraryCreateWithoutAliasesInput, LibraryUncheckedCreateWithoutAliasesInput>
  }

  export type LibraryUpsertWithoutAliasesInput = {
    update: XOR<LibraryUpdateWithoutAliasesInput, LibraryUncheckedUpdateWithoutAliasesInput>
    create: XOR<LibraryCreateWithoutAliasesInput, LibraryUncheckedCreateWithoutAliasesInput>
    where?: LibraryWhereInput
  }

  export type LibraryUpdateToOneWithWhereWithoutAliasesInput = {
    where?: LibraryWhereInput
    data: XOR<LibraryUpdateWithoutAliasesInput, LibraryUncheckedUpdateWithoutAliasesInput>
  }

  export type LibraryUpdateWithoutAliasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    docsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    defaultVersion?: NullableStringFieldUpdateOperationsInput | string | null
    popularityScore?: FloatFieldUpdateOperationsInput | number
    totalSnippets?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    ecosystem?: StringFieldUpdateOperationsInput | string
    tags?: LibraryUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastCrawledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutLibrariesNestedInput
    versions?: LibraryVersionUpdateManyWithoutLibraryNestedInput
    documentationChunks?: DocumentationChunkUpdateManyWithoutLibraryNestedInput
    usageLogs?: UsageLogUpdateManyWithoutLibraryNestedInput
  }

  export type LibraryUncheckedUpdateWithoutAliasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    docsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    defaultVersion?: NullableStringFieldUpdateOperationsInput | string | null
    popularityScore?: FloatFieldUpdateOperationsInput | number
    totalSnippets?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    ecosystem?: StringFieldUpdateOperationsInput | string
    tags?: LibraryUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    clientId?: StringFieldUpdateOperationsInput | string
    lastCrawledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: LibraryVersionUncheckedUpdateManyWithoutLibraryNestedInput
    documentationChunks?: DocumentationChunkUncheckedUpdateManyWithoutLibraryNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutLibraryNestedInput
  }

  export type LibraryVersionCreateWithoutDocumentationChunksInput = {
    id?: string
    version: string
    releaseDate?: Date | string | null
    isLatest?: boolean
    docsSnapshotUrl?: string | null
    library: LibraryCreateNestedOneWithoutVersionsInput
  }

  export type LibraryVersionUncheckedCreateWithoutDocumentationChunksInput = {
    id?: string
    libraryId: string
    version: string
    releaseDate?: Date | string | null
    isLatest?: boolean
    docsSnapshotUrl?: string | null
  }

  export type LibraryVersionCreateOrConnectWithoutDocumentationChunksInput = {
    where: LibraryVersionWhereUniqueInput
    create: XOR<LibraryVersionCreateWithoutDocumentationChunksInput, LibraryVersionUncheckedCreateWithoutDocumentationChunksInput>
  }

  export type LibraryCreateWithoutDocumentationChunksInput = {
    id: string
    name: string
    displayName: string
    description?: string | null
    vendor?: string | null
    repoUrl?: string | null
    docsUrl?: string | null
    defaultVersion?: string | null
    popularityScore?: number
    totalSnippets?: number
    totalTokens?: number
    language: string
    ecosystem: string
    tags?: LibraryCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastCrawledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutLibrariesInput
    versions?: LibraryVersionCreateNestedManyWithoutLibraryInput
    aliases?: LibraryAliasCreateNestedManyWithoutLibraryInput
    usageLogs?: UsageLogCreateNestedManyWithoutLibraryInput
  }

  export type LibraryUncheckedCreateWithoutDocumentationChunksInput = {
    id: string
    name: string
    displayName: string
    description?: string | null
    vendor?: string | null
    repoUrl?: string | null
    docsUrl?: string | null
    defaultVersion?: string | null
    popularityScore?: number
    totalSnippets?: number
    totalTokens?: number
    language: string
    ecosystem: string
    tags?: LibraryCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    clientId: string
    lastCrawledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: LibraryVersionUncheckedCreateNestedManyWithoutLibraryInput
    aliases?: LibraryAliasUncheckedCreateNestedManyWithoutLibraryInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutLibraryInput
  }

  export type LibraryCreateOrConnectWithoutDocumentationChunksInput = {
    where: LibraryWhereUniqueInput
    create: XOR<LibraryCreateWithoutDocumentationChunksInput, LibraryUncheckedCreateWithoutDocumentationChunksInput>
  }

  export type LibraryVersionUpsertWithoutDocumentationChunksInput = {
    update: XOR<LibraryVersionUpdateWithoutDocumentationChunksInput, LibraryVersionUncheckedUpdateWithoutDocumentationChunksInput>
    create: XOR<LibraryVersionCreateWithoutDocumentationChunksInput, LibraryVersionUncheckedCreateWithoutDocumentationChunksInput>
    where?: LibraryVersionWhereInput
  }

  export type LibraryVersionUpdateToOneWithWhereWithoutDocumentationChunksInput = {
    where?: LibraryVersionWhereInput
    data: XOR<LibraryVersionUpdateWithoutDocumentationChunksInput, LibraryVersionUncheckedUpdateWithoutDocumentationChunksInput>
  }

  export type LibraryVersionUpdateWithoutDocumentationChunksInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    docsSnapshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    library?: LibraryUpdateOneRequiredWithoutVersionsNestedInput
  }

  export type LibraryVersionUncheckedUpdateWithoutDocumentationChunksInput = {
    id?: StringFieldUpdateOperationsInput | string
    libraryId?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    docsSnapshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LibraryUpsertWithoutDocumentationChunksInput = {
    update: XOR<LibraryUpdateWithoutDocumentationChunksInput, LibraryUncheckedUpdateWithoutDocumentationChunksInput>
    create: XOR<LibraryCreateWithoutDocumentationChunksInput, LibraryUncheckedCreateWithoutDocumentationChunksInput>
    where?: LibraryWhereInput
  }

  export type LibraryUpdateToOneWithWhereWithoutDocumentationChunksInput = {
    where?: LibraryWhereInput
    data: XOR<LibraryUpdateWithoutDocumentationChunksInput, LibraryUncheckedUpdateWithoutDocumentationChunksInput>
  }

  export type LibraryUpdateWithoutDocumentationChunksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    docsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    defaultVersion?: NullableStringFieldUpdateOperationsInput | string | null
    popularityScore?: FloatFieldUpdateOperationsInput | number
    totalSnippets?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    ecosystem?: StringFieldUpdateOperationsInput | string
    tags?: LibraryUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastCrawledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutLibrariesNestedInput
    versions?: LibraryVersionUpdateManyWithoutLibraryNestedInput
    aliases?: LibraryAliasUpdateManyWithoutLibraryNestedInput
    usageLogs?: UsageLogUpdateManyWithoutLibraryNestedInput
  }

  export type LibraryUncheckedUpdateWithoutDocumentationChunksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    docsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    defaultVersion?: NullableStringFieldUpdateOperationsInput | string | null
    popularityScore?: FloatFieldUpdateOperationsInput | number
    totalSnippets?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    ecosystem?: StringFieldUpdateOperationsInput | string
    tags?: LibraryUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    clientId?: StringFieldUpdateOperationsInput | string
    lastCrawledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: LibraryVersionUncheckedUpdateManyWithoutLibraryNestedInput
    aliases?: LibraryAliasUncheckedUpdateManyWithoutLibraryNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutLibraryNestedInput
  }

  export type UserCreateWithoutApiKeysInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    hashedPassword?: string | null
    oauthProvider?: string | null
    oauthId?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutUsersInput
    mcpConfigurations?: MCPConfigurationCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messageReactions?: MessageReactionCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    themes?: ThemeCreateNestedManyWithoutCreatorInput
    personalizationAnalytics?: PersonalizationAnalyticsCreateNestedManyWithoutUserInput
    conversationShares?: ConversationShareCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutApiKeysInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    hashedPassword?: string | null
    oauthProvider?: string | null
    oauthId?: string | null
    role?: Role
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    mcpConfigurations?: MCPConfigurationUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messageReactions?: MessageReactionUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    themes?: ThemeUncheckedCreateNestedManyWithoutCreatorInput
    personalizationAnalytics?: PersonalizationAnalyticsUncheckedCreateNestedManyWithoutUserInput
    conversationShares?: ConversationShareUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutApiKeysInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
  }

  export type UsageLogCreateWithoutApiKeyInput = {
    id?: string
    toolName: string
    query?: string | null
    tokensReturned?: number | null
    responseTimeMs?: number | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutUsageLogsInput
    library?: LibraryCreateNestedOneWithoutUsageLogsInput
  }

  export type UsageLogUncheckedCreateWithoutApiKeyInput = {
    id?: string
    userId?: string | null
    libraryId?: string | null
    toolName: string
    query?: string | null
    tokensReturned?: number | null
    responseTimeMs?: number | null
    createdAt?: Date | string
  }

  export type UsageLogCreateOrConnectWithoutApiKeyInput = {
    where: UsageLogWhereUniqueInput
    create: XOR<UsageLogCreateWithoutApiKeyInput, UsageLogUncheckedCreateWithoutApiKeyInput>
  }

  export type UsageLogCreateManyApiKeyInputEnvelope = {
    data: UsageLogCreateManyApiKeyInput | UsageLogCreateManyApiKeyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutApiKeysInput = {
    update: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>
  }

  export type UserUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutUsersNestedInput
    mcpConfigurations?: MCPConfigurationUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messageReactions?: MessageReactionUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    themes?: ThemeUpdateManyWithoutCreatorNestedInput
    personalizationAnalytics?: PersonalizationAnalyticsUpdateManyWithoutUserNestedInput
    conversationShares?: ConversationShareUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mcpConfigurations?: MCPConfigurationUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messageReactions?: MessageReactionUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    themes?: ThemeUncheckedUpdateManyWithoutCreatorNestedInput
    personalizationAnalytics?: PersonalizationAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    conversationShares?: ConversationShareUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UsageLogUpsertWithWhereUniqueWithoutApiKeyInput = {
    where: UsageLogWhereUniqueInput
    update: XOR<UsageLogUpdateWithoutApiKeyInput, UsageLogUncheckedUpdateWithoutApiKeyInput>
    create: XOR<UsageLogCreateWithoutApiKeyInput, UsageLogUncheckedCreateWithoutApiKeyInput>
  }

  export type UsageLogUpdateWithWhereUniqueWithoutApiKeyInput = {
    where: UsageLogWhereUniqueInput
    data: XOR<UsageLogUpdateWithoutApiKeyInput, UsageLogUncheckedUpdateWithoutApiKeyInput>
  }

  export type UsageLogUpdateManyWithWhereWithoutApiKeyInput = {
    where: UsageLogScalarWhereInput
    data: XOR<UsageLogUpdateManyMutationInput, UsageLogUncheckedUpdateManyWithoutApiKeyInput>
  }

  export type UserCreateWithoutUsageLogsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    hashedPassword?: string | null
    oauthProvider?: string | null
    oauthId?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutUsersInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    mcpConfigurations?: MCPConfigurationCreateNestedManyWithoutUserInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messageReactions?: MessageReactionCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    themes?: ThemeCreateNestedManyWithoutCreatorInput
    personalizationAnalytics?: PersonalizationAnalyticsCreateNestedManyWithoutUserInput
    conversationShares?: ConversationShareCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutUsageLogsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    hashedPassword?: string | null
    oauthProvider?: string | null
    oauthId?: string | null
    role?: Role
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    mcpConfigurations?: MCPConfigurationUncheckedCreateNestedManyWithoutUserInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messageReactions?: MessageReactionUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    themes?: ThemeUncheckedCreateNestedManyWithoutCreatorInput
    personalizationAnalytics?: PersonalizationAnalyticsUncheckedCreateNestedManyWithoutUserInput
    conversationShares?: ConversationShareUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutUsageLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUsageLogsInput, UserUncheckedCreateWithoutUsageLogsInput>
  }

  export type ApiKeyCreateWithoutUsageLogsInput = {
    id?: string
    keyHash: string
    keyPrefix: string
    name?: string | null
    tier?: string
    quotaDaily?: number
    quotaMonthly?: number
    usedDaily?: number
    usedMonthly?: number
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
    user: UserCreateNestedOneWithoutApiKeysInput
  }

  export type ApiKeyUncheckedCreateWithoutUsageLogsInput = {
    id?: string
    userId: string
    keyHash: string
    keyPrefix: string
    name?: string | null
    tier?: string
    quotaDaily?: number
    quotaMonthly?: number
    usedDaily?: number
    usedMonthly?: number
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type ApiKeyCreateOrConnectWithoutUsageLogsInput = {
    where: ApiKeyWhereUniqueInput
    create: XOR<ApiKeyCreateWithoutUsageLogsInput, ApiKeyUncheckedCreateWithoutUsageLogsInput>
  }

  export type LibraryCreateWithoutUsageLogsInput = {
    id: string
    name: string
    displayName: string
    description?: string | null
    vendor?: string | null
    repoUrl?: string | null
    docsUrl?: string | null
    defaultVersion?: string | null
    popularityScore?: number
    totalSnippets?: number
    totalTokens?: number
    language: string
    ecosystem: string
    tags?: LibraryCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastCrawledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutLibrariesInput
    versions?: LibraryVersionCreateNestedManyWithoutLibraryInput
    aliases?: LibraryAliasCreateNestedManyWithoutLibraryInput
    documentationChunks?: DocumentationChunkCreateNestedManyWithoutLibraryInput
  }

  export type LibraryUncheckedCreateWithoutUsageLogsInput = {
    id: string
    name: string
    displayName: string
    description?: string | null
    vendor?: string | null
    repoUrl?: string | null
    docsUrl?: string | null
    defaultVersion?: string | null
    popularityScore?: number
    totalSnippets?: number
    totalTokens?: number
    language: string
    ecosystem: string
    tags?: LibraryCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    clientId: string
    lastCrawledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: LibraryVersionUncheckedCreateNestedManyWithoutLibraryInput
    aliases?: LibraryAliasUncheckedCreateNestedManyWithoutLibraryInput
    documentationChunks?: DocumentationChunkUncheckedCreateNestedManyWithoutLibraryInput
  }

  export type LibraryCreateOrConnectWithoutUsageLogsInput = {
    where: LibraryWhereUniqueInput
    create: XOR<LibraryCreateWithoutUsageLogsInput, LibraryUncheckedCreateWithoutUsageLogsInput>
  }

  export type UserUpsertWithoutUsageLogsInput = {
    update: XOR<UserUpdateWithoutUsageLogsInput, UserUncheckedUpdateWithoutUsageLogsInput>
    create: XOR<UserCreateWithoutUsageLogsInput, UserUncheckedCreateWithoutUsageLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUsageLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUsageLogsInput, UserUncheckedUpdateWithoutUsageLogsInput>
  }

  export type UserUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutUsersNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    mcpConfigurations?: MCPConfigurationUpdateManyWithoutUserNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messageReactions?: MessageReactionUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    themes?: ThemeUpdateManyWithoutCreatorNestedInput
    personalizationAnalytics?: PersonalizationAnalyticsUpdateManyWithoutUserNestedInput
    conversationShares?: ConversationShareUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    mcpConfigurations?: MCPConfigurationUncheckedUpdateManyWithoutUserNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messageReactions?: MessageReactionUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    themes?: ThemeUncheckedUpdateManyWithoutCreatorNestedInput
    personalizationAnalytics?: PersonalizationAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    conversationShares?: ConversationShareUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ApiKeyUpsertWithoutUsageLogsInput = {
    update: XOR<ApiKeyUpdateWithoutUsageLogsInput, ApiKeyUncheckedUpdateWithoutUsageLogsInput>
    create: XOR<ApiKeyCreateWithoutUsageLogsInput, ApiKeyUncheckedCreateWithoutUsageLogsInput>
    where?: ApiKeyWhereInput
  }

  export type ApiKeyUpdateToOneWithWhereWithoutUsageLogsInput = {
    where?: ApiKeyWhereInput
    data: XOR<ApiKeyUpdateWithoutUsageLogsInput, ApiKeyUncheckedUpdateWithoutUsageLogsInput>
  }

  export type ApiKeyUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: StringFieldUpdateOperationsInput | string
    quotaDaily?: IntFieldUpdateOperationsInput | number
    quotaMonthly?: IntFieldUpdateOperationsInput | number
    usedDaily?: IntFieldUpdateOperationsInput | number
    usedMonthly?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutApiKeysNestedInput
  }

  export type ApiKeyUncheckedUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: StringFieldUpdateOperationsInput | string
    quotaDaily?: IntFieldUpdateOperationsInput | number
    quotaMonthly?: IntFieldUpdateOperationsInput | number
    usedDaily?: IntFieldUpdateOperationsInput | number
    usedMonthly?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LibraryUpsertWithoutUsageLogsInput = {
    update: XOR<LibraryUpdateWithoutUsageLogsInput, LibraryUncheckedUpdateWithoutUsageLogsInput>
    create: XOR<LibraryCreateWithoutUsageLogsInput, LibraryUncheckedCreateWithoutUsageLogsInput>
    where?: LibraryWhereInput
  }

  export type LibraryUpdateToOneWithWhereWithoutUsageLogsInput = {
    where?: LibraryWhereInput
    data: XOR<LibraryUpdateWithoutUsageLogsInput, LibraryUncheckedUpdateWithoutUsageLogsInput>
  }

  export type LibraryUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    docsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    defaultVersion?: NullableStringFieldUpdateOperationsInput | string | null
    popularityScore?: FloatFieldUpdateOperationsInput | number
    totalSnippets?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    ecosystem?: StringFieldUpdateOperationsInput | string
    tags?: LibraryUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastCrawledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutLibrariesNestedInput
    versions?: LibraryVersionUpdateManyWithoutLibraryNestedInput
    aliases?: LibraryAliasUpdateManyWithoutLibraryNestedInput
    documentationChunks?: DocumentationChunkUpdateManyWithoutLibraryNestedInput
  }

  export type LibraryUncheckedUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    docsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    defaultVersion?: NullableStringFieldUpdateOperationsInput | string | null
    popularityScore?: FloatFieldUpdateOperationsInput | number
    totalSnippets?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    ecosystem?: StringFieldUpdateOperationsInput | string
    tags?: LibraryUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    clientId?: StringFieldUpdateOperationsInput | string
    lastCrawledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: LibraryVersionUncheckedUpdateManyWithoutLibraryNestedInput
    aliases?: LibraryAliasUncheckedUpdateManyWithoutLibraryNestedInput
    documentationChunks?: DocumentationChunkUncheckedUpdateManyWithoutLibraryNestedInput
  }

  export type UserCreateWithoutMcpConfigurationsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    hashedPassword?: string | null
    oauthProvider?: string | null
    oauthId?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutUsersInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messageReactions?: MessageReactionCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    themes?: ThemeCreateNestedManyWithoutCreatorInput
    personalizationAnalytics?: PersonalizationAnalyticsCreateNestedManyWithoutUserInput
    conversationShares?: ConversationShareCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutMcpConfigurationsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    hashedPassword?: string | null
    oauthProvider?: string | null
    oauthId?: string | null
    role?: Role
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messageReactions?: MessageReactionUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    themes?: ThemeUncheckedCreateNestedManyWithoutCreatorInput
    personalizationAnalytics?: PersonalizationAnalyticsUncheckedCreateNestedManyWithoutUserInput
    conversationShares?: ConversationShareUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutMcpConfigurationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMcpConfigurationsInput, UserUncheckedCreateWithoutMcpConfigurationsInput>
  }

  export type UserUpsertWithoutMcpConfigurationsInput = {
    update: XOR<UserUpdateWithoutMcpConfigurationsInput, UserUncheckedUpdateWithoutMcpConfigurationsInput>
    create: XOR<UserCreateWithoutMcpConfigurationsInput, UserUncheckedCreateWithoutMcpConfigurationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMcpConfigurationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMcpConfigurationsInput, UserUncheckedUpdateWithoutMcpConfigurationsInput>
  }

  export type UserUpdateWithoutMcpConfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutUsersNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messageReactions?: MessageReactionUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    themes?: ThemeUpdateManyWithoutCreatorNestedInput
    personalizationAnalytics?: PersonalizationAnalyticsUpdateManyWithoutUserNestedInput
    conversationShares?: ConversationShareUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutMcpConfigurationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messageReactions?: MessageReactionUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    themes?: ThemeUncheckedUpdateManyWithoutCreatorNestedInput
    personalizationAnalytics?: PersonalizationAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    conversationShares?: ConversationShareUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutOauthTokensInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    hashedPassword?: string | null
    oauthProvider?: string | null
    oauthId?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutUsersInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    mcpConfigurations?: MCPConfigurationCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messageReactions?: MessageReactionCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    themes?: ThemeCreateNestedManyWithoutCreatorInput
    personalizationAnalytics?: PersonalizationAnalyticsCreateNestedManyWithoutUserInput
    conversationShares?: ConversationShareCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutOauthTokensInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    hashedPassword?: string | null
    oauthProvider?: string | null
    oauthId?: string | null
    role?: Role
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    mcpConfigurations?: MCPConfigurationUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messageReactions?: MessageReactionUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    themes?: ThemeUncheckedCreateNestedManyWithoutCreatorInput
    personalizationAnalytics?: PersonalizationAnalyticsUncheckedCreateNestedManyWithoutUserInput
    conversationShares?: ConversationShareUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutOauthTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOauthTokensInput, UserUncheckedCreateWithoutOauthTokensInput>
  }

  export type UserUpsertWithoutOauthTokensInput = {
    update: XOR<UserUpdateWithoutOauthTokensInput, UserUncheckedUpdateWithoutOauthTokensInput>
    create: XOR<UserCreateWithoutOauthTokensInput, UserUncheckedCreateWithoutOauthTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOauthTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOauthTokensInput, UserUncheckedUpdateWithoutOauthTokensInput>
  }

  export type UserUpdateWithoutOauthTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutUsersNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    mcpConfigurations?: MCPConfigurationUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messageReactions?: MessageReactionUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    themes?: ThemeUpdateManyWithoutCreatorNestedInput
    personalizationAnalytics?: PersonalizationAnalyticsUpdateManyWithoutUserNestedInput
    conversationShares?: ConversationShareUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutOauthTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    mcpConfigurations?: MCPConfigurationUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messageReactions?: MessageReactionUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    themes?: ThemeUncheckedUpdateManyWithoutCreatorNestedInput
    personalizationAnalytics?: PersonalizationAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    conversationShares?: ConversationShareUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type OAuthAuthorizationCodeCreateWithoutClientInput = {
    id?: string
    code: string
    userId: string
    redirectUri: string
    scopes?: OAuthAuthorizationCodeCreatescopesInput | string[]
    codeChallenge?: string | null
    codeChallengeMethod?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OAuthAuthorizationCodeUncheckedCreateWithoutClientInput = {
    id?: string
    code: string
    userId: string
    redirectUri: string
    scopes?: OAuthAuthorizationCodeCreatescopesInput | string[]
    codeChallenge?: string | null
    codeChallengeMethod?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OAuthAuthorizationCodeCreateOrConnectWithoutClientInput = {
    where: OAuthAuthorizationCodeWhereUniqueInput
    create: XOR<OAuthAuthorizationCodeCreateWithoutClientInput, OAuthAuthorizationCodeUncheckedCreateWithoutClientInput>
  }

  export type OAuthAuthorizationCodeCreateManyClientInputEnvelope = {
    data: OAuthAuthorizationCodeCreateManyClientInput | OAuthAuthorizationCodeCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type OAuthAccessTokenCreateWithoutClientInput = {
    id?: string
    tokenHash: string
    userId: string
    scopes?: OAuthAccessTokenCreatescopesInput | string[]
    expiresAt: Date | string
    createdAt?: Date | string
    refreshToken?: OAuthRefreshTokenCreateNestedManyWithoutAccessTokenInput
  }

  export type OAuthAccessTokenUncheckedCreateWithoutClientInput = {
    id?: string
    tokenHash: string
    userId: string
    scopes?: OAuthAccessTokenCreatescopesInput | string[]
    expiresAt: Date | string
    createdAt?: Date | string
    refreshToken?: OAuthRefreshTokenUncheckedCreateNestedManyWithoutAccessTokenInput
  }

  export type OAuthAccessTokenCreateOrConnectWithoutClientInput = {
    where: OAuthAccessTokenWhereUniqueInput
    create: XOR<OAuthAccessTokenCreateWithoutClientInput, OAuthAccessTokenUncheckedCreateWithoutClientInput>
  }

  export type OAuthAccessTokenCreateManyClientInputEnvelope = {
    data: OAuthAccessTokenCreateManyClientInput | OAuthAccessTokenCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type OAuthRefreshTokenCreateWithoutClientInput = {
    id?: string
    tokenHash: string
    userId: string
    scopes?: OAuthRefreshTokenCreatescopesInput | string[]
    expiresAt: Date | string
    isRevoked?: boolean
    createdAt?: Date | string
    accessToken: OAuthAccessTokenCreateNestedOneWithoutRefreshTokenInput
  }

  export type OAuthRefreshTokenUncheckedCreateWithoutClientInput = {
    id?: string
    tokenHash: string
    accessTokenId: string
    userId: string
    scopes?: OAuthRefreshTokenCreatescopesInput | string[]
    expiresAt: Date | string
    isRevoked?: boolean
    createdAt?: Date | string
  }

  export type OAuthRefreshTokenCreateOrConnectWithoutClientInput = {
    where: OAuthRefreshTokenWhereUniqueInput
    create: XOR<OAuthRefreshTokenCreateWithoutClientInput, OAuthRefreshTokenUncheckedCreateWithoutClientInput>
  }

  export type OAuthRefreshTokenCreateManyClientInputEnvelope = {
    data: OAuthRefreshTokenCreateManyClientInput | OAuthRefreshTokenCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type OAuthAuthorizationCodeUpsertWithWhereUniqueWithoutClientInput = {
    where: OAuthAuthorizationCodeWhereUniqueInput
    update: XOR<OAuthAuthorizationCodeUpdateWithoutClientInput, OAuthAuthorizationCodeUncheckedUpdateWithoutClientInput>
    create: XOR<OAuthAuthorizationCodeCreateWithoutClientInput, OAuthAuthorizationCodeUncheckedCreateWithoutClientInput>
  }

  export type OAuthAuthorizationCodeUpdateWithWhereUniqueWithoutClientInput = {
    where: OAuthAuthorizationCodeWhereUniqueInput
    data: XOR<OAuthAuthorizationCodeUpdateWithoutClientInput, OAuthAuthorizationCodeUncheckedUpdateWithoutClientInput>
  }

  export type OAuthAuthorizationCodeUpdateManyWithWhereWithoutClientInput = {
    where: OAuthAuthorizationCodeScalarWhereInput
    data: XOR<OAuthAuthorizationCodeUpdateManyMutationInput, OAuthAuthorizationCodeUncheckedUpdateManyWithoutClientInput>
  }

  export type OAuthAuthorizationCodeScalarWhereInput = {
    AND?: OAuthAuthorizationCodeScalarWhereInput | OAuthAuthorizationCodeScalarWhereInput[]
    OR?: OAuthAuthorizationCodeScalarWhereInput[]
    NOT?: OAuthAuthorizationCodeScalarWhereInput | OAuthAuthorizationCodeScalarWhereInput[]
    id?: StringFilter<"OAuthAuthorizationCode"> | string
    code?: StringFilter<"OAuthAuthorizationCode"> | string
    clientId?: StringFilter<"OAuthAuthorizationCode"> | string
    userId?: StringFilter<"OAuthAuthorizationCode"> | string
    redirectUri?: StringFilter<"OAuthAuthorizationCode"> | string
    scopes?: StringNullableListFilter<"OAuthAuthorizationCode">
    codeChallenge?: StringNullableFilter<"OAuthAuthorizationCode"> | string | null
    codeChallengeMethod?: StringNullableFilter<"OAuthAuthorizationCode"> | string | null
    expiresAt?: DateTimeFilter<"OAuthAuthorizationCode"> | Date | string
    createdAt?: DateTimeFilter<"OAuthAuthorizationCode"> | Date | string
  }

  export type OAuthAccessTokenUpsertWithWhereUniqueWithoutClientInput = {
    where: OAuthAccessTokenWhereUniqueInput
    update: XOR<OAuthAccessTokenUpdateWithoutClientInput, OAuthAccessTokenUncheckedUpdateWithoutClientInput>
    create: XOR<OAuthAccessTokenCreateWithoutClientInput, OAuthAccessTokenUncheckedCreateWithoutClientInput>
  }

  export type OAuthAccessTokenUpdateWithWhereUniqueWithoutClientInput = {
    where: OAuthAccessTokenWhereUniqueInput
    data: XOR<OAuthAccessTokenUpdateWithoutClientInput, OAuthAccessTokenUncheckedUpdateWithoutClientInput>
  }

  export type OAuthAccessTokenUpdateManyWithWhereWithoutClientInput = {
    where: OAuthAccessTokenScalarWhereInput
    data: XOR<OAuthAccessTokenUpdateManyMutationInput, OAuthAccessTokenUncheckedUpdateManyWithoutClientInput>
  }

  export type OAuthAccessTokenScalarWhereInput = {
    AND?: OAuthAccessTokenScalarWhereInput | OAuthAccessTokenScalarWhereInput[]
    OR?: OAuthAccessTokenScalarWhereInput[]
    NOT?: OAuthAccessTokenScalarWhereInput | OAuthAccessTokenScalarWhereInput[]
    id?: StringFilter<"OAuthAccessToken"> | string
    tokenHash?: StringFilter<"OAuthAccessToken"> | string
    clientId?: StringFilter<"OAuthAccessToken"> | string
    userId?: StringFilter<"OAuthAccessToken"> | string
    scopes?: StringNullableListFilter<"OAuthAccessToken">
    expiresAt?: DateTimeFilter<"OAuthAccessToken"> | Date | string
    createdAt?: DateTimeFilter<"OAuthAccessToken"> | Date | string
  }

  export type OAuthRefreshTokenUpsertWithWhereUniqueWithoutClientInput = {
    where: OAuthRefreshTokenWhereUniqueInput
    update: XOR<OAuthRefreshTokenUpdateWithoutClientInput, OAuthRefreshTokenUncheckedUpdateWithoutClientInput>
    create: XOR<OAuthRefreshTokenCreateWithoutClientInput, OAuthRefreshTokenUncheckedCreateWithoutClientInput>
  }

  export type OAuthRefreshTokenUpdateWithWhereUniqueWithoutClientInput = {
    where: OAuthRefreshTokenWhereUniqueInput
    data: XOR<OAuthRefreshTokenUpdateWithoutClientInput, OAuthRefreshTokenUncheckedUpdateWithoutClientInput>
  }

  export type OAuthRefreshTokenUpdateManyWithWhereWithoutClientInput = {
    where: OAuthRefreshTokenScalarWhereInput
    data: XOR<OAuthRefreshTokenUpdateManyMutationInput, OAuthRefreshTokenUncheckedUpdateManyWithoutClientInput>
  }

  export type OAuthRefreshTokenScalarWhereInput = {
    AND?: OAuthRefreshTokenScalarWhereInput | OAuthRefreshTokenScalarWhereInput[]
    OR?: OAuthRefreshTokenScalarWhereInput[]
    NOT?: OAuthRefreshTokenScalarWhereInput | OAuthRefreshTokenScalarWhereInput[]
    id?: StringFilter<"OAuthRefreshToken"> | string
    tokenHash?: StringFilter<"OAuthRefreshToken"> | string
    accessTokenId?: StringFilter<"OAuthRefreshToken"> | string
    clientId?: StringFilter<"OAuthRefreshToken"> | string
    userId?: StringFilter<"OAuthRefreshToken"> | string
    scopes?: StringNullableListFilter<"OAuthRefreshToken">
    expiresAt?: DateTimeFilter<"OAuthRefreshToken"> | Date | string
    isRevoked?: BoolFilter<"OAuthRefreshToken"> | boolean
    createdAt?: DateTimeFilter<"OAuthRefreshToken"> | Date | string
  }

  export type OAuthClientCreateWithoutAuthorizationCodesInput = {
    id?: string
    clientId: string
    clientSecretHash: string
    name: string
    redirectUris?: OAuthClientCreateredirectUrisInput | string[]
    allowedScopes?: OAuthClientCreateallowedScopesInput | string[]
    grantTypes?: OAuthClientCreategrantTypesInput | string[]
    requirePkce?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accessTokens?: OAuthAccessTokenCreateNestedManyWithoutClientInput
    refreshTokens?: OAuthRefreshTokenCreateNestedManyWithoutClientInput
  }

  export type OAuthClientUncheckedCreateWithoutAuthorizationCodesInput = {
    id?: string
    clientId: string
    clientSecretHash: string
    name: string
    redirectUris?: OAuthClientCreateredirectUrisInput | string[]
    allowedScopes?: OAuthClientCreateallowedScopesInput | string[]
    grantTypes?: OAuthClientCreategrantTypesInput | string[]
    requirePkce?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accessTokens?: OAuthAccessTokenUncheckedCreateNestedManyWithoutClientInput
    refreshTokens?: OAuthRefreshTokenUncheckedCreateNestedManyWithoutClientInput
  }

  export type OAuthClientCreateOrConnectWithoutAuthorizationCodesInput = {
    where: OAuthClientWhereUniqueInput
    create: XOR<OAuthClientCreateWithoutAuthorizationCodesInput, OAuthClientUncheckedCreateWithoutAuthorizationCodesInput>
  }

  export type OAuthClientUpsertWithoutAuthorizationCodesInput = {
    update: XOR<OAuthClientUpdateWithoutAuthorizationCodesInput, OAuthClientUncheckedUpdateWithoutAuthorizationCodesInput>
    create: XOR<OAuthClientCreateWithoutAuthorizationCodesInput, OAuthClientUncheckedCreateWithoutAuthorizationCodesInput>
    where?: OAuthClientWhereInput
  }

  export type OAuthClientUpdateToOneWithWhereWithoutAuthorizationCodesInput = {
    where?: OAuthClientWhereInput
    data: XOR<OAuthClientUpdateWithoutAuthorizationCodesInput, OAuthClientUncheckedUpdateWithoutAuthorizationCodesInput>
  }

  export type OAuthClientUpdateWithoutAuthorizationCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecretHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    redirectUris?: OAuthClientUpdateredirectUrisInput | string[]
    allowedScopes?: OAuthClientUpdateallowedScopesInput | string[]
    grantTypes?: OAuthClientUpdategrantTypesInput | string[]
    requirePkce?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessTokens?: OAuthAccessTokenUpdateManyWithoutClientNestedInput
    refreshTokens?: OAuthRefreshTokenUpdateManyWithoutClientNestedInput
  }

  export type OAuthClientUncheckedUpdateWithoutAuthorizationCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecretHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    redirectUris?: OAuthClientUpdateredirectUrisInput | string[]
    allowedScopes?: OAuthClientUpdateallowedScopesInput | string[]
    grantTypes?: OAuthClientUpdategrantTypesInput | string[]
    requirePkce?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessTokens?: OAuthAccessTokenUncheckedUpdateManyWithoutClientNestedInput
    refreshTokens?: OAuthRefreshTokenUncheckedUpdateManyWithoutClientNestedInput
  }

  export type OAuthClientCreateWithoutAccessTokensInput = {
    id?: string
    clientId: string
    clientSecretHash: string
    name: string
    redirectUris?: OAuthClientCreateredirectUrisInput | string[]
    allowedScopes?: OAuthClientCreateallowedScopesInput | string[]
    grantTypes?: OAuthClientCreategrantTypesInput | string[]
    requirePkce?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    authorizationCodes?: OAuthAuthorizationCodeCreateNestedManyWithoutClientInput
    refreshTokens?: OAuthRefreshTokenCreateNestedManyWithoutClientInput
  }

  export type OAuthClientUncheckedCreateWithoutAccessTokensInput = {
    id?: string
    clientId: string
    clientSecretHash: string
    name: string
    redirectUris?: OAuthClientCreateredirectUrisInput | string[]
    allowedScopes?: OAuthClientCreateallowedScopesInput | string[]
    grantTypes?: OAuthClientCreategrantTypesInput | string[]
    requirePkce?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    authorizationCodes?: OAuthAuthorizationCodeUncheckedCreateNestedManyWithoutClientInput
    refreshTokens?: OAuthRefreshTokenUncheckedCreateNestedManyWithoutClientInput
  }

  export type OAuthClientCreateOrConnectWithoutAccessTokensInput = {
    where: OAuthClientWhereUniqueInput
    create: XOR<OAuthClientCreateWithoutAccessTokensInput, OAuthClientUncheckedCreateWithoutAccessTokensInput>
  }

  export type OAuthRefreshTokenCreateWithoutAccessTokenInput = {
    id?: string
    tokenHash: string
    userId: string
    scopes?: OAuthRefreshTokenCreatescopesInput | string[]
    expiresAt: Date | string
    isRevoked?: boolean
    createdAt?: Date | string
    client: OAuthClientCreateNestedOneWithoutRefreshTokensInput
  }

  export type OAuthRefreshTokenUncheckedCreateWithoutAccessTokenInput = {
    id?: string
    tokenHash: string
    clientId: string
    userId: string
    scopes?: OAuthRefreshTokenCreatescopesInput | string[]
    expiresAt: Date | string
    isRevoked?: boolean
    createdAt?: Date | string
  }

  export type OAuthRefreshTokenCreateOrConnectWithoutAccessTokenInput = {
    where: OAuthRefreshTokenWhereUniqueInput
    create: XOR<OAuthRefreshTokenCreateWithoutAccessTokenInput, OAuthRefreshTokenUncheckedCreateWithoutAccessTokenInput>
  }

  export type OAuthRefreshTokenCreateManyAccessTokenInputEnvelope = {
    data: OAuthRefreshTokenCreateManyAccessTokenInput | OAuthRefreshTokenCreateManyAccessTokenInput[]
    skipDuplicates?: boolean
  }

  export type OAuthClientUpsertWithoutAccessTokensInput = {
    update: XOR<OAuthClientUpdateWithoutAccessTokensInput, OAuthClientUncheckedUpdateWithoutAccessTokensInput>
    create: XOR<OAuthClientCreateWithoutAccessTokensInput, OAuthClientUncheckedCreateWithoutAccessTokensInput>
    where?: OAuthClientWhereInput
  }

  export type OAuthClientUpdateToOneWithWhereWithoutAccessTokensInput = {
    where?: OAuthClientWhereInput
    data: XOR<OAuthClientUpdateWithoutAccessTokensInput, OAuthClientUncheckedUpdateWithoutAccessTokensInput>
  }

  export type OAuthClientUpdateWithoutAccessTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecretHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    redirectUris?: OAuthClientUpdateredirectUrisInput | string[]
    allowedScopes?: OAuthClientUpdateallowedScopesInput | string[]
    grantTypes?: OAuthClientUpdategrantTypesInput | string[]
    requirePkce?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorizationCodes?: OAuthAuthorizationCodeUpdateManyWithoutClientNestedInput
    refreshTokens?: OAuthRefreshTokenUpdateManyWithoutClientNestedInput
  }

  export type OAuthClientUncheckedUpdateWithoutAccessTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecretHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    redirectUris?: OAuthClientUpdateredirectUrisInput | string[]
    allowedScopes?: OAuthClientUpdateallowedScopesInput | string[]
    grantTypes?: OAuthClientUpdategrantTypesInput | string[]
    requirePkce?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorizationCodes?: OAuthAuthorizationCodeUncheckedUpdateManyWithoutClientNestedInput
    refreshTokens?: OAuthRefreshTokenUncheckedUpdateManyWithoutClientNestedInput
  }

  export type OAuthRefreshTokenUpsertWithWhereUniqueWithoutAccessTokenInput = {
    where: OAuthRefreshTokenWhereUniqueInput
    update: XOR<OAuthRefreshTokenUpdateWithoutAccessTokenInput, OAuthRefreshTokenUncheckedUpdateWithoutAccessTokenInput>
    create: XOR<OAuthRefreshTokenCreateWithoutAccessTokenInput, OAuthRefreshTokenUncheckedCreateWithoutAccessTokenInput>
  }

  export type OAuthRefreshTokenUpdateWithWhereUniqueWithoutAccessTokenInput = {
    where: OAuthRefreshTokenWhereUniqueInput
    data: XOR<OAuthRefreshTokenUpdateWithoutAccessTokenInput, OAuthRefreshTokenUncheckedUpdateWithoutAccessTokenInput>
  }

  export type OAuthRefreshTokenUpdateManyWithWhereWithoutAccessTokenInput = {
    where: OAuthRefreshTokenScalarWhereInput
    data: XOR<OAuthRefreshTokenUpdateManyMutationInput, OAuthRefreshTokenUncheckedUpdateManyWithoutAccessTokenInput>
  }

  export type OAuthAccessTokenCreateWithoutRefreshTokenInput = {
    id?: string
    tokenHash: string
    userId: string
    scopes?: OAuthAccessTokenCreatescopesInput | string[]
    expiresAt: Date | string
    createdAt?: Date | string
    client: OAuthClientCreateNestedOneWithoutAccessTokensInput
  }

  export type OAuthAccessTokenUncheckedCreateWithoutRefreshTokenInput = {
    id?: string
    tokenHash: string
    clientId: string
    userId: string
    scopes?: OAuthAccessTokenCreatescopesInput | string[]
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OAuthAccessTokenCreateOrConnectWithoutRefreshTokenInput = {
    where: OAuthAccessTokenWhereUniqueInput
    create: XOR<OAuthAccessTokenCreateWithoutRefreshTokenInput, OAuthAccessTokenUncheckedCreateWithoutRefreshTokenInput>
  }

  export type OAuthClientCreateWithoutRefreshTokensInput = {
    id?: string
    clientId: string
    clientSecretHash: string
    name: string
    redirectUris?: OAuthClientCreateredirectUrisInput | string[]
    allowedScopes?: OAuthClientCreateallowedScopesInput | string[]
    grantTypes?: OAuthClientCreategrantTypesInput | string[]
    requirePkce?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    authorizationCodes?: OAuthAuthorizationCodeCreateNestedManyWithoutClientInput
    accessTokens?: OAuthAccessTokenCreateNestedManyWithoutClientInput
  }

  export type OAuthClientUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    clientId: string
    clientSecretHash: string
    name: string
    redirectUris?: OAuthClientCreateredirectUrisInput | string[]
    allowedScopes?: OAuthClientCreateallowedScopesInput | string[]
    grantTypes?: OAuthClientCreategrantTypesInput | string[]
    requirePkce?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    authorizationCodes?: OAuthAuthorizationCodeUncheckedCreateNestedManyWithoutClientInput
    accessTokens?: OAuthAccessTokenUncheckedCreateNestedManyWithoutClientInput
  }

  export type OAuthClientCreateOrConnectWithoutRefreshTokensInput = {
    where: OAuthClientWhereUniqueInput
    create: XOR<OAuthClientCreateWithoutRefreshTokensInput, OAuthClientUncheckedCreateWithoutRefreshTokensInput>
  }

  export type OAuthAccessTokenUpsertWithoutRefreshTokenInput = {
    update: XOR<OAuthAccessTokenUpdateWithoutRefreshTokenInput, OAuthAccessTokenUncheckedUpdateWithoutRefreshTokenInput>
    create: XOR<OAuthAccessTokenCreateWithoutRefreshTokenInput, OAuthAccessTokenUncheckedCreateWithoutRefreshTokenInput>
    where?: OAuthAccessTokenWhereInput
  }

  export type OAuthAccessTokenUpdateToOneWithWhereWithoutRefreshTokenInput = {
    where?: OAuthAccessTokenWhereInput
    data: XOR<OAuthAccessTokenUpdateWithoutRefreshTokenInput, OAuthAccessTokenUncheckedUpdateWithoutRefreshTokenInput>
  }

  export type OAuthAccessTokenUpdateWithoutRefreshTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scopes?: OAuthAccessTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: OAuthClientUpdateOneRequiredWithoutAccessTokensNestedInput
  }

  export type OAuthAccessTokenUncheckedUpdateWithoutRefreshTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scopes?: OAuthAccessTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthClientUpsertWithoutRefreshTokensInput = {
    update: XOR<OAuthClientUpdateWithoutRefreshTokensInput, OAuthClientUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<OAuthClientCreateWithoutRefreshTokensInput, OAuthClientUncheckedCreateWithoutRefreshTokensInput>
    where?: OAuthClientWhereInput
  }

  export type OAuthClientUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: OAuthClientWhereInput
    data: XOR<OAuthClientUpdateWithoutRefreshTokensInput, OAuthClientUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type OAuthClientUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecretHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    redirectUris?: OAuthClientUpdateredirectUrisInput | string[]
    allowedScopes?: OAuthClientUpdateallowedScopesInput | string[]
    grantTypes?: OAuthClientUpdategrantTypesInput | string[]
    requirePkce?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorizationCodes?: OAuthAuthorizationCodeUpdateManyWithoutClientNestedInput
    accessTokens?: OAuthAccessTokenUpdateManyWithoutClientNestedInput
  }

  export type OAuthClientUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSecretHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    redirectUris?: OAuthClientUpdateredirectUrisInput | string[]
    allowedScopes?: OAuthClientUpdateallowedScopesInput | string[]
    grantTypes?: OAuthClientUpdategrantTypesInput | string[]
    requirePkce?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authorizationCodes?: OAuthAuthorizationCodeUncheckedUpdateManyWithoutClientNestedInput
    accessTokens?: OAuthAccessTokenUncheckedUpdateManyWithoutClientNestedInput
  }

  export type DownloadResultCreateWithoutDownloadTaskInput = {
    id?: string
    success?: boolean
    local_path: string
    metadata: JsonNullValueInput | InputJsonValue
    files: JsonNullValueInput | InputJsonValue
    errors?: DownloadResultCreateerrorsInput | string[]
    created_at?: Date | string
  }

  export type DownloadResultUncheckedCreateWithoutDownloadTaskInput = {
    id?: string
    success?: boolean
    local_path: string
    metadata: JsonNullValueInput | InputJsonValue
    files: JsonNullValueInput | InputJsonValue
    errors?: DownloadResultCreateerrorsInput | string[]
    created_at?: Date | string
  }

  export type DownloadResultCreateOrConnectWithoutDownloadTaskInput = {
    where: DownloadResultWhereUniqueInput
    create: XOR<DownloadResultCreateWithoutDownloadTaskInput, DownloadResultUncheckedCreateWithoutDownloadTaskInput>
  }

  export type DownloadResultCreateManyDownloadTaskInputEnvelope = {
    data: DownloadResultCreateManyDownloadTaskInput | DownloadResultCreateManyDownloadTaskInput[]
    skipDuplicates?: boolean
  }

  export type DownloadResultUpsertWithWhereUniqueWithoutDownloadTaskInput = {
    where: DownloadResultWhereUniqueInput
    update: XOR<DownloadResultUpdateWithoutDownloadTaskInput, DownloadResultUncheckedUpdateWithoutDownloadTaskInput>
    create: XOR<DownloadResultCreateWithoutDownloadTaskInput, DownloadResultUncheckedCreateWithoutDownloadTaskInput>
  }

  export type DownloadResultUpdateWithWhereUniqueWithoutDownloadTaskInput = {
    where: DownloadResultWhereUniqueInput
    data: XOR<DownloadResultUpdateWithoutDownloadTaskInput, DownloadResultUncheckedUpdateWithoutDownloadTaskInput>
  }

  export type DownloadResultUpdateManyWithWhereWithoutDownloadTaskInput = {
    where: DownloadResultScalarWhereInput
    data: XOR<DownloadResultUpdateManyMutationInput, DownloadResultUncheckedUpdateManyWithoutDownloadTaskInput>
  }

  export type DownloadResultScalarWhereInput = {
    AND?: DownloadResultScalarWhereInput | DownloadResultScalarWhereInput[]
    OR?: DownloadResultScalarWhereInput[]
    NOT?: DownloadResultScalarWhereInput | DownloadResultScalarWhereInput[]
    id?: StringFilter<"DownloadResult"> | string
    task_id?: StringFilter<"DownloadResult"> | string
    success?: BoolFilter<"DownloadResult"> | boolean
    local_path?: StringFilter<"DownloadResult"> | string
    metadata?: JsonFilter<"DownloadResult">
    files?: JsonFilter<"DownloadResult">
    errors?: StringNullableListFilter<"DownloadResult">
    created_at?: DateTimeFilter<"DownloadResult"> | Date | string
  }

  export type DownloadTaskCreateWithoutDownloadResultsInput = {
    id?: string
    type: string
    source: JsonNullValueInput | InputJsonValue
    options: JsonNullValueInput | InputJsonValue
    priority?: string
    status?: string
    progress: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    error?: string | null
    retry_count?: number
  }

  export type DownloadTaskUncheckedCreateWithoutDownloadResultsInput = {
    id?: string
    type: string
    source: JsonNullValueInput | InputJsonValue
    options: JsonNullValueInput | InputJsonValue
    priority?: string
    status?: string
    progress: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    error?: string | null
    retry_count?: number
  }

  export type DownloadTaskCreateOrConnectWithoutDownloadResultsInput = {
    where: DownloadTaskWhereUniqueInput
    create: XOR<DownloadTaskCreateWithoutDownloadResultsInput, DownloadTaskUncheckedCreateWithoutDownloadResultsInput>
  }

  export type DownloadTaskUpsertWithoutDownloadResultsInput = {
    update: XOR<DownloadTaskUpdateWithoutDownloadResultsInput, DownloadTaskUncheckedUpdateWithoutDownloadResultsInput>
    create: XOR<DownloadTaskCreateWithoutDownloadResultsInput, DownloadTaskUncheckedCreateWithoutDownloadResultsInput>
    where?: DownloadTaskWhereInput
  }

  export type DownloadTaskUpdateToOneWithWhereWithoutDownloadResultsInput = {
    where?: DownloadTaskWhereInput
    data: XOR<DownloadTaskUpdateWithoutDownloadResultsInput, DownloadTaskUncheckedUpdateWithoutDownloadResultsInput>
  }

  export type DownloadTaskUpdateWithoutDownloadResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    source?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retry_count?: IntFieldUpdateOperationsInput | number
  }

  export type DownloadTaskUncheckedUpdateWithoutDownloadResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    source?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retry_count?: IntFieldUpdateOperationsInput | number
  }

  export type PromptTemplateCreateWithoutCategoryRelInput = {
    id: string
    version: string
    name: string
    description?: string | null
    status?: string
    template: string
    variables?: JsonNullValueInput | InputJsonValue
    examples?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    optimization?: JsonNullValueInput | InputJsonValue
    testing?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: PromptExecutionCreateNestedManyWithoutTemplateInput
    changes?: TemplateChangeCreateNestedManyWithoutTemplateInput
    optimizations?: OptimizationRecordCreateNestedManyWithoutTemplateInput
  }

  export type PromptTemplateUncheckedCreateWithoutCategoryRelInput = {
    id: string
    version: string
    name: string
    description?: string | null
    status?: string
    template: string
    variables?: JsonNullValueInput | InputJsonValue
    examples?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    optimization?: JsonNullValueInput | InputJsonValue
    testing?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: PromptExecutionUncheckedCreateNestedManyWithoutTemplateInput
    changes?: TemplateChangeUncheckedCreateNestedManyWithoutTemplateInput
    optimizations?: OptimizationRecordUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type PromptTemplateCreateOrConnectWithoutCategoryRelInput = {
    where: PromptTemplateWhereUniqueInput
    create: XOR<PromptTemplateCreateWithoutCategoryRelInput, PromptTemplateUncheckedCreateWithoutCategoryRelInput>
  }

  export type PromptTemplateCreateManyCategoryRelInputEnvelope = {
    data: PromptTemplateCreateManyCategoryRelInput | PromptTemplateCreateManyCategoryRelInput[]
    skipDuplicates?: boolean
  }

  export type PromptCategoryCreateWithoutChildrenInput = {
    id: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    templates?: PromptTemplateCreateNestedManyWithoutCategoryRelInput
    parent?: PromptCategoryCreateNestedOneWithoutChildrenInput
  }

  export type PromptCategoryUncheckedCreateWithoutChildrenInput = {
    id: string
    name: string
    description?: string | null
    parentCategory?: string | null
    icon?: string | null
    color?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    templates?: PromptTemplateUncheckedCreateNestedManyWithoutCategoryRelInput
  }

  export type PromptCategoryCreateOrConnectWithoutChildrenInput = {
    where: PromptCategoryWhereUniqueInput
    create: XOR<PromptCategoryCreateWithoutChildrenInput, PromptCategoryUncheckedCreateWithoutChildrenInput>
  }

  export type PromptCategoryCreateWithoutParentInput = {
    id: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    templates?: PromptTemplateCreateNestedManyWithoutCategoryRelInput
    children?: PromptCategoryCreateNestedManyWithoutParentInput
  }

  export type PromptCategoryUncheckedCreateWithoutParentInput = {
    id: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    templates?: PromptTemplateUncheckedCreateNestedManyWithoutCategoryRelInput
    children?: PromptCategoryUncheckedCreateNestedManyWithoutParentInput
  }

  export type PromptCategoryCreateOrConnectWithoutParentInput = {
    where: PromptCategoryWhereUniqueInput
    create: XOR<PromptCategoryCreateWithoutParentInput, PromptCategoryUncheckedCreateWithoutParentInput>
  }

  export type PromptCategoryCreateManyParentInputEnvelope = {
    data: PromptCategoryCreateManyParentInput | PromptCategoryCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type PromptTemplateUpsertWithWhereUniqueWithoutCategoryRelInput = {
    where: PromptTemplateWhereUniqueInput
    update: XOR<PromptTemplateUpdateWithoutCategoryRelInput, PromptTemplateUncheckedUpdateWithoutCategoryRelInput>
    create: XOR<PromptTemplateCreateWithoutCategoryRelInput, PromptTemplateUncheckedCreateWithoutCategoryRelInput>
  }

  export type PromptTemplateUpdateWithWhereUniqueWithoutCategoryRelInput = {
    where: PromptTemplateWhereUniqueInput
    data: XOR<PromptTemplateUpdateWithoutCategoryRelInput, PromptTemplateUncheckedUpdateWithoutCategoryRelInput>
  }

  export type PromptTemplateUpdateManyWithWhereWithoutCategoryRelInput = {
    where: PromptTemplateScalarWhereInput
    data: XOR<PromptTemplateUpdateManyMutationInput, PromptTemplateUncheckedUpdateManyWithoutCategoryRelInput>
  }

  export type PromptTemplateScalarWhereInput = {
    AND?: PromptTemplateScalarWhereInput | PromptTemplateScalarWhereInput[]
    OR?: PromptTemplateScalarWhereInput[]
    NOT?: PromptTemplateScalarWhereInput | PromptTemplateScalarWhereInput[]
    id?: StringFilter<"PromptTemplate"> | string
    version?: StringFilter<"PromptTemplate"> | string
    name?: StringFilter<"PromptTemplate"> | string
    description?: StringNullableFilter<"PromptTemplate"> | string | null
    category?: StringFilter<"PromptTemplate"> | string
    status?: StringFilter<"PromptTemplate"> | string
    template?: StringFilter<"PromptTemplate"> | string
    variables?: JsonFilter<"PromptTemplate">
    examples?: JsonFilter<"PromptTemplate">
    metadata?: JsonFilter<"PromptTemplate">
    constraints?: JsonFilter<"PromptTemplate">
    optimization?: JsonFilter<"PromptTemplate">
    testing?: JsonFilter<"PromptTemplate">
    createdAt?: DateTimeFilter<"PromptTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"PromptTemplate"> | Date | string
  }

  export type PromptCategoryUpsertWithoutChildrenInput = {
    update: XOR<PromptCategoryUpdateWithoutChildrenInput, PromptCategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<PromptCategoryCreateWithoutChildrenInput, PromptCategoryUncheckedCreateWithoutChildrenInput>
    where?: PromptCategoryWhereInput
  }

  export type PromptCategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: PromptCategoryWhereInput
    data: XOR<PromptCategoryUpdateWithoutChildrenInput, PromptCategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type PromptCategoryUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templates?: PromptTemplateUpdateManyWithoutCategoryRelNestedInput
    parent?: PromptCategoryUpdateOneWithoutChildrenNestedInput
  }

  export type PromptCategoryUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentCategory?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templates?: PromptTemplateUncheckedUpdateManyWithoutCategoryRelNestedInput
  }

  export type PromptCategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: PromptCategoryWhereUniqueInput
    update: XOR<PromptCategoryUpdateWithoutParentInput, PromptCategoryUncheckedUpdateWithoutParentInput>
    create: XOR<PromptCategoryCreateWithoutParentInput, PromptCategoryUncheckedCreateWithoutParentInput>
  }

  export type PromptCategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: PromptCategoryWhereUniqueInput
    data: XOR<PromptCategoryUpdateWithoutParentInput, PromptCategoryUncheckedUpdateWithoutParentInput>
  }

  export type PromptCategoryUpdateManyWithWhereWithoutParentInput = {
    where: PromptCategoryScalarWhereInput
    data: XOR<PromptCategoryUpdateManyMutationInput, PromptCategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type PromptCategoryScalarWhereInput = {
    AND?: PromptCategoryScalarWhereInput | PromptCategoryScalarWhereInput[]
    OR?: PromptCategoryScalarWhereInput[]
    NOT?: PromptCategoryScalarWhereInput | PromptCategoryScalarWhereInput[]
    id?: StringFilter<"PromptCategory"> | string
    name?: StringFilter<"PromptCategory"> | string
    description?: StringNullableFilter<"PromptCategory"> | string | null
    parentCategory?: StringNullableFilter<"PromptCategory"> | string | null
    icon?: StringNullableFilter<"PromptCategory"> | string | null
    color?: StringNullableFilter<"PromptCategory"> | string | null
    order?: IntFilter<"PromptCategory"> | number
    createdAt?: DateTimeFilter<"PromptCategory"> | Date | string
    updatedAt?: DateTimeFilter<"PromptCategory"> | Date | string
  }

  export type PromptCategoryCreateWithoutTemplatesInput = {
    id: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: PromptCategoryCreateNestedOneWithoutChildrenInput
    children?: PromptCategoryCreateNestedManyWithoutParentInput
  }

  export type PromptCategoryUncheckedCreateWithoutTemplatesInput = {
    id: string
    name: string
    description?: string | null
    parentCategory?: string | null
    icon?: string | null
    color?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: PromptCategoryUncheckedCreateNestedManyWithoutParentInput
  }

  export type PromptCategoryCreateOrConnectWithoutTemplatesInput = {
    where: PromptCategoryWhereUniqueInput
    create: XOR<PromptCategoryCreateWithoutTemplatesInput, PromptCategoryUncheckedCreateWithoutTemplatesInput>
  }

  export type PromptExecutionCreateWithoutTemplateInput = {
    id?: string
    templateVersion: string
    variables?: JsonNullValueInput | InputJsonValue
    renderedPrompt: string
    context?: NullableJsonNullValueInput | InputJsonValue
    model: string
    provider: string
    response?: string | null
    metrics?: JsonNullValueInput | InputJsonValue
    quality?: JsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    abTestVariant?: string | null
    userId?: string | null
    createdAt?: Date | string
  }

  export type PromptExecutionUncheckedCreateWithoutTemplateInput = {
    id?: string
    templateVersion: string
    variables?: JsonNullValueInput | InputJsonValue
    renderedPrompt: string
    context?: NullableJsonNullValueInput | InputJsonValue
    model: string
    provider: string
    response?: string | null
    metrics?: JsonNullValueInput | InputJsonValue
    quality?: JsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    abTestVariant?: string | null
    userId?: string | null
    createdAt?: Date | string
  }

  export type PromptExecutionCreateOrConnectWithoutTemplateInput = {
    where: PromptExecutionWhereUniqueInput
    create: XOR<PromptExecutionCreateWithoutTemplateInput, PromptExecutionUncheckedCreateWithoutTemplateInput>
  }

  export type PromptExecutionCreateManyTemplateInputEnvelope = {
    data: PromptExecutionCreateManyTemplateInput | PromptExecutionCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type TemplateChangeCreateWithoutTemplateInput = {
    id?: string
    fromVersion: string
    toVersion: string
    changes: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TemplateChangeUncheckedCreateWithoutTemplateInput = {
    id?: string
    fromVersion: string
    toVersion: string
    changes: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TemplateChangeCreateOrConnectWithoutTemplateInput = {
    where: TemplateChangeWhereUniqueInput
    create: XOR<TemplateChangeCreateWithoutTemplateInput, TemplateChangeUncheckedCreateWithoutTemplateInput>
  }

  export type TemplateChangeCreateManyTemplateInputEnvelope = {
    data: TemplateChangeCreateManyTemplateInput | TemplateChangeCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type OptimizationRecordCreateWithoutTemplateInput = {
    id?: string
    timestamp: Date | string
    type: string
    reason?: string | null
    changes?: JsonNullValueInput | InputJsonValue
    metricsBefore?: JsonNullValueInput | InputJsonValue
    metricsAfter?: JsonNullValueInput | InputJsonValue
    improvement?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type OptimizationRecordUncheckedCreateWithoutTemplateInput = {
    id?: string
    timestamp: Date | string
    type: string
    reason?: string | null
    changes?: JsonNullValueInput | InputJsonValue
    metricsBefore?: JsonNullValueInput | InputJsonValue
    metricsAfter?: JsonNullValueInput | InputJsonValue
    improvement?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type OptimizationRecordCreateOrConnectWithoutTemplateInput = {
    where: OptimizationRecordWhereUniqueInput
    create: XOR<OptimizationRecordCreateWithoutTemplateInput, OptimizationRecordUncheckedCreateWithoutTemplateInput>
  }

  export type OptimizationRecordCreateManyTemplateInputEnvelope = {
    data: OptimizationRecordCreateManyTemplateInput | OptimizationRecordCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type PromptCategoryUpsertWithoutTemplatesInput = {
    update: XOR<PromptCategoryUpdateWithoutTemplatesInput, PromptCategoryUncheckedUpdateWithoutTemplatesInput>
    create: XOR<PromptCategoryCreateWithoutTemplatesInput, PromptCategoryUncheckedCreateWithoutTemplatesInput>
    where?: PromptCategoryWhereInput
  }

  export type PromptCategoryUpdateToOneWithWhereWithoutTemplatesInput = {
    where?: PromptCategoryWhereInput
    data: XOR<PromptCategoryUpdateWithoutTemplatesInput, PromptCategoryUncheckedUpdateWithoutTemplatesInput>
  }

  export type PromptCategoryUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: PromptCategoryUpdateOneWithoutChildrenNestedInput
    children?: PromptCategoryUpdateManyWithoutParentNestedInput
  }

  export type PromptCategoryUncheckedUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentCategory?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PromptCategoryUncheckedUpdateManyWithoutParentNestedInput
  }

  export type PromptExecutionUpsertWithWhereUniqueWithoutTemplateInput = {
    where: PromptExecutionWhereUniqueInput
    update: XOR<PromptExecutionUpdateWithoutTemplateInput, PromptExecutionUncheckedUpdateWithoutTemplateInput>
    create: XOR<PromptExecutionCreateWithoutTemplateInput, PromptExecutionUncheckedCreateWithoutTemplateInput>
  }

  export type PromptExecutionUpdateWithWhereUniqueWithoutTemplateInput = {
    where: PromptExecutionWhereUniqueInput
    data: XOR<PromptExecutionUpdateWithoutTemplateInput, PromptExecutionUncheckedUpdateWithoutTemplateInput>
  }

  export type PromptExecutionUpdateManyWithWhereWithoutTemplateInput = {
    where: PromptExecutionScalarWhereInput
    data: XOR<PromptExecutionUpdateManyMutationInput, PromptExecutionUncheckedUpdateManyWithoutTemplateInput>
  }

  export type PromptExecutionScalarWhereInput = {
    AND?: PromptExecutionScalarWhereInput | PromptExecutionScalarWhereInput[]
    OR?: PromptExecutionScalarWhereInput[]
    NOT?: PromptExecutionScalarWhereInput | PromptExecutionScalarWhereInput[]
    id?: StringFilter<"PromptExecution"> | string
    templateId?: StringFilter<"PromptExecution"> | string
    templateVersion?: StringFilter<"PromptExecution"> | string
    variables?: JsonFilter<"PromptExecution">
    renderedPrompt?: StringFilter<"PromptExecution"> | string
    context?: JsonNullableFilter<"PromptExecution">
    model?: StringFilter<"PromptExecution"> | string
    provider?: StringFilter<"PromptExecution"> | string
    response?: StringNullableFilter<"PromptExecution"> | string | null
    metrics?: JsonFilter<"PromptExecution">
    quality?: JsonFilter<"PromptExecution">
    feedback?: JsonNullableFilter<"PromptExecution">
    abTestVariant?: StringNullableFilter<"PromptExecution"> | string | null
    userId?: StringNullableFilter<"PromptExecution"> | string | null
    createdAt?: DateTimeFilter<"PromptExecution"> | Date | string
  }

  export type TemplateChangeUpsertWithWhereUniqueWithoutTemplateInput = {
    where: TemplateChangeWhereUniqueInput
    update: XOR<TemplateChangeUpdateWithoutTemplateInput, TemplateChangeUncheckedUpdateWithoutTemplateInput>
    create: XOR<TemplateChangeCreateWithoutTemplateInput, TemplateChangeUncheckedCreateWithoutTemplateInput>
  }

  export type TemplateChangeUpdateWithWhereUniqueWithoutTemplateInput = {
    where: TemplateChangeWhereUniqueInput
    data: XOR<TemplateChangeUpdateWithoutTemplateInput, TemplateChangeUncheckedUpdateWithoutTemplateInput>
  }

  export type TemplateChangeUpdateManyWithWhereWithoutTemplateInput = {
    where: TemplateChangeScalarWhereInput
    data: XOR<TemplateChangeUpdateManyMutationInput, TemplateChangeUncheckedUpdateManyWithoutTemplateInput>
  }

  export type TemplateChangeScalarWhereInput = {
    AND?: TemplateChangeScalarWhereInput | TemplateChangeScalarWhereInput[]
    OR?: TemplateChangeScalarWhereInput[]
    NOT?: TemplateChangeScalarWhereInput | TemplateChangeScalarWhereInput[]
    id?: StringFilter<"TemplateChange"> | string
    templateId?: StringFilter<"TemplateChange"> | string
    fromVersion?: StringFilter<"TemplateChange"> | string
    toVersion?: StringFilter<"TemplateChange"> | string
    changes?: JsonFilter<"TemplateChange">
    createdAt?: DateTimeFilter<"TemplateChange"> | Date | string
  }

  export type OptimizationRecordUpsertWithWhereUniqueWithoutTemplateInput = {
    where: OptimizationRecordWhereUniqueInput
    update: XOR<OptimizationRecordUpdateWithoutTemplateInput, OptimizationRecordUncheckedUpdateWithoutTemplateInput>
    create: XOR<OptimizationRecordCreateWithoutTemplateInput, OptimizationRecordUncheckedCreateWithoutTemplateInput>
  }

  export type OptimizationRecordUpdateWithWhereUniqueWithoutTemplateInput = {
    where: OptimizationRecordWhereUniqueInput
    data: XOR<OptimizationRecordUpdateWithoutTemplateInput, OptimizationRecordUncheckedUpdateWithoutTemplateInput>
  }

  export type OptimizationRecordUpdateManyWithWhereWithoutTemplateInput = {
    where: OptimizationRecordScalarWhereInput
    data: XOR<OptimizationRecordUpdateManyMutationInput, OptimizationRecordUncheckedUpdateManyWithoutTemplateInput>
  }

  export type OptimizationRecordScalarWhereInput = {
    AND?: OptimizationRecordScalarWhereInput | OptimizationRecordScalarWhereInput[]
    OR?: OptimizationRecordScalarWhereInput[]
    NOT?: OptimizationRecordScalarWhereInput | OptimizationRecordScalarWhereInput[]
    id?: StringFilter<"OptimizationRecord"> | string
    templateId?: StringFilter<"OptimizationRecord"> | string
    timestamp?: DateTimeFilter<"OptimizationRecord"> | Date | string
    type?: StringFilter<"OptimizationRecord"> | string
    reason?: StringNullableFilter<"OptimizationRecord"> | string | null
    changes?: JsonFilter<"OptimizationRecord">
    metricsBefore?: JsonFilter<"OptimizationRecord">
    metricsAfter?: JsonFilter<"OptimizationRecord">
    improvement?: DecimalNullableFilter<"OptimizationRecord"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"OptimizationRecord"> | Date | string
  }

  export type PromptTemplateCreateWithoutChangesInput = {
    id: string
    version: string
    name: string
    description?: string | null
    status?: string
    template: string
    variables?: JsonNullValueInput | InputJsonValue
    examples?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    optimization?: JsonNullValueInput | InputJsonValue
    testing?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryRel: PromptCategoryCreateNestedOneWithoutTemplatesInput
    executions?: PromptExecutionCreateNestedManyWithoutTemplateInput
    optimizations?: OptimizationRecordCreateNestedManyWithoutTemplateInput
  }

  export type PromptTemplateUncheckedCreateWithoutChangesInput = {
    id: string
    version: string
    name: string
    description?: string | null
    category: string
    status?: string
    template: string
    variables?: JsonNullValueInput | InputJsonValue
    examples?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    optimization?: JsonNullValueInput | InputJsonValue
    testing?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: PromptExecutionUncheckedCreateNestedManyWithoutTemplateInput
    optimizations?: OptimizationRecordUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type PromptTemplateCreateOrConnectWithoutChangesInput = {
    where: PromptTemplateWhereUniqueInput
    create: XOR<PromptTemplateCreateWithoutChangesInput, PromptTemplateUncheckedCreateWithoutChangesInput>
  }

  export type PromptTemplateUpsertWithoutChangesInput = {
    update: XOR<PromptTemplateUpdateWithoutChangesInput, PromptTemplateUncheckedUpdateWithoutChangesInput>
    create: XOR<PromptTemplateCreateWithoutChangesInput, PromptTemplateUncheckedCreateWithoutChangesInput>
    where?: PromptTemplateWhereInput
  }

  export type PromptTemplateUpdateToOneWithWhereWithoutChangesInput = {
    where?: PromptTemplateWhereInput
    data: XOR<PromptTemplateUpdateWithoutChangesInput, PromptTemplateUncheckedUpdateWithoutChangesInput>
  }

  export type PromptTemplateUpdateWithoutChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    examples?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    optimization?: JsonNullValueInput | InputJsonValue
    testing?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryRel?: PromptCategoryUpdateOneRequiredWithoutTemplatesNestedInput
    executions?: PromptExecutionUpdateManyWithoutTemplateNestedInput
    optimizations?: OptimizationRecordUpdateManyWithoutTemplateNestedInput
  }

  export type PromptTemplateUncheckedUpdateWithoutChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    examples?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    optimization?: JsonNullValueInput | InputJsonValue
    testing?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: PromptExecutionUncheckedUpdateManyWithoutTemplateNestedInput
    optimizations?: OptimizationRecordUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type PromptTemplateCreateWithoutExecutionsInput = {
    id: string
    version: string
    name: string
    description?: string | null
    status?: string
    template: string
    variables?: JsonNullValueInput | InputJsonValue
    examples?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    optimization?: JsonNullValueInput | InputJsonValue
    testing?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryRel: PromptCategoryCreateNestedOneWithoutTemplatesInput
    changes?: TemplateChangeCreateNestedManyWithoutTemplateInput
    optimizations?: OptimizationRecordCreateNestedManyWithoutTemplateInput
  }

  export type PromptTemplateUncheckedCreateWithoutExecutionsInput = {
    id: string
    version: string
    name: string
    description?: string | null
    category: string
    status?: string
    template: string
    variables?: JsonNullValueInput | InputJsonValue
    examples?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    optimization?: JsonNullValueInput | InputJsonValue
    testing?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    changes?: TemplateChangeUncheckedCreateNestedManyWithoutTemplateInput
    optimizations?: OptimizationRecordUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type PromptTemplateCreateOrConnectWithoutExecutionsInput = {
    where: PromptTemplateWhereUniqueInput
    create: XOR<PromptTemplateCreateWithoutExecutionsInput, PromptTemplateUncheckedCreateWithoutExecutionsInput>
  }

  export type PromptTemplateUpsertWithoutExecutionsInput = {
    update: XOR<PromptTemplateUpdateWithoutExecutionsInput, PromptTemplateUncheckedUpdateWithoutExecutionsInput>
    create: XOR<PromptTemplateCreateWithoutExecutionsInput, PromptTemplateUncheckedCreateWithoutExecutionsInput>
    where?: PromptTemplateWhereInput
  }

  export type PromptTemplateUpdateToOneWithWhereWithoutExecutionsInput = {
    where?: PromptTemplateWhereInput
    data: XOR<PromptTemplateUpdateWithoutExecutionsInput, PromptTemplateUncheckedUpdateWithoutExecutionsInput>
  }

  export type PromptTemplateUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    examples?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    optimization?: JsonNullValueInput | InputJsonValue
    testing?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryRel?: PromptCategoryUpdateOneRequiredWithoutTemplatesNestedInput
    changes?: TemplateChangeUpdateManyWithoutTemplateNestedInput
    optimizations?: OptimizationRecordUpdateManyWithoutTemplateNestedInput
  }

  export type PromptTemplateUncheckedUpdateWithoutExecutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    examples?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    optimization?: JsonNullValueInput | InputJsonValue
    testing?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changes?: TemplateChangeUncheckedUpdateManyWithoutTemplateNestedInput
    optimizations?: OptimizationRecordUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type PromptTemplateCreateWithoutOptimizationsInput = {
    id: string
    version: string
    name: string
    description?: string | null
    status?: string
    template: string
    variables?: JsonNullValueInput | InputJsonValue
    examples?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    optimization?: JsonNullValueInput | InputJsonValue
    testing?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryRel: PromptCategoryCreateNestedOneWithoutTemplatesInput
    executions?: PromptExecutionCreateNestedManyWithoutTemplateInput
    changes?: TemplateChangeCreateNestedManyWithoutTemplateInput
  }

  export type PromptTemplateUncheckedCreateWithoutOptimizationsInput = {
    id: string
    version: string
    name: string
    description?: string | null
    category: string
    status?: string
    template: string
    variables?: JsonNullValueInput | InputJsonValue
    examples?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    optimization?: JsonNullValueInput | InputJsonValue
    testing?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    executions?: PromptExecutionUncheckedCreateNestedManyWithoutTemplateInput
    changes?: TemplateChangeUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type PromptTemplateCreateOrConnectWithoutOptimizationsInput = {
    where: PromptTemplateWhereUniqueInput
    create: XOR<PromptTemplateCreateWithoutOptimizationsInput, PromptTemplateUncheckedCreateWithoutOptimizationsInput>
  }

  export type PromptTemplateUpsertWithoutOptimizationsInput = {
    update: XOR<PromptTemplateUpdateWithoutOptimizationsInput, PromptTemplateUncheckedUpdateWithoutOptimizationsInput>
    create: XOR<PromptTemplateCreateWithoutOptimizationsInput, PromptTemplateUncheckedCreateWithoutOptimizationsInput>
    where?: PromptTemplateWhereInput
  }

  export type PromptTemplateUpdateToOneWithWhereWithoutOptimizationsInput = {
    where?: PromptTemplateWhereInput
    data: XOR<PromptTemplateUpdateWithoutOptimizationsInput, PromptTemplateUncheckedUpdateWithoutOptimizationsInput>
  }

  export type PromptTemplateUpdateWithoutOptimizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    examples?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    optimization?: JsonNullValueInput | InputJsonValue
    testing?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryRel?: PromptCategoryUpdateOneRequiredWithoutTemplatesNestedInput
    executions?: PromptExecutionUpdateManyWithoutTemplateNestedInput
    changes?: TemplateChangeUpdateManyWithoutTemplateNestedInput
  }

  export type PromptTemplateUncheckedUpdateWithoutOptimizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    examples?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    optimization?: JsonNullValueInput | InputJsonValue
    testing?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: PromptExecutionUncheckedUpdateManyWithoutTemplateNestedInput
    changes?: TemplateChangeUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type UserCreateWithoutConversationsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    hashedPassword?: string | null
    oauthProvider?: string | null
    oauthId?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutUsersInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    mcpConfigurations?: MCPConfigurationCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutUserInput
    messageReactions?: MessageReactionCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    themes?: ThemeCreateNestedManyWithoutCreatorInput
    personalizationAnalytics?: PersonalizationAnalyticsCreateNestedManyWithoutUserInput
    conversationShares?: ConversationShareCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutConversationsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    hashedPassword?: string | null
    oauthProvider?: string | null
    oauthId?: string | null
    role?: Role
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    mcpConfigurations?: MCPConfigurationUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutUserInput
    messageReactions?: MessageReactionUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    themes?: ThemeUncheckedCreateNestedManyWithoutCreatorInput
    personalizationAnalytics?: PersonalizationAnalyticsUncheckedCreateNestedManyWithoutUserInput
    conversationShares?: ConversationShareUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutConversationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
  }

  export type MessageCreateWithoutConversationInput = {
    id?: string
    role: string
    content: string
    timestamp?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    reactions?: MessageReactionCreateNestedManyWithoutMessageInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: string
    role: string
    content: string
    timestamp?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    reactions?: MessageReactionUncheckedCreateNestedManyWithoutMessageInput
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: MessageCreateManyConversationInput | MessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type ConversationShareCreateWithoutConversationInput = {
    id?: string
    shareId: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    creator: UserCreateNestedOneWithoutConversationSharesInput
  }

  export type ConversationShareUncheckedCreateWithoutConversationInput = {
    id?: string
    shareId: string
    createdBy: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
  }

  export type ConversationShareCreateOrConnectWithoutConversationInput = {
    where: ConversationShareWhereUniqueInput
    create: XOR<ConversationShareCreateWithoutConversationInput, ConversationShareUncheckedCreateWithoutConversationInput>
  }

  export type ConversationShareCreateManyConversationInputEnvelope = {
    data: ConversationShareCreateManyConversationInput | ConversationShareCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type ConversationExportCreateWithoutConversationInput = {
    id?: string
    format: string
    options?: JsonNullValueInput | InputJsonValue
    status?: string
    downloadUrl?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    error?: string | null
  }

  export type ConversationExportUncheckedCreateWithoutConversationInput = {
    id?: string
    format: string
    options?: JsonNullValueInput | InputJsonValue
    status?: string
    downloadUrl?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    error?: string | null
  }

  export type ConversationExportCreateOrConnectWithoutConversationInput = {
    where: ConversationExportWhereUniqueInput
    create: XOR<ConversationExportCreateWithoutConversationInput, ConversationExportUncheckedCreateWithoutConversationInput>
  }

  export type ConversationExportCreateManyConversationInputEnvelope = {
    data: ConversationExportCreateManyConversationInput | ConversationExportCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutConversationsInput = {
    update: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConversationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type UserUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutUsersNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    mcpConfigurations?: MCPConfigurationUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutUserNestedInput
    messageReactions?: MessageReactionUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    themes?: ThemeUpdateManyWithoutCreatorNestedInput
    personalizationAnalytics?: PersonalizationAnalyticsUpdateManyWithoutUserNestedInput
    conversationShares?: ConversationShareUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    mcpConfigurations?: MCPConfigurationUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutUserNestedInput
    messageReactions?: MessageReactionUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    themes?: ThemeUncheckedUpdateManyWithoutCreatorNestedInput
    personalizationAnalytics?: PersonalizationAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    conversationShares?: ConversationShareUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    role?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    timestamp?: DateTimeFilter<"Message"> | Date | string
    metadata?: JsonFilter<"Message">
  }

  export type ConversationShareUpsertWithWhereUniqueWithoutConversationInput = {
    where: ConversationShareWhereUniqueInput
    update: XOR<ConversationShareUpdateWithoutConversationInput, ConversationShareUncheckedUpdateWithoutConversationInput>
    create: XOR<ConversationShareCreateWithoutConversationInput, ConversationShareUncheckedCreateWithoutConversationInput>
  }

  export type ConversationShareUpdateWithWhereUniqueWithoutConversationInput = {
    where: ConversationShareWhereUniqueInput
    data: XOR<ConversationShareUpdateWithoutConversationInput, ConversationShareUncheckedUpdateWithoutConversationInput>
  }

  export type ConversationShareUpdateManyWithWhereWithoutConversationInput = {
    where: ConversationShareScalarWhereInput
    data: XOR<ConversationShareUpdateManyMutationInput, ConversationShareUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationExportUpsertWithWhereUniqueWithoutConversationInput = {
    where: ConversationExportWhereUniqueInput
    update: XOR<ConversationExportUpdateWithoutConversationInput, ConversationExportUncheckedUpdateWithoutConversationInput>
    create: XOR<ConversationExportCreateWithoutConversationInput, ConversationExportUncheckedCreateWithoutConversationInput>
  }

  export type ConversationExportUpdateWithWhereUniqueWithoutConversationInput = {
    where: ConversationExportWhereUniqueInput
    data: XOR<ConversationExportUpdateWithoutConversationInput, ConversationExportUncheckedUpdateWithoutConversationInput>
  }

  export type ConversationExportUpdateManyWithWhereWithoutConversationInput = {
    where: ConversationExportScalarWhereInput
    data: XOR<ConversationExportUpdateManyMutationInput, ConversationExportUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationExportScalarWhereInput = {
    AND?: ConversationExportScalarWhereInput | ConversationExportScalarWhereInput[]
    OR?: ConversationExportScalarWhereInput[]
    NOT?: ConversationExportScalarWhereInput | ConversationExportScalarWhereInput[]
    id?: StringFilter<"ConversationExport"> | string
    conversationId?: StringFilter<"ConversationExport"> | string
    format?: StringFilter<"ConversationExport"> | string
    options?: JsonFilter<"ConversationExport">
    status?: StringFilter<"ConversationExport"> | string
    downloadUrl?: StringNullableFilter<"ConversationExport"> | string | null
    expiresAt?: DateTimeNullableFilter<"ConversationExport"> | Date | string | null
    createdAt?: DateTimeFilter<"ConversationExport"> | Date | string
    completedAt?: DateTimeNullableFilter<"ConversationExport"> | Date | string | null
    error?: StringNullableFilter<"ConversationExport"> | string | null
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    title: string
    metadata?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutConversationsInput
    shares?: ConversationShareCreateNestedManyWithoutConversationInput
    exports?: ConversationExportCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId: string
    title: string
    metadata?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    shares?: ConversationShareUncheckedCreateNestedManyWithoutConversationInput
    exports?: ConversationExportUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type MessageReactionCreateWithoutMessageInput = {
    id?: string
    emoji: string
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutMessageReactionsInput
  }

  export type MessageReactionUncheckedCreateWithoutMessageInput = {
    id?: string
    userId: string
    emoji: string
    timestamp?: Date | string
  }

  export type MessageReactionCreateOrConnectWithoutMessageInput = {
    where: MessageReactionWhereUniqueInput
    create: XOR<MessageReactionCreateWithoutMessageInput, MessageReactionUncheckedCreateWithoutMessageInput>
  }

  export type MessageReactionCreateManyMessageInputEnvelope = {
    data: MessageReactionCreateManyMessageInput | MessageReactionCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type MessageAttachmentCreateWithoutMessageInput = {
    id?: string
    type: string
    name: string
    url: string
    size?: bigint | number | null
    mimeType?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    thumbnail?: string | null
  }

  export type MessageAttachmentUncheckedCreateWithoutMessageInput = {
    id?: string
    type: string
    name: string
    url: string
    size?: bigint | number | null
    mimeType?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    thumbnail?: string | null
  }

  export type MessageAttachmentCreateOrConnectWithoutMessageInput = {
    where: MessageAttachmentWhereUniqueInput
    create: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput>
  }

  export type MessageAttachmentCreateManyMessageInputEnvelope = {
    data: MessageAttachmentCreateManyMessageInput | MessageAttachmentCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
    shares?: ConversationShareUpdateManyWithoutConversationNestedInput
    exports?: ConversationExportUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shares?: ConversationShareUncheckedUpdateManyWithoutConversationNestedInput
    exports?: ConversationExportUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type MessageReactionUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageReactionWhereUniqueInput
    update: XOR<MessageReactionUpdateWithoutMessageInput, MessageReactionUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageReactionCreateWithoutMessageInput, MessageReactionUncheckedCreateWithoutMessageInput>
  }

  export type MessageReactionUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageReactionWhereUniqueInput
    data: XOR<MessageReactionUpdateWithoutMessageInput, MessageReactionUncheckedUpdateWithoutMessageInput>
  }

  export type MessageReactionUpdateManyWithWhereWithoutMessageInput = {
    where: MessageReactionScalarWhereInput
    data: XOR<MessageReactionUpdateManyMutationInput, MessageReactionUncheckedUpdateManyWithoutMessageInput>
  }

  export type MessageAttachmentUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageAttachmentWhereUniqueInput
    update: XOR<MessageAttachmentUpdateWithoutMessageInput, MessageAttachmentUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageAttachmentCreateWithoutMessageInput, MessageAttachmentUncheckedCreateWithoutMessageInput>
  }

  export type MessageAttachmentUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageAttachmentWhereUniqueInput
    data: XOR<MessageAttachmentUpdateWithoutMessageInput, MessageAttachmentUncheckedUpdateWithoutMessageInput>
  }

  export type MessageAttachmentUpdateManyWithWhereWithoutMessageInput = {
    where: MessageAttachmentScalarWhereInput
    data: XOR<MessageAttachmentUpdateManyMutationInput, MessageAttachmentUncheckedUpdateManyWithoutMessageInput>
  }

  export type MessageAttachmentScalarWhereInput = {
    AND?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
    OR?: MessageAttachmentScalarWhereInput[]
    NOT?: MessageAttachmentScalarWhereInput | MessageAttachmentScalarWhereInput[]
    id?: StringFilter<"MessageAttachment"> | string
    messageId?: StringFilter<"MessageAttachment"> | string
    type?: StringFilter<"MessageAttachment"> | string
    name?: StringFilter<"MessageAttachment"> | string
    url?: StringFilter<"MessageAttachment"> | string
    size?: BigIntNullableFilter<"MessageAttachment"> | bigint | number | null
    mimeType?: StringNullableFilter<"MessageAttachment"> | string | null
    metadata?: JsonFilter<"MessageAttachment">
    thumbnail?: StringNullableFilter<"MessageAttachment"> | string | null
  }

  export type MessageCreateWithoutReactionsInput = {
    id?: string
    role: string
    content: string
    timestamp?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    attachments?: MessageAttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutReactionsInput = {
    id?: string
    conversationId: string
    role: string
    content: string
    timestamp?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    attachments?: MessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutReactionsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReactionsInput, MessageUncheckedCreateWithoutReactionsInput>
  }

  export type UserCreateWithoutMessageReactionsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    hashedPassword?: string | null
    oauthProvider?: string | null
    oauthId?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutUsersInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    mcpConfigurations?: MCPConfigurationCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    themes?: ThemeCreateNestedManyWithoutCreatorInput
    personalizationAnalytics?: PersonalizationAnalyticsCreateNestedManyWithoutUserInput
    conversationShares?: ConversationShareCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutMessageReactionsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    hashedPassword?: string | null
    oauthProvider?: string | null
    oauthId?: string | null
    role?: Role
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    mcpConfigurations?: MCPConfigurationUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    themes?: ThemeUncheckedCreateNestedManyWithoutCreatorInput
    personalizationAnalytics?: PersonalizationAnalyticsUncheckedCreateNestedManyWithoutUserInput
    conversationShares?: ConversationShareUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutMessageReactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessageReactionsInput, UserUncheckedCreateWithoutMessageReactionsInput>
  }

  export type MessageUpsertWithoutReactionsInput = {
    update: XOR<MessageUpdateWithoutReactionsInput, MessageUncheckedUpdateWithoutReactionsInput>
    create: XOR<MessageCreateWithoutReactionsInput, MessageUncheckedCreateWithoutReactionsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutReactionsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutReactionsInput, MessageUncheckedUpdateWithoutReactionsInput>
  }

  export type MessageUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type UserUpsertWithoutMessageReactionsInput = {
    update: XOR<UserUpdateWithoutMessageReactionsInput, UserUncheckedUpdateWithoutMessageReactionsInput>
    create: XOR<UserCreateWithoutMessageReactionsInput, UserUncheckedCreateWithoutMessageReactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessageReactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessageReactionsInput, UserUncheckedUpdateWithoutMessageReactionsInput>
  }

  export type UserUpdateWithoutMessageReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutUsersNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    mcpConfigurations?: MCPConfigurationUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    themes?: ThemeUpdateManyWithoutCreatorNestedInput
    personalizationAnalytics?: PersonalizationAnalyticsUpdateManyWithoutUserNestedInput
    conversationShares?: ConversationShareUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutMessageReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    mcpConfigurations?: MCPConfigurationUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    themes?: ThemeUncheckedUpdateManyWithoutCreatorNestedInput
    personalizationAnalytics?: PersonalizationAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    conversationShares?: ConversationShareUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type MessageCreateWithoutAttachmentsInput = {
    id?: string
    role: string
    content: string
    timestamp?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    reactions?: MessageReactionCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    conversationId: string
    role: string
    content: string
    timestamp?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    reactions?: MessageReactionUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutAttachmentsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
  }

  export type MessageUpsertWithoutAttachmentsInput = {
    update: XOR<MessageUpdateWithoutAttachmentsInput, MessageUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutAttachmentsInput, MessageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type MessageUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    reactions?: MessageReactionUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    reactions?: MessageReactionUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type ConversationCreateWithoutSharesInput = {
    id?: string
    title: string
    metadata?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    exports?: ConversationExportCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutSharesInput = {
    id?: string
    userId: string
    title: string
    metadata?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    exports?: ConversationExportUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutSharesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutSharesInput, ConversationUncheckedCreateWithoutSharesInput>
  }

  export type UserCreateWithoutConversationSharesInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    hashedPassword?: string | null
    oauthProvider?: string | null
    oauthId?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutUsersInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    mcpConfigurations?: MCPConfigurationCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messageReactions?: MessageReactionCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    themes?: ThemeCreateNestedManyWithoutCreatorInput
    personalizationAnalytics?: PersonalizationAnalyticsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConversationSharesInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    hashedPassword?: string | null
    oauthProvider?: string | null
    oauthId?: string | null
    role?: Role
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    mcpConfigurations?: MCPConfigurationUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messageReactions?: MessageReactionUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    themes?: ThemeUncheckedCreateNestedManyWithoutCreatorInput
    personalizationAnalytics?: PersonalizationAnalyticsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConversationSharesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationSharesInput, UserUncheckedCreateWithoutConversationSharesInput>
  }

  export type ConversationUpsertWithoutSharesInput = {
    update: XOR<ConversationUpdateWithoutSharesInput, ConversationUncheckedUpdateWithoutSharesInput>
    create: XOR<ConversationCreateWithoutSharesInput, ConversationUncheckedCreateWithoutSharesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutSharesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutSharesInput, ConversationUncheckedUpdateWithoutSharesInput>
  }

  export type ConversationUpdateWithoutSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    exports?: ConversationExportUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    exports?: ConversationExportUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type UserUpsertWithoutConversationSharesInput = {
    update: XOR<UserUpdateWithoutConversationSharesInput, UserUncheckedUpdateWithoutConversationSharesInput>
    create: XOR<UserCreateWithoutConversationSharesInput, UserUncheckedCreateWithoutConversationSharesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConversationSharesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConversationSharesInput, UserUncheckedUpdateWithoutConversationSharesInput>
  }

  export type UserUpdateWithoutConversationSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutUsersNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    mcpConfigurations?: MCPConfigurationUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messageReactions?: MessageReactionUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    themes?: ThemeUpdateManyWithoutCreatorNestedInput
    personalizationAnalytics?: PersonalizationAnalyticsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    mcpConfigurations?: MCPConfigurationUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messageReactions?: MessageReactionUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    themes?: ThemeUncheckedUpdateManyWithoutCreatorNestedInput
    personalizationAnalytics?: PersonalizationAnalyticsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ConversationCreateWithoutExportsInput = {
    id?: string
    title: string
    metadata?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    shares?: ConversationShareCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutExportsInput = {
    id?: string
    userId: string
    title: string
    metadata?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    shares?: ConversationShareUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutExportsInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutExportsInput, ConversationUncheckedCreateWithoutExportsInput>
  }

  export type ConversationUpsertWithoutExportsInput = {
    update: XOR<ConversationUpdateWithoutExportsInput, ConversationUncheckedUpdateWithoutExportsInput>
    create: XOR<ConversationCreateWithoutExportsInput, ConversationUncheckedCreateWithoutExportsInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutExportsInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutExportsInput, ConversationUncheckedUpdateWithoutExportsInput>
  }

  export type ConversationUpdateWithoutExportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    shares?: ConversationShareUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutExportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    shares?: ConversationShareUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ContextChunkCreateWithoutSourceInput = {
    id?: string
    content: string
    positionStart?: number
    positionEnd?: number
    positionIndex?: number
    positionTotal?: number
    sectionTitle?: string | null
    codeBlocks?: number
    links?: number
    images?: number
    complexity?: string
    embedding?: ContextChunkCreateembeddingInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContextChunkUncheckedCreateWithoutSourceInput = {
    id?: string
    content: string
    positionStart?: number
    positionEnd?: number
    positionIndex?: number
    positionTotal?: number
    sectionTitle?: string | null
    codeBlocks?: number
    links?: number
    images?: number
    complexity?: string
    embedding?: ContextChunkCreateembeddingInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContextChunkCreateOrConnectWithoutSourceInput = {
    where: ContextChunkWhereUniqueInput
    create: XOR<ContextChunkCreateWithoutSourceInput, ContextChunkUncheckedCreateWithoutSourceInput>
  }

  export type ContextChunkCreateManySourceInputEnvelope = {
    data: ContextChunkCreateManySourceInput | ContextChunkCreateManySourceInput[]
    skipDuplicates?: boolean
  }

  export type ContextChunkUpsertWithWhereUniqueWithoutSourceInput = {
    where: ContextChunkWhereUniqueInput
    update: XOR<ContextChunkUpdateWithoutSourceInput, ContextChunkUncheckedUpdateWithoutSourceInput>
    create: XOR<ContextChunkCreateWithoutSourceInput, ContextChunkUncheckedCreateWithoutSourceInput>
  }

  export type ContextChunkUpdateWithWhereUniqueWithoutSourceInput = {
    where: ContextChunkWhereUniqueInput
    data: XOR<ContextChunkUpdateWithoutSourceInput, ContextChunkUncheckedUpdateWithoutSourceInput>
  }

  export type ContextChunkUpdateManyWithWhereWithoutSourceInput = {
    where: ContextChunkScalarWhereInput
    data: XOR<ContextChunkUpdateManyMutationInput, ContextChunkUncheckedUpdateManyWithoutSourceInput>
  }

  export type ContextChunkScalarWhereInput = {
    AND?: ContextChunkScalarWhereInput | ContextChunkScalarWhereInput[]
    OR?: ContextChunkScalarWhereInput[]
    NOT?: ContextChunkScalarWhereInput | ContextChunkScalarWhereInput[]
    id?: StringFilter<"ContextChunk"> | string
    sourceId?: StringFilter<"ContextChunk"> | string
    content?: StringFilter<"ContextChunk"> | string
    positionStart?: IntFilter<"ContextChunk"> | number
    positionEnd?: IntFilter<"ContextChunk"> | number
    positionIndex?: IntFilter<"ContextChunk"> | number
    positionTotal?: IntFilter<"ContextChunk"> | number
    sectionTitle?: StringNullableFilter<"ContextChunk"> | string | null
    codeBlocks?: IntFilter<"ContextChunk"> | number
    links?: IntFilter<"ContextChunk"> | number
    images?: IntFilter<"ContextChunk"> | number
    complexity?: StringFilter<"ContextChunk"> | string
    embedding?: FloatNullableListFilter<"ContextChunk">
    createdAt?: DateTimeFilter<"ContextChunk"> | Date | string
    updatedAt?: DateTimeFilter<"ContextChunk"> | Date | string
  }

  export type ContextSourceCreateWithoutChunksInput = {
    id?: string
    type: string
    title: string
    content: string
    url?: string | null
    libraryId?: string | null
    version?: string | null
    language: string
    tags?: ContextSourceCreatetagsInput | string[]
    relevanceScore?: number
    freshness?: number
    popularity?: number
    lastUpdated?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContextSourceUncheckedCreateWithoutChunksInput = {
    id?: string
    type: string
    title: string
    content: string
    url?: string | null
    libraryId?: string | null
    version?: string | null
    language: string
    tags?: ContextSourceCreatetagsInput | string[]
    relevanceScore?: number
    freshness?: number
    popularity?: number
    lastUpdated?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContextSourceCreateOrConnectWithoutChunksInput = {
    where: ContextSourceWhereUniqueInput
    create: XOR<ContextSourceCreateWithoutChunksInput, ContextSourceUncheckedCreateWithoutChunksInput>
  }

  export type ContextSourceUpsertWithoutChunksInput = {
    update: XOR<ContextSourceUpdateWithoutChunksInput, ContextSourceUncheckedUpdateWithoutChunksInput>
    create: XOR<ContextSourceCreateWithoutChunksInput, ContextSourceUncheckedCreateWithoutChunksInput>
    where?: ContextSourceWhereInput
  }

  export type ContextSourceUpdateToOneWithWhereWithoutChunksInput = {
    where?: ContextSourceWhereInput
    data: XOR<ContextSourceUpdateWithoutChunksInput, ContextSourceUncheckedUpdateWithoutChunksInput>
  }

  export type ContextSourceUpdateWithoutChunksInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    libraryId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    tags?: ContextSourceUpdatetagsInput | string[]
    relevanceScore?: FloatFieldUpdateOperationsInput | number
    freshness?: FloatFieldUpdateOperationsInput | number
    popularity?: FloatFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextSourceUncheckedUpdateWithoutChunksInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    libraryId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    language?: StringFieldUpdateOperationsInput | string
    tags?: ContextSourceUpdatetagsInput | string[]
    relevanceScore?: FloatFieldUpdateOperationsInput | number
    freshness?: FloatFieldUpdateOperationsInput | number
    popularity?: FloatFieldUpdateOperationsInput | number
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextResultCreateWithoutQueryInput = {
    id?: string
    sources?: JsonNullValueInput | InputJsonValue
    chunks?: JsonNullValueInput | InputJsonValue
    summary?: string | null
    totalSources?: number
    totalChunks?: number
    queryTime?: number
    relevanceScore?: number
    coverage?: number
    freshness?: number
    suggestions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ContextResultUncheckedCreateWithoutQueryInput = {
    id?: string
    sources?: JsonNullValueInput | InputJsonValue
    chunks?: JsonNullValueInput | InputJsonValue
    summary?: string | null
    totalSources?: number
    totalChunks?: number
    queryTime?: number
    relevanceScore?: number
    coverage?: number
    freshness?: number
    suggestions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ContextResultCreateOrConnectWithoutQueryInput = {
    where: ContextResultWhereUniqueInput
    create: XOR<ContextResultCreateWithoutQueryInput, ContextResultUncheckedCreateWithoutQueryInput>
  }

  export type ContextResultCreateManyQueryInputEnvelope = {
    data: ContextResultCreateManyQueryInput | ContextResultCreateManyQueryInput[]
    skipDuplicates?: boolean
  }

  export type ContextQueryAnalyticsCreateWithoutQueryInput = {
    id?: string
    conversationId: string
    queryText: string
    intent: JsonNullValueInput | InputJsonValue
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    resultMetadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ContextQueryAnalyticsUncheckedCreateWithoutQueryInput = {
    id?: string
    conversationId: string
    queryText: string
    intent: JsonNullValueInput | InputJsonValue
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    resultMetadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ContextQueryAnalyticsCreateOrConnectWithoutQueryInput = {
    where: ContextQueryAnalyticsWhereUniqueInput
    create: XOR<ContextQueryAnalyticsCreateWithoutQueryInput, ContextQueryAnalyticsUncheckedCreateWithoutQueryInput>
  }

  export type ContextQueryAnalyticsCreateManyQueryInputEnvelope = {
    data: ContextQueryAnalyticsCreateManyQueryInput | ContextQueryAnalyticsCreateManyQueryInput[]
    skipDuplicates?: boolean
  }

  export type ContextResultUpsertWithWhereUniqueWithoutQueryInput = {
    where: ContextResultWhereUniqueInput
    update: XOR<ContextResultUpdateWithoutQueryInput, ContextResultUncheckedUpdateWithoutQueryInput>
    create: XOR<ContextResultCreateWithoutQueryInput, ContextResultUncheckedCreateWithoutQueryInput>
  }

  export type ContextResultUpdateWithWhereUniqueWithoutQueryInput = {
    where: ContextResultWhereUniqueInput
    data: XOR<ContextResultUpdateWithoutQueryInput, ContextResultUncheckedUpdateWithoutQueryInput>
  }

  export type ContextResultUpdateManyWithWhereWithoutQueryInput = {
    where: ContextResultScalarWhereInput
    data: XOR<ContextResultUpdateManyMutationInput, ContextResultUncheckedUpdateManyWithoutQueryInput>
  }

  export type ContextResultScalarWhereInput = {
    AND?: ContextResultScalarWhereInput | ContextResultScalarWhereInput[]
    OR?: ContextResultScalarWhereInput[]
    NOT?: ContextResultScalarWhereInput | ContextResultScalarWhereInput[]
    id?: StringFilter<"ContextResult"> | string
    queryId?: StringFilter<"ContextResult"> | string
    sources?: JsonFilter<"ContextResult">
    chunks?: JsonFilter<"ContextResult">
    summary?: StringNullableFilter<"ContextResult"> | string | null
    totalSources?: IntFilter<"ContextResult"> | number
    totalChunks?: IntFilter<"ContextResult"> | number
    queryTime?: IntFilter<"ContextResult"> | number
    relevanceScore?: FloatFilter<"ContextResult"> | number
    coverage?: FloatFilter<"ContextResult"> | number
    freshness?: FloatFilter<"ContextResult"> | number
    suggestions?: JsonFilter<"ContextResult">
    createdAt?: DateTimeFilter<"ContextResult"> | Date | string
  }

  export type ContextQueryAnalyticsUpsertWithWhereUniqueWithoutQueryInput = {
    where: ContextQueryAnalyticsWhereUniqueInput
    update: XOR<ContextQueryAnalyticsUpdateWithoutQueryInput, ContextQueryAnalyticsUncheckedUpdateWithoutQueryInput>
    create: XOR<ContextQueryAnalyticsCreateWithoutQueryInput, ContextQueryAnalyticsUncheckedCreateWithoutQueryInput>
  }

  export type ContextQueryAnalyticsUpdateWithWhereUniqueWithoutQueryInput = {
    where: ContextQueryAnalyticsWhereUniqueInput
    data: XOR<ContextQueryAnalyticsUpdateWithoutQueryInput, ContextQueryAnalyticsUncheckedUpdateWithoutQueryInput>
  }

  export type ContextQueryAnalyticsUpdateManyWithWhereWithoutQueryInput = {
    where: ContextQueryAnalyticsScalarWhereInput
    data: XOR<ContextQueryAnalyticsUpdateManyMutationInput, ContextQueryAnalyticsUncheckedUpdateManyWithoutQueryInput>
  }

  export type ContextQueryAnalyticsScalarWhereInput = {
    AND?: ContextQueryAnalyticsScalarWhereInput | ContextQueryAnalyticsScalarWhereInput[]
    OR?: ContextQueryAnalyticsScalarWhereInput[]
    NOT?: ContextQueryAnalyticsScalarWhereInput | ContextQueryAnalyticsScalarWhereInput[]
    id?: StringFilter<"ContextQueryAnalytics"> | string
    queryId?: StringNullableFilter<"ContextQueryAnalytics"> | string | null
    conversationId?: StringFilter<"ContextQueryAnalytics"> | string
    queryText?: StringFilter<"ContextQueryAnalytics"> | string
    intent?: JsonFilter<"ContextQueryAnalytics">
    entities?: JsonFilter<"ContextQueryAnalytics">
    filters?: JsonFilter<"ContextQueryAnalytics">
    options?: JsonFilter<"ContextQueryAnalytics">
    resultMetadata?: JsonFilter<"ContextQueryAnalytics">
    createdAt?: DateTimeFilter<"ContextQueryAnalytics"> | Date | string
  }

  export type ContextQueryCreateWithoutResultsInput = {
    id?: string
    conversationId: string
    messageId: string
    queryText: string
    intentType?: string | null
    intentConfidence?: number | null
    intentKeywords?: ContextQueryCreateintentKeywordsInput | string[]
    intentCategory?: string | null
    intentSubcategory?: string | null
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    analytics?: ContextQueryAnalyticsCreateNestedManyWithoutQueryInput
  }

  export type ContextQueryUncheckedCreateWithoutResultsInput = {
    id?: string
    conversationId: string
    messageId: string
    queryText: string
    intentType?: string | null
    intentConfidence?: number | null
    intentKeywords?: ContextQueryCreateintentKeywordsInput | string[]
    intentCategory?: string | null
    intentSubcategory?: string | null
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    analytics?: ContextQueryAnalyticsUncheckedCreateNestedManyWithoutQueryInput
  }

  export type ContextQueryCreateOrConnectWithoutResultsInput = {
    where: ContextQueryWhereUniqueInput
    create: XOR<ContextQueryCreateWithoutResultsInput, ContextQueryUncheckedCreateWithoutResultsInput>
  }

  export type ContextQueryUpsertWithoutResultsInput = {
    update: XOR<ContextQueryUpdateWithoutResultsInput, ContextQueryUncheckedUpdateWithoutResultsInput>
    create: XOR<ContextQueryCreateWithoutResultsInput, ContextQueryUncheckedCreateWithoutResultsInput>
    where?: ContextQueryWhereInput
  }

  export type ContextQueryUpdateToOneWithWhereWithoutResultsInput = {
    where?: ContextQueryWhereInput
    data: XOR<ContextQueryUpdateWithoutResultsInput, ContextQueryUncheckedUpdateWithoutResultsInput>
  }

  export type ContextQueryUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    queryText?: StringFieldUpdateOperationsInput | string
    intentType?: NullableStringFieldUpdateOperationsInput | string | null
    intentConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    intentKeywords?: ContextQueryUpdateintentKeywordsInput | string[]
    intentCategory?: NullableStringFieldUpdateOperationsInput | string | null
    intentSubcategory?: NullableStringFieldUpdateOperationsInput | string | null
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: ContextQueryAnalyticsUpdateManyWithoutQueryNestedInput
  }

  export type ContextQueryUncheckedUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    queryText?: StringFieldUpdateOperationsInput | string
    intentType?: NullableStringFieldUpdateOperationsInput | string | null
    intentConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    intentKeywords?: ContextQueryUpdateintentKeywordsInput | string[]
    intentCategory?: NullableStringFieldUpdateOperationsInput | string | null
    intentSubcategory?: NullableStringFieldUpdateOperationsInput | string | null
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    analytics?: ContextQueryAnalyticsUncheckedUpdateManyWithoutQueryNestedInput
  }

  export type ContextQueryCreateWithoutAnalyticsInput = {
    id?: string
    conversationId: string
    messageId: string
    queryText: string
    intentType?: string | null
    intentConfidence?: number | null
    intentKeywords?: ContextQueryCreateintentKeywordsInput | string[]
    intentCategory?: string | null
    intentSubcategory?: string | null
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    results?: ContextResultCreateNestedManyWithoutQueryInput
  }

  export type ContextQueryUncheckedCreateWithoutAnalyticsInput = {
    id?: string
    conversationId: string
    messageId: string
    queryText: string
    intentType?: string | null
    intentConfidence?: number | null
    intentKeywords?: ContextQueryCreateintentKeywordsInput | string[]
    intentCategory?: string | null
    intentSubcategory?: string | null
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    results?: ContextResultUncheckedCreateNestedManyWithoutQueryInput
  }

  export type ContextQueryCreateOrConnectWithoutAnalyticsInput = {
    where: ContextQueryWhereUniqueInput
    create: XOR<ContextQueryCreateWithoutAnalyticsInput, ContextQueryUncheckedCreateWithoutAnalyticsInput>
  }

  export type ContextQueryUpsertWithoutAnalyticsInput = {
    update: XOR<ContextQueryUpdateWithoutAnalyticsInput, ContextQueryUncheckedUpdateWithoutAnalyticsInput>
    create: XOR<ContextQueryCreateWithoutAnalyticsInput, ContextQueryUncheckedCreateWithoutAnalyticsInput>
    where?: ContextQueryWhereInput
  }

  export type ContextQueryUpdateToOneWithWhereWithoutAnalyticsInput = {
    where?: ContextQueryWhereInput
    data: XOR<ContextQueryUpdateWithoutAnalyticsInput, ContextQueryUncheckedUpdateWithoutAnalyticsInput>
  }

  export type ContextQueryUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    queryText?: StringFieldUpdateOperationsInput | string
    intentType?: NullableStringFieldUpdateOperationsInput | string | null
    intentConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    intentKeywords?: ContextQueryUpdateintentKeywordsInput | string[]
    intentCategory?: NullableStringFieldUpdateOperationsInput | string | null
    intentSubcategory?: NullableStringFieldUpdateOperationsInput | string | null
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: ContextResultUpdateManyWithoutQueryNestedInput
  }

  export type ContextQueryUncheckedUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    queryText?: StringFieldUpdateOperationsInput | string
    intentType?: NullableStringFieldUpdateOperationsInput | string | null
    intentConfidence?: NullableFloatFieldUpdateOperationsInput | number | null
    intentKeywords?: ContextQueryUpdateintentKeywordsInput | string[]
    intentCategory?: NullableStringFieldUpdateOperationsInput | string | null
    intentSubcategory?: NullableStringFieldUpdateOperationsInput | string | null
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    results?: ContextResultUncheckedUpdateManyWithoutQueryNestedInput
  }

  export type UserCreateWithoutUserPreferencesInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    hashedPassword?: string | null
    oauthProvider?: string | null
    oauthId?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutUsersInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    mcpConfigurations?: MCPConfigurationCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messageReactions?: MessageReactionCreateNestedManyWithoutUserInput
    themes?: ThemeCreateNestedManyWithoutCreatorInput
    personalizationAnalytics?: PersonalizationAnalyticsCreateNestedManyWithoutUserInput
    conversationShares?: ConversationShareCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutUserPreferencesInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    hashedPassword?: string | null
    oauthProvider?: string | null
    oauthId?: string | null
    role?: Role
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    mcpConfigurations?: MCPConfigurationUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messageReactions?: MessageReactionUncheckedCreateNestedManyWithoutUserInput
    themes?: ThemeUncheckedCreateNestedManyWithoutCreatorInput
    personalizationAnalytics?: PersonalizationAnalyticsUncheckedCreateNestedManyWithoutUserInput
    conversationShares?: ConversationShareUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutUserPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserPreferencesInput, UserUncheckedCreateWithoutUserPreferencesInput>
  }

  export type UserUpsertWithoutUserPreferencesInput = {
    update: XOR<UserUpdateWithoutUserPreferencesInput, UserUncheckedUpdateWithoutUserPreferencesInput>
    create: XOR<UserCreateWithoutUserPreferencesInput, UserUncheckedCreateWithoutUserPreferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserPreferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserPreferencesInput, UserUncheckedUpdateWithoutUserPreferencesInput>
  }

  export type UserUpdateWithoutUserPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutUsersNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    mcpConfigurations?: MCPConfigurationUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messageReactions?: MessageReactionUpdateManyWithoutUserNestedInput
    themes?: ThemeUpdateManyWithoutCreatorNestedInput
    personalizationAnalytics?: PersonalizationAnalyticsUpdateManyWithoutUserNestedInput
    conversationShares?: ConversationShareUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutUserPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    mcpConfigurations?: MCPConfigurationUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messageReactions?: MessageReactionUncheckedUpdateManyWithoutUserNestedInput
    themes?: ThemeUncheckedUpdateManyWithoutCreatorNestedInput
    personalizationAnalytics?: PersonalizationAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    conversationShares?: ConversationShareUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutThemesInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    hashedPassword?: string | null
    oauthProvider?: string | null
    oauthId?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutUsersInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    mcpConfigurations?: MCPConfigurationCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messageReactions?: MessageReactionCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    personalizationAnalytics?: PersonalizationAnalyticsCreateNestedManyWithoutUserInput
    conversationShares?: ConversationShareCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutThemesInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    hashedPassword?: string | null
    oauthProvider?: string | null
    oauthId?: string | null
    role?: Role
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    mcpConfigurations?: MCPConfigurationUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messageReactions?: MessageReactionUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    personalizationAnalytics?: PersonalizationAnalyticsUncheckedCreateNestedManyWithoutUserInput
    conversationShares?: ConversationShareUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutThemesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutThemesInput, UserUncheckedCreateWithoutThemesInput>
  }

  export type UserUpsertWithoutThemesInput = {
    update: XOR<UserUpdateWithoutThemesInput, UserUncheckedUpdateWithoutThemesInput>
    create: XOR<UserCreateWithoutThemesInput, UserUncheckedCreateWithoutThemesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutThemesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutThemesInput, UserUncheckedUpdateWithoutThemesInput>
  }

  export type UserUpdateWithoutThemesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutUsersNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    mcpConfigurations?: MCPConfigurationUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messageReactions?: MessageReactionUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    personalizationAnalytics?: PersonalizationAnalyticsUpdateManyWithoutUserNestedInput
    conversationShares?: ConversationShareUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutThemesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    mcpConfigurations?: MCPConfigurationUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messageReactions?: MessageReactionUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    personalizationAnalytics?: PersonalizationAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    conversationShares?: ConversationShareUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutPersonalizationAnalyticsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    hashedPassword?: string | null
    oauthProvider?: string | null
    oauthId?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutUsersInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    mcpConfigurations?: MCPConfigurationCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogCreateNestedManyWithoutUserInput
    oauthTokens?: OAuthTokenCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    messageReactions?: MessageReactionCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    themes?: ThemeCreateNestedManyWithoutCreatorInput
    conversationShares?: ConversationShareCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutPersonalizationAnalyticsInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    hashedPassword?: string | null
    oauthProvider?: string | null
    oauthId?: string | null
    role?: Role
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    mcpConfigurations?: MCPConfigurationUncheckedCreateNestedManyWithoutUserInput
    usageLogs?: UsageLogUncheckedCreateNestedManyWithoutUserInput
    oauthTokens?: OAuthTokenUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    messageReactions?: MessageReactionUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    themes?: ThemeUncheckedCreateNestedManyWithoutCreatorInput
    conversationShares?: ConversationShareUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutPersonalizationAnalyticsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPersonalizationAnalyticsInput, UserUncheckedCreateWithoutPersonalizationAnalyticsInput>
  }

  export type UserUpsertWithoutPersonalizationAnalyticsInput = {
    update: XOR<UserUpdateWithoutPersonalizationAnalyticsInput, UserUncheckedUpdateWithoutPersonalizationAnalyticsInput>
    create: XOR<UserCreateWithoutPersonalizationAnalyticsInput, UserUncheckedCreateWithoutPersonalizationAnalyticsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPersonalizationAnalyticsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPersonalizationAnalyticsInput, UserUncheckedUpdateWithoutPersonalizationAnalyticsInput>
  }

  export type UserUpdateWithoutPersonalizationAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutUsersNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    mcpConfigurations?: MCPConfigurationUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messageReactions?: MessageReactionUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    themes?: ThemeUpdateManyWithoutCreatorNestedInput
    conversationShares?: ConversationShareUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutPersonalizationAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    mcpConfigurations?: MCPConfigurationUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messageReactions?: MessageReactionUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    themes?: ThemeUncheckedUpdateManyWithoutCreatorNestedInput
    conversationShares?: ConversationShareUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type InvoiceCreateWithoutUserProfileInput = {
    id?: string
    number: string
    status?: InvoiceStatus
    period: JsonNullValueInput | InputJsonValue
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    currency?: string
    items?: JsonNullValueInput | InputJsonValue
    billingAddress?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutUserProfileInput = {
    id?: string
    number: string
    status?: InvoiceStatus
    period: JsonNullValueInput | InputJsonValue
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    currency?: string
    items?: JsonNullValueInput | InputJsonValue
    billingAddress?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutUserProfileInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutUserProfileInput, InvoiceUncheckedCreateWithoutUserProfileInput>
  }

  export type InvoiceCreateManyUserProfileInputEnvelope = {
    data: InvoiceCreateManyUserProfileInput | InvoiceCreateManyUserProfileInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutUserProfileInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status?: PaymentStatus
    providerTransactionId?: string | null
    failureReason?: string | null
    refundedAmount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutUserProfileInput = {
    id?: string
    invoiceId: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status?: PaymentStatus
    providerTransactionId?: string | null
    failureReason?: string | null
    refundedAmount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type PaymentCreateOrConnectWithoutUserProfileInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserProfileInput, PaymentUncheckedCreateWithoutUserProfileInput>
  }

  export type PaymentCreateManyUserProfileInputEnvelope = {
    data: PaymentCreateManyUserProfileInput | PaymentCreateManyUserProfileInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutUserProfileInput = {
    id?: string
    plan: string
    status?: SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    interval?: SubscriptionInterval
    intervalCount?: number
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type SubscriptionUncheckedCreateWithoutUserProfileInput = {
    id?: string
    plan: string
    status?: SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    interval?: SubscriptionInterval
    intervalCount?: number
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type SubscriptionCreateOrConnectWithoutUserProfileInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUserProfileInput, SubscriptionUncheckedCreateWithoutUserProfileInput>
  }

  export type SubscriptionCreateManyUserProfileInputEnvelope = {
    data: SubscriptionCreateManyUserProfileInput | SubscriptionCreateManyUserProfileInput[]
    skipDuplicates?: boolean
  }

  export type CreditCreateWithoutUserProfileInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    reason: string
    type: CreditType
    expiresAt?: Date | string | null
    usedAt?: Date | string | null
    invoiceId?: string | null
    createdAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type CreditUncheckedCreateWithoutUserProfileInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    reason: string
    type: CreditType
    expiresAt?: Date | string | null
    usedAt?: Date | string | null
    invoiceId?: string | null
    createdAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type CreditCreateOrConnectWithoutUserProfileInput = {
    where: CreditWhereUniqueInput
    create: XOR<CreditCreateWithoutUserProfileInput, CreditUncheckedCreateWithoutUserProfileInput>
  }

  export type CreditCreateManyUserProfileInputEnvelope = {
    data: CreditCreateManyUserProfileInput | CreditCreateManyUserProfileInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceUpsertWithWhereUniqueWithoutUserProfileInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutUserProfileInput, InvoiceUncheckedUpdateWithoutUserProfileInput>
    create: XOR<InvoiceCreateWithoutUserProfileInput, InvoiceUncheckedCreateWithoutUserProfileInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutUserProfileInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutUserProfileInput, InvoiceUncheckedUpdateWithoutUserProfileInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutUserProfileInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    number?: StringFilter<"Invoice"> | string
    userId?: StringFilter<"Invoice"> | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | InvoiceStatus
    period?: JsonFilter<"Invoice">
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    paidDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    subtotal?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    tax?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Invoice"> | string
    items?: JsonFilter<"Invoice">
    billingAddress?: JsonFilter<"Invoice">
    metadata?: JsonFilter<"Invoice">
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserProfileInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserProfileInput, PaymentUncheckedUpdateWithoutUserProfileInput>
    create: XOR<PaymentCreateWithoutUserProfileInput, PaymentUncheckedCreateWithoutUserProfileInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserProfileInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserProfileInput, PaymentUncheckedUpdateWithoutUserProfileInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserProfileInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    invoiceId?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | PaymentStatus
    providerTransactionId?: StringNullableFilter<"Payment"> | string | null
    failureReason?: StringNullableFilter<"Payment"> | string | null
    refundedAmount?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    processedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    metadata?: JsonFilter<"Payment">
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutUserProfileInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutUserProfileInput, SubscriptionUncheckedUpdateWithoutUserProfileInput>
    create: XOR<SubscriptionCreateWithoutUserProfileInput, SubscriptionUncheckedCreateWithoutUserProfileInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutUserProfileInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutUserProfileInput, SubscriptionUncheckedUpdateWithoutUserProfileInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutUserProfileInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    plan?: StringFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusFilter<"Subscription"> | SubscriptionStatus
    currentPeriodStart?: DateTimeFilter<"Subscription"> | Date | string
    currentPeriodEnd?: DateTimeFilter<"Subscription"> | Date | string
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    amount?: DecimalFilter<"Subscription"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Subscription"> | string
    interval?: EnumSubscriptionIntervalFilter<"Subscription"> | SubscriptionInterval
    intervalCount?: IntFilter<"Subscription"> | number
    trialStart?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    trialEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    metadata?: JsonFilter<"Subscription">
  }

  export type CreditUpsertWithWhereUniqueWithoutUserProfileInput = {
    where: CreditWhereUniqueInput
    update: XOR<CreditUpdateWithoutUserProfileInput, CreditUncheckedUpdateWithoutUserProfileInput>
    create: XOR<CreditCreateWithoutUserProfileInput, CreditUncheckedCreateWithoutUserProfileInput>
  }

  export type CreditUpdateWithWhereUniqueWithoutUserProfileInput = {
    where: CreditWhereUniqueInput
    data: XOR<CreditUpdateWithoutUserProfileInput, CreditUncheckedUpdateWithoutUserProfileInput>
  }

  export type CreditUpdateManyWithWhereWithoutUserProfileInput = {
    where: CreditScalarWhereInput
    data: XOR<CreditUpdateManyMutationInput, CreditUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type CreditScalarWhereInput = {
    AND?: CreditScalarWhereInput | CreditScalarWhereInput[]
    OR?: CreditScalarWhereInput[]
    NOT?: CreditScalarWhereInput | CreditScalarWhereInput[]
    id?: StringFilter<"Credit"> | string
    userId?: StringFilter<"Credit"> | string
    amount?: DecimalFilter<"Credit"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Credit"> | string
    reason?: StringFilter<"Credit"> | string
    type?: EnumCreditTypeFilter<"Credit"> | CreditType
    expiresAt?: DateTimeNullableFilter<"Credit"> | Date | string | null
    usedAt?: DateTimeNullableFilter<"Credit"> | Date | string | null
    invoiceId?: StringNullableFilter<"Credit"> | string | null
    createdAt?: DateTimeFilter<"Credit"> | Date | string
    metadata?: JsonFilter<"Credit">
  }

  export type UserProfileCreateWithoutInvoicesInput = {
    id?: string
    userId: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentCreateNestedManyWithoutUserProfileInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserProfileInput
    credits?: CreditCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutInvoicesInput = {
    id?: string
    userId: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutUserProfileInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserProfileInput
    credits?: CreditUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutInvoicesInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutInvoicesInput, UserProfileUncheckedCreateWithoutInvoicesInput>
  }

  export type PaymentCreateWithoutInvoiceInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status?: PaymentStatus
    providerTransactionId?: string | null
    failureReason?: string | null
    refundedAmount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    userProfile: UserProfileCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status?: PaymentStatus
    providerTransactionId?: string | null
    failureReason?: string | null
    refundedAmount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateManyInvoiceInputEnvelope = {
    data: PaymentCreateManyInvoiceInput | PaymentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type UserProfileUpsertWithoutInvoicesInput = {
    update: XOR<UserProfileUpdateWithoutInvoicesInput, UserProfileUncheckedUpdateWithoutInvoicesInput>
    create: XOR<UserProfileCreateWithoutInvoicesInput, UserProfileUncheckedCreateWithoutInvoicesInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutInvoicesInput, UserProfileUncheckedUpdateWithoutInvoicesInput>
  }

  export type UserProfileUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUpdateManyWithoutUserProfileNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserProfileNestedInput
    credits?: CreditUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutUserProfileNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserProfileNestedInput
    credits?: CreditUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    id?: string
    number: string
    status?: InvoiceStatus
    period: JsonNullValueInput | InputJsonValue
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    currency?: string
    items?: JsonNullValueInput | InputJsonValue
    billingAddress?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userProfile: UserProfileCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string
    number: string
    userId: string
    status?: InvoiceStatus
    period: JsonNullValueInput | InputJsonValue
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    currency?: string
    items?: JsonNullValueInput | InputJsonValue
    billingAddress?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type UserProfileCreateWithoutPaymentsInput = {
    id?: string
    userId: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutUserProfileInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserProfileInput
    credits?: CreditCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutPaymentsInput = {
    id?: string
    userId: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserProfileInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserProfileInput
    credits?: CreditUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutPaymentsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutPaymentsInput, UserProfileUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    period?: JsonNullValueInput | InputJsonValue
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    billingAddress?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProfile?: UserProfileUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    period?: JsonNullValueInput | InputJsonValue
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    billingAddress?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUpsertWithoutPaymentsInput = {
    update: XOR<UserProfileUpdateWithoutPaymentsInput, UserProfileUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserProfileCreateWithoutPaymentsInput, UserProfileUncheckedCreateWithoutPaymentsInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutPaymentsInput, UserProfileUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserProfileUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutUserProfileNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserProfileNestedInput
    credits?: CreditUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutUserProfileNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserProfileNestedInput
    credits?: CreditUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileCreateWithoutSubscriptionsInput = {
    id?: string
    userId: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutUserProfileInput
    payments?: PaymentCreateNestedManyWithoutUserProfileInput
    credits?: CreditCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    userId: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserProfileInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserProfileInput
    credits?: CreditUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutSubscriptionsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutSubscriptionsInput, UserProfileUncheckedCreateWithoutSubscriptionsInput>
  }

  export type UserProfileUpsertWithoutSubscriptionsInput = {
    update: XOR<UserProfileUpdateWithoutSubscriptionsInput, UserProfileUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<UserProfileCreateWithoutSubscriptionsInput, UserProfileUncheckedCreateWithoutSubscriptionsInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutSubscriptionsInput, UserProfileUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UserProfileUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutUserProfileNestedInput
    payments?: PaymentUpdateManyWithoutUserProfileNestedInput
    credits?: CreditUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutUserProfileNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserProfileNestedInput
    credits?: CreditUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileCreateWithoutCreditsInput = {
    id?: string
    userId: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutUserProfileInput
    payments?: PaymentCreateNestedManyWithoutUserProfileInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutCreditsInput = {
    id?: string
    userId: string
    firstName?: string | null
    lastName?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    postalCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserProfileInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserProfileInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutCreditsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutCreditsInput, UserProfileUncheckedCreateWithoutCreditsInput>
  }

  export type UserProfileUpsertWithoutCreditsInput = {
    update: XOR<UserProfileUpdateWithoutCreditsInput, UserProfileUncheckedUpdateWithoutCreditsInput>
    create: XOR<UserProfileCreateWithoutCreditsInput, UserProfileUncheckedCreateWithoutCreditsInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutCreditsInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutCreditsInput, UserProfileUncheckedUpdateWithoutCreditsInput>
  }

  export type UserProfileUpdateWithoutCreditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutUserProfileNestedInput
    payments?: PaymentUpdateManyWithoutUserProfileNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutCreditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutUserProfileNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserProfileNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type ModuleOnClientCreateManyClientInput = {
    id?: string
    moduleId: string
    enabled?: boolean
  }

  export type EnvironmentVariableCreateManyClientInput = {
    id?: string
    key: string
    value: string
    environment?: Environment
  }

  export type UserCreateManyClientInput = {
    id?: string
    email: string
    name?: string | null
    avatar?: string | null
    hashedPassword?: string | null
    oauthProvider?: string | null
    oauthId?: string | null
    role?: Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LibraryCreateManyClientInput = {
    id: string
    name: string
    displayName: string
    description?: string | null
    vendor?: string | null
    repoUrl?: string | null
    docsUrl?: string | null
    defaultVersion?: string | null
    popularityScore?: number
    totalSnippets?: number
    totalTokens?: number
    language: string
    ecosystem: string
    tags?: LibraryCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastCrawledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleOnClientUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    module?: ModuleUpdateOneRequiredWithoutClientsNestedInput
  }

  export type ModuleOnClientUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ModuleOnClientUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EnvironmentVariableUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    environment?: EnumEnvironmentFieldUpdateOperationsInput | Environment
  }

  export type EnvironmentVariableUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    environment?: EnumEnvironmentFieldUpdateOperationsInput | Environment
  }

  export type EnvironmentVariableUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    environment?: EnumEnvironmentFieldUpdateOperationsInput | Environment
  }

  export type UserUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    mcpConfigurations?: MCPConfigurationUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUpdateManyWithoutUserNestedInput
    oauthTokens?: OAuthTokenUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    messageReactions?: MessageReactionUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    themes?: ThemeUpdateManyWithoutCreatorNestedInput
    personalizationAnalytics?: PersonalizationAnalyticsUpdateManyWithoutUserNestedInput
    conversationShares?: ConversationShareUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    mcpConfigurations?: MCPConfigurationUncheckedUpdateManyWithoutUserNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutUserNestedInput
    oauthTokens?: OAuthTokenUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    messageReactions?: MessageReactionUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    themes?: ThemeUncheckedUpdateManyWithoutCreatorNestedInput
    personalizationAnalytics?: PersonalizationAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    conversationShares?: ConversationShareUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    oauthProvider?: NullableStringFieldUpdateOperationsInput | string | null
    oauthId?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LibraryUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    docsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    defaultVersion?: NullableStringFieldUpdateOperationsInput | string | null
    popularityScore?: FloatFieldUpdateOperationsInput | number
    totalSnippets?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    ecosystem?: StringFieldUpdateOperationsInput | string
    tags?: LibraryUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastCrawledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: LibraryVersionUpdateManyWithoutLibraryNestedInput
    aliases?: LibraryAliasUpdateManyWithoutLibraryNestedInput
    documentationChunks?: DocumentationChunkUpdateManyWithoutLibraryNestedInput
    usageLogs?: UsageLogUpdateManyWithoutLibraryNestedInput
  }

  export type LibraryUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    docsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    defaultVersion?: NullableStringFieldUpdateOperationsInput | string | null
    popularityScore?: FloatFieldUpdateOperationsInput | number
    totalSnippets?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    ecosystem?: StringFieldUpdateOperationsInput | string
    tags?: LibraryUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastCrawledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: LibraryVersionUncheckedUpdateManyWithoutLibraryNestedInput
    aliases?: LibraryAliasUncheckedUpdateManyWithoutLibraryNestedInput
    documentationChunks?: DocumentationChunkUncheckedUpdateManyWithoutLibraryNestedInput
    usageLogs?: UsageLogUncheckedUpdateManyWithoutLibraryNestedInput
  }

  export type LibraryUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    repoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    docsUrl?: NullableStringFieldUpdateOperationsInput | string | null
    defaultVersion?: NullableStringFieldUpdateOperationsInput | string | null
    popularityScore?: FloatFieldUpdateOperationsInput | number
    totalSnippets?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    ecosystem?: StringFieldUpdateOperationsInput | string
    tags?: LibraryUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    lastCrawledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleOnClientCreateManyModuleInput = {
    id?: string
    clientId: string
    enabled?: boolean
  }

  export type ModuleOnClientUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    client?: ClientUpdateOneRequiredWithoutModulesNestedInput
  }

  export type ModuleOnClientUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ModuleOnClientUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ApiKeyCreateManyUserInput = {
    id?: string
    keyHash: string
    keyPrefix: string
    name?: string | null
    tier?: string
    quotaDaily?: number
    quotaMonthly?: number
    usedDaily?: number
    usedMonthly?: number
    lastUsedAt?: Date | string | null
    expiresAt?: Date | string | null
    isActive?: boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type MCPConfigurationCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    configData: JsonNullValueInput | InputJsonValue
    status?: ConfigStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageLogCreateManyUserInput = {
    id?: string
    apiKeyId?: string | null
    libraryId?: string | null
    toolName: string
    query?: string | null
    tokensReturned?: number | null
    responseTimeMs?: number | null
    createdAt?: Date | string
  }

  export type OAuthTokenCreateManyUserInput = {
    id?: string
    provider: string
    accessToken: string
    refreshToken?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type ConversationCreateManyUserInput = {
    id?: string
    title: string
    metadata?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageReactionCreateManyUserInput = {
    id?: string
    messageId: string
    emoji: string
    timestamp?: Date | string
  }

  export type ThemeCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    category: string
    colors: JsonNullValueInput | InputJsonValue
    typography: JsonNullValueInput | InputJsonValue
    spacing: JsonNullValueInput | InputJsonValue
    shadows: JsonNullValueInput | InputJsonValue
    borderRadius: JsonNullValueInput | InputJsonValue
    animations: JsonNullValueInput | InputJsonValue
    custom?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonalizationAnalyticsCreateManyUserInput = {
    id?: string
    actionType: string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ConversationShareCreateManyCreatorInput = {
    id?: string
    conversationId: string
    shareId: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
  }

  export type ApiKeyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: StringFieldUpdateOperationsInput | string
    quotaDaily?: IntFieldUpdateOperationsInput | number
    quotaMonthly?: IntFieldUpdateOperationsInput | number
    usedDaily?: IntFieldUpdateOperationsInput | number
    usedMonthly?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLogs?: UsageLogUpdateManyWithoutApiKeyNestedInput
  }

  export type ApiKeyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: StringFieldUpdateOperationsInput | string
    quotaDaily?: IntFieldUpdateOperationsInput | number
    quotaMonthly?: IntFieldUpdateOperationsInput | number
    usedDaily?: IntFieldUpdateOperationsInput | number
    usedMonthly?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLogs?: UsageLogUncheckedUpdateManyWithoutApiKeyNestedInput
  }

  export type ApiKeyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyHash?: StringFieldUpdateOperationsInput | string
    keyPrefix?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tier?: StringFieldUpdateOperationsInput | string
    quotaDaily?: IntFieldUpdateOperationsInput | number
    quotaMonthly?: IntFieldUpdateOperationsInput | number
    usedDaily?: IntFieldUpdateOperationsInput | number
    usedMonthly?: IntFieldUpdateOperationsInput | number
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    permissions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MCPConfigurationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    configData?: JsonNullValueInput | InputJsonValue
    status?: EnumConfigStatusFieldUpdateOperationsInput | ConfigStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MCPConfigurationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    configData?: JsonNullValueInput | InputJsonValue
    status?: EnumConfigStatusFieldUpdateOperationsInput | ConfigStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MCPConfigurationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    configData?: JsonNullValueInput | InputJsonValue
    status?: EnumConfigStatusFieldUpdateOperationsInput | ConfigStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    toolName?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    tokensReturned?: NullableIntFieldUpdateOperationsInput | number | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiKey?: ApiKeyUpdateOneWithoutUsageLogsNestedInput
    library?: LibraryUpdateOneWithoutUsageLogsNestedInput
  }

  export type UsageLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    apiKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    libraryId?: NullableStringFieldUpdateOperationsInput | string | null
    toolName?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    tokensReturned?: NullableIntFieldUpdateOperationsInput | number | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    apiKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    libraryId?: NullableStringFieldUpdateOperationsInput | string | null
    toolName?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    tokensReturned?: NullableIntFieldUpdateOperationsInput | number | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutConversationNestedInput
    shares?: ConversationShareUpdateManyWithoutConversationNestedInput
    exports?: ConversationExportUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    shares?: ConversationShareUncheckedUpdateManyWithoutConversationNestedInput
    exports?: ConversationExportUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutReactionsNestedInput
  }

  export type MessageReactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThemeUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    colors?: JsonNullValueInput | InputJsonValue
    typography?: JsonNullValueInput | InputJsonValue
    spacing?: JsonNullValueInput | InputJsonValue
    shadows?: JsonNullValueInput | InputJsonValue
    borderRadius?: JsonNullValueInput | InputJsonValue
    animations?: JsonNullValueInput | InputJsonValue
    custom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThemeUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    colors?: JsonNullValueInput | InputJsonValue
    typography?: JsonNullValueInput | InputJsonValue
    spacing?: JsonNullValueInput | InputJsonValue
    shadows?: JsonNullValueInput | InputJsonValue
    borderRadius?: JsonNullValueInput | InputJsonValue
    animations?: JsonNullValueInput | InputJsonValue
    custom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThemeUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    colors?: JsonNullValueInput | InputJsonValue
    typography?: JsonNullValueInput | InputJsonValue
    spacing?: JsonNullValueInput | InputJsonValue
    shadows?: JsonNullValueInput | InputJsonValue
    borderRadius?: JsonNullValueInput | InputJsonValue
    animations?: JsonNullValueInput | InputJsonValue
    custom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalizationAnalyticsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalizationAnalyticsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalizationAnalyticsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationShareUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    shareId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    conversation?: ConversationUpdateOneRequiredWithoutSharesNestedInput
  }

  export type ConversationShareUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    shareId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
  }

  export type ConversationShareUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    shareId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
  }

  export type LibraryVersionCreateManyLibraryInput = {
    id?: string
    version: string
    releaseDate?: Date | string | null
    isLatest?: boolean
    docsSnapshotUrl?: string | null
  }

  export type LibraryAliasCreateManyLibraryInput = {
    id?: string
    alias: string
  }

  export type DocumentationChunkCreateManyLibraryInput = {
    id?: string
    libraryVersionId: string
    chunkIndex: number
    content: string
    contentType: string
    sourceUrl?: string | null
    tokenCount: number
    embeddingId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UsageLogCreateManyLibraryInput = {
    id?: string
    userId?: string | null
    apiKeyId?: string | null
    toolName: string
    query?: string | null
    tokensReturned?: number | null
    responseTimeMs?: number | null
    createdAt?: Date | string
  }

  export type LibraryVersionUpdateWithoutLibraryInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    docsSnapshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    documentationChunks?: DocumentationChunkUpdateManyWithoutLibraryVersionNestedInput
  }

  export type LibraryVersionUncheckedUpdateWithoutLibraryInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    docsSnapshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
    documentationChunks?: DocumentationChunkUncheckedUpdateManyWithoutLibraryVersionNestedInput
  }

  export type LibraryVersionUncheckedUpdateManyWithoutLibraryInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isLatest?: BoolFieldUpdateOperationsInput | boolean
    docsSnapshotUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LibraryAliasUpdateWithoutLibraryInput = {
    id?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
  }

  export type LibraryAliasUncheckedUpdateWithoutLibraryInput = {
    id?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
  }

  export type LibraryAliasUncheckedUpdateManyWithoutLibraryInput = {
    id?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentationChunkUpdateWithoutLibraryInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tokenCount?: IntFieldUpdateOperationsInput | number
    embeddingId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryVersion?: LibraryVersionUpdateOneRequiredWithoutDocumentationChunksNestedInput
  }

  export type DocumentationChunkUncheckedUpdateWithoutLibraryInput = {
    id?: StringFieldUpdateOperationsInput | string
    libraryVersionId?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tokenCount?: IntFieldUpdateOperationsInput | number
    embeddingId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentationChunkUncheckedUpdateManyWithoutLibraryInput = {
    id?: StringFieldUpdateOperationsInput | string
    libraryVersionId?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tokenCount?: IntFieldUpdateOperationsInput | number
    embeddingId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLogUpdateWithoutLibraryInput = {
    id?: StringFieldUpdateOperationsInput | string
    toolName?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    tokensReturned?: NullableIntFieldUpdateOperationsInput | number | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutUsageLogsNestedInput
    apiKey?: ApiKeyUpdateOneWithoutUsageLogsNestedInput
  }

  export type UsageLogUncheckedUpdateWithoutLibraryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    apiKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    toolName?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    tokensReturned?: NullableIntFieldUpdateOperationsInput | number | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLogUncheckedUpdateManyWithoutLibraryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    apiKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    toolName?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    tokensReturned?: NullableIntFieldUpdateOperationsInput | number | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentationChunkCreateManyLibraryVersionInput = {
    id?: string
    chunkIndex: number
    content: string
    contentType: string
    sourceUrl?: string | null
    tokenCount: number
    embeddingId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    libraryId?: string | null
  }

  export type DocumentationChunkUpdateWithoutLibraryVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tokenCount?: IntFieldUpdateOperationsInput | number
    embeddingId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Library?: LibraryUpdateOneWithoutDocumentationChunksNestedInput
  }

  export type DocumentationChunkUncheckedUpdateWithoutLibraryVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tokenCount?: IntFieldUpdateOperationsInput | number
    embeddingId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentationChunkUncheckedUpdateManyWithoutLibraryVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tokenCount?: IntFieldUpdateOperationsInput | number
    embeddingId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    libraryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsageLogCreateManyApiKeyInput = {
    id?: string
    userId?: string | null
    libraryId?: string | null
    toolName: string
    query?: string | null
    tokensReturned?: number | null
    responseTimeMs?: number | null
    createdAt?: Date | string
  }

  export type UsageLogUpdateWithoutApiKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    toolName?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    tokensReturned?: NullableIntFieldUpdateOperationsInput | number | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutUsageLogsNestedInput
    library?: LibraryUpdateOneWithoutUsageLogsNestedInput
  }

  export type UsageLogUncheckedUpdateWithoutApiKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    libraryId?: NullableStringFieldUpdateOperationsInput | string | null
    toolName?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    tokensReturned?: NullableIntFieldUpdateOperationsInput | number | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageLogUncheckedUpdateManyWithoutApiKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    libraryId?: NullableStringFieldUpdateOperationsInput | string | null
    toolName?: StringFieldUpdateOperationsInput | string
    query?: NullableStringFieldUpdateOperationsInput | string | null
    tokensReturned?: NullableIntFieldUpdateOperationsInput | number | null
    responseTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAuthorizationCodeCreateManyClientInput = {
    id?: string
    code: string
    userId: string
    redirectUri: string
    scopes?: OAuthAuthorizationCodeCreatescopesInput | string[]
    codeChallenge?: string | null
    codeChallengeMethod?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OAuthAccessTokenCreateManyClientInput = {
    id?: string
    tokenHash: string
    userId: string
    scopes?: OAuthAccessTokenCreatescopesInput | string[]
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type OAuthRefreshTokenCreateManyClientInput = {
    id?: string
    tokenHash: string
    accessTokenId: string
    userId: string
    scopes?: OAuthRefreshTokenCreatescopesInput | string[]
    expiresAt: Date | string
    isRevoked?: boolean
    createdAt?: Date | string
  }

  export type OAuthAuthorizationCodeUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    redirectUri?: StringFieldUpdateOperationsInput | string
    scopes?: OAuthAuthorizationCodeUpdatescopesInput | string[]
    codeChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    codeChallengeMethod?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAuthorizationCodeUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    redirectUri?: StringFieldUpdateOperationsInput | string
    scopes?: OAuthAuthorizationCodeUpdatescopesInput | string[]
    codeChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    codeChallengeMethod?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAuthorizationCodeUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    redirectUri?: StringFieldUpdateOperationsInput | string
    scopes?: OAuthAuthorizationCodeUpdatescopesInput | string[]
    codeChallenge?: NullableStringFieldUpdateOperationsInput | string | null
    codeChallengeMethod?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthAccessTokenUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scopes?: OAuthAccessTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: OAuthRefreshTokenUpdateManyWithoutAccessTokenNestedInput
  }

  export type OAuthAccessTokenUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scopes?: OAuthAccessTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshToken?: OAuthRefreshTokenUncheckedUpdateManyWithoutAccessTokenNestedInput
  }

  export type OAuthAccessTokenUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scopes?: OAuthAccessTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthRefreshTokenUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scopes?: OAuthRefreshTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessToken?: OAuthAccessTokenUpdateOneRequiredWithoutRefreshTokenNestedInput
  }

  export type OAuthRefreshTokenUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    accessTokenId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scopes?: OAuthRefreshTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthRefreshTokenUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    accessTokenId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scopes?: OAuthRefreshTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthRefreshTokenCreateManyAccessTokenInput = {
    id?: string
    tokenHash: string
    clientId: string
    userId: string
    scopes?: OAuthRefreshTokenCreatescopesInput | string[]
    expiresAt: Date | string
    isRevoked?: boolean
    createdAt?: Date | string
  }

  export type OAuthRefreshTokenUpdateWithoutAccessTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scopes?: OAuthRefreshTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: OAuthClientUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type OAuthRefreshTokenUncheckedUpdateWithoutAccessTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scopes?: OAuthRefreshTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OAuthRefreshTokenUncheckedUpdateManyWithoutAccessTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    scopes?: OAuthRefreshTokenUpdatescopesInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DownloadResultCreateManyDownloadTaskInput = {
    id?: string
    success?: boolean
    local_path: string
    metadata: JsonNullValueInput | InputJsonValue
    files: JsonNullValueInput | InputJsonValue
    errors?: DownloadResultCreateerrorsInput | string[]
    created_at?: Date | string
  }

  export type DownloadResultUpdateWithoutDownloadTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    local_path?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    files?: JsonNullValueInput | InputJsonValue
    errors?: DownloadResultUpdateerrorsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DownloadResultUncheckedUpdateWithoutDownloadTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    local_path?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    files?: JsonNullValueInput | InputJsonValue
    errors?: DownloadResultUpdateerrorsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DownloadResultUncheckedUpdateManyWithoutDownloadTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    success?: BoolFieldUpdateOperationsInput | boolean
    local_path?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    files?: JsonNullValueInput | InputJsonValue
    errors?: DownloadResultUpdateerrorsInput | string[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptTemplateCreateManyCategoryRelInput = {
    id: string
    version: string
    name: string
    description?: string | null
    status?: string
    template: string
    variables?: JsonNullValueInput | InputJsonValue
    examples?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    optimization?: JsonNullValueInput | InputJsonValue
    testing?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromptCategoryCreateManyParentInput = {
    id: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromptTemplateUpdateWithoutCategoryRelInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    examples?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    optimization?: JsonNullValueInput | InputJsonValue
    testing?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: PromptExecutionUpdateManyWithoutTemplateNestedInput
    changes?: TemplateChangeUpdateManyWithoutTemplateNestedInput
    optimizations?: OptimizationRecordUpdateManyWithoutTemplateNestedInput
  }

  export type PromptTemplateUncheckedUpdateWithoutCategoryRelInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    examples?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    optimization?: JsonNullValueInput | InputJsonValue
    testing?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    executions?: PromptExecutionUncheckedUpdateManyWithoutTemplateNestedInput
    changes?: TemplateChangeUncheckedUpdateManyWithoutTemplateNestedInput
    optimizations?: OptimizationRecordUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type PromptTemplateUncheckedUpdateManyWithoutCategoryRelInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    examples?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    optimization?: JsonNullValueInput | InputJsonValue
    testing?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptCategoryUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templates?: PromptTemplateUpdateManyWithoutCategoryRelNestedInput
    children?: PromptCategoryUpdateManyWithoutParentNestedInput
  }

  export type PromptCategoryUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templates?: PromptTemplateUncheckedUpdateManyWithoutCategoryRelNestedInput
    children?: PromptCategoryUncheckedUpdateManyWithoutParentNestedInput
  }

  export type PromptCategoryUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptExecutionCreateManyTemplateInput = {
    id?: string
    templateVersion: string
    variables?: JsonNullValueInput | InputJsonValue
    renderedPrompt: string
    context?: NullableJsonNullValueInput | InputJsonValue
    model: string
    provider: string
    response?: string | null
    metrics?: JsonNullValueInput | InputJsonValue
    quality?: JsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    abTestVariant?: string | null
    userId?: string | null
    createdAt?: Date | string
  }

  export type TemplateChangeCreateManyTemplateInput = {
    id?: string
    fromVersion: string
    toVersion: string
    changes: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OptimizationRecordCreateManyTemplateInput = {
    id?: string
    timestamp: Date | string
    type: string
    reason?: string | null
    changes?: JsonNullValueInput | InputJsonValue
    metricsBefore?: JsonNullValueInput | InputJsonValue
    metricsAfter?: JsonNullValueInput | InputJsonValue
    improvement?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
  }

  export type PromptExecutionUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateVersion?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    renderedPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    model?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: JsonNullValueInput | InputJsonValue
    quality?: JsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    abTestVariant?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptExecutionUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateVersion?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    renderedPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    model?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: JsonNullValueInput | InputJsonValue
    quality?: JsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    abTestVariant?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptExecutionUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateVersion?: StringFieldUpdateOperationsInput | string
    variables?: JsonNullValueInput | InputJsonValue
    renderedPrompt?: StringFieldUpdateOperationsInput | string
    context?: NullableJsonNullValueInput | InputJsonValue
    model?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    metrics?: JsonNullValueInput | InputJsonValue
    quality?: JsonNullValueInput | InputJsonValue
    feedback?: NullableJsonNullValueInput | InputJsonValue
    abTestVariant?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateChangeUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromVersion?: StringFieldUpdateOperationsInput | string
    toVersion?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateChangeUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromVersion?: StringFieldUpdateOperationsInput | string
    toVersion?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateChangeUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromVersion?: StringFieldUpdateOperationsInput | string
    toVersion?: StringFieldUpdateOperationsInput | string
    changes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptimizationRecordUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: JsonNullValueInput | InputJsonValue
    metricsBefore?: JsonNullValueInput | InputJsonValue
    metricsAfter?: JsonNullValueInput | InputJsonValue
    improvement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptimizationRecordUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: JsonNullValueInput | InputJsonValue
    metricsBefore?: JsonNullValueInput | InputJsonValue
    metricsAfter?: JsonNullValueInput | InputJsonValue
    improvement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OptimizationRecordUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: JsonNullValueInput | InputJsonValue
    metricsBefore?: JsonNullValueInput | InputJsonValue
    metricsAfter?: JsonNullValueInput | InputJsonValue
    improvement?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyConversationInput = {
    id?: string
    role: string
    content: string
    timestamp?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type ConversationShareCreateManyConversationInput = {
    id?: string
    shareId: string
    createdBy: string
    createdAt?: Date | string
    expiresAt?: Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
  }

  export type ConversationExportCreateManyConversationInput = {
    id?: string
    format: string
    options?: JsonNullValueInput | InputJsonValue
    status?: string
    downloadUrl?: string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    error?: string | null
  }

  export type MessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    reactions?: MessageReactionUpdateManyWithoutMessageNestedInput
    attachments?: MessageAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
    reactions?: MessageReactionUncheckedUpdateManyWithoutMessageNestedInput
    attachments?: MessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type ConversationShareUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shareId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
    creator?: UserUpdateOneRequiredWithoutConversationSharesNestedInput
  }

  export type ConversationShareUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shareId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
  }

  export type ConversationShareUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shareId?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    settings?: JsonNullValueInput | InputJsonValue
    analytics?: JsonNullValueInput | InputJsonValue
  }

  export type ConversationExportUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversationExportUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversationExportUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageReactionCreateManyMessageInput = {
    id?: string
    userId: string
    emoji: string
    timestamp?: Date | string
  }

  export type MessageAttachmentCreateManyMessageInput = {
    id?: string
    type: string
    name: string
    url: string
    size?: bigint | number | null
    mimeType?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    thumbnail?: string | null
  }

  export type MessageReactionUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMessageReactionsNestedInput
  }

  export type MessageReactionUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReactionUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    emoji?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageAttachmentUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageAttachmentUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MessageAttachmentUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContextChunkCreateManySourceInput = {
    id?: string
    content: string
    positionStart?: number
    positionEnd?: number
    positionIndex?: number
    positionTotal?: number
    sectionTitle?: string | null
    codeBlocks?: number
    links?: number
    images?: number
    complexity?: string
    embedding?: ContextChunkCreateembeddingInput | number[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContextChunkUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    positionStart?: IntFieldUpdateOperationsInput | number
    positionEnd?: IntFieldUpdateOperationsInput | number
    positionIndex?: IntFieldUpdateOperationsInput | number
    positionTotal?: IntFieldUpdateOperationsInput | number
    sectionTitle?: NullableStringFieldUpdateOperationsInput | string | null
    codeBlocks?: IntFieldUpdateOperationsInput | number
    links?: IntFieldUpdateOperationsInput | number
    images?: IntFieldUpdateOperationsInput | number
    complexity?: StringFieldUpdateOperationsInput | string
    embedding?: ContextChunkUpdateembeddingInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextChunkUncheckedUpdateWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    positionStart?: IntFieldUpdateOperationsInput | number
    positionEnd?: IntFieldUpdateOperationsInput | number
    positionIndex?: IntFieldUpdateOperationsInput | number
    positionTotal?: IntFieldUpdateOperationsInput | number
    sectionTitle?: NullableStringFieldUpdateOperationsInput | string | null
    codeBlocks?: IntFieldUpdateOperationsInput | number
    links?: IntFieldUpdateOperationsInput | number
    images?: IntFieldUpdateOperationsInput | number
    complexity?: StringFieldUpdateOperationsInput | string
    embedding?: ContextChunkUpdateembeddingInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextChunkUncheckedUpdateManyWithoutSourceInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    positionStart?: IntFieldUpdateOperationsInput | number
    positionEnd?: IntFieldUpdateOperationsInput | number
    positionIndex?: IntFieldUpdateOperationsInput | number
    positionTotal?: IntFieldUpdateOperationsInput | number
    sectionTitle?: NullableStringFieldUpdateOperationsInput | string | null
    codeBlocks?: IntFieldUpdateOperationsInput | number
    links?: IntFieldUpdateOperationsInput | number
    images?: IntFieldUpdateOperationsInput | number
    complexity?: StringFieldUpdateOperationsInput | string
    embedding?: ContextChunkUpdateembeddingInput | number[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextResultCreateManyQueryInput = {
    id?: string
    sources?: JsonNullValueInput | InputJsonValue
    chunks?: JsonNullValueInput | InputJsonValue
    summary?: string | null
    totalSources?: number
    totalChunks?: number
    queryTime?: number
    relevanceScore?: number
    coverage?: number
    freshness?: number
    suggestions?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ContextQueryAnalyticsCreateManyQueryInput = {
    id?: string
    conversationId: string
    queryText: string
    intent: JsonNullValueInput | InputJsonValue
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    resultMetadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ContextResultUpdateWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sources?: JsonNullValueInput | InputJsonValue
    chunks?: JsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    totalSources?: IntFieldUpdateOperationsInput | number
    totalChunks?: IntFieldUpdateOperationsInput | number
    queryTime?: IntFieldUpdateOperationsInput | number
    relevanceScore?: FloatFieldUpdateOperationsInput | number
    coverage?: FloatFieldUpdateOperationsInput | number
    freshness?: FloatFieldUpdateOperationsInput | number
    suggestions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextResultUncheckedUpdateWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sources?: JsonNullValueInput | InputJsonValue
    chunks?: JsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    totalSources?: IntFieldUpdateOperationsInput | number
    totalChunks?: IntFieldUpdateOperationsInput | number
    queryTime?: IntFieldUpdateOperationsInput | number
    relevanceScore?: FloatFieldUpdateOperationsInput | number
    coverage?: FloatFieldUpdateOperationsInput | number
    freshness?: FloatFieldUpdateOperationsInput | number
    suggestions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextResultUncheckedUpdateManyWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    sources?: JsonNullValueInput | InputJsonValue
    chunks?: JsonNullValueInput | InputJsonValue
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    totalSources?: IntFieldUpdateOperationsInput | number
    totalChunks?: IntFieldUpdateOperationsInput | number
    queryTime?: IntFieldUpdateOperationsInput | number
    relevanceScore?: FloatFieldUpdateOperationsInput | number
    coverage?: FloatFieldUpdateOperationsInput | number
    freshness?: FloatFieldUpdateOperationsInput | number
    suggestions?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextQueryAnalyticsUpdateWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    queryText?: StringFieldUpdateOperationsInput | string
    intent?: JsonNullValueInput | InputJsonValue
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    resultMetadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextQueryAnalyticsUncheckedUpdateWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    queryText?: StringFieldUpdateOperationsInput | string
    intent?: JsonNullValueInput | InputJsonValue
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    resultMetadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContextQueryAnalyticsUncheckedUpdateManyWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    queryText?: StringFieldUpdateOperationsInput | string
    intent?: JsonNullValueInput | InputJsonValue
    entities?: JsonNullValueInput | InputJsonValue
    filters?: JsonNullValueInput | InputJsonValue
    options?: JsonNullValueInput | InputJsonValue
    resultMetadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateManyUserProfileInput = {
    id?: string
    number: string
    status?: InvoiceStatus
    period: JsonNullValueInput | InputJsonValue
    issueDate?: Date | string
    dueDate: Date | string
    paidDate?: Date | string | null
    subtotal?: Decimal | DecimalJsLike | number | string
    tax?: Decimal | DecimalJsLike | number | string
    total?: Decimal | DecimalJsLike | number | string
    currency?: string
    items?: JsonNullValueInput | InputJsonValue
    billingAddress?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyUserProfileInput = {
    id?: string
    invoiceId: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status?: PaymentStatus
    providerTransactionId?: string | null
    failureReason?: string | null
    refundedAmount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type SubscriptionCreateManyUserProfileInput = {
    id?: string
    plan: string
    status?: SubscriptionStatus
    currentPeriodStart: Date | string
    currentPeriodEnd: Date | string
    cancelAtPeriodEnd?: boolean
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    interval?: SubscriptionInterval
    intervalCount?: number
    trialStart?: Date | string | null
    trialEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type CreditCreateManyUserProfileInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    reason: string
    type: CreditType
    expiresAt?: Date | string | null
    usedAt?: Date | string | null
    invoiceId?: string | null
    createdAt?: Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type InvoiceUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    period?: JsonNullValueInput | InputJsonValue
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    billingAddress?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    period?: JsonNullValueInput | InputJsonValue
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    billingAddress?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | InvoiceStatus
    period?: JsonNullValueInput | InputJsonValue
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    items?: JsonNullValueInput | InputJsonValue
    billingAddress?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | PaymentStatus
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | PaymentStatus
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type PaymentUncheckedUpdateManyWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | PaymentStatus
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type SubscriptionUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumSubscriptionIntervalFieldUpdateOperationsInput | SubscriptionInterval
    intervalCount?: IntFieldUpdateOperationsInput | number
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type SubscriptionUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumSubscriptionIntervalFieldUpdateOperationsInput | SubscriptionInterval
    intervalCount?: IntFieldUpdateOperationsInput | number
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | SubscriptionStatus
    currentPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    interval?: EnumSubscriptionIntervalFieldUpdateOperationsInput | SubscriptionInterval
    intervalCount?: IntFieldUpdateOperationsInput | number
    trialStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type CreditUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    type?: EnumCreditTypeFieldUpdateOperationsInput | CreditType
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type CreditUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    type?: EnumCreditTypeFieldUpdateOperationsInput | CreditType
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type CreditUncheckedUpdateManyWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    type?: EnumCreditTypeFieldUpdateOperationsInput | CreditType
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type PaymentCreateManyInvoiceInput = {
    id?: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    currency: string
    status?: PaymentStatus
    providerTransactionId?: string | null
    failureReason?: string | null
    refundedAmount?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | PaymentStatus
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    userProfile?: UserProfileUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | PaymentStatus
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | PaymentStatus
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}